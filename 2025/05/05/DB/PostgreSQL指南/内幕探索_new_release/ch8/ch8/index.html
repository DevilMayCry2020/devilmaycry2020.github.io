

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Smile">
  <meta name="keywords" content="">
  
    <meta name="description" content="ch8. Buffer Manager缓冲区管理器负责管理共享内存与持久化存储之间的数据传输，对数据库管理系统(DBMS)的性能有重大影响。PostgreSQL的缓冲区管理器工作效率非常高。 本章将介绍PostgreSQL的缓冲区管理器。首先概述缓冲区管理器，随后的章节将详细介绍以下几个主题：  缓冲区管理器结构   缓冲区管理器锁   缓冲区管理器的工作原理   环形缓冲区   脏页刷新">
<meta property="og:type" content="article">
<meta property="og:title" content="ch8. Buffer Manager">
<meta property="og:url" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/index.html">
<meta property="og:site_name" content="Smile">
<meta property="og:description" content="ch8. Buffer Manager缓冲区管理器负责管理共享内存与持久化存储之间的数据传输，对数据库管理系统(DBMS)的性能有重大影响。PostgreSQL的缓冲区管理器工作效率非常高。 本章将介绍PostgreSQL的缓冲区管理器。首先概述缓冲区管理器，随后的章节将详细介绍以下几个主题：  缓冲区管理器结构   缓冲区管理器锁   缓冲区管理器的工作原理   环形缓冲区   脏页刷新">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_1.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_2.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_3.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_4.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_5.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_6.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_7.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_8.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_9.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_10.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_11.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_12.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_13.png">
<meta property="article:published_time" content="2025-05-05T12:24:15.180Z">
<meta property="article:modified_time" content="2025-05-06T11:45:19.245Z">
<meta property="article:author" content="Smile">
<meta property="article:tag" content="book">
<meta property="article:tag" content="database">
<meta property="article:tag" content="transactions">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img.png">
  
  
  
  <title>ch8. Buffer Manager - Smile</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"smilemzy.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Smile</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="ch8. Buffer Manager"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-05 20:24" pubdate>
          2025年5月5日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7.8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          66 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">ch8. Buffer Manager</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="ch8-Buffer-Manager"><a href="#ch8-Buffer-Manager" class="headerlink" title="ch8. Buffer Manager"></a>ch8. Buffer Manager</h2><p>缓冲区管理器负责管理共享内存与持久化存储之间的数据传输，<br>对数据库管理系统(DBMS)的性能有重大影响。PostgreSQL的缓冲区管理器工作效率非常高。</p>
<p>本章将介绍PostgreSQL的缓冲区管理器。首先概述缓冲区管理器，随后的章节将详细介绍以下几个主题：</p>
<ol>
<li>缓冲区管理器结构  </li>
<li>缓冲区管理器锁  </li>
<li>缓冲区管理器的工作原理  </li>
<li>环形缓冲区  </li>
<li>脏页刷新</li>
</ol>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img.png" srcset="/img/loading.gif" lazyload alt="img.png"></p>
<table>
<thead>
<tr>
<th>Chapter Contents</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#8-Overview">8.1 Overview</a></td>
</tr>
<tr>
<td><a href="#buffer-ms">8.2 Buffer Manager Structure</a></td>
</tr>
<tr>
<td><a href="#buffer-ml">8.3 Buffer Manager Locks</a></td>
</tr>
<tr>
<td><a href="#buffer-mw">8.4 How the Buffer Manager Works</a></td>
</tr>
<tr>
<td><a href="#Ring-Buffer">8.5 Ring Buffer</a></td>
</tr>
<tr>
<td><a href="#Flush-DP">8.6 Flushing Dirty Pages</a></td>
</tr>
</tbody></table>
<h3 id="8-1-Overview"><a href="#8-1-Overview" class="headerlink" title="8.1 Overview"></a><a name="8-Overview"></a>8.1 Overview</h3><p>本节将介绍一些关键概念，这些概念对于理解后续章节的内容至关重要。</p>
<h4 id="8-1-1-Buffer-Manager-Structure"><a href="#8-1-1-Buffer-Manager-Structure" class="headerlink" title="8.1.1. Buffer Manager Structure"></a>8.1.1. Buffer Manager Structure</h4><p>PostgreSQL的缓冲区管理器包含缓冲区表、缓冲区描述符和缓冲池这几个关键部分，这些将在下一节详细描述。</p>
<p>缓冲池层负责存储数据文件页面，比如表和索引，以及空闲空间映射和可见性映射等。</p>
<p>缓冲池是一个数组结构，其中每个槽位存储一个数据文件的页面。缓冲池数组的索引被称为buffer_ids。</p>
<p>第8.2节和8.3节将进一步详述缓冲区管理器内部结构的具体细节。</p>
<h4 id="8-1-2-Buffer-Tag"><a href="#8-1-2-Buffer-Tag" class="headerlink" title="8.1.2. Buffer Tag"></a>8.1.2. Buffer Tag</h4><p>在PostgreSQL中，所有数据文件的每一页都可以被分配一个唯一的标签，即缓冲区标签（buffer tag）。<br>当缓冲区管理器接收到请求时，PostgreSQL会使用目标页面的buffer_tag来进行处理。</p>
<p>缓冲区标签（buffer_tag）包含五个值：</p>
<p>specOid：包含目标页面的关系所属表空间的OID。<br>dbOid：包含目标页面的关系所属数据库的OID。<br>relFileNode：包含目标页面的关系文件的文件节点号。<br>blockNum：目标页面在关系文件中的块编号。<br>forkNum：页面所属关系的分叉编号。表、空闲空间映射和可见性映射的分叉编号分别定义为0、1和2。  </p>
<p>通过这样的标签体系，PostgreSQL能精确地定位和管理数据库中任意页面的信息，提高数据访问的效率和准确性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Buffer tag identifies which disk block the buffer contains.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Note: the BufferTag data must be sufficient to determine where to write the</span><br><span class="hljs-comment"> * block, without reference to pg_class or pg_tablespace entries.  It&#x27;s</span><br><span class="hljs-comment"> * possible that the backend flushing the buffer doesn&#x27;t even believe the</span><br><span class="hljs-comment"> * relation is visible yet (its xact may have started before the xact that</span><br><span class="hljs-comment"> * created the rel).  The storage manager must be able to cope anyway.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Note: if there&#x27;s any pad bytes in the struct, InitBufferTag will have</span><br><span class="hljs-comment"> * to be fixed to zero them, since this struct is used as a hash key.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buftag</span></span><br><span class="hljs-class">&#123;</span><br>	Oid			spcOid;			<span class="hljs-comment">/* tablespace oid */</span><br>	Oid			dbOid;			<span class="hljs-comment">/* database oid */</span><br>	RelFileNumber relNumber;	<span class="hljs-comment">/* relation file number */</span><br>	ForkNumber	forkNum;		<span class="hljs-comment">/* fork number */</span><br>	BlockNumber blockNum;		<span class="hljs-comment">/* blknum relative to begin of reln */</span><br>&#125; BufferTag;<br></code></pre></td></tr></table></figure>
<p>例如，缓冲区标签‘{16821, 16384, 37721, 0, 7}’标识了一个特定页面，该页面位于表空间OID为16821、<br>数据库OID为16384的数据库中，具体是OID为37721的表的第一个分叉（fork number为0）的第七个块。</p>
<p>同样，缓冲区标签‘{16821, 16384, 37721, 1, 3}’标识了另一个页面，该页面位于表空间OID为16821、<br>数据库OID为16384的数据库中，但这次是OID为37721的表的空闲空间映射分叉（fork number为1）的第三个块。</p>
<h4 id="8-1-3-How-a-Backend-Process-Reads-Pages"><a href="#8-1-3-How-a-Backend-Process-Reads-Pages" class="headerlink" title="8.1.3. How a Backend Process Reads Pages"></a>8.1.3. How a Backend Process Reads Pages</h4><p>本小节将描述后台进程如何从缓冲区管理器中读取页面（参见图8.2）。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_1.png" srcset="/img/loading.gif" lazyload alt="img_1.png"></p>
<p>(1) 当需要读取表或索引页面时，后台进程会向缓冲区管理器发送一个请求，该请求包含了页面的缓冲区标签（buffer_tag）。</p>
<p>(2) 缓冲区管理器根据该标签返回存储请求页面的缓冲池槽位的缓冲区ID（buffer_ID）。如果请求的页面不在缓冲池中，缓冲区管理器会将页面从持久化存储加载到缓冲池的一个槽位中，然后返回该槽位的缓冲区ID。</p>
<p>(3) 后台进程根据得到的缓冲区ID访问相应的槽位（以读取所需页面）。</p>
<p>当后台进程修改缓冲池中的页面（例如，通过插入元组）时，那些尚未刷新到存储器中的已修改页面被称为脏页。</p>
<p>第8.4节将更详细地描述缓冲区管理器的工作方式。</p>
<h4 id="8-1-4-Page-Replacement-Algorithm"><a href="#8-1-4-Page-Replacement-Algorithm" class="headerlink" title="8.1.4. Page Replacement Algorithm"></a>8.1.4. Page Replacement Algorithm</h4><p>当缓冲池的所有槽位都被占用，且请求的页面不在缓冲池中时，<br>缓冲区管理器必须选择缓冲池中的一页来替换为请求的页面。在计算机科学领域，这种页面选择算法通常被称为页面置换算法，<br>而被选中的页面称为牺牲页（victim page）。</p>
<p>自从计算机科学诞生以来，页面置换算法的研究一直在进行。已经提出了许多置换算法，<br>而PostgreSQL自8.1版本起开始使用时钟扫描（clock sweep）算法。相比之前版本中使用<br>的LRU（Least Recently Used）算法，时钟扫描算法更为简单且效率更高。</p>
<p>第8.4.4节将详细描述时钟扫描算法的具体细节。</p>
<h4 id="8-1-5-Flushing-Dirty-Pages"><a href="#8-1-5-Flushing-Dirty-Pages" class="headerlink" title="8.1.5. Flushing Dirty Pages"></a>8.1.5. Flushing Dirty Pages</h4><p>脏页最终需要被刷新到存储器中。然而，缓冲区管理器本身并不能独立完成这项任务。在PostgreSQL中，有两个后台进程<br>负责处理此事：检查点进程（checkpointer）和后台写入器（background writer）。</p>
<p>第8.6节将详细介绍检查点进程和后台写入器的工作原理。</p>
<blockquote>
<p> Direct I&#x2F;O</p>
<p>PostgreSQL在15及更早的版本中并不支持直接I&#x2F;O（Direct I&#x2F;O），<br>尽管这个问题已被讨论过。可以参考pgsql-ML上的这篇文章和另一篇文章。(<a target="_blank" rel="noopener" href="https://www.postgresql.org/message-id/529E267F.4050700@agliodbs.com">https://www.postgresql.org/message-id/529E267F.4050700@agliodbs.com</a>)<br>(<a target="_blank" rel="noopener" href="https://lwn.net/Articles/580542/)(https://www.postgresql.org/docs/16/runtime-config-developer.html#GUC-DEBUG-IO-DIRECT)">https://lwn.net/Articles/580542/)(https://www.postgresql.org/docs/16/runtime-config-developer.html#GUC-DEBUG-IO-DIRECT)</a></p>
<p>在版本16中，新增了一个debug-io-direct选项。这个选项是为了让开发者能够<br>改进PostgreSQL中直接I&#x2F;O的使用。如果开发进展顺利，直接I&#x2F;O有望在不久的将来得到正式的支持。</p>
</blockquote>
<h3 id="8-2-Buffer-Manager-Structure"><a href="#8-2-Buffer-Manager-Structure" class="headerlink" title="8.2 Buffer Manager Structure"></a><a name="buffer-ms"></a>8.2 Buffer Manager Structure</h3><p>PostgreSQL的缓冲区管理器包含三层结构：“缓冲池”、“缓冲描述符”和“缓冲表”（如图8.3所示）：</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_2.png" srcset="/img/loading.gif" lazyload alt="img_2.png"></p>
<ol>
<li><p>缓冲池：一个用于存储数据文件页面的数组。数组中的每个位置称为缓冲区ID（buffer_ids）。</p>
</li>
<li><p>缓冲描述符：一个缓冲描述符数组。每个描述符与缓冲池中的一个槽位一对一对应，并保存该槽位中存储页面的元数据。<br>注意，“缓冲描述符层”这一术语是出于方便而采用的，并且仅在此文档中使用。</p>
</li>
<li><p>缓冲表：一个哈希表，用于存储存储页面的缓冲区标签（buffer_tags）与其各自元数据所在的缓冲描述符的缓冲区<br>ID之间的关联关系。</p>
</li>
</ol>
<p>以下各小节将详细描述这些层次结构。</p>
<h4 id="8-2-1-Buffer-Table"><a href="#8-2-1-Buffer-Table" class="headerlink" title="8.2.1. Buffer Table"></a>8.2.1. Buffer Table</h4><p>缓冲表逻辑上可以分为三部分：哈希函数、哈希桶槽位和数据项（如图8.4所示）。</p>
<p>内置的哈希函数将缓冲区标签（buffer_tags）映射到哈希桶槽位。尽管哈希桶槽位的数量大于缓冲池槽位的数量，<br>但仍可能发生碰撞。因此，缓冲表使用带有链表的分离链接法来解决碰撞问题。当数据项被映射到同一个桶槽时，<br>该方法将这些项存储在同一链表中，如图8.4所示。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_3.png" srcset="/img/loading.gif" lazyload alt="img_3.png"></p>
<p>数据条目由两个值组成：页面的buffer_tag和存储该页面元数据的描述符的buffer_id。<br>例如，数据条目‘Tag_A, id&#x3D;1’表示buffer_id为‘1’的缓冲描述符存储了标记为Tag_A的页面的元数据。</p>
<blockquote>
<p>Hash Function</p>
<p>哈希函数是calc_bucket()和hash()这两个函数的组合功能。<br>以下是它作为一个伪函数的表示形式。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">uint32 <span class="hljs-keyword">bucket_slot </span>= calc_bucket(unsigned hash(<span class="hljs-keyword">BufferTag </span><span class="hljs-keyword">buffer_tag), </span>uint32 <span class="hljs-keyword">bucket_size)</span><br></code></pre></td></tr></table></figure></blockquote>
<p>注意：基本操作（如数据条目的查找、插入和删除）在这里没有解释。<br>这些是非常常见的操作，并将在后续章节中进行说明。</p>
<h4 id="8-2-2-Buffer-Descriptor"><a href="#8-2-2-Buffer-Descriptor" class="headerlink" title="8.2.2. Buffer Descriptor"></a>8.2.2. Buffer Descriptor</h4><p>在9.6版本中，缓冲描述符的结构得到了改进。首先，我将解释9.5及更早版本中的缓冲描述符，<br>然后说明9.6及以后版本中的缓冲描述符与之前版本的不同之处。</p>
<p>缓冲描述符层的详细内容将在下一个小节中描述。</p>
<h5 id="8-2-2-1-Versions-9-5-or-earlier"><a href="#8-2-2-1-Versions-9-5-or-earlier" class="headerlink" title="8.2.2.1. Versions 9.5 or earlier"></a>8.2.2.1. Versions 9.5 or earlier</h5><p>在9.5及更早版本中，缓冲描述符结构保存了对应缓冲池槽位中存储页面的元数据。<br>缓冲描述符结构由BufferDesc结构定义。以下是其中一些主要字段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Flags for buffer descriptors</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Note: TAG_VALID essentially means that there is a buffer hashtable</span><br><span class="hljs-comment"> * entry associated with the buffer&#x27;s tag.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_DIRTY                (1 &lt;&lt; 0)    <span class="hljs-comment">/* data needs writing */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_VALID                (1 &lt;&lt; 1)    <span class="hljs-comment">/* data is valid */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_TAG_VALID            (1 &lt;&lt; 2)    <span class="hljs-comment">/* tag is assigned */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_IO_IN_PROGRESS       (1 &lt;&lt; 3)    <span class="hljs-comment">/* read or write in progress */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_IO_ERROR             (1 &lt;&lt; 4)    <span class="hljs-comment">/* previous I/O failed */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_JUST_DIRTIED         (1 &lt;&lt; 5)    <span class="hljs-comment">/* dirtied since write started */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_PIN_COUNT_WAITER     (1 &lt;&lt; 6)    <span class="hljs-comment">/* have waiter for sole pin */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_CHECKPOINT_NEEDED    (1 &lt;&lt; 7)    <span class="hljs-comment">/* must write for checkpoint */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_PERMANENT            (1 &lt;&lt; 8)    <span class="hljs-comment">/* permanent relation (not unlogged) */</span></span><br><br>src/include/storage/buf_internals.h<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sbufdesc</span><br>&#123;<br>   BufferTag    tag;                 <span class="hljs-comment">/* ID of page contained in buffer */</span><br>   BufFlags     flags;               <span class="hljs-comment">/* see bit definitions above */</span><br>   uint16       usage_count;         <span class="hljs-comment">/* usage counter for clock sweep code */</span><br>   <span class="hljs-type">unsigned</span>     refcount;            <span class="hljs-comment">/* # of backends holding pins on buffer */</span><br>   <span class="hljs-type">int</span>          wait_backend_pid;    <span class="hljs-comment">/* backend PID of pin-count waiter */</span><br>   <span class="hljs-type">slock_t</span>      buf_hdr_lock;        <span class="hljs-comment">/* protects the above fields */</span><br>   <span class="hljs-type">int</span>          buf_id;              <span class="hljs-comment">/* buffer&#x27;s index number (from 0) */</span><br>   <span class="hljs-type">int</span>          freeNext;            <span class="hljs-comment">/* link in freelist chain */</span><br><br>   LWLockId     io_in_progress_lock; <span class="hljs-comment">/* to wait for I/O to complete */</span><br>   LWLockId     content_lock;        <span class="hljs-comment">/* to lock access to buffer contents */</span><br>&#125; BufferDesc;<br></code></pre></td></tr></table></figure>

<p>tag字段保存了对应缓冲池槽位中存储页面的buffer_tag。(buffer_tag在8.1.2节中定义。)</p>
<p>buf_id用于标识描述符，它等同于相应缓冲池槽位的buffer_id。</p>
<p>refcount（也称为pin计数）持有当前正在访问关联存储页面的PostgreSQL进程数量。<br>当一个PostgreSQL进程访问存储页面时，refcount必须增加1（refcount++）。<br>访问页面后，refcount必须减少1（refcount–）。当refcount为零时，表示关联的存储页面未被固定<br>（即当前没有被访问）。否则，页面被视为已被固定。</p>
<p>usage_count记录了自页面加载到相应缓冲池槽以来被访问的次数，它用于页面置换算法（8.4.4节）。</p>
<p>content_lock和io_in_progress_lock是轻量级锁，用于控制对关联存储页面的访问。这些字段在8.3.2节中有描述。</p>
<p>flags可以保存关联存储页面的多种状态。主要状态包括：<br>dirty位表示存储页面已被修改（脏）。<br>valid位指示存储页面是否有效，意味着它可以被读取或写入。<br>如果此位有效，则相应的缓冲池槽存储了一个页面，且描述符持有页面元数据，<br>存储页面可读可写。如果此位无效，则描述符不持有任何元数据，存储页面不能被读写。<br>io_in_progress位表示缓冲区管理器是否正在从存储中读取或写入关联页面。  </p>
<p>buf_hdr_lock是一个自旋锁，用于保护flags、usage_count和refcount这些字段。  </p>
<p>freeNext是一个指针，指向用于生成空闲列表的下一个描述符，空闲列表的概念在下一小节中会有描述。</p>
<h5 id="8-2-2-2-Versions-9-6-or-later"><a href="#8-2-2-2-Versions-9-6-or-later" class="headerlink" title="8.2.2.2. Versions 9.6 or later"></a>8.2.2.2. Versions 9.6 or later</h5><p>The buffer descriptor structure is defined by the BufferDesc structure.</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Flags for buffer descriptors</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">Note:</span> BM_TAG_VALID essentially means that there is a buffer hashtable</span><br><span class="hljs-comment"> * entry associated with the buffer&#x27;s tag.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#define BM_LOCKED		(1U &lt;&lt; 22)	/* buffer header is locked */</span><br><span class="hljs-meta">#define BM_DIRTY		(1U &lt;&lt; 23)	/* data needs writing */</span><br><span class="hljs-meta">#define BM_VALID		(1U &lt;&lt; 24)	/* data is valid */</span><br><span class="hljs-meta">#define BM_TAG_VALID		(1U &lt;&lt; 25)	/* tag is assigned */</span><br><span class="hljs-meta">#define BM_IO_IN_PROGRESS	(1U &lt;&lt; 26)	/* read or write in progress */</span><br><span class="hljs-meta">#define BM_IO_ERROR		(1U &lt;&lt; 27)	/* previous I/O failed */</span><br><span class="hljs-meta">#define BM_JUST_DIRTIED		(1U &lt;&lt; 28)	/* dirtied since write started */</span><br><span class="hljs-meta">#define BM_PIN_COUNT_WAITER	(1U &lt;&lt; 29)	/* have waiter for sole pin */</span><br><span class="hljs-meta">#define BM_CHECKPOINT_NEEDED	(1U &lt;&lt; 30)	/* must write for checkpoint */</span><br><span class="hljs-meta">#define BM_PERMANENT		(1U &lt;&lt; 31)	/* permanent buffer (not unlogged,</span><br>						 * <span class="hljs-keyword">or</span> init fork) */<br><br><span class="hljs-meta">#define PG_HAVE_ATOMIC_U32_SUPPORT</span><br>typedef struct pg_atomic_uint32<br>&#123;<br>	<span class="hljs-keyword">volatile</span> uint32 <span class="hljs-keyword">value</span>;<br>&#125; pg_atomic_uint32;<br><br><br>typedef struct BufferDesc<br>&#123;<br>	BufferTag	tag;			<span class="hljs-comment">/* ID of page contained in buffer */</span><br>	<span class="hljs-type">int</span>		buf_id;			<span class="hljs-comment">/* buffer&#x27;s index number (from 0) */</span><br><br>	<span class="hljs-comment">/* state of the tag, containing flags, refcount and usagecount */</span><br>	pg_atomic_uint32 state;<br><br>	<span class="hljs-type">int</span>		wait_backend_pgprocno;	<span class="hljs-comment">/* backend of pin-count waiter */</span><br>	<span class="hljs-type">int</span>		freeNext;		<span class="hljs-comment">/* link in freelist chain */</span><br>	LWLock		content_lock;	<span class="hljs-comment">/* to lock access to buffer contents */</span><br>&#125; BufferDesc;<br></code></pre></td></tr></table></figure>

<ol>
<li>tag字段保存了相应缓冲池槽位中存储页面的buffer_tag。  </li>
<li>buf_id用于标识描述符。  </li>
<li>content_lock是一个轻量级锁，用于控制对关联存储页面的访问。  </li>
<li>freeNext是一个指针，指向用于构建空闲链表的下一个描述符，空闲链表有助于管理缓冲区描述符的分配与回收。  </li>
<li>states（这里可能原意是指结构中的某些集合状态字段，尽管直接翻译为“状态”可能不够准确）可以保存关联存储页面的<br>多个状态和变量，例如refcount（引用计数）和usage_count（使用计数）。</li>
</ol>
<p>flags、usage_count和refcount这三个字段已被合并成一个单一的32位数据（称为states），以便使用CPU原子操作。<br>因此，由于不再需要保护这些值，io_in_progress_lock和自旋锁（buf_hdr_lock）已经被移除。</p>
<blockquote>
<p>Atomic Operations</p>
<p>原子操作不通过软件来独占控制数据，而是利用硬件强制的独占控制以及原子性的读改写操作来高效地执行。</p>
</blockquote>
<h5 id="8-2-2-3-Descriptor-States"><a href="#8-2-2-3-Descriptor-States" class="headerlink" title="8.2.2.3. Descriptor States"></a>8.2.2.3. Descriptor States</h5><p>为了简化以下描述，我们定义了三种描述符状态如下：</p>
<ol>
<li>空闲（Empty）：当相应的缓冲池槽位没有存储页面（即refcount和usage_count都为0时），这个描述符的状态为空闲。  </li>
<li>固定（Pinned）：当相应的缓冲池槽位存储了一个页面，并且有任意PostgreSQL进程正在访问该页面<br>（即refcount和usage_count都大于等于1时），这个缓冲描述符的状态为固定。  </li>
<li>未固定（Unpinned）：当相应的缓冲池槽位存储了一个页面，但没有PostgreSQL进程正在访问该页面<br>（即usage_count大于等于1，但refcount为0时），这个缓冲描述符的状态为未固定。</li>
</ol>
<p>每个描述符都将处于上述三种状态之一。描述符的状态会根据特定条件发生变化，这些条件在下一小节中描述。</p>
<p>在接下来的图示中，缓冲描述符的状态通过不同颜色的方框表示：</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_4.png" srcset="/img/loading.gif" lazyload alt="img_4.png"></p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_5.png" srcset="/img/loading.gif" lazyload alt="img_5.png"></p>
<h4 id="8-2-3-Buffer-Descriptors-Layer"><a href="#8-2-3-Buffer-Descriptors-Layer" class="headerlink" title="8.2.3. Buffer Descriptors Layer"></a>8.2.3. Buffer Descriptors Layer</h4><p>一组缓冲描述符构成了一个数组，在本文档中被称为缓冲描述符层。</p>
<p>当PostgreSQL服务器启动时，所有缓冲描述符的状态都是’空闲’。<br>在PostgreSQL中，这些描述符构成一个被称为空闲列表（freelist）的链表（图8.5）。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_6.png" srcset="/img/loading.gif" lazyload alt="img_6.png"></p>
<blockquote>
<p>Note</p>
<p>重要的是要注意，PostgreSQL中的空闲列表（freelist）与Oracle中的空闲列表概念完全不同。<br>PostgreSQL中的空闲列表仅仅是<strong>空缓冲描述符</strong>的简单链表。而在PostgreSQL中，用于追踪块内可用空间的<br>自由空间映射（Freespace Maps，FSM），在5.3.4节中有描述，它们起到了与Oracle中空闲列表相似的作用。</p>
</blockquote>
<p>图8.6展示了如何加载第一个页面。</p>
<p>(1) 从空闲列表的顶部检索一个空闲的描述符，并对其进行固定（即增加其refcount和usage_count各1）。<br>(2) 在缓冲表中插入一条新记录，该记录将第一个页面的标签映射到检索到的描述符的buffer_id。<br>(3) 从存储中将新页面加载到相应的缓冲池槽位中。<br>(4) 将新页面的元数据保存到检索到的描述符中。  </p>
<p>第二页及之后的页面以类似的方式加载。更多细节在8.4.2节中提供。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_7.png" srcset="/img/loading.gif" lazyload alt="img_7.png"></p>
<p>从空闲列表中检索过的描述符始终会持有页面的元数据。换句话说，一旦被使用过，<br>非空的描述符就不会再返回到空闲列表中。然而，当发生以下情况之一时，相应的描述符会被再次添加到空闲列表中，<br>并且描述符的状态会被设置为’空闲’：</p>
<ol>
<li>表或索引被删除。  </li>
<li>数据库被删除。  </li>
<li>使用VACUUM FULL命令清理表或索引。</li>
</ol>
<p>这样，那些不再需要的页面所对应的缓冲描述符就能被有效地回收并重新利用。</p>
<blockquote>
<p>为什么空闲描述符构成了空闲列表？<br>空闲列表的创建是为了允许立即获取首个描述符，这是动态内存资源分配中的一种常见做法。<br>想要了解更多相关信息，请参考这一描述。(<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Free_list">https://en.wikipedia.org/wiki/Free_list</a>)</p>
</blockquote>
<p>缓冲描述符层包含一个无符号的32位整型变量，即nextVictimBuffer。这个变量用于第8.4.4节所述的页面替换算法中。</p>
<h4 id="8-2-4-Buffer-Pool"><a href="#8-2-4-Buffer-Pool" class="headerlink" title="8.2.4. Buffer Pool"></a>8.2.4. Buffer Pool</h4><p>缓冲池是一个简单的数组，用于存储数据文件页面，如表和索引。缓冲池数组的索引称为buffer_ids。</p>
<p>缓冲池槽的大小为8 KB，这与页面的大小相等。因此，每个槽位可以存储整个页面。</p>
<h3 id="8-3-Buffer-Manager-Locks"><a href="#8-3-Buffer-Manager-Locks" class="headerlink" title="8.3 Buffer Manager Locks"></a><a name="buffer-ml"></a>8.3 Buffer Manager Locks</h3><p>缓冲区管理器为了多种目的使用了许多锁。本节将介绍在后续章节说明中必需的锁。</p>
<blockquote>
<p>Note</p>
<p>请注意，本节中描述的锁是缓冲区管理器同步机制的一部分，它们与任何SQL语句或SQL选项无关。</p>
</blockquote>
<h4 id="8-3-1-Buffer-Table-Locks"><a href="#8-3-1-Buffer-Table-Locks" class="headerlink" title="8.3.1. Buffer Table Locks"></a>8.3.1. Buffer Table Locks</h4><p>BufMappingLock用于保护整个缓冲表的数据完整性。它是一种轻量级锁，<br>既可用于共享模式也可用于排他模式。当在缓冲表中搜索条目时，后端进程持有共享的BufMappingLock。<br>而在插入或删除条目时，后端进程则持有排他的锁。</p>
<p>为了减少缓冲表中的竞争状况，BufMappingLock被分割成多个分区（默认为128个分区）。<br>每个BufMappingLock分区负责保护相应哈希桶槽位的一部分。</p>
<p>图8.7展示了一个典型的例子，说明了分割BufMappingLock的效果。两个后端进程可以同时<br>以排他模式持有各自的BufMappingLock分区来插入新的数据条目。如果BufMappingLock是一个单一的系统范围锁，<br>那么这两个进程就不得不根据哪个进程先开始而等待对方完成。通过分割，提高了并发性能，减少了锁竞争导致的等待时间。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_8.png" srcset="/img/loading.gif" lazyload alt="img_8.png"><br>图8.7展示了两个进程同时以排他模式获取BufMappingLock的各自分区以插入新数据条目的场景。</p>
<p>缓冲表还需要许多其他锁。例如，缓冲表内部在删除条目时使用了自旋锁。<br>但是，这些其他锁的描述在此文档中被省略，因为它们不是本说明所需的内容。</p>
<blockquote>
<p>Info</p>
<p>在PostgreSQL 9.4版本之前，默认情况下BufMappingLock被分割成了16个独立的锁。</p>
</blockquote>
<h4 id="8-3-2-Locks-for-Each-Buffer-Descriptor"><a href="#8-3-2-Locks-for-Each-Buffer-Descriptor" class="headerlink" title="8.3.2. Locks for Each Buffer Descriptor"></a>8.3.2. Locks for Each Buffer Descriptor</h4><p>在9.5或更早的版本中，每个缓冲描述符使用了两个轻量级锁，即content_lock和io_in_progress_lock，来控制<br>对相应缓冲池槽位中存储页面的访问。<br>当检查或更改其自身字段的值（即usage_count、refcount、flags）时，会使用一个自旋锁（buf_hdr_lock）。</p>
<p>在9.6版本中，缓冲区访问方法得到了改进。io_in_progress_lock和自旋锁（buf_hdr_lock）被移除了。<br>9.6及以后的版本不再使用这些锁，而是利用CPU原子操作来检查和更改这些值。这样做提高了并发处理能力并减少<br>了锁带来的开销。</p>
<h5 id="8-3-2-1-content-lock"><a href="#8-3-2-1-content-lock" class="headerlink" title="8.3.2.1. content_lock"></a>8.3.2.1. content_lock</h5><p>content_lock是一个典型的用于实施访问限制的锁，它可以用于共享模式和排他模式。</p>
<p>当读取页面时，后台进程会获取存储该页面的缓冲描述符的共享content_lock。</p>
<p>在执行以下任一操作时，会获取排他content_lock：</p>
<ol>
<li>向存储页面中插入行（即元组）或更改存储页面中元组的t_xmin&#x2F;t_xmax字段。<br>（t_xmin和t_xmax字段在第5.2节中有描述；简单来说，在删除或更新行时，相关元组的这些字段会被修改。）</li>
<li>物理删除存储页面上的元组或压缩页面上的空闲空间。（这是由真空处理（vacuuming）和HOT（Heap Only Tuple）<br>实现的，分别在第6章和第7章中有描述。）  </li>
<li>对存储页面中的元组进行冻结操作。（冻结操作在第5.10.1节和第6.3节中有说明。）</li>
</ol>
<p>官方的README文件提供了更多详细信息。(src&#x2F;backend&#x2F;storage&#x2F;buffer&#x2F;README)</p>
<h5 id="8-3-2-2-io-in-progress-lock-versions-9-5-or-earlier"><a href="#8-3-2-2-io-in-progress-lock-versions-9-5-or-earlier" class="headerlink" title="8.3.2.2. io_in_progress_lock (versions 9.5 or earlier)"></a>8.3.2.2. io_in_progress_lock (versions 9.5 or earlier)</h5><p>在9.5或更早的版本中，io_in_progress锁用于等待缓冲区上I&#x2F;O操作的完成。<br>当一个PostgreSQL进程从存储加载或向存储写入页面数据时，该进程在访问存储期间会获取相应描述符的<br>排他io_in_progress锁。</p>
<h5 id="8-3-2-3-spinlock-versions-9-5-or-earlier"><a href="#8-3-2-3-spinlock-versions-9-5-or-earlier" class="headerlink" title="8.3.2.3. spinlock (versions 9.5 or earlier)"></a>8.3.2.3. spinlock (versions 9.5 or earlier)</h5><p>当检查或更改flags或其他字段（如refcount和usage_count）时，会使用自旋锁。以下是使用自旋锁的两个具体示例：</p>
<p>(1) 固定一个缓冲描述符：</p>
<ol>
<li>获取缓冲描述符的自旋锁。  </li>
<li>将其refcount和usage_count的值各增加1。  </li>
<li>释放自旋锁。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">LockBufHdr(bufferdesc);    <span class="hljs-comment">/* Acquire a spinlock */</span><br>bufferdesc-&gt;refcont++;<br>bufferdesc-&gt;usage_count++;<br>UnlockBufHdr(bufferdesc); <span class="hljs-comment">/* Release the spinlock */</span><br></code></pre></td></tr></table></figure>
<p>(2) 将脏位设置为‘1’：</p>
<ol>
<li>获取缓冲描述符的自旋锁。  </li>
<li>使用按位操作将脏位设置为‘1’。  </li>
<li>释放自旋锁。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_DIRTY             (1 &lt;&lt; 0)    <span class="hljs-comment">/* data needs writing */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_VALID             (1 &lt;&lt; 1)    <span class="hljs-comment">/* data is valid */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_TAG_VALID         (1 &lt;&lt; 2)    <span class="hljs-comment">/* tag is assigned */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_IO_IN_PROGRESS    (1 &lt;&lt; 3)    <span class="hljs-comment">/* read or write in progress */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_JUST_DIRTIED      (1 &lt;&lt; 5)    <span class="hljs-comment">/* dirtied since write started */</span></span><br><br>LockBufHdr(bufferdesc);<br>bufferdesc-&gt;flags |= BM_DIRTY;<br>UnlockBufHdr(bufferdesc);<br></code></pre></td></tr></table></figure>
<p>更改其他标志位也是按照同样的方式进行。</p>
<h3 id="8-4-How-the-Buffer-Manager-Works"><a href="#8-4-How-the-Buffer-Manager-Works" class="headerlink" title="8.4 How the Buffer Manager Works"></a><a name="buffer-mw"></a>8.4 How the Buffer Manager Works</h3><p>本节描述缓冲区管理器的工作原理。当后台进程需要访问期望的页面时，它会调用ReadBufferExtended()函数。</p>
<p>ReadBufferExtended()函数的行为依赖于三种逻辑情况。每种情况在以下小节中进行描述。<br>此外，最终小节将介绍PostgreSQL的时钟扫描页面替换算法。</p>
<h4 id="8-4-1-Accessing-a-Page-Stored-in-the-Buffer-Pool"><a href="#8-4-1-Accessing-a-Page-Stored-in-the-Buffer-Pool" class="headerlink" title="8.4.1. Accessing a Page Stored in the Buffer Pool"></a>8.4.1. Accessing a Page Stored in the Buffer Pool</h4><p><strong>访问缓冲池中已存储的页面</strong></p>
<p>首先，描述最简单的情况，即所需页面已经存储在缓冲池中。在这种情况下，缓冲区管理器执行以下步骤：</p>
<p>(1) 创建所需页面的buffer_tag（在此例中，buffer_tag为’Tag_C’），并使用哈希函数计算包含所创建buffer_tag关联条目的哈希桶槽位。</p>
<p>(2) 以共享模式获取覆盖所得哈希桶槽位的BufMappingLock分区（此锁将在步骤(5)中释放）。</p>
<p>(3) 查找标签为’Tag_C’的条目，并从该条目中获取buffer_id。在此例中，buffer_id为2。</p>
<p>(4) 为buffer_id为2的缓冲描述符设置固定（pin），将描述符的refcount和usage_count各增加1。（第8.3.2节描述了固定操作）</p>
<p>(5) 释放BufMappingLock。</p>
<p>(6) 访问buffer_id为2的缓冲池槽位。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_9.png" srcset="/img/loading.gif" lazyload alt="img_9.png"></p>
<p>接着，当从缓冲池槽位的页面中读取行时，PostgreSQL进程会获取相应缓冲描述符的共享content_lock。<br>因此，多个进程可以同时读取缓冲池槽位中的页面。</p>
<p>当向页面中插入（以及更新或删除）行时，Postgres进程会获取相应缓冲描述符的排他content_lock。<br>（需要注意的是，页面的脏位必须设置为1。）</p>
<p>访问页面后，相应缓冲描述符的refcount值会减1。</p>
<h4 id="8-4-2-Loading-a-Page-from-Storage-to-Empty-Slot"><a href="#8-4-2-Loading-a-Page-from-Storage-to-Empty-Slot" class="headerlink" title="8.4.2. Loading a Page from Storage to Empty Slot"></a>8.4.2. Loading a Page from Storage to Empty Slot</h4><p><strong>从存储加载页面到空闲槽位</strong></p>
<p>在第二种情况下，假设所需的页面不在缓冲池中，且空闲列表有空闲元素（即空描述符）。<br>此时，缓冲区管理器执行以下步骤：</p>
<p>(1) 查找缓冲表（我们假设未找到）。</p>
<ol>
<li>创建所需页面的buffer_tag（在此例中为’Tag_E’）并计算相应的哈希桶槽位。  </li>
<li>以共享模式获取BufMappingLock分区。  </li>
<li>查找缓冲表。（根据假设，未找到。）  </li>
<li>释放BufMappingLock。</li>
</ol>
<p>(2) 从空闲列表中获取一个空的缓冲描述符并将其固定。在此例中，获取的描述符的buffer_id为4。</p>
<p>(3) 以排他模式获取BufMappingLock分区。（此锁将在步骤(6)中释放。）</p>
<p>(4) 创建一个新的数据条目，该条目包含buffer_tag ‘Tag_E’和buffer_id 4，并将创建的条目插入到缓冲表中。</p>
<p>(5) 如下所示，从存储加载所需页面数据到buffer_id为4的缓冲池槽位：</p>
<ol>
<li><strong>在9.5或更早版本中</strong>，获取相应描述符的排他io_in_progress_lock。  </li>
<li>将相应描述符的io_in_progress位设置为1，以防止其他进程访问。  </li>
<li>从存储加载所需页面数据到缓冲池槽位。  </li>
<li>更改相应描述符的状态：将io_in_progress位设置为0，并将有效位设置为1。  </li>
<li><strong>在9.5或更早版本中</strong>，释放io_in_progress_lock。</li>
</ol>
<p>(6) 释放BufMappingLock。</p>
<p>(7) 访问buffer_id为4的缓冲池槽位。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_10.png" srcset="/img/loading.gif" lazyload alt="img_10.png"></p>
<h4 id="8-4-3-Loading-a-Page-from-Storage-to-a-Victim-Buffer-Pool-Slot"><a href="#8-4-3-Loading-a-Page-from-Storage-to-a-Victim-Buffer-Pool-Slot" class="headerlink" title="8.4.3. Loading a Page from Storage to a Victim Buffer Pool Slot"></a>8.4.3. Loading a Page from Storage to a Victim Buffer Pool Slot</h4><p><strong>从存储加载页面到牺牲缓冲池槽位</strong></p>
<p>在这种情况下，假设所有缓冲池槽位都被页面占用，但所需的页面并未存储在其中。缓冲区管理器执行以下步骤：</p>
<p>(1) 创建所需页面的buffer_tag并查找缓冲表。在此例中，我们假设buffer_tag为’Tag_M’（未找到所需页面）。</p>
<p>(2) 使用时钟扫描算法选择一个牺牲缓冲池槽位。从缓冲表中获取旧条目，该条目包含牺牲槽位的buffer_id，<br>并在缓冲描述符层中固定牺牲槽位。在此例中，牺牲槽位的buffer_id为5，旧条目为’Tag_F, id&#x3D;5’。<br>时钟扫描算法在8.4.4节中描述。</p>
<p>(3) 如果牺牲页面脏，则刷新（写入和fsync）牺牲页面数据；否则进入步骤(4)。<br>在覆盖新数据前，脏页面必须写入存储。刷新脏页面的操作如下：</p>
<ol>
<li>获取buffer_id为5的描述符的共享content_lock和排他io_in_progress锁（在步骤6中释放）。  </li>
<li>更改相应描述符的状态：将io_in_progress位设置为1，将just_dirtied位设置为0。  </li>
<li>根据情况，调用XLogFlush()函数将WAL缓冲区中的WAL数据写入当前WAL段文件<br>（具体细节省略；WAL和XLogFlush()函数在第9章中描述）。  </li>
<li>将牺牲页面数据刷新到存储。  </li>
<li>更改相应描述符的状态：将io_in_progress位设置为0，将有效位设置为1。  </li>
<li>释放io_in_progress和content_lock锁。</li>
</ol>
<p>(4) 以排他模式获取包含旧条目的槽位的旧BufMappingLock分区。</p>
<p>(5) 获取新BufMappingLock分区并向缓冲表插入新条目：</p>
<ol>
<li>创建由新buffer_tag ‘Tag_M’和牺牲者的buffer_id组成的新条目。  </li>
<li>获取包含新条目的槽位的新BufMappingLock分区的排他锁。  </li>
<li>将新条目插入缓冲表中。</li>
</ol>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_11.png" srcset="/img/loading.gif" lazyload alt="img_11.png"></p>
<p>(6) 从缓冲表中删除旧条目，并释放旧的BufMappingLock分区。</p>
<p>(7) 从存储加载所需页面数据到牺牲缓冲槽位。然后，更新buffer_id为5的描述符的标志位；<br>将脏位设为0，并初始化其他位。</p>
<p>(8) 释放新的BufMappingLock分区。</p>
<p>(9) 访问buffer_id为5的缓冲池槽位。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_12.png" srcset="/img/loading.gif" lazyload alt="img_12.png"></p>
<h4 id="8-4-4-Page-Replacement-Algorithm-Clock-Sweep"><a href="#8-4-4-Page-Replacement-Algorithm-Clock-Sweep" class="headerlink" title="8.4.4. Page Replacement Algorithm: Clock Sweep"></a>8.4.4. Page Replacement Algorithm: Clock Sweep</h4><p><strong>页面替换算法：时钟扫描</strong></p>
<p>本节剩余部分将描述时钟扫描算法。此算法是低开销的NFU（不经常使用）算法变体，<br>能高效地选择使用频率较低的页面。</p>
<p>想象缓冲描述符组成一个环形列表（见图8.12）。一个无符号的32位整数nextVictimBuffer总是指向其中一个缓冲描述符，<br>并顺时针旋转。该算法的伪代码及描述如下：</p>
<blockquote>
<p>Pseudocode: clock-sweep</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs commandline">    WHILE true<br>(1)    Obtain the candidate buffer descriptor pointed by the nextVictimBuffer<br>(2)    IF the candidate descriptor is &#x27;unpinned&#x27; THEN<br>(3)       IF the candidate descriptor&#x27;s usage_count == 0 THEN<br>             BREAK WHILE LOOP  /* the corresponding slot of this descriptor */<br>                               /* is victim slot.                           */<br>          ELSE<br>             Decrease the candidate descriptpor&#x27;s usage_count by 1<br>          END IF<br>       END IF<br>(4)    Advance nextVictimBuffer to the next one<br>    END WHILE <br>(5) RETURN buffer_id of the victim<br></code></pre></td></tr></table></figure>

<p>(1) 获取由nextVictimBuffer指向的候选缓冲描述符。<br>(2) 如果候选缓冲描述符未被固定，进入步骤(3)。否则，进入步骤(4)。<br>(3) 如果候选描述符的usage_count为0，选择该描述符对应的槽位作为牺牲者，进入步骤(5)。<br>否则，将此描述符的usage_count减1，然后回到步骤(4)。<br>(4) 将nextVictimBuffer推进到下一个描述符（如果是最后一个，则回绕到开头），<br>然后返回步骤(1)。重复此过程，直到找到牺牲者。<br>(5) 返回牺牲者的buffer_id。  </p>
</blockquote>
<p>图8.12展示了一个具体示例。缓冲描述符以蓝色或青色方框表示，方框内的数字展示了每个描述符的usage_count。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_13.png" srcset="/img/loading.gif" lazyload alt="img_13.png"></p>
<ol>
<li>nextVictimBuffer指向第一个描述符（buffer_id为1）。但是，由于该描述符被固定，所以跳过了它。  </li>
<li>nextVictimBuffer指向第二个描述符（buffer_id为2）。此描述符未被固定，但其usage_count为2。<br>因此，将usage_count减1，并将nextVictimBuffer推进到第三个候选描述符。  </li>
<li>nextVictimBuffer指向第三个描述符（buffer_id为3）。此描述符未被固定且其usage_count为0。<br>因此，在这一轮中，这就是牺牲者。</li>
</ol>
<p>每当nextVictimBuffer遍历到一个未固定的描述符时，都会将其usage_count减1。<br>因此，如果缓冲池中存在未固定的描述符，通过循环移动nextVictimBuffer，<br>此算法总能找到一个usage_count为0的牺牲者。</p>
<h3 id="8-5-Ring-Buffer"><a href="#8-5-Ring-Buffer" class="headerlink" title="8.5 Ring Buffer"></a><a name="Ring-Buffer"></a>8.5 Ring Buffer</h3><p><strong>环形缓冲区</strong></p>
<p>当读取或写入大型表时，PostgreSQL会使用环形缓冲区而非缓冲池。</p>
<p>环形缓冲区是一个小型且临时的缓冲区域。满足以下任一条件时，会在共享内存中分配一个环形缓冲区：</p>
<p>(1). 批量读取：<br>当扫描的表大小超过缓冲池大小的四分之一（ shared_buffers &#x2F; 4 ）时。这种情况下，环形缓冲区的大小为256 KB。</p>
<p>(2). 批量写入：<br>当执行下列SQL命令时。这种情况下，环形缓冲区的大小为16 MB。</p>
<ol>
<li>COPY FROM命令。  </li>
<li>CREATE TABLE AS命令。  </li>
<li>CREATE MATERIALIZED VIEW或REFRESH MATERIALIZED VIEW命令。  </li>
<li>ALTER TABLE命令。</li>
</ol>
<p>(3). Vacuum-processing:<br>当自动真空处理（autovacuum）执行真空处理时。这种情况下，环形缓冲区的大小也为256 KB。</p>
<p>分配的环形缓冲区在使用完毕后会立即释放。</p>
<p>环形缓冲区的好处显而易见。如果后端进程在不使用环形缓冲区的情况下读取大型表，<br>缓冲池中存储的所有页面都会被替换出去，从而降低了缓存命中率。环形缓冲区通过为大型表提供一个临时缓冲区域，<br>避免了这个问题。</p>
<blockquote>
<p>为什么批量读取和真空处理的默认环形缓冲区大小为256 KB呢？</p>
<p>为何是256 KB？答案在缓冲区管理器源代码目录下的README文件(src&#x2F;backend&#x2F;storage&#x2F;buffer&#x2F;README)中有解释。</p>
<p>对于顺序扫描，使用了256 KB大小的环。这个大小足够小，能够适应L2缓存，使得从操作系统缓存传输页面到<br>共享缓冲区缓存的过程变得高效。通常情况下，即使更小的容量也常常足够，但环形缓冲区必须足够大，<br>以容纳扫描过程中同时被固定的全部页面。（节选）</p>
</blockquote>
<h3 id="8-6-Flushing-Dirty-Pages"><a href="#8-6-Flushing-Dirty-Pages" class="headerlink" title="8.6 Flushing Dirty Pages"></a><a name="Flush-DP"></a>8.6 Flushing Dirty Pages</h3><p>除了替换牺牲页面外，检查点进程（checkpointer）和后台写入器进程（background writer）还会将脏页面刷新到存储中。<br>这两个进程具有相同的刷新脏页功能，但它们扮演的角色和行为有所不同。</p>
<p>检查点进程在每次检查点开始时，会向WAL段文件写入检查点记录并刷新脏页面。第9.7节描述了检查点及何时启动。</p>
<p>后台写入器的作用是减轻检查点密集写入的影响。后台写入器持续不断地、以最小化对数据库活动影响的方式一点点刷新脏页面。<br>默认情况下，后台写入器每隔200毫秒（由bgwriter_delay定义）唤醒一次，并最多刷新bgwriter_lru_maxpages个页面<br>（默认是100页）。</p>
<p>这样的设计旨在平衡性能和数据安全性，确保即使在高负载下也能定期将数据持久化，同时避免在检查点时刻产生太大<br>的I&#x2F;O压力，从而维持数据库运行的稳定性。</p>
<blockquote>
<p>为什么检查点进程要与后台写入器分开？</p>
<p>在9.1或更早的版本中，后台写入器进程定期执行检查点处理工作。</p>
<p>在9.2版本中，检查点进程从后台写入器进程中分离出来。原因在于一份名为“分离后台写入器和检查点进程”的提案中<br>有所描述，下面摘录了其中的部分内容(<a target="_blank" rel="noopener" href="https://www.postgresql.org/message-id/CA%2BU5nMLv2ah-HNHaQ%3D2rxhp_hDJ9jcf-LL2kW3sE4msfnUw9gA%40mail.gmail.com)%EF%BC%9A">https://www.postgresql.org/message-id/CA%2BU5nMLv2ah-HNHaQ%3D2rxhp_hDJ9jcf-LL2kW3sE4msfnUw9gA%40mail.gmail.com)：</a></p>
<p>目前（2011年），后台写入器进程同时执行后台写入、检查点处理以及其他一些职责。<br>这意味着我们无法在不停止后台写入的情况下执行最后检查点的fsync操作，因此在一个进程中同时做这两件事会<br>对性能产生负面影响。<br>此外，我们在9.2版本的目标是用闩锁（latches）代替轮询循环以降低功耗。后台写入器循环的复杂性较高，<br>而且似乎不太可能提出一个使用闩锁的干净解决方案。<br>（节选）</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/BOOK/" class="category-chain-item">BOOK</a>
  
  
    <span>></span>
    
  <a href="/categories/BOOK/PostgreSQL%E6%8C%87%E5%8D%97%EF%BC%9A%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2/" class="category-chain-item">PostgreSQL指南：内幕探索</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/book/" class="print-no-link">#book</a>
      
        <a href="/tags/database/" class="print-no-link">#database</a>
      
        <a href="/tags/transactions/" class="print-no-link">#transactions</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>ch8. Buffer Manager</div>
      <div>http://smilemzy.com/2025/05/05/DB/PostgreSQL指南/内幕探索_new_release/ch8/ch8/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Smile</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/" title="ch9. WRITE AHEAD LOGGING (WAL)">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ch9. WRITE AHEAD LOGGING (WAL)</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch7/ch7/" title="ch7. HOT and Index-Only Scans">
                        <span class="hidden-mobile">ch7. HOT and Index-Only Scans</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
