

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Smile">
  <meta name="keywords" content="">
  
    <meta name="description" content="ch9. WRITE AHEAD LOGGING (WAL)事务日志是数据库的重要组成部分,因为它们可以确保即使在系统故障的情况下也不会丢失任何数据。它们是数据库系统中所有更改和操作的历史记录。这确保了即使出现电源故障或服务器崩溃等故障,也不会丢失任何数据。 日志包含已执行的每个事务的足够信息,因此数据库服务器可以通过在事务日志中重放更改和操作来恢复数据库集群,以应对服务器崩溃的情况。 在计算机科">
<meta property="og:type" content="article">
<meta property="og:title" content="ch9. WRITE AHEAD LOGGING (WAL)">
<meta property="og:url" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/index.html">
<meta property="og:site_name" content="Smile">
<meta property="og:description" content="ch9. WRITE AHEAD LOGGING (WAL)事务日志是数据库的重要组成部分,因为它们可以确保即使在系统故障的情况下也不会丢失任何数据。它们是数据库系统中所有更改和操作的历史记录。这确保了即使出现电源故障或服务器崩溃等故障,也不会丢失任何数据。 日志包含已执行的每个事务的足够信息,因此数据库服务器可以通过在事务日志中重放更改和操作来恢复数据库集群,以应对服务器崩溃的情况。 在计算机科">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_1.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_2.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_3.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_4.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_5.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_6.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_7.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_8.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_9.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_10.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_11.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_12.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_13.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_14.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_15.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_16.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_17.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_18.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_19.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_20.png">
<meta property="article:published_time" content="2025-05-05T12:24:15.204Z">
<meta property="article:modified_time" content="2025-05-06T11:45:19.346Z">
<meta property="article:author" content="Smile">
<meta property="article:tag" content="book">
<meta property="article:tag" content="database">
<meta property="article:tag" content="transactions">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img.png">
  
  
  
  <title>ch9. WRITE AHEAD LOGGING (WAL) - Smile</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"smilemzy.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Smile</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="ch9. WRITE AHEAD LOGGING (WAL)"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-05 20:24" pubdate>
          2025年5月5日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          10k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          86 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">ch9. WRITE AHEAD LOGGING (WAL)</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="ch9-WRITE-AHEAD-LOGGING-WAL"><a href="#ch9-WRITE-AHEAD-LOGGING-WAL" class="headerlink" title="ch9. WRITE AHEAD LOGGING (WAL)"></a>ch9. WRITE AHEAD LOGGING (WAL)</h2><p>事务日志是数据库的重要组成部分,因为它们可以确保即使在系统故障的情况下也不会丢失任何数据。<br>它们是数据库系统中所有更改和操作的历史记录。这确保了即使出现电源故障或服务器崩溃等故障,<br>也不会丢失任何数据。</p>
<p>日志包含已执行的每个事务的足够信息,因此数据库服务器可以通过在事务日志中重放更改和操作来恢复数据库集群,<br>以应对服务器崩溃的情况。</p>
<p>在计算机科学领域,WAL是”预写式日志”(Write-Ahead Logging)的缩写,这是一种要求将更改和操作都写入事务<br>日志的协议或规则。但是,在PostgreSQL中,WAL也是”预写式日志”(Write Ahead Log)的缩写。<br>在PostgreSQL中,WAL一词可以与事务日志互换使用,它也指用于将操作写入事务日志的实现机制(WAL)。<br>尽管这可能会造成混淆,但本文将采用PostgreSQL的定义。</p>
<p>WAL机制是在7.1版本中首次实现的,用于减轻服务器崩溃的影响。它还使得实现时间点恢复(PITR)和流复制(SR)<br>成为可能,这两者分别在第10章和第11章中进行了描述。</p>
<p>尽管理解WAL机制对于使用PostgreSQL进行系统集成和管理至关重要,<br>但这种机制的复杂性使得无法简单概括其描述。因此,PostgreSQL中WAL的完整解释如下:</p>
<ol>
<li>WAL(事务日志)的逻辑和物理结构。  </li>
<li>WAL数据的内部布局。  </li>
<li>WAL数据的写入。  </li>
<li>WAL写入器进程。  </li>
<li>检查点处理。  </li>
<li>数据库恢复处理。  </li>
<li>WAL段文件的管理。  </li>
<li>连续归档。</li>
</ol>
<table>
<thead>
<tr>
<th>Chapter Contents</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#9-Overview">9.1. Overview</a></td>
</tr>
<tr>
<td><a href="#tlog-wal">9.2. Transaction Log and WAL Segment Files</a></td>
</tr>
<tr>
<td><a href="#wal-seg">9.3. Internal Layout of WAL Segment</a></td>
</tr>
<tr>
<td><a href="#xlog-record">9.4. Internal Layout of XLOG Record</a></td>
</tr>
<tr>
<td><a href="#write-xlog">9.5. Writing of XLOG Records</a></td>
</tr>
<tr>
<td><a href="#wal-writer">9.6. WAL Writer Process</a></td>
</tr>
<tr>
<td><a href="#checkpoint">9.7. Checkpoint Processing in PostgreSQL</a></td>
</tr>
<tr>
<td><a href="#recovery">9.8. Database Recovery in PostgreSQL</a></td>
</tr>
<tr>
<td><a href="#wal-file">9.9. WAL Segment Files Management</a></td>
</tr>
<tr>
<td><a href="#archive">9.10. Continuous Archiving and Archive Logs</a></td>
</tr>
</tbody></table>
<h3 id="9-1-Overview"><a href="#9-1-Overview" class="headerlink" title="9.1. Overview"></a><a name="9-Overview"></a>9.1. Overview</h3><p>让我们一起来了解一下WAL（Write-Ahead Log，预写式日志）机制的概览。为了阐明WAL解决的问题，<br>第一小节将展示如果PostgreSQL没有实现WAL，在发生崩溃时会发生什么情况。第二小节将介绍一些关键概念，<br>并展示本章主要主题的概览：WAL数据的写入与数据库恢复过程。最后一小节通过增加另一个关键概念来完善WAL的概览。</p>
<p>在本节中，为了简化描述，我们使用了一个仅包含一页的表TABLE_A作为示例。</p>
<h4 id="9-1-1-Insertion-Operations-without-WAL"><a href="#9-1-1-Insertion-Operations-without-WAL" class="headerlink" title="9.1.1. Insertion Operations without WAL"></a>9.1.1. Insertion Operations without WAL</h4><p><strong>不使用WAL的插入操作</strong></p>
<p>正如第8章所述，每个数据库管理系统都实现了共享缓冲池，以提供对关系页面的有效访问。</p>
<p>假设我们在未实现WAL特性的PostgreSQL中向TABLE_A插入一些数据元组。这种情况在图9.1中进行了说明。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img.png" srcset="/img/loading.gif" lazyload alt="img.png"></p>
<ol>
<li>当我们发出第一条INSERT语句时，PostgreSQL会将TABLE_A页面从数据库集群加载到内存中的共享缓冲池，<br>并在页面中插入一个元组。页面不会立即写回到数据库集群中。（如第8章所述，修改过的页面通常被称为脏页面。）  </li>
<li>当我们发出第二条INSERT语句时，PostgreSQL会在缓冲池中的页面插入一个新的元组。该页面尚未被写入到存储中。  </li>
<li>如果操作系统或PostgreSQL服务器因任何原因（如电源故障）发生故障，所有插入的数据都将丢失。</li>
</ol>
<p>因此，没有WAL的数据库在系统故障面前是非常脆弱的。</p>
<blockquote>
<p>Historical Info</p>
<p>在引入WAL之前（7.0或更早版本），PostgreSQL为了确保数据的持久性，<br>每当内存中的页面发生变化时，就会发出sync系统调用来执行磁盘的同步写入。<br>这使得INSERT、UPDATE等修改命令的性能非常差。</p>
</blockquote>
<h4 id="9-1-2-Insertion-Operations-and-Database-Recovery"><a href="#9-1-2-Insertion-Operations-and-Database-Recovery" class="headerlink" title="9.1.2. Insertion Operations and Database Recovery"></a>9.1.2. Insertion Operations and Database Recovery</h4><p>为了解决上述系统故障问题而又不损害性能，PostgreSQL支持WAL。<br>在本小节中，将首先介绍一些关键词和关键概念，随后讲述WAL数据的写入与数据库的恢复过程。</p>
<p>PostgreSQL将所有修改作为历史数据写入持久化存储中，以便应对故障。在PostgreSQL中，这些历史数据被称为<br>XLOG记录或WAL数据。</p>
<p>XLOG记录由插入、删除或提交动作等变更操作写入内存中的WAL缓冲区。当事务提交或中止时，它们会立即被写入<br>到存储上的WAL段文件中。（准确地说，XLOG记录的写入可能发生在其他情况下。具体细节将在第9.5节中描述。）<br>XLOG记录的LSN（Log Sequence Number，日志序列号）代表其记录在事务日志上的写入位置。<br>记录的LSN用作XLOG记录的唯一ID。</p>
<p>在考虑数据库系统如何恢复时，可能会产生一个问题：PostgreSQL从哪个点开始恢复？答案是REDO点。<br>即最近一次检查点启动时刻XLOG记录被写入的位置。（PostgreSQL中的检查点在第9.7节中描述。）实际上，<br>数据库恢复过程与检查点过程紧密相关，这两个过程是不可分割的。</p>
<blockquote>
<p>Info</p>
<p>WAL和检查点进程是在7.1版本中同时实现的。</p>
</blockquote>
<p>随着主要关键词和概念的介绍刚刚结束，接下来将描述带有WAL的元组插入过程。请参考图9.2及其后续描述。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_1.png" srcset="/img/loading.gif" lazyload alt="img_1.png"></p>
<blockquote>
<p>Notation</p>
<p>TABLE_A的LSN显示的是TABLE_A页面头部的pd_lsn值。<br>页面的LSN同理。</p>
</blockquote>
<ol>
<li>检查点进程作为后台进程，会周期性地执行检查点操作。每当检查点进程启动时，<br>它会在当前的WAL段中写入一个称为检查点记录的XLOG记录。这个记录包含了最新REDO点的位置。  </li>
<li>当我们发出第一条INSERT语句时，PostgreSQL会将TABLE_A页面加载到共享缓冲池中，<br>在页面中插入一个元组，创建并在这个语句的LSN_1位置向WAL缓冲区写入一条XLOG记录，<br>同时将TABLE_A的LSN从LSN_0更新到LSN_1。<br>在此例中，这条XLOG记录是由头数据和整个元组组成的一对。  </li>
<li>随着该事务的提交，PostgreSQL会创建并写入一条关于此提交动作的XLOG记录到WAL缓冲区，<br>然后从LSN_1开始，将WAL缓冲区中的所有XLOG记录写入并刷新到WAL段文件中。  </li>
<li>当我们发出第二条INSERT语句时，PostgreSQL在页面中插入一个新的元组，<br>创建并在此元组的LSN_2位置向WAL缓冲区写入XLOG记录，并将TABLE_A的LSN从LSN_1更新到LSN_2。  </li>
<li>当此语句的事务提交时，PostgreSQL的操作方式与步骤(3)相同。  </li>
<li>假设操作系统发生故障。尽管共享缓冲池中的所有数据都丢失了，<br>但对页面的所有修改都作为历史数据被写入到了WAL段文件中。</li>
</ol>
<p>下面的指示说明了如何将我们的数据库集群恢复到崩溃前的状态。<br>无需特别操作，因为通过重新启动，PostgreSQL会自动进入恢复模式。请参阅图9.3（以及此幻灯片）。<br>PostgreSQL将顺序读取并重放从REDO点开始的适当WAL段文件中的XLOG记录。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_2.png" srcset="/img/loading.gif" lazyload alt="img_2.png"></p>
<ol>
<li>PostgreSQL从适当的WAL段文件中读取第一条INSERT语句的XLOG记录，<br>并将TABLE_A页面从数据库集群加载到共享缓冲池中。  </li>
<li>在尝试重放XLOG记录之前，PostgreSQL会将XLOG记录的LSN与对应页面的LSN进行比较。这样做的原因将在第9.8节中描述。<br>重放XLOG记录的规则如下： 如果XLOG记录的LSN大于页面的LSN，那么XLOG记录的数据部分会被插入到页面中，<br>并且页面的LSN会被更新为XLOG记录的LSN。 另一方面，如果XLOG记录的LSN较小，则除了读取下一条WAL记录外，<br>无需做其他操作。 在此例中，由于XLOG记录的LSN（LSN_1）大于TABLE_A的LSN（LSN_0）<br>，因此XLOG记录被重放。随后，TABLE_A的LSN从LSN_0更新为LSN_1。  </li>
<li>PostgreSQL以相同的方式重放剩余的XLOG记录。</li>
</ol>
<p>通过按时间顺序重放WAL段文件中写入的XLOG记录，PostgreSQL可以以这种方式自我恢复。<br>因此，PostgreSQL的XLOG记录是REDO日志。</p>
<blockquote>
<p>Note</p>
<p>PostgreSQL does not support UNDO log.</p>
</blockquote>
<p>虽然写入XLOG记录确实会消耗一定的成本，但这与写入整个修改过的页面相比微不足道。<br>我们确信，我们获得的利益，即系统故障容忍度，远大于我们的付出。</p>
<h4 id="9-1-3-Full-Page-Writes"><a href="#9-1-3-Full-Page-Writes" class="headerlink" title="9.1.3. Full-Page Writes"></a>9.1.3. Full-Page Writes</h4><p>假设由于操作系统在后台写入器进程正在写入脏页面时发生故障，导致存储上的TABLE_A页面数据损坏。<br>由于XLOG记录不能在损坏的页面上重放，我们需要额外的功能来处理这种情况。</p>
<p>PostgreSQL支持一种称为全页写入的特性来应对这类故障。如果启用此功能，PostgreSQL会在每次检查点后，<br>对每个页面的首次更改时，将页头数据和整个页面作为一个XLOG记录写入。（这是默认设置。）在PostgreSQL中，<br>包含整个页面的这种XLOG记录称为备份块（或全页映像）。</p>
<p>让我们再次描述元组的插入过程，但这次启用全页写入。请参阅图9.4及其后续描述。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_3.png" srcset="/img/loading.gif" lazyload alt="img_3.png"></p>
<ol>
<li>检查点进程开始执行检查点操作。  </li>
<li>当我们插入第一条INSERT语句时，PostgreSQL的操作方式与上一小节类似，但这里的XLOG记录是该页面的备份块，<br>因为这是在最近一次检查点之后首次对该页面进行写入。（换句话说，它包含了整个页面的内容。）  </li>
<li>随着该事务的提交，PostgreSQL的操作方式与上一小节相同。    </li>
<li>当我们插入第二条INSERT语句时，PostgreSQL的操作方式与上一小节相同，因为这次的XLOG记录并不是备份块。  </li>
<li>当此语句的事务提交时，PostgreSQL的操作方式与上一小节相同。  </li>
<li>为了展示全页写入的有效性，让我们考虑这样一个场景：由于后台写入器在向存储（硬盘驱动器或固态硬盘）<br>写入TABLE_A页面时操作系统发生故障，导致存储上的TABLE_A页面数据损坏。</li>
</ol>
<p>重启PostgreSQL服务器以修复损坏的集群。请参阅图9.5及其后续描述。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_4.png" srcset="/img/loading.gif" lazyload alt="img_4.png"></p>
<ol>
<li>PostgreSQL读取第一条INSERT语句的XLOG记录，并将损坏的TABLE_A页面从数据库集群加载到共享缓冲池中。<br>在此例中，XLOG记录是备份块， 因为根据全页写入的写入规则，每个页面的第一个XLOG记录始终是其备份块。  </li>
<li>当XLOG记录是其备份块时，将应用另一条重放规则：无论两个LSN的值如何，记录的数据部分（即页面本身）<br>都要覆盖写入到页面上，并将页面的LSN更新为XLOG记录的LSN。 在此例中，PostgreSQL将记录的数据部分<br>覆盖到损坏的页面上，并将TABLE_A的LSN更新为LSN_1。这样，损坏的页面就通过其备份块得到了恢复。  </li>
<li>由于第二条XLOG记录是非备份块，PostgreSQL的操作方式与前一小节中的说明相同。</li>
</ol>
<p>通过这种方式，即使由于进程或操作系统崩溃导致某些数据写入错误，PostgreSQL也能恢复数据库。</p>
<blockquote>
<p>WAL、备份与复制</p>
<p>如前所述，WAL可以防止由于进程或操作系统崩溃导致的数据丢失。然而，如果发生文件系统或介质故障，数据将会丢失。<br>为了解决这类故障，PostgreSQL提供了在线备份和复制功能。<br>如果定期进行在线备份，即使发生介质故障，也可以从最近的备份中恢复数据库。<br>但需要注意的是，最后一次备份之后所做的更改无法恢复。</p>
<p>同步复制功能可以实时地将所有更改存储到另一个存储或主机上。这意味着，<br>如果主服务器发生介质故障，可以从辅助服务器上恢复数据。</p>
<p>有关更多信息，请分别参阅第10章和第11章。</p>
</blockquote>
<h3 id="9-2-Transaction-Log-and-WAL-Segment-Files"><a href="#9-2-Transaction-Log-and-WAL-Segment-Files" class="headerlink" title="9.2. Transaction Log and WAL Segment Files"></a><a name="tlog-wal"></a>9.2. Transaction Log and WAL Segment Files</h3><p>逻辑上，PostgreSQL将XLOG记录写入一个长度为8字节的虚拟文件（理论上可达16 ExaBytes）。</p>
<p>由于事务日志的容量实际上是无限的，可以说8字节的地址空间是相当庞大的，我们不可能直接处理这么大的文件。<br>因此，PostgreSQL中的事务日志， 默认情况下被划分为多个16 megabytes大小的文件，每个这样的文件称为一个WAL段。<br>请参见图9.6。</p>
<blockquote>
<p>WAL段文件大小</p>
<p>在11或更高版本中，可以在使用initdb命令创建PostgreSQL集群时，通过–wal-segsize选项配置WAL段文件的大小。</p>
</blockquote>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_5.png" srcset="/img/loading.gif" lazyload alt="img_5.png"></p>
<p>WAL段文件名采用十六进制24位数字表示，命名规则如下：</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_6.png" srcset="/img/loading.gif" lazyload alt="img_6.png"></p>
<blockquote>
<p>timelineld</p>
<p>PostgreSQL的WAL中包含时间线ID（4字节无符号整数）的概念，<br>这在第10章描述的即时点恢复（Point-in-Time Recovery, PITR）<br>中使用。但在本章中，时间线ID固定为0x00000001，因为在以下描述中不需要这个概念。</p>
</blockquote>
<p>第一个WAL段文件名为000000010000000000000001。如果第一个文件已通过写入XLOG记录填满，那么将提供<br>第二个文件000000010000000000000002。文件按递增顺序依次使用。在0000000100000000000000FF填满后，<br>下一个文件将是000000010000000100000000。以此类推，每当最后两位数字进位时，中间的8位数字增加1。</p>
<p>同样，0000000100000001000000FF填满后，将提供000000010000000200000000，依此类推。</p>
<p><strong>pg_xlogfile_name &#x2F; pg_walfile_name</strong></p>
<p>使用内置函数pg_xlogfile_name（9.6或更早版本）或pg_walfile_name（10或更高版本），我们可以找到包含指定<br>LSN的WAL段文件名。下面是一个示例：</p>
<p>在PostgreSQL中，你可以通过这两个函数输入一个LSN值，函数会返回该LSN所在的WAL文件名。<br>这对于管理和恢复数据库时定位特定WAL段非常有用。例如，如果你需要知道某个特定事务日志记录所在的确切WAL文件，<br>就可以使用这些函数来获取该信息。在不同版本的PostgreSQL中，需选用相应的函数来进行查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> pg_xlogfile_name(<span class="hljs-string">&#x27;1/00002D3E&#x27;</span>);  # <span class="hljs-keyword">In</span> versions <span class="hljs-number">10</span> <span class="hljs-keyword">or</span> later, &quot;SELECT pg_walfile_name(&#x27;1/00002D3E&#x27;);&quot;<br>     pg_xlogfile_name     <br><span class="hljs-comment">--------------------------</span><br> <span class="hljs-number">000000010000000100000000</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>
<h3 id="9-3-Internal-Layout-of-WAL-Segment"><a href="#9-3-Internal-Layout-of-WAL-Segment" class="headerlink" title="9.3. Internal Layout of WAL Segment"></a><a name="wal-seg"></a>9.3. Internal Layout of WAL Segment</h3><p><strong>WAL段的内部结构</strong></p>
<p>WAL段默认是一个16MB大小的文件，其内部被划分为8192字节（8KB）大小的页面。<br>首页面包含一个由XLogLongPageHeaderData结构定义的页头数据，而所有其他页面的页头则包含由<br>XLogPageHeaderData结构定义的页面信息。在页头之后，XLOG记录按照从页首开始的降序在每个页面中写入。<br>请参见图9.7。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_7.png" srcset="/img/loading.gif" lazyload alt="img_7.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> XLogPageHeaderData *XLogPageHeader;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * When the XLP_LONG_HEADER flag is set, we store additional fields in the</span><br><span class="hljs-comment"> * page header.  (This is ordinarily done just in the first page of an</span><br><span class="hljs-comment"> * XLOG file.)	The additional fields serve to identify the file accurately.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XLogLongPageHeaderData</span></span><br><span class="hljs-class">&#123;</span><br>	XLogPageHeaderData <span class="hljs-built_in">std</span>;		<span class="hljs-comment">/* standard header fields */</span><br>	uint64		xlp_sysid;		<span class="hljs-comment">/* system identifier from pg_control */</span><br>	uint32		xlp_seg_size;	<span class="hljs-comment">/* just as a cross-check */</span><br>	uint32		xlp_xlog_blcksz;	<span class="hljs-comment">/* just as a cross-check */</span><br>&#125; XLogLongPageHeaderData;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Each page of XLOG file has a header like this:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XLOG_PAGE_MAGIC 0xD113	<span class="hljs-comment">/* can be used as WAL version indicator */</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XLogPageHeaderData</span></span><br><span class="hljs-class">&#123;</span><br>	uint16		xlp_magic;		<span class="hljs-comment">/* magic value for correctness checks */</span><br>	uint16		xlp_info;		<span class="hljs-comment">/* flag bits, see below */</span><br>	TimeLineID	xlp_tli;		<span class="hljs-comment">/* TimeLineID of first record on page */</span><br>	XLogRecPtr	xlp_pageaddr;	<span class="hljs-comment">/* XLOG address of this page */</span><br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * When there is not enough space on current page for whole record, we</span><br><span class="hljs-comment">	 * continue on the next page.  xlp_rem_len is the number of bytes</span><br><span class="hljs-comment">	 * remaining from a previous page; it tracks xl_tot_len in the initial</span><br><span class="hljs-comment">	 * header.  Note that the continuation data isn&#x27;t necessarily aligned.</span><br><span class="hljs-comment">	 */</span><br>	uint32		xlp_rem_len;	<span class="hljs-comment">/* total len of remaining data for record */</span><br>&#125; XLogPageHeaderData;<br></code></pre></td></tr></table></figure>

<p>XLogLongPageHeaderData结构和XLogPageHeaderData结构在src&#x2F;include&#x2F;access&#x2F;xlog_internal.h文件中定义。<br>这里省略了对这两个结构的详细解释，因为在接下来的描述中并不需要它们的具体细节。</p>
<h3 id="9-4-Internal-Layout-of-XLOG-Record"><a href="#9-4-Internal-Layout-of-XLOG-Record" class="headerlink" title="9.4. Internal Layout of XLOG Record"></a><a name="xlog-record"></a>9.4. Internal Layout of XLOG Record</h3><p>一条XLOG记录由通用的头部部分和相关的数据部分组成。第一个小节描述了头部结构。接下来的两个小节分别<br>解释了9.4及更早版本和9.5版本中数据部分的结构。(数据格式在9.5版本中发生了变化。)</p>
<h4 id="9-4-1-Header-Portion-of-XLOG-Record"><a href="#9-4-1-Header-Portion-of-XLOG-Record" class="headerlink" title="9.4.1. Header Portion of XLOG Record"></a>9.4.1. Header Portion of XLOG Record</h4><p><strong>XLOG 记录的头部部分</strong><br>所有的XLOG记录都有一个由XLogRecord结构定义的通用头部部分。<br>下面展示了9.4及更早版本的结构,尽管在9.5版本中已经发生了变化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XLogRecord</span></span><br><span class="hljs-class">&#123;</span><br>   uint32          xl_tot_len;   <span class="hljs-comment">/* total len of entire record */</span><br>   TransactionId   xl_xid;       <span class="hljs-comment">/* xact id */</span><br>   uint32          xl_len;       <span class="hljs-comment">/* total len of rmgr data. This variable was removed in ver.9.5. */</span><br>   uint8           xl_info;      <span class="hljs-comment">/* flag bits, see below */</span><br>   RmgrId          xl_rmid;      <span class="hljs-comment">/* resource manager for this record */</span><br>   <span class="hljs-comment">/* 2 bytes of padding here, initialize to zero */</span><br>   XLogRecPtr      xl_prev;      <span class="hljs-comment">/* ptr to previous record in log */</span><br>   pg_crc32        xl_crc;       <span class="hljs-comment">/* CRC for this record */</span><br>&#125; XLogRecord;<br></code></pre></td></tr></table></figure>

<blockquote>
<p> The Header Portion of XLOG Record in versions 9.5 or later.</p>
<p>在9.5及更高版本中,XLogRecord结构中移除了一个变量(xl_len),以优化XLOG记录格式,<br>从而减少了几个字节的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XLogRecord</span></span><br><span class="hljs-class">&#123;</span><br>  uint32          xl_tot_len;             <span class="hljs-comment">/* total len of entire record */</span><br>  TransactionId 	xl_xid;           	<span class="hljs-comment">/* xact id */</span><br>  XLogRecPtr      xl_prev;                <span class="hljs-comment">/* ptr to previous record in log */</span><br>  uint8           xl_info;                <span class="hljs-comment">/* flag bits, see below */</span><br>  RmgrId          xl_rmid;                <span class="hljs-comment">/* resource manager for this record */</span><br>  <span class="hljs-comment">/* 2 bytes of padding here, initialize to zero */</span><br>  pg_crc32c       xl_crc;                 <span class="hljs-comment">/* CRC for this record */</span><br>  <span class="hljs-comment">/* XLogRecordBlockHeaders and XLogRecordDataHeader follow, no padding */</span><br>&#125; XLogRecord;<br></code></pre></td></tr></table></figure></blockquote>
<p>除了两个变量外，大多数变量都很明显,不需要进行描述。</p>
<p>xl_rmid和xl_info是与资源管理器相关的变量,资源管理器是与WAL特性相关的操作集合,<br>例如写入和重放XLOG记录。随着每个PostgreSQL版本的发展,资源管理器的数量也在增加。<br>PostgreSQL 10版本包含以下内容:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Resource manager</th>
</tr>
</thead>
<tbody><tr>
<td>Heap tuple operations</td>
<td>RM_HEAP, RM_HEAP2</td>
</tr>
<tr>
<td>Index operations</td>
<td>RM_BTREE, RM_HASH, RM_GIN, RM_GIST, RM_SPGIST, RM_BRIN</td>
</tr>
<tr>
<td>Sequence operations</td>
<td>RM_SEQ</td>
</tr>
<tr>
<td>Transaction operations</td>
<td>RM_XACT, RM_MULTIXACT, RM_CLOG, RM_XLOG, RM_COMMIT_TS</td>
</tr>
<tr>
<td>Tablespace operations</td>
<td>RM_SMGR, RM_DBASE, RM_TBLSPC, RM_RELMAP</td>
</tr>
<tr>
<td>replication and hot standby operations</td>
<td>RM_STANDBY, RM_REPLORIGIN, RM_GENERIC_ID, RM_LOGICALMSG_ID</td>
</tr>
</tbody></table>
<p>以下是一些代表性的资源管理器工作示例:</p>
<ol>
<li>如果发出了一条INSERT语句,其XLOG记录的头部变量xl_rmid和xl_info分别被设置<br>为’RM_HEAP’和’XLOG_HEAP_INSERT’。在恢复数据库集群时,根据xl_info选择RM_HEAP的heap_xlog_insert()<br>函数来重放这条XLOG记录。  </li>
<li>类似地,对于UPDATE语句,XLOG记录的头部变量xl_info被设置为’XLOG_HEAP_UPDATE’。在数据库恢复时,<br>RM_HEAP的heap_xlog_update()函数会重放这条记录。  </li>
<li>当事务提交时,其XLOG记录的头部变量xl_rmid和xl_info被设置为’RM_XACT’和’XLOG_XACT_COMMIT’。<br>在恢复数据库集群时,xact_redo_commit()函数会重放这条记录。</li>
</ol>
<blockquote>
<p>Info</p>
<p>XLogRecord structure in versions 9.4 or earlier is defined<br>in src&#x2F;include&#x2F;access&#x2F;xlog.h and that of versions 9.5 or later is<br>defined in src&#x2F;include&#x2F;access&#x2F;xlogrecord.h.</p>
<p>The heap_xlog_insert and heap_xlog_update are defined in<br>src&#x2F;backend&#x2F;access&#x2F;heap&#x2F;heapam.c; while the function xact_redo_commit<br>is defined in src&#x2F;backend&#x2F;access&#x2F;transam&#x2F;xact.c.</p>
</blockquote>
<h4 id="9-4-2-Data-Portion-of-XLOG-Record-versions-9-4-or-earlier"><a href="#9-4-2-Data-Portion-of-XLOG-Record-versions-9-4-or-earlier" class="headerlink" title="9.4.2. Data Portion of XLOG Record (versions 9.4 or earlier)"></a>9.4.2. Data Portion of XLOG Record (versions 9.4 or earlier)</h4><p><strong>XLOG 记录的数据部分 (9.4 版本或更早)</strong></p>
<p>XLOG 记录的数据部分可以分为两类:备份块(包含整个页面)<br>和非备份块(包含不同的数据,具体取决于操作)。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_8.png" srcset="/img/loading.gif" lazyload alt="img_8.png"></p>
<p>XLOG 记录的内部布局如下所述,并给出一些具体示例。</p>
<h5 id="9-4-2-1-Backup-Block"><a href="#9-4-2-1-Backup-Block" class="headerlink" title="9.4.2.1. Backup Block"></a>9.4.2.1. Backup Block</h5><p>备份块的结构如图 9.8(a) 所示。它由两个数据结构和一个数据对象组成:</p>
<ol>
<li>XLogRecord 结构(头部部分)。  </li>
<li>BkpBlock 结构。  </li>
<li>整个页面,除了空闲空间。</li>
</ol>
<p>BkpBlock 结构包含标识数据库集群中页面的变量(即包含该页面的关系的 relfilenode<br>和 fork 号,以及页面的块号),以及页面空闲空间的起始位置和长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BkpBlock</span> @ <span class="hljs-title">include</span>/<span class="hljs-title">access</span>/<span class="hljs-title">xlog_internal</span>.<span class="hljs-title">h</span></span><br><span class="hljs-class">&#123;</span><br>  RelFileNode node;        <span class="hljs-comment">/* relation containing block */</span><br>  ForkNumber  fork;        <span class="hljs-comment">/* fork within the relation */</span><br>  BlockNumber block;       <span class="hljs-comment">/* block number */</span><br>  uint16      hole_offset; <span class="hljs-comment">/* number of bytes before &quot;hole&quot; */</span><br>  uint16      hole_length; <span class="hljs-comment">/* number of bytes in &quot;hole&quot; */</span><br><br>  <span class="hljs-comment">/* ACTUAL BLOCK DATA FOLLOWS AT END OF STRUCT */</span><br>&#125; BkpBlock;<br></code></pre></td></tr></table></figure>

<h5 id="9-4-2-2-Non-Backup-Block"><a href="#9-4-2-2-Non-Backup-Block" class="headerlink" title="9.4.2.2. Non-Backup Block"></a>9.4.2.2. Non-Backup Block</h5><p>对于非备份块,数据部分的布局根据操作的不同而有所不同。以 INSERT 语句的 XLOG 记录为例进行说明,<br>如图 9.8(b) 所示。在这种情况下, INSERT 语句的 XLOG 记录由两个数据结构和一个数据对象组成:</p>
<ol>
<li>XLogRecord (头部部分) 结构。  </li>
<li>xl_heap_insert 结构。  </li>
<li>插入的元组,除去了几个字节。</li>
</ol>
<p>xl_heap_insert 结构包含标识数据库集群中插入的元组的变量(即包含该元组的表的 relfilenode<br>和元组的 tid), 以及该元组的可见性标志。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BlockIdData</span></span><br><span class="hljs-class">&#123;</span><br>   uint16          bi_hi;<br>   uint16          bi_lo;<br>&#125; BlockIdData;<br><br><span class="hljs-keyword">typedef</span> uint16 OffsetNumber;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ItemPointerData</span></span><br><span class="hljs-class">&#123;</span><br>   BlockIdData     ip_blkid;<br>   OffsetNumber    ip_posid;<br>&#125;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RelFileNode</span></span><br><span class="hljs-class">&#123;</span><br>   Oid             spcNode;             <span class="hljs-comment">/* tablespace */</span><br>   Oid             dbNode;              <span class="hljs-comment">/* database */</span><br>   Oid             relNode;             <span class="hljs-comment">/* relation */</span><br>&#125; RelFileNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xl_heaptid</span></span><br><span class="hljs-class">&#123;</span><br>   RelFileNode     node;<br>   ItemPointerData tid;                 <span class="hljs-comment">/* changed tuple id */</span><br>&#125; xl_heaptid;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xl_heap_insert</span></span><br><span class="hljs-class">&#123;</span><br>   xl_heaptid      target;              <span class="hljs-comment">/* inserted tuple id */</span><br>   <span class="hljs-type">bool</span>            all_visible_cleared; <span class="hljs-comment">/* PD_ALL_VISIBLE was cleared */</span><br>&#125; xl_heap_insert;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>info</p>
<p>从插入的元组中删除几个字节的原因在于 xl_heap_header 结构的源代码注释中有所描述:</p>
<p>“我们不会在 WAL 中存储插入或更新的元组的整个固定部分(HeapTupleHeaderData)；通过<br>重建 WAL 记录中其他地方可用的字段,或者可能根本不需要重建,我们可以节省几个字节。”</p>
</blockquote>
<p>再举一个例子。如图 9.8(c) 所示,检查点记录的 XLOG 记录非常简单,由两个数据结构组成:</p>
<ol>
<li>XLogRecord 结构(头部部分)。  </li>
<li>Checkpoint 结构,其中包含检查点信息(更多细节见第 9.7 节)。</li>
</ol>
<blockquote>
<p>info</p>
<p>The xl_heap_header structure is defined in src&#x2F;include&#x2F;access&#x2F;htup.h<br>while the CheckPoint structure is defined in src&#x2F;include&#x2F;catalog&#x2F;pg_control.h.</p>
</blockquote>
<h4 id="9-4-3-Data-Portion-of-XLOG-Record-versions-9-5-or-later"><a href="#9-4-3-Data-Portion-of-XLOG-Record-versions-9-5-or-later" class="headerlink" title="9.4.3. Data Portion of XLOG Record (versions 9.5 or later)"></a>9.4.3. Data Portion of XLOG Record (versions 9.5 or later)</h4><p>在 9.4 或更早的版本中,XLOG 记录没有通用格式,所以每个资源管理器都必须定义自己的格式。<br>这使得维护源代码和实现与 WAL 相关的新功能变得越来越困难。为了解决这个问题,<br>在 9.5 版本中引入了一种独立于资源管理器的通用结构化格式。</p>
<p>XLOG 记录的数据部分可以分为两部分:头部和数据部分,如图 9.9 所示。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_9.png" srcset="/img/loading.gif" lazyload alt="img_9.png"></p>
<p>XLOG 记录的头部包含零个或多个 XLogRecordBlockHeaders 和零个或一个<br>XLogRecordDataHeaderShort(或 XLogRecordDataHeaderLong)。它至少必须包含这些之一。</p>
<p>当记录存储完整页面映像(即备份块)时,XLogRecordBlockHeader 包括<br>XLogRecordBlockImageHeader,如果该块被压缩,还包括 XLogRecordBlockCompressHeader。</p>
<p>XLogRecordBlockHeader<br>XLogRecordBlockImageHeader<br>XLogRecordBlockCompressHeader<br>XLogRecordDataHeader  </p>
<p>数据部分由零个或多个块数据和零个或一个主数据组成,分别对应于 XLogRecordBlockHeader(s)<br>和 XLogRecordDataHeader。</p>
<blockquote>
<p>WAL compression</p>
<p>在版本 9.5 或更高版本中,XLOG 记录中的全页图像可以通过设置参数 wal_compression &#x3D; enable 使用 LZ 压缩方法进行压缩。在这种情况下,将添加 XLogRecordBlockCompressHeader 结构。</p>
<p>这个特性有两个优点和一个缺点:</p>
<p>优点:<br>减少写入记录的 I&#x2F;O 成本。<br>抑制 WAL 段文件的消耗。</p>
<p>缺点:<br>消耗大量 CPU 资源进行压缩。</p>
</blockquote>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_10.png" srcset="/img/loading.gif" lazyload alt="img_10.png"></p>
<h5 id="9-4-3-1-Backup-Block"><a href="#9-4-3-1-Backup-Block" class="headerlink" title="9.4.3.1. Backup Block"></a>9.4.3.1. Backup Block</h5><p>由 INSERT 语句创建的备份块如图 9.10(a) 所示。它由四个数据结构和一个数据对象组成:</p>
<ol>
<li>XLogRecord 结构(头部部分)。  </li>
<li>XLogRecordBlockHeader 结构,包括一个 XLogRecordBlockImageHeader 结构。  </li>
<li>XLogRecordDataHeaderShort 结构。  </li>
<li>备份块(块数据)。  </li>
<li>xl_heap_insert 结构(主数据)。</li>
</ol>
<p>XLogRecordBlockHeader 结构包含了标识数据库集群中块的变量(relfilenode、<br>fork 编号和块编号)。XLogRecordImageHeader 结构包含了这个块的长度和偏移量。<br>(这两个头部结构together可以存储与 9.4 版本之前使用的 BkBlock 结构相同的数据。)</p>
<p>XLogRecordDataHeaderShort 结构存储了 xl_heap_insert 结构的长度,这是记录的主要数据。<br>(见下文。)</p>
<blockquote>
<p>info</p>
<p>XLOG记录中的全页图像的主数据并不经常使用,除了在某些特殊情况下,如逻辑解码和投机性插入。<br>在重播记录时,这些主数据被忽略,因此是冗余数据。这一点未来可能会改进。</p>
<p>此外,备份块记录的主数据取决于创建它们的语句。例如,UPDATE语句会<br>附加xl_heap_lock或xl_heap_updated。</p>
</blockquote>
<h5 id="9-4-3-2-Non-Backup-Block"><a href="#9-4-3-2-Non-Backup-Block" class="headerlink" title="9.4.3.2. Non-Backup Block"></a>9.4.3.2. Non-Backup Block</h5><p>接下来,我将描述由INSERT语句创建的非备份块记录(见图9.10(b))。<br>它由四种数据结构和一个数据对象组成:</p>
<ol>
<li>XLogRecord结构(头部部分)  </li>
<li>XLogRecordBlockHeader结构  </li>
<li>XLogRecordDataHeaderShort结构  </li>
<li>插入的元组(准确地说,是一个xl_heap_header结构和一个插入的数据整体)  </li>
<li>xl_heap_insert结构(主要数据)</li>
</ol>
<p>XLogRecordBlockHeader结构包含三个值(relfilenode、fork number和block number)来<br>指定插入元组的块,以及插入元组数据部分的长度。XLogRecordDataHeaderShort结构包含新的<br>xl_heap_insert结构的长度,这是该记录的主要数据。</p>
<p>新的xl_heap_insert结构只包含两个值:该元组在块内的偏移量和可见性标志。它变得非常简单,<br>因为XLogRecordBlockHeader结构存储了旧的xl_heap_insert结构中的大部分数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xl_heap_insert</span></span><br><span class="hljs-class">&#123;</span><br>        OffsetNumber	offnum;            <span class="hljs-comment">/* inserted tuple&#x27;s offset */</span><br>        uint8           flags;<br><br>        <span class="hljs-comment">/* xl_heap_header &amp; TUPLE DATA in backup block 0 */</span><br>&#125; xl_heap_insert;<br></code></pre></td></tr></table></figure>

<p>作为最后一个示例,图9.10(c)中显示了一个checkpoint记录。它由三种数据结构组成:</p>
<ol>
<li>XLogRecord结构(头部部分)</li>
<li>XLogRecordDataHeaderShort结构(包含主要数据长度)</li>
<li>CheckPoint结构(主要数据)</li>
</ol>
<blockquote>
<p>info</p>
<p>xl_heap_header 结构体被定义在 src&#x2F;include&#x2F;access&#x2F;htup.h 中,而 CheckPoint 结构体被定义在 src&#x2F;include&#x2F;catalog&#x2F;pg_control.h 中。</p>
</blockquote>
<p>虽然新的格式对我们来说有些复杂,但它对资源管理器的解析器来说设计得很好。<br>此外,许多类型的 XLOG 记录的大小通常比之前的小。主要结构体的大小如图 9.8 和 9.10 所示,<br>您可以计算这些记录的大小并进行比较。(新检查点的大小大于以前的,但它包含更多变量。)</p>
<h3 id="9-5-Writing-of-XLOG-Records"><a href="#9-5-Writing-of-XLOG-Records" class="headerlink" title="9.5. Writing of XLOG Records"></a><a name="write-xlog"></a>9.5. Writing of XLOG Records</h3><p>很好,我们已经完成了热身练习,现在准备开始学习 XLOG 记录的写入了。<br>我将尽可能详细地解释该部分内容。</p>
<p>首先,请执行以下语句来探索 PostgreSQL 的内部机制:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">INSERT INTO</span> tbl <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;A&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>好的,通过执行上述语句,内部函数 exec_simple_query() 被调用。<br>exec_simple_query() 的伪代码如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">exec_simple_query() @postgres.c<br><br>(<span class="hljs-number">1</span>) ExtendCLOG() @<span class="hljs-built_in">clog</span>.c                  <span class="hljs-comment">/* Write the state of this transaction</span><br><span class="hljs-comment">                                           * &quot;IN_PROGRESS&quot; to the CLOG.</span><br><span class="hljs-comment">                                           */</span><br>(<span class="hljs-number">2</span>) heap_insert()@heapam.c                <span class="hljs-comment">/* Insert a tuple, creates a XLOG record,</span><br><span class="hljs-comment">                                           * and invoke the function XLogInsert.</span><br><span class="hljs-comment">                                           */</span><br>(<span class="hljs-number">3</span>)   XLogInsert() @xloginsert.c (<span class="hljs-number">9.4</span> or earlier, xlog.c)<br>                                          <span class="hljs-comment">/* Write the XLOG record of the inserted tuple</span><br><span class="hljs-comment">                                           *  to the WAL buffer, and update page&#x27;s pd_lsn.</span><br><span class="hljs-comment">                                           */</span><br>(<span class="hljs-number">4</span>) finish_xact_command() @postgres.c     <span class="hljs-comment">/* Invoke commit action.*/</span>   <br>      XLogInsert() @xloginsert.c (<span class="hljs-number">9.4</span> or earlier, xlog.c)<br>                                          <span class="hljs-comment">/* Write a XLOG record of this commit action </span><br><span class="hljs-comment">                                           * to the WAL buffer.</span><br><span class="hljs-comment">                                           */</span><br>(<span class="hljs-number">5</span>)   XLogWrite() @xloginsert.c (<span class="hljs-number">9.4</span> or earlier, xlog.c)<br>                                          <span class="hljs-comment">/* Write and flush all XLOG records on</span><br><span class="hljs-comment">                                           * the WAL buffer to WAL segment.</span><br><span class="hljs-comment">                                           */</span><br>(<span class="hljs-number">6</span>) TransactionIdCommitTree() @transam.c  <span class="hljs-comment">/* Change the state of this transaction </span><br><span class="hljs-comment">                                           * from &quot;IN_PROGRESS&quot; to &quot;COMMITTED&quot;</span><br><span class="hljs-comment">                                           * on the CLOG.</span><br><span class="hljs-comment">                                           */</span><br></code></pre></td></tr></table></figure>

<p>在以下段落中,将逐行解释伪代码,以帮助您理解 XLOG 记录的写入过程。也请参考图 9.11 和 9.12。</p>
<p>(1) 函数 ExtendCLOG() 将该事务的状态写入(内存中的) CLOG 中,状态为 ‘IN_PROGRESS’。</p>
<p>(2) 函数 heap_insert() 将一个堆元组插入到共享缓冲池中的目标页面,<br>创建该页面的 XLOG 记录,并调用函数 XLogInsert()。</p>
<p>(3) 函数 XLogInsert() 将 heap_insert() 创建的 XLOG 记录写入 WAL 缓冲区,<br>位置为 LSN_1,然后将修改页面的 pd_lsn 从 LSN_0 更新为 LSN_1。</p>
<p>(4) 函数 finish_xact_command()被调用来提交该事务,它创建提交操作的 XLOG 记录,<br>然后函数 XLogInsert() 将此记录写入 WAL 缓冲区,位置为 LSN_2。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_11.png" srcset="/img/loading.gif" lazyload alt="img_11.png"></p>
<p>(5) 函数 XLogWrite() 将 WAL 缓冲区中的所有 XLOG 记录写入并刷新到 WAL 段文件中。<br>如果参数 wal_sync_method 设置为 ‘open_sync’ 或 ‘open_datasync’，这些记录将被同步写入,<br>因为该函数使用 open() 系统调用,并设置 ‘O_SYNC’ 或 ‘O_DSYNC’ 标志进行写入。<br>如果参数设置为 ‘fsync’、’fsync_writethrough’ 或 ‘fdatasync’，将执行相应的系统<br>调用 - fsync()、带 F_FULLFSYNC 选项的 fcntl() 或 fdatasync()。无论如何,<br>所有 XLOG 记录都被确保写入存储介质。</p>
<p>(6) 函数 TransactionIdCommitTree() 将该事务的状态从 ‘IN_PROGRESS’ 更改为 ‘COMMITTED’<br>状态,写入 CLOG。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_12.png" srcset="/img/loading.gif" lazyload alt="img_12.png"></p>
<p>在上述示例中,提交操作导致将 XLOG 记录写入 WAL 段,但也可能由以下任何情况触发写入:</p>
<ol>
<li>一个正在运行的事务已提交或中止。  </li>
<li>WAL 缓冲区已被填满大量元组。(WAL 缓冲区大小由参数 wal_buffers 设置。)  </li>
<li>WAL 写入进程定期执行写入操作。(参见下一节。)</li>
</ol>
<p>如果发生上述任何情况,WAL 缓冲区中的所有 WAL 记录都将写入 WAL 段文件,无论它们所属的事务<br>是否已提交。</p>
<p>毫无疑问,DML(数据操作语言)操作会写入 XLOG 记录,但非 DML 操作也会如此。<br>如前所述,提交操作会写入一条包含已提交事务 ID 的 XLOG 记录。另一个例子是检查点操作,<br>它会写入一条包含检查点相关信息的 XLOG 记录。</p>
<p>此外,SELECT 语句在特殊情况下会创建 XLOG 记录,尽管它通常不会创建这些记录。<br>例如,如果在 SELECT 语句期间通过 HOT (Heap Only Tuple) 删除了不必要的元组并对<br>必要的元组进行了页面碎片整理,那么被修改页面的 XLOG 记录就会被写入 WAL 缓冲区。</p>
<blockquote>
<p>Direct I&#x2F;O</p>
<p>PostgreSQL 15 及之前的版本都不支持直接 I&#x2F;O,尽管这个功能一直在讨论中。<br>可以参考 pgsql-ML 上的这个讨论以及这篇文章。</p>
<p>在 16 版本中,新增了 debug-io-direct 选项。这个选项是为开发人员准备的,<br>用于改进 PostgreSQL 中对直接 I&#x2F;O 的使用。如果开发进展顺利,未来不久直接 I&#x2F;O 功能将<br>得到正式支持。</p>
</blockquote>
<h3 id="9-6-WAL-Writer-Process"><a href="#9-6-WAL-Writer-Process" class="headerlink" title="9.6. WAL Writer Process"></a><a name="wal-writer"></a>9.6. WAL Writer Process</h3><p><strong>WAL 写入进程</strong></p>
<p>WAL 写入进程是一个后台进程,它会定期检查 WAL 缓冲区并将所有未写入的 XLOG 记录写入<br>到 WAL 段中。这个进程可以帮助避免 XLOG 记录写入的突发情况。如果没有启用 WAL 写入进程,<br>当大量数据同时被提交时,XLOG 记录的写入可能会成为瓶颈。</p>
<p>WAL 写入进程默认是启用的,不能被禁用。检查间隔由配置参数 wal_writer_delay 设置,<br>默认值为 200 毫秒。</p>
<h3 id="9-7-Checkpoint-Processing-in-PostgreSQL"><a href="#9-7-Checkpoint-Processing-in-PostgreSQL" class="headerlink" title="9.7. Checkpoint Processing in PostgreSQL"></a><a name="checkpoint"></a>9.7. Checkpoint Processing in PostgreSQL</h3><p>在PostgreSQL中，检查点进程（后台进程）负责执行检查点操作。当以下任一情况发生时，检查点进程将启动：</p>
<ol>
<li>自上一个检查点以来，设置的checkpoint_timeout间隔时间已经过去（默认间隔为300秒）。  </li>
<li>在9.4或更早版本中，自上一个检查点以来，已使用的WAL段文件数量达到了checkpoint_segments设置的数量<br>（默认为3个段）。  </li>
<li>在9.5或更高版本中，pg_wal目录（在9.6或更早版本中为pg_xlog目录）中WAL段文件的总大小超过了<br>max_wal_size参数设定的值（默认值为1GB（64个文件））。  </li>
<li>PostgreSQL服务器以smart或fast模式停止。  </li>
<li>超级用户手动执行CHECKPOINT命令。</li>
</ol>
<blockquote>
<p>info</p>
<p>在9.1或更早的版本中，如第8.6节所述，后台写入器进程同时负责检查点处理和脏页写入。</p>
</blockquote>
<p>在接下来的小节中，将概述检查点的流程以及保存当前检查点元数据的pg_control文件。</p>
<h4 id="9-7-1-Outline-of-the-Checkpoint-Processing"><a href="#9-7-1-Outline-of-the-Checkpoint-Processing" class="headerlink" title="9.7.1. Outline of the Checkpoint Processing"></a>9.7.1. Outline of the Checkpoint Processing</h4><p>检查点过程有两个方面：为数据库恢复做准备，以及清理共享缓冲池中的脏页。<br>在本小节中，我们将重点关注前者方面，并描述其内部处理过程。请参见图9.13以获得概览。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_13.png" srcset="/img/loading.gif" lazyload alt="img_13.png"></p>
<p>(1) 当检查点进程启动时，REDO点被存储在内存中。REDO点是最新检查点启动时刻写入的日志记录的位置，<br>它是数据库恢复的起始点。</p>
<p>(2) 该检查点的XLOG记录（即，检查点记录）被写入WAL缓冲区。该记录的数据部分由CheckPoint结构定义，<br>该结构包含多个变量，如步骤(1)中存储的REDO点。<br>检查点记录被写入的位置也称为检查点。</p>
<p>(3) 共享内存中的所有数据（例如，clog的内容等）都被刷新到存储器中。</p>
<p>(4) 共享缓冲池中的所有脏页都会逐渐被写入并刷新到存储器中。</p>
<p>(5) 更新pg_control文件。这个文件包含了诸如检查点记录写入位置（即，检查点位置）等基本信息。<br>我们将在后面更详细地讨论这个文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CheckPoint</span></span><br><span class="hljs-class">&#123;</span><br>  XLogRecPtr      redo;           <span class="hljs-comment">/* next RecPtr available when we began to</span><br><span class="hljs-comment">                                   * create CheckPoint (i.e. REDO start point) */</span><br>  TimeLineID      ThisTimeLineID; <span class="hljs-comment">/* current TLI */</span><br>  TimeLineID      PrevTimeLineID; <span class="hljs-comment">/* previous TLI, if this record begins a new</span><br><span class="hljs-comment">                                   * timeline (equals ThisTimeLineID otherwise) */</span><br>  <span class="hljs-type">bool</span>            fullPageWrites; <span class="hljs-comment">/* current full_page_writes */</span><br>  uint32          nextXidEpoch;   <span class="hljs-comment">/* higher-order bits of nextXid */</span><br>  TransactionId   nextXid;        <span class="hljs-comment">/* next free XID */</span><br>  Oid             nextOid;        <span class="hljs-comment">/* next free OID */</span><br>  MultiXactId     nextMulti;      <span class="hljs-comment">/* next free MultiXactId */</span><br>  MultiXactOffset nextMultiOffset;<span class="hljs-comment">/* next free MultiXact offset */</span><br>  TransactionId   oldestXid;      <span class="hljs-comment">/* cluster-wide minimum datfrozenxid */</span><br>  Oid             oldestXidDB;    <span class="hljs-comment">/* database with minimum datfrozenxid */</span><br>  MultiXactId     oldestMulti;    <span class="hljs-comment">/* cluster-wide minimum datminmxid */</span><br>  Oid             oldestMultiDB;  <span class="hljs-comment">/* database with minimum datminmxid */</span><br>  <span class="hljs-type">pg_time_t</span>       time;           <span class="hljs-comment">/* time stamp of checkpoint */</span><br><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  * Oldest XID still running. This is only needed to initialize hot standby</span><br><span class="hljs-comment">  * mode from an online checkpoint, so we only bother calculating this for</span><br><span class="hljs-comment">  * online checkpoints and only when wal_level is hot_standby. Otherwise</span><br><span class="hljs-comment">  * it&#x27;s set to InvalidTransactionId.</span><br><span class="hljs-comment">  */</span><br>  TransactionId oldestActiveXid;<br>&#125; CheckPoint;<br></code></pre></td></tr></table></figure>

<p>综上所述，从数据库恢复的角度来概括，检查点创建了一个包含REDO点的检查点记录，并在pg_control文件中存储了<br>检查点位置和其他信息。这样PostgreSQL就可以根据pg_control文件提供的REDO点（从检查点记录中获得），<br>通过重放WAL数据来自我恢复。</p>
<h4 id="9-7-2-pg-control-File"><a href="#9-7-2-pg-control-File" class="headerlink" title="9.7.2. pg_control File"></a>9.7.2. pg_control File</h4><p>由于pg_control文件包含了检查点的基本信息，对于数据库恢复至关重要。如果该文件被损坏或无法读取，<br>恢复过程将无法启动，因为它无法获取一个起始点。</p>
<p>尽管pg_control文件存储了超过40项内容，但以下是下一节将需要的三项内容：  </p>
<ol>
<li>状态（State）——在最近一次检查点启动时数据库服务器的状态。总共有七种状态：<br>‘start up’ 表示系统正在启动。<br>‘shut down’ 表示系统正在通过shutdown命令正常关闭。<br>‘in production’ 表示系统正在运行。等等。  </li>
<li>最新检查点位置（Latest checkpoint location）——最新检查点记录的LSN位置。</li>
<li>前一个检查点位置（Prior checkpoint location）——前一个检查点记录的LSN位置。<br>请注意，在版本11中，这一项已被弃用；具体细节在下方中描述。</li>
</ol>
<p>pg_control文件存储在基础目录下的global子目录中。可以使用pg_controldata工具显示其内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres&gt; </span><span class="language-bash">pg_controldata  /usr/local/pgsql/data</span><br>pg_control version number:            1300<br>Catalog version number:               202306141<br>Database system identifier:           7250496631638317596<br>Database cluster state:               in production<br>pg_control last modified:             Mon Jan 1 15:16:38 2024<br>Latest checkpoint location:           0/16AF0090<br>Latest checkpoint&#x27;s REDO location:    0/16AF0090<br>Latest checkpoint&#x27;s REDO WAL file:    000000010000000000000016<br><br>... snip ...<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Removal of prior checkpoint in PostgreSQL 11</p>
<p>PostgreSQL 11及以上版本仅保留包含最新检查点或更新的日志段。为了减少用于保存pg_wal子目录下WAL<br>段文件的磁盘空间，不保留包含前一个检查点的较老日志段文件。详情可参考此线程讨论。</p>
<p><a target="_blank" rel="noopener" href="http://www.postgresql-archive.org/Remove-secondary-checkpoint-tt5989050.html">http://www.postgresql-archive.org/Remove-secondary-checkpoint-tt5989050.html</a></p>
</blockquote>
<h3 id="9-8-Database-Recovery-in-PostgreSQL"><a href="#9-8-Database-Recovery-in-PostgreSQL" class="headerlink" title="9.8. Database Recovery in PostgreSQL"></a><a name="recovery"></a>9.8. Database Recovery in PostgreSQL</h3><p>PostgreSQL采用基于重做日志的恢复机制。如果数据库服务器崩溃，PostgreSQL可以通过顺序重放WAL<br>段文件中从REDO点开始的XLOG记录来恢复数据库集群。</p>
<p>到本节为止，我们已经多次谈到数据库恢复。在这里，我将描述关于恢复的两个尚未解释的事项。</p>
<p>第一件事是PostgreSQL如何启动恢复过程。当PostgreSQL启动时，它首先读取pg_control文件。<br>从那时起，以下是恢复过程的详细步骤。请参阅图9.14及以下描述。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_14.png" srcset="/img/loading.gif" lazyload alt="img_14.png"></p>
<ol>
<li>PostgreSQL在启动时读取pg_control文件中的所有项目。如果状态项为’in production’，PostgreSQL会进入恢复模式 ，<br>因为这意味着数据库没有正常关闭。如果状态为’shut down’，PostgreSQL则进入常规启动模式。  </li>
<li>PostgreSQL根据pg_control文件中所写的最新检查点记录的位置，从相应的WAL段文件中读取该记录，<br>并从中获取REDO点。如果最新的检查点记录无效，PostgreSQL会尝试读取前一个记录。如果两个记录都不可读，<br>则放弃自我恢复。（注意，在PostgreSQL 11或之后的版本中，不再存储前一个检查点。）  </li>
<li>相应的资源管理器从REDO点开始，按顺序读取并重放XLOG记录，直到达到最新WAL段的末尾。当重放XLOG记录时，<br>如果它是备份块，则无论其LSN如何，都会覆盖到对应的表页面上。否则，对于非备份块的XLOG记录，<br>只有当记录的LSN大于对应页面的’pd_lsn’时，才会进行重放。</li>
</ol>
<p>第二点是关于LSN比较的问题：为什么需要比较非备份块的LSN和相应页面的pd_lsn。与之前的例子不同，<br>这里将通过一个具体示例来解释这一点，强调这种比较的必要性。请参阅图9.15和9.16。<br>（注意，为了简化描述，此处省略了WAL缓冲区。）</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_15.png" srcset="/img/loading.gif" lazyload alt="img_15.png"></p>
<ol>
<li>PostgreSQL向TABLE_A插入一个元组，并在LSN_1处写入一条XLOG记录。  </li>
<li>后台写入进程将TABLE_A的页面写入到存储器中。此时，该页面的pd_lsn为LSN_1。  </li>
<li>PostgreSQL再次向TABLE_A插入一个新的元组，并在LSN_2处写入一条XLOG记录。<br>但是，修改后的页面尚未写入存储器。</li>
</ol>
<p>与概述中的示例不同，在此场景中，TABLE_A的页面已经至少被写入存储器一次。</p>
<p>接下来，立即模式下关闭数据库，然后重新启动数据库。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_16.png" srcset="/img/loading.gif" lazyload alt="img_16.png"></p>
<ol>
<li>PostgreSQL加载第一条XLOG记录和TABLE_A的页面，但由于记录的LSN(LSN_1)不大于页面<br>的LSN（也是LSN_1），因此不会对其进行重放。实际上，显然没有必要重放它。  </li>
<li>接下来，PostgreSQL重放第二条XLOG记录，因为该记录的LSN(LSN_2)大于TABLE_A页面当前的LSN(LSN_1)。</li>
</ol>
<p>从这个例子可以看出，如果非备份块的重放顺序错误或非备份块被重放多次，<br>数据库集群将不再保持一致性。简而言之，非备份块的重做（重放）操作不是幂等的。因此，为了保持正确的重放顺序，<br>只有当非备份块记录的LSN大于对应页面的pd_lsn时，才应该对其进行重放。</p>
<p>另一方面，由于备份块的重做操作是幂等的，所以备份块可以不考虑其LSN而被重放任意次数。</p>
<h3 id="9-9-WAL-Segment-Files-Management"><a href="#9-9-WAL-Segment-Files-Management" class="headerlink" title="9.9. WAL Segment Files Management"></a><a name="wal-file"></a>9.9. WAL Segment Files Management</h3><p>PostgreSQL将XLOG记录写入存储在pg_wal子目录中的WAL段文件之一（在9.6或更早版本中为pg_xlog子目录）。<br>如果旧的WAL段文件已满，将切换到新的WAL段文件。WAL文件的数量取决于多个配置参数以及服务器活动。<br>此外，从9.5版本开始，对WAL段文件的管理策略得到了改进。</p>
<p>以下小节将描述WAL段文件是如何切换和管理的。</p>
<h4 id="9-9-1-WAL-Segment-Switches"><a href="#9-9-1-WAL-Segment-Switches" class="headerlink" title="9.9.1. WAL Segment Switches"></a>9.9.1. WAL Segment Switches</h4><p>WAL段的切换发生在以下任一事件发生时：</p>
<ol>
<li>WAL段已填满。  </li>
<li>调用了pg_switch_xlog函数。  </li>
<li>archive_mode参数被启用且archive_timeout参数设定的时间到期。</li>
</ol>
<p>当WAL段文件切换时，通常会对其进行回收（重命名并重新使用）以备将来使用。但是，如果不再需要，<br>可能会在之后将其删除。</p>
<h4 id="9-9-2-WAL-Segment-Management"><a href="#9-9-2-WAL-Segment-Management" class="headerlink" title="9.9.2. WAL Segment Management"></a>9.9.2. WAL Segment Management</h4><p>每当检查点开始时，PostgreSQL会估计并为下一个检查点周期准备所需的WAL段文件数量。这个估计基于前一个检查点周期中<br>消耗的WAL段文件数量。</p>
<p>WAL段文件的数量从包含前一个REDO点的段开始计数（在10或更早版本中；在11或更高版本中即为REDO点所在段），<br>并且该值必须位于min_wal_size参数（默认为80MB，或5个文件）和max_wal_size参数（默认为1GB，或64个文件）之间。</p>
<p>如果检查点开始，PostgreSQL将保留或回收必要的WAL段文件，并移除任何不必要的文件。</p>
<p>图9.17展示了一个具体示例。假设在检查点开始之前有六个WAL段文件，其中WAL_3包含前一个REDO点<br>（在10或更早版本中；在11或更高版本中即为当前REDO点），并且PostgreSQL估计将需要五个文件。<br>在这种情况下，WAL_1将被重命名为WAL_7以便回收，而WAL_2将被移除。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_17.png" srcset="/img/loading.gif" lazyload alt="img_17.png"></p>
<p>如果由于WAL活动突增导致需要更多的WAL段文件，只要WAL段文件的总大小小于<br>max_wal_size参数，就会创建新的WAL段文件。例如，在图9.18中，如果WAL_7已经被填满，将会新创建WAL_8。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_18.png" srcset="/img/loading.gif" lazyload alt="img_18.png"></p>
<p>WAL段文件的数量会根据服务器活动进行调整。如果WAL数据写入量持续增加，<br>预估所需的WAL段文件数量以及WAL段文件的总大小将逐渐增加。相反，如果WAL数据写入量减少，这些数值也会减少。</p>
<p>如果WAL段文件的总大小超过了max_wal_size参数设定的值，将启动一个检查点。图9.19说明了这种情况。<br>通过执行检查点操作，将创建一个新的REDO点并丢弃前一个REDO点；随后，不必要的旧WAL段文件将被回收。<br>这样一来，PostgreSQL将始终只保留数据库恢复所需WAL段文件。</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_19.png" srcset="/img/loading.gif" lazyload alt="img_19.png"></p>
<p>wal_keep_size参数（在12或更早版本中为wal_keep_segments）和复制槽（replication slot）特性也会影响WAL段文件的数量。</p>
<h3 id="9-10-Continuous-Archiving-and-Archive-Logs"><a href="#9-10-Continuous-Archiving-and-Archive-Logs" class="headerlink" title="9.10. Continuous Archiving and Archive Logs"></a><a name="archive"></a>9.10. Continuous Archiving and Archive Logs</h3><p>连续归档是一种特性，它在WAL（Write-Ahead Log）段文件切换时，将这些文件复制到归档区域。<br>此操作由归档（后台）进程执行。被复制的文件称为归档日志。此功能通常用于热物理备份和PITR（时间点恢复），<br>这些在第10章中有详细描述。</p>
<p>归档区域的路径由配置参数‘archive_command’设置。例如，以下参数配置会每当发生段切换时，<br>将WAL段文件复制到目录‘&#x2F;home&#x2F;postgres&#x2F;archives&#x2F;’：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">archive_command = &#x27;cp %p /home/postgres/archives/%f&#x27;<br></code></pre></td></tr></table></figure>

<p>在这个命令中，%p代表当前要归档的WAL段文件的完整路径，%f代表不包含路径的WAL段文件名</p>
<p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_20.png" srcset="/img/loading.gif" lazyload alt="img_20.png"></p>
<p>archive_command参数可以设置为任何Unix命令或工具。这意味着您可以使用scp命令或任何其他文件备份工具<br>将归档日志传输到另一台主机，而不仅仅局限于使用简单的复制命令。</p>
<blockquote>
<p>archive_library</p>
<p>在PostgreSQL 14或更早的版本中，连续归档只能使用shell命令来实现。</p>
<p>但从PostgreSQL 15开始，引入了一个可加载库功能，这使得您能够通过一个库来实现连续归档，为归档过程提供了更多灵活性和扩展性。</p>
<p>欲了解更多详情，请参考archive_library和basic_archive相关的文档说明。</p>
<p><a target="_blank" rel="noopener" href="https://www.postgresql.org/docs/current/runtime-config-wal.html#GUC-ARCHIVE-LIBRARY">https://www.postgresql.org/docs/current/runtime-config-wal.html#GUC-ARCHIVE-LIBRARY</a><br><a target="_blank" rel="noopener" href="https://www.postgresql.org/docs/current/basic-archive.html">https://www.postgresql.org/docs/current/basic-archive.html</a></p>
</blockquote>
<blockquote>
<p>Note</p>
<p>PostgreSQL不会自动清理产生的归档日志。因此，在使用此功能时，必须妥善管理这些日志。<br>如果不采取任何措施，归档日志的数量将会持续增长。</p>
<p>pg_archivecleanup实用程序是管理归档日志文件的有用工具之一。</p>
<p>您也可以使用find命令来删除归档日志。例如，以下命令会删除所有超过三天前创建的归档日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /home/postgres/archives/ -type f -name &#x27;*.wal&#x27; -mtime +3 -exec rm &#123;&#125; \;<br></code></pre></td></tr></table></figure>

<p>在这个命令中：</p>
<p>&#x2F;home&#x2F;postgres&#x2F;archives&#x2F; 是归档日志存放的目录路径。<br>-type f 表示只查找文件。<br>-name ‘*.wal’ 指定了查找以.wal结尾的文件，这是PostgreSQL归档日志的一般命名格式。<br>-mtime +3 表示查找修改时间超过3天的文件。<br>-exec rm {} ; 则是对找到的每个文件执行删除操作。<br>请谨慎使用此类删除命令，确保在执行之前有适当的备份或确认这些日志确实不再需要。</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/BOOK/" class="category-chain-item">BOOK</a>
  
  
    <span>></span>
    
  <a href="/categories/BOOK/PostgreSQL%E6%8C%87%E5%8D%97%EF%BC%9A%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2/" class="category-chain-item">PostgreSQL指南：内幕探索</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/book/" class="print-no-link">#book</a>
      
        <a href="/tags/database/" class="print-no-link">#database</a>
      
        <a href="/tags/transactions/" class="print-no-link">#transactions</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>ch9. WRITE AHEAD LOGGING (WAL)</div>
      <div>http://smilemzy.com/2025/05/05/DB/PostgreSQL指南/内幕探索_new_release/ch9/ch9/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Smile</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch1/ch1/" title="ch1. 概述">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ch1. 概述</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/" title="ch8. Buffer Manager">
                        <span class="hidden-mobile">ch8. Buffer Manager</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
