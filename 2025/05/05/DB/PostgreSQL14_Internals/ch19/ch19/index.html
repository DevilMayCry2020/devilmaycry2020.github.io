

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5/fluid.png">
  <link rel="icon" href="/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Smile">
  <meta name="keywords" content="">
  
    <meta name="description" content="ch19. Index Access Methods本章主要内容如下：    Chapter Contents    19.1 Indexes and Extensibility   19.2 Operator Classes and Families   19.3 Indexing Engine Interface   19.1 Indexes and Extensibility索引是一种数据库">
<meta property="og:type" content="article">
<meta property="og:title" content="ch19. Index Access Methods">
<meta property="og:url" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch19/ch19/index.html">
<meta property="og:site_name" content="Smile">
<meta property="og:description" content="ch19. Index Access Methods本章主要内容如下：    Chapter Contents    19.1 Indexes and Extensibility   19.2 Operator Classes and Families   19.3 Indexing Engine Interface   19.1 Indexes and Extensibility索引是一种数据库">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch19/ch19/img.png">
<meta property="article:published_time" content="2025-05-05T12:24:14.596Z">
<meta property="article:modified_time" content="2025-05-05T13:25:00.429Z">
<meta property="article:author" content="Smile">
<meta property="article:tag" content="book">
<meta property="article:tag" content="database">
<meta property="article:tag" content="transactions">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch19/ch19/img.png">
  
  
  
  <title>ch19. Index Access Methods - Smile</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"smilemzy.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/内存泄漏排查/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Smile</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="ch19. Index Access Methods"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-05 20:24" pubdate>
          2025年5月5日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          42 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">ch19. Index Access Methods</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="ch19-Index-Access-Methods"><a href="#ch19-Index-Access-Methods" class="headerlink" title="ch19. Index Access Methods"></a>ch19. Index Access Methods</h2><p>本章主要内容如下：</p>
<table>
<thead>
<tr>
<th>Chapter Contents</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#cp1">19.1 Indexes and Extensibility</a></td>
</tr>
<tr>
<td><a href="#cp2">19.2 Operator Classes and Families</a></td>
</tr>
<tr>
<td><a href="#cp3">19.3 Indexing Engine Interface</a></td>
</tr>
</tbody></table>
<h3 id="19-1-Indexes-and-Extensibility"><a href="#19-1-Indexes-and-Extensibility" class="headerlink" title="19.1 Indexes and Extensibility"></a><a name="cp1"></a>19.1 Indexes and Extensibility</h3><p>索引是一种数据库对象，主要用于加速数据访问。它们是辅助数据结构：任何索引都可以基于堆数据删除并重建。除了加速数据访问之外，索引还用于强制执行某些完整性约束。</p>
<p>PostgreSQL 内核提供了六种内置的索引访问方法 (索引类型)：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> amname <span class="hljs-keyword">FROM</span> pg_am <span class="hljs-keyword">WHERE</span> amtype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;i&#x27;</span>;<br> amname<br>−−−−−−−−<br> btree<br> hash<br> gist<br> gin<br> spgist<br> brin<br>(<span class="hljs-number">6</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>PostgresSQL 的可扩展性意味着可以在不修改内核的情况下添加新的访问方法。其中一个此类扩展 (bloom 方法) 被包含在标准模块集中。</p>
<p>尽管各种索引类型之间存在诸多差异，但最终都是将键 (例如索引列的值) 与包含该键的堆元组进行匹配。元组由 6 字节的元组 ID (TID) 引用。知道键或者关于键的一些信息，就可以快速读取可能包含所需数据的元组，而无需扫描整个表。</p>
<p>为了确保新的访问方法可以作为扩展被添加，PostgreSQL 实现了一个通用的索引引擎。其主要目标是检索和处理特定访问方法返回的 TID：</p>
<pre><code class="hljs">从相应的堆元组中读取数据
检查特定快照中元组的可见性
如果访问方法的评估并不明确，则重新检查条件
</code></pre>
<p>索引引擎还参与在优化阶段所构建的计划的执行。在评估各种执行路径时，优化器需要知道所有可能适用的访问方法的属性：此方法能否按照要求的顺序返回数据，还是需要一个单独的排序阶段？是否可以立即返回前几个值，还是说必须等待整个结果集被获取？诸如此类。</p>
<p>不仅仅是优化器需要了解访问方法的特定信息。索引的创建也提出了更多需要解答的问题：访问方法是否支持多列索引？这个索引能否保证唯一性？</p>
<p>索引引擎允许使用多种访问方法；为了得以支持，访问方法必须实现一个特定的接口来声明其特性和属性。</p>
<p>访问方法用于解决以下问题：</p>
<pre><code class="hljs">实现建立索引的算法，以及插入和删除索引条目
在页面之间分配索引条目 (由缓冲区缓存管理器进一步处理)
实现清理的算法
获取锁以确保正确的并发操作
生成 WAL 条目
根据键查找索引数据
评估索引扫描的成本
</code></pre>
<p>PostgreSQL 的可扩展性还体现在能够添加新数据类型的能力上，而访问方法事先对此一无所知。因此，访问方法必须定义它们自己的接口，以便插入任意数据类型。</p>
<p>为了特定的访问方法能够使用新的数据类型，需要实现相应的接口，即提供可与索引一起使用的操作符，可能还包括一些辅助支持函数。这样的一组操作符和函数被称为操作符类。</p>
<p>索引逻辑由访问方法自身实现了部分，但有些则交由操作符类。这种分配相当随意：虽然 B 树将所有逻辑内置于访问方法中，但其他一些方法可能只提供主框架，将所有实现细节留给特定的操作符类来决定。同一数据类型通常由若干个操作符类支持，用户可以选择行为最合适的一个。</p>
<p>以下是整体概况的一小部分：</p>
<p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch19/ch19/img.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img.png"></p>
<h3 id="19-2-Operator-Classes-and-Families"><a href="#19-2-Operator-Classes-and-Families" class="headerlink" title="19.2 Operator Classes and Families"></a><a name="cp2"></a>19.2 Operator Classes and Families</h3><h4 id="19-2-1-操作符类"><a href="#19-2-1-操作符类" class="headerlink" title="19.2.1 操作符类"></a>19.2.1 操作符类</h4><p>访问方法接口 1 由操作符类实现，2 操作符类是访问方法应用于特定数据类型的一组操作符和支持函数。</p>
<p>操作符类存储在系统目录的 pg_opclass 表中。以下查询返回上述所说的完整数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> amname, opcname, opcintype::regtype<br><span class="hljs-keyword">FROM</span> pg_am am<br>  <span class="hljs-keyword">JOIN</span> pg_opclass opc <span class="hljs-keyword">ON</span> opcmethod <span class="hljs-operator">=</span> am.oid;<br> amname <span class="hljs-operator">|</span>           opcname            <span class="hljs-operator">|</span>          opcintype<br>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> btree 	<span class="hljs-operator">|</span> array_ops                    <span class="hljs-operator">|</span> anyarray<br> hash 	<span class="hljs-operator">|</span> array_ops                    <span class="hljs-operator">|</span> anyarray<br> btree  <span class="hljs-operator">|</span> bit_ops                      <span class="hljs-operator">|</span> bit<br> btree  <span class="hljs-operator">|</span> bool_ops                     <span class="hljs-operator">|</span> <span class="hljs-type">boolean</span><br> ...<br> brin 	<span class="hljs-operator">|</span> pg_lsn_minmax_multi_ops      <span class="hljs-operator">|</span> pg_lsn<br> brin 	<span class="hljs-operator">|</span> pg_lsn_bloom_ops             <span class="hljs-operator">|</span> pg_lsn<br> brin   <span class="hljs-operator">|</span> box_inclusion_ops            <span class="hljs-operator">|</span> box<br>(<span class="hljs-number">177</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>在大多数情况下，我们不必了解任何有关操作符类的信息。我们只需简单地创建一个默认使用某个操作符类的索引。</p>
<p>例如，此处是支持文本类型的 B 树操作符类。其中一个类总是被标记为默认类：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> opcname, opcdefault<br><span class="hljs-keyword">FROM</span> pg_am am<br>  <span class="hljs-keyword">JOIN</span> pg_opclass opc <span class="hljs-keyword">ON</span> opcmethod <span class="hljs-operator">=</span> am.oid<br><span class="hljs-keyword">WHERE</span> amname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;btree&#x27;</span><br>  <span class="hljs-keyword">AND</span> opcintype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;text&#x27;</span>::regtype;<br>       opcname       <span class="hljs-operator">|</span> opcdefault<br>−−−−−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br> text_ops            <span class="hljs-operator">|</span> t<br> varchar_ops         <span class="hljs-operator">|</span> f<br> text_pattern_ops    <span class="hljs-operator">|</span> f<br> varchar_pattern_ops <span class="hljs-operator">|</span> f<br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>一个典型的索引创建命令如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> aircrafts(model, <span class="hljs-keyword">range</span>);<br></code></pre></td></tr></table></figure>

<p>但这只是一种简写，它可以展开为以下语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> aircrafts<br><span class="hljs-keyword">USING</span> btree <span class="hljs-comment">-- the default access method</span><br>(<br>  model text_ops, <span class="hljs-comment">-- the default operator class for text</span><br>  <span class="hljs-keyword">range</span> int4_ops <span class="hljs-comment">-- the default operator class for integer</span><br>);<br></code></pre></td></tr></table></figure>

<p>如果你想使用不同类型的索引或实现某些自定义行为，那么你必须明确指定所需的访问方法或操作符类。</p>
<p>为特定访问方法和数据类型定义的每个操作符类必须包含一组处理此类型参数的操作符，并实现该访问方法的语义。</p>
<p>例如，btree 访问方法定义了五个强制性的比较操作符。任何 btree 操作符类都必须包含这五个操作符：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> opcname, amopstrategy, amopopr::regoperator<br><span class="hljs-keyword">FROM</span> pg_am am<br>  <span class="hljs-keyword">JOIN</span> pg_opfamily opf <span class="hljs-keyword">ON</span> opfmethod <span class="hljs-operator">=</span> am.oid<br>  <span class="hljs-keyword">JOIN</span> pg_opclass opc <span class="hljs-keyword">ON</span> opcfamily <span class="hljs-operator">=</span> opf.oid<br>  <span class="hljs-keyword">JOIN</span> pg_amop amop <span class="hljs-keyword">ON</span> amopfamily <span class="hljs-operator">=</span> opcfamily<br>  <span class="hljs-keyword">WHERE</span> amname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;btree&#x27;</span><br>  <span class="hljs-keyword">AND</span> opcname <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;text_ops&#x27;</span>, <span class="hljs-string">&#x27;text_pattern_ops&#x27;</span>)<br>  <span class="hljs-keyword">AND</span> amoplefttype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;text&#x27;</span>::regtype<br>  <span class="hljs-keyword">AND</span> amoprighttype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;text&#x27;</span>::regtype<br>  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> opcname, amopstrategy;<br>     opcname      <span class="hljs-operator">|</span> amopstrategy <span class="hljs-operator">|</span>     amopopr<br>−−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−<br> text_ops         <span class="hljs-operator">|</span>            <span class="hljs-number">1</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(text,text)<br> text_ops         <span class="hljs-operator">|</span>            <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;=</span>(text,text)<br> text_ops         <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span> <span class="hljs-operator">=</span>(text,text)<br> text_ops         <span class="hljs-operator">|</span>            <span class="hljs-number">4</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&gt;=</span>(text,text)<br> text_ops         <span class="hljs-operator">|</span>            <span class="hljs-number">5</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&gt;</span>(text,text)<br> text_pattern_ops <span class="hljs-operator">|</span>            <span class="hljs-number">1</span> <span class="hljs-operator">|</span> <span class="hljs-operator">~</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">~</span>(text,text)<br> text_pattern_ops <span class="hljs-operator">|</span>            <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-operator">~</span><span class="hljs-operator">&lt;=</span><span class="hljs-operator">~</span>(text,text)<br> text_pattern_ops <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span> <span class="hljs-operator">=</span>(text,text)<br> text_pattern_ops <span class="hljs-operator">|</span>            <span class="hljs-number">4</span> <span class="hljs-operator">|</span> <span class="hljs-operator">~</span><span class="hljs-operator">&gt;=</span><span class="hljs-operator">~</span>(text,text)<br> text_pattern_ops <span class="hljs-operator">|</span>            <span class="hljs-number">5</span> <span class="hljs-operator">|</span> <span class="hljs-operator">~</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">~</span>(text,text)<br>(<span class="hljs-number">10</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>访问方法所暗示的操作符的语义由显示为 amopstrategy 的策略编号反映。3 例如，对于 btree 来说，策略 1 表示小于，策略 2 表示小于或等于，依此类推。操作符本身可以有任意名称。</p>
<p>上面的示例显示了两种类型的操作符。普通操作符和带有波浪线的操作符之间的区别在于，后者不考虑排序规则 4 并执行字符串的逐位比较。尽管如此，两种风格的操作符都实现了相同的逻辑比较操作。</p>
<p>text_pattern_ops 操作符类旨在解决对 ‘~~’ 操作符 (对应于 LIKE 操作符) 的支持限制。在使用非 C 排序规则的数据库中，这个操作符不能使用文本字段上的常规索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> lc_collate;<br> lc_collate<br>−−−−−−−−−−−−−<br> en_US.UTF−<span class="hljs-number">8</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> tickets(passenger_name);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tickets <span class="hljs-keyword">WHERE</span> passenger_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;ELENA%&#x27;</span>;<br>                  QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> tickets<br>   <span class="hljs-keyword">Filter</span>: (passenger_name <span class="hljs-operator">~</span><span class="hljs-operator">~</span> <span class="hljs-string">&#x27;ELENA%&#x27;</span>::text)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>使用 text_pattern_ops 操作符类的索引行为有所不同：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX tickets_passenger_name_pattern_idx<br><span class="hljs-keyword">ON</span> tickets(passenger_name text_pattern_ops);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tickets <span class="hljs-keyword">WHERE</span> passenger_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;ELENA%&#x27;</span>;<br>                          QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Bitmap Heap Scan <span class="hljs-keyword">on</span> tickets<br>   <span class="hljs-keyword">Filter</span>: (passenger_name <span class="hljs-operator">~</span><span class="hljs-operator">~</span> <span class="hljs-string">&#x27;ELENA%&#x27;</span>::text)<br>   −<span class="hljs-operator">&gt;</span> Bitmap Index Scan <span class="hljs-keyword">on</span> tickets_passenger_name_pattern_idx<br>       Index Cond: ((passenger_name <span class="hljs-operator">~</span><span class="hljs-operator">&gt;=</span><span class="hljs-operator">~</span> <span class="hljs-string">&#x27;ELENA&#x27;</span>::text) <span class="hljs-keyword">AND</span><br>       (passenger_name <span class="hljs-operator">~</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">~</span> <span class="hljs-string">&#x27;ELENB&#x27;</span>::text))<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>注意 Index Cond 中过滤表达式的变化。搜索现在仅使用 % 之前的模板前缀，而 false-positive 会在基于 Filter 条件的重新检查期间被过滤掉。btree 访问方法的操作符类没有提供用于比较模板的操作符，而使用 B 树的唯一方法是使用比较操作符重写此条件。text_pattern_ops 类的操作符不考虑排序规则，这让我们有机会使用等价条件代替。5</p>
<p>如果满足以下两个前置条件，则可以使用索引来加速过滤条件的访问：</p>
<pre><code class="hljs">1. 条件写成 “indexed-column operator expression” (如果操作符有指定的可交换操作符 6，条件也可以写成 “expression operator indexed-column” 的形式)。7

2. 操作符属于索引声明中为索引列指定的操作符类。
</code></pre>
<p>例如，以下查询便可以使用索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tickets <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;ELENA BELOVA&#x27;</span> <span class="hljs-operator">=</span> passenger_name;<br>                       QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> tickets_passenger_name_idx <span class="hljs-keyword">on</span> tickets<br>   Index Cond: (passenger_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ELENA BELOVA&#x27;</span>::text)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>
<p>请注意 Index Cond 条件中参数的位置：在执行阶段，索引字段必须在左侧。当参数被置换时，操作符被一个可交换的操作符替换；在此例中，它是相同的操作符，因为等值关系是可交换的。</p>
<p>在接下来的查询中，由于条件中的列名被函数调用替换，因此技术上不可能使用常规索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tickets <span class="hljs-keyword">WHERE</span> initcap(passenger_name) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Elena Belova&#x27;</span>;<br>                         QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> tickets<br>   <span class="hljs-keyword">Filter</span>: (initcap(passenger_name) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Elena Belova&#x27;</span>::text)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)						<br></code></pre></td></tr></table></figure>

<p>此处你可以使用表达式索引 8，它在声明中指定了一个任意表达式，而不是列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> tickets( (initcap(passenger_name)) );<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tickets <span class="hljs-keyword">WHERE</span> initcap(passenger_name) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Elena Belova&#x27;</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Bitmap Heap Scan <span class="hljs-keyword">on</span> tickets<br>   Recheck Cond: (initcap(passenger_name) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Elena Belova&#x27;</span>::text)<br>   −<span class="hljs-operator">&gt;</span> Bitmap Index Scan <span class="hljs-keyword">on</span> tickets_initcap_idx<br>       Index Cond: (initcap(passenger_name) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Elena Belova&#x27;</span>::text)<br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>索引表达式只能依赖于堆元组值，不能受到数据库中存储的其他数据或配置参数 (如区域设置) 的影响。换句话说，如果表达式包含任何函数调用，这些函数必须是 IMMUTABLE 9，并且它们必须遵循这个稳定性分类。否则，针对同一查询，索引扫描和堆扫描可能会返回不同的结果。</p>
<p>除了常规操作符之外，操作符类可以提供访问方法所需的支持函数 10。例如，btree 访问方法定义了五个支持函数 11；第一个 (比较两个值) 函数是必需的，而所有其他函数都可以不存在：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> amprocnum, amproc::regproc<br><span class="hljs-keyword">FROM</span> pg_am am<br>  <span class="hljs-keyword">JOIN</span> pg_opfamily opf <span class="hljs-keyword">ON</span> opfmethod <span class="hljs-operator">=</span> am.oid<br>  <span class="hljs-keyword">JOIN</span> pg_opclass opc <span class="hljs-keyword">ON</span> opcfamily <span class="hljs-operator">=</span> opf.oid<br>  <span class="hljs-keyword">JOIN</span> pg_amproc amproc <span class="hljs-keyword">ON</span> amprocfamily <span class="hljs-operator">=</span> opcfamily<br><span class="hljs-keyword">WHERE</span> amname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;btree&#x27;</span><br>  <span class="hljs-keyword">AND</span> opcname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;text_ops&#x27;</span><br>  <span class="hljs-keyword">AND</span> amproclefttype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;text&#x27;</span>::regtype<br>  <span class="hljs-keyword">AND</span> amprocrighttype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;text&#x27;</span>::regtype<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> amprocnum;<br> amprocnum <span class="hljs-operator">|</span>       amproc<br>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−<br>         <span class="hljs-number">1</span> <span class="hljs-operator">|</span> bttextcmp<br>         <span class="hljs-number">2</span> <span class="hljs-operator">|</span> bttextsortsupport<br>         <span class="hljs-number">4</span> <span class="hljs-operator">|</span> btvarstrequalimage<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<h4 id="19-2-2-操作符族"><a href="#19-2-2-操作符族" class="headerlink" title="19.2.2 操作符族"></a>19.2.2 操作符族</h4><p>每个操作符类始终属于某个操作符族 12 (在 pg_opfamily 表中列出)。一个操作符族可以包含多个以相同方式处理相似数据类型的操作符类。</p>
<p>例如，integer_ops 族包括几个用于整数数据类型的类，这些类的语义相同，但大小有所不同：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> opcname, opcintype::regtype<br><span class="hljs-keyword">FROM</span> pg_am am<br>  <span class="hljs-keyword">JOIN</span> pg_opfamily opf <span class="hljs-keyword">ON</span> opfmethod <span class="hljs-operator">=</span> am.oid<br>  <span class="hljs-keyword">JOIN</span> pg_opclass opc <span class="hljs-keyword">ON</span> opcfamily <span class="hljs-operator">=</span> opf.oid<br><span class="hljs-keyword">WHERE</span> amname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;btree&#x27;</span><br>  <span class="hljs-keyword">AND</span> opfname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;integer_ops&#x27;</span>;<br> opcname  <span class="hljs-operator">|</span> opcintype<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−<br> int2_ops <span class="hljs-operator">|</span> <span class="hljs-type">smallint</span><br> int4_ops <span class="hljs-operator">|</span> <span class="hljs-type">integer</span><br> int8_ops <span class="hljs-operator">|</span> <span class="hljs-type">bigint</span><br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>
<p>datetime_ops 族包含用于处理日期的操作符类：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> opcname, opcintype::regtype<br><span class="hljs-keyword">FROM</span> pg_am am<br>  <span class="hljs-keyword">JOIN</span> pg_opfamily opf <span class="hljs-keyword">ON</span> opfmethod <span class="hljs-operator">=</span> am.oid<br>  <span class="hljs-keyword">JOIN</span> pg_opclass opc <span class="hljs-keyword">ON</span> opcfamily <span class="hljs-operator">=</span> opf.oid<br><span class="hljs-keyword">WHERE</span> amname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;btree&#x27;</span><br>  <span class="hljs-keyword">AND</span> opfname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;datetime_ops&#x27;</span>;<br>     opcname     <span class="hljs-operator">|</span>          opcintype<br>−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> date_ops        <span class="hljs-operator">|</span> <span class="hljs-type">date</span><br> timestamptz_ops <span class="hljs-operator">|</span> <span class="hljs-type">timestamp</span> <span class="hljs-keyword">with</span> <span class="hljs-type">time</span> zone<br> timestamp_ops 	 <span class="hljs-operator">|</span> <span class="hljs-type">timestamp</span> <span class="hljs-keyword">without</span> <span class="hljs-type">time</span> zone<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)	<br></code></pre></td></tr></table></figure>

<p>虽然每个操作符类支持单一数据类型，但一个族可以包含用于不同数据类型的操作符类：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> opcname, amopopr::regoperator<br><span class="hljs-keyword">FROM</span> pg_am am<br>  <span class="hljs-keyword">JOIN</span> pg_opfamily opf <span class="hljs-keyword">ON</span> opfmethod <span class="hljs-operator">=</span> am.oid<br>  <span class="hljs-keyword">JOIN</span> pg_opclass opc <span class="hljs-keyword">ON</span> opcfamily <span class="hljs-operator">=</span> opf.oid<br>  <span class="hljs-keyword">JOIN</span> pg_amop amop <span class="hljs-keyword">ON</span> amopfamily <span class="hljs-operator">=</span> opcfamily<br><span class="hljs-keyword">WHERE</span> amname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;btree&#x27;</span><br>  <span class="hljs-keyword">AND</span> opfname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;integer_ops&#x27;</span><br>  <span class="hljs-keyword">AND</span> amoplefttype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;integer&#x27;</span>::regtype<br>  <span class="hljs-keyword">AND</span> amopstrategy <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> opcname;<br> opcname  <span class="hljs-operator">|</span>       amopopr<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−<br> int2_ops <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(<span class="hljs-type">integer</span>,<span class="hljs-type">bigint</span>)<br> int2_ops <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(<span class="hljs-type">integer</span>,<span class="hljs-type">smallint</span>)<br> int2_ops <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(<span class="hljs-type">integer</span>,<span class="hljs-type">integer</span>)<br> int4_ops <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(<span class="hljs-type">integer</span>,<span class="hljs-type">bigint</span>)<br> int4_ops <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(<span class="hljs-type">integer</span>,<span class="hljs-type">smallint</span>)<br> int4_ops <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(<span class="hljs-type">integer</span>,<span class="hljs-type">integer</span>)<br> int8_ops <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(<span class="hljs-type">integer</span>,<span class="hljs-type">bigint</span>)<br> int8_ops <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(<span class="hljs-type">integer</span>,<span class="hljs-type">smallint</span>)<br> int8_ops <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(<span class="hljs-type">integer</span>,<span class="hljs-type">integer</span>)<br>(<span class="hljs-number">9</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>由于将各种操作符分组至一个单独的操作符族中，规划器在使用索引处理涉及不同类型的值的条件时，可以不需要进行类型转换。</p>
<h3 id="19-3-Indexing-Engine-Interface"><a href="#19-3-Indexing-Engine-Interface" class="headerlink" title="19.3 Indexing Engine Interface"></a><a name="cp3"></a>19.3 Indexing Engine Interface</h3><p>如同表访问方法一样 ，pg_am 表的 amhandler 列包含实现了接口的函数名称：13</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> amname, amhandler <span class="hljs-keyword">FROM</span> pg_am <span class="hljs-keyword">WHERE</span> amtype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;i&#x27;</span>;<br> amname <span class="hljs-operator">|</span>  amhandler<br>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−<br> btree  <span class="hljs-operator">|</span> bthandler<br> hash 	<span class="hljs-operator">|</span> hashhandler<br> gist 	<span class="hljs-operator">|</span> gisthandler<br> gin    <span class="hljs-operator">|</span> ginhandler<br> spgist <span class="hljs-operator">|</span> spghandler<br> brin 	<span class="hljs-operator">|</span> brinhandler<br>(<span class="hljs-number">6</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>此函数用真实值填充接口结构 14 中的占位符。其中一些是负责与索引访问相关的独立任务的函数 (例如，它们可以执行索引扫描并返回堆元组 ID)，而其他一些是索引引擎必须知晓的索引方法的属性。</p>
<p>所有属性分为三类：15</p>
<pre><code class="hljs">访问方法属性
特定索引的属性
索引的列级属性
</code></pre>
<p>访问方法和索引级属性之间的区别是为了将来考虑：目前，基于特定访问方法的所有索引在这两个层次上始终具有相同的属性。</p>
<h4 id="19-3-1-访问方法属性"><a href="#19-3-1-访问方法属性" class="headerlink" title="19.3.1 访问方法属性"></a>19.3.1 访问方法属性</h4><p>以下五个属性在访问方法层面定义 (此处以 B 树方法为例)：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> a.amname, p.name, pg_indexam_has_property(a.oid, p.name)<br><span class="hljs-keyword">FROM</span> pg_am a, <span class="hljs-built_in">unnest</span>(<span class="hljs-keyword">array</span>[<br>  <span class="hljs-string">&#x27;can_order&#x27;</span>, <span class="hljs-string">&#x27;can_unique&#x27;</span>, <span class="hljs-string">&#x27;can_multi_col&#x27;</span>,<br>  <span class="hljs-string">&#x27;can_exclude&#x27;</span>, <span class="hljs-string">&#x27;can_include&#x27;</span><br>]) p(name)<br><span class="hljs-keyword">WHERE</span> a.amname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;btree&#x27;</span>;<br> amname <span class="hljs-operator">|</span>     name      <span class="hljs-operator">|</span> pg_indexam_has_property<br>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−−−<br> btree  <span class="hljs-operator">|</span> can_order     <span class="hljs-operator">|</span> t<br> btree  <span class="hljs-operator">|</span> can_unique    <span class="hljs-operator">|</span> t<br> btree  <span class="hljs-operator">|</span> can_multi_col <span class="hljs-operator">|</span> t<br> btree  <span class="hljs-operator">|</span> can_exclude 	<span class="hljs-operator">|</span> t<br> btree  <span class="hljs-operator">|</span> can_include 	<span class="hljs-operator">|</span> t<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p><strong>CAN ORDER</strong>：接收排序数据的能力 16。这个属性目前只有 B 树支持。</p>
<p>要按要求的顺序获取结果，始终可以先扫描表，然后对获取的数据进行排序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> seats <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> seat_no;<br>       QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−<br> Sort<br>   Sort Key: seat_no<br>   −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> seats<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>但是如果有支持该属性的索引，那么数据可以立即按照所需顺序返回：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> seats <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> aircraft_code;<br>              QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> seats_pkey <span class="hljs-keyword">on</span> seats<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>
<p><strong>CAN UNIQUE</strong>：支持唯一约束和主键约束 17。此属性仅适用于 B 树。</p>
<p>每次声明唯一约束或主键约束时，PostgreSQL 会自动创建一个唯一索引用于支持这个约束。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> bookings(book_ref, book_date, total_amount)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;000004&#x27;</span>, now(), <span class="hljs-number">100.00</span>);<br>ERROR: duplicate key <span class="hljs-keyword">value</span> violates <span class="hljs-keyword">unique</span> <span class="hljs-keyword">constraint</span><br>&quot;bookings_pkey&quot;<br>DETAIL: Key (book_ref)<span class="hljs-operator">=</span>(<span class="hljs-number">000004</span>) already exists.<br></code></pre></td></tr></table></figure>

<p>也就是说，如果你只是简单地创建了一个唯一索引而没有明确声明一个完整性约束，效果似乎是完全一样的：索引列将不允许重复。那么区别是什么呢？</p>
<p>完整性约束定义了一个绝不能违反的属性，而索引只是保证这一属性的一种机制。理论上，约束也可以通过其他手段施加。</p>
<p>例如，PostgreSQL 不支持分区表全局索引，但你仍然可以在这样的表上创建唯一约束 (如果它包含分区键)。在这种情况下，全局唯一性由每个分区的本地唯一索引来确保，因为不同分区不能有相同的分区键。</p>
<p><strong>CAN MULTI COL</strong>：创建多列索引的能力。18</p>
<p>多列索引可以加速对不同列施加的多个条件的搜索。例如，ticket_flights 表有一个复合主键，所以相应的索引是建立在多个列上的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> \d ticket_flights_pkey<br>     Index &quot;bookings.ticket_flights_pkey&quot;<br>  <span class="hljs-keyword">Column</span>   <span class="hljs-operator">|</span>     Type      <span class="hljs-operator">|</span> Key? <span class="hljs-operator">|</span> Definition<br>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br> ticket_no <span class="hljs-operator">|</span> <span class="hljs-type">character</span>(<span class="hljs-number">13</span>) <span class="hljs-operator">|</span> yes  <span class="hljs-operator">|</span> ticket_no<br> flight_id <span class="hljs-operator">|</span> <span class="hljs-type">integer</span>       <span class="hljs-operator">|</span> yes  <span class="hljs-operator">|</span> flight_id<br><span class="hljs-keyword">primary key</span>, btree, <span class="hljs-keyword">for</span> <span class="hljs-keyword">table</span> &quot;bookings.ticket_flights&quot;<br></code></pre></td></tr></table></figure>

<p>根据票号和航班 ID 搜索航班使用的是索引扫描：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> ticket_flights<br><span class="hljs-keyword">WHERE</span> ticket_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0005432001355&#x27;</span><br>  <span class="hljs-keyword">AND</span> flight_id <span class="hljs-operator">=</span> <span class="hljs-number">51618</span>;<br>                        QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> ticket_flights_pkey <span class="hljs-keyword">on</span> ticket_flights<br>   Index Cond: ((ticket_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0005432001355&#x27;</span>::bpchar) <span class="hljs-keyword">AND</span><br>   (flight_id <span class="hljs-operator">=</span> <span class="hljs-number">51618</span>))<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>通常情况下，即使过滤条件只涉及其某些列，多列索引也可以加速搜索。对于 B 树，如果过滤条件涵盖了索引声明中最先出现的相关列，搜索将会很高效：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> ticket_flights<br><span class="hljs-keyword">WHERE</span> ticket_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0005432001355&#x27;</span>;<br>                        QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> ticket_flights_pkey <span class="hljs-keyword">on</span> ticket_flights<br>   Index Cond: (ticket_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0005432001355&#x27;</span>::bpchar)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>在所有其他情况下 (例如，如果条件仅包含 flights_id)，搜索实际上将仅限于初始列 (如果查询包含相应的条件)，而其他条件仅用于过滤返回的结果。其他类型的索引可能会有不同的行为。</p>
<p><strong>CAN EXCLUDE</strong>：支持排它约束。19</p>
<p>排它约束保证表中任何两行都不会满足由操作符定义的条件。为了施加这个约束，PostgreSQL 会自动创建一个索引；必须有一个操作符类，其中包含约束条件中使用的操作符。</p>
<p>通常用于此目的的是交集操作符 &amp;&amp;。例如，你可以使用它来明确声明会议室不能在同一时间被预订两次，或者地图上的建筑物不能重叠。</p>
<p>有了相等运算符，排它约束就具有了唯一性的含义：禁止表中有两行具有相同的键值。尽管如此，它与唯一约束不同：特别是，排它约束的键无法被外键引用，也不能在 ON CONFLICT 子句中使用。</p>
<p><strong>CAN INCLUDE</strong>：向索引中添加非键列的能力，使得这个索引成为覆盖索引。</p>
<p>使用这个属性，你可以用额外的列扩展唯一索引。这样的索引仍然可以保证所有键列的值都是唯一的，同时从包含的列中检索数据可以不需要访问堆：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX <span class="hljs-keyword">ON</span> flights(flight_id) INCLUDE (status);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> status <span class="hljs-keyword">FROM</span> flights<br><span class="hljs-keyword">WHERE</span> flight_id <span class="hljs-operator">=</span> <span class="hljs-number">51618</span>;<br>                          QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index <span class="hljs-keyword">Only</span> Scan <span class="hljs-keyword">using</span> flights_flight_id_status_idx <span class="hljs-keyword">on</span> flights<br>	 Index Cond: (flight_id <span class="hljs-operator">=</span> <span class="hljs-number">51618</span>)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>


<h4 id="19-3-2-索引级属性"><a href="#19-3-2-索引级属性" class="headerlink" title="19.3.2 索引级属性"></a>19.3.2 索引级属性</h4><p>以下是与索引相关的属性 (显示现有索引)：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> p.name, pg_index_has_property(<span class="hljs-string">&#x27;seats_pkey&#x27;</span>, p.name)<br><span class="hljs-keyword">FROM</span> <span class="hljs-built_in">unnest</span>(<span class="hljs-keyword">array</span>[<br>  <span class="hljs-string">&#x27;clusterable&#x27;</span>, <span class="hljs-string">&#x27;index_scan&#x27;</span>, <span class="hljs-string">&#x27;bitmap_scan&#x27;</span>, <span class="hljs-string">&#x27;backward_scan&#x27;</span><br>]) p(name);<br>     name      <span class="hljs-operator">|</span> pg_index_has_property<br>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−<br> clusterable   <span class="hljs-operator">|</span> t<br> index_scan    <span class="hljs-operator">|</span> t<br> bitmap_scan   <span class="hljs-operator">|</span> t<br> backward_scan <span class="hljs-operator">|</span> t<br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>CLUSTERABLE：根据索引扫描返回的 ID 顺序物理移动堆元组的能力。此属性显示是否支持 CLUSTER 命令。</p>
<p>INDEX SCAN：支持索引扫描。这个属性意味着访问方法可以逐个返回 TIDs。尽管看起来奇怪，但有些索引不提供这个功能。</p>
<p>BITMAP SCAN：支持位图扫描。这个属性定义了访问方法是否可以一次性创建并返回所有 TIDs 的位图。</p>
<p>BACKWARD SCAN：与索引创建时指定的顺序相比，能够以相反的顺序返回结果。只有当访问方法支持索引扫描时，这个属性才有意义。</p>
<h4 id="19-3-3-列级属性"><a href="#19-3-3-列级属性" class="headerlink" title="19.3.3 列级属性"></a>19.3.3 列级属性</h4><p>最后，让我们看一下列属性：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> p.name,<br>  pg_index_column_has_property(<span class="hljs-string">&#x27;seats_pkey&#x27;</span>, <span class="hljs-number">1</span>, p.name)<br><span class="hljs-keyword">FROM</span> <span class="hljs-built_in">unnest</span>(<span class="hljs-keyword">array</span>[<br>  <span class="hljs-string">&#x27;asc&#x27;</span>, <span class="hljs-string">&#x27;desc&#x27;</span>, <span class="hljs-string">&#x27;nulls_first&#x27;</span>, <span class="hljs-string">&#x27;nulls_last&#x27;</span>, <span class="hljs-string">&#x27;orderable&#x27;</span>,<br>  <span class="hljs-string">&#x27;distance_orderable&#x27;</span>, <span class="hljs-string">&#x27;returnable&#x27;</span>, <span class="hljs-string">&#x27;search_array&#x27;</span>, <span class="hljs-string">&#x27;search_nulls&#x27;</span><br>]) p(name);<br>        name        <span class="hljs-operator">|</span> pg_index_column_has_property<br>−−−−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-keyword">asc</span>                <span class="hljs-operator">|</span> t<br> <span class="hljs-keyword">desc</span>               <span class="hljs-operator">|</span> f<br> nulls_first        <span class="hljs-operator">|</span> f<br> nulls_last         <span class="hljs-operator">|</span> t<br> orderable          <span class="hljs-operator">|</span> t<br> distance_orderable <span class="hljs-operator">|</span> f<br> returnable         <span class="hljs-operator">|</span> t<br> search_array       <span class="hljs-operator">|</span> t<br> search_nulls       <span class="hljs-operator">|</span> t<br>(<span class="hljs-number">9</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>ASC，DESC，NULLS FIRST，NULLS LAST：用于排序列值。</p>
<p>这些属性定义了列值应按升序还是降序存储，以及空值是应该出现在常规值之前还是之后。所有这些属性仅适用于 B 树。</p>
<p>ORDERABLE：使用 ORDER BY 子句对列值进行排序的能力。此属性仅适用于 B 树。</p>
<p>DISTANCE ORDERABLE：支持排序操作符。20</p>
<p>与返回逻辑值的常规索引操作符不同，排序操作符返回了一个实数，表示从一个参数到另一个参数的”距离”。索引支持查询的 ORDER BY 子句中指定的此类操作符。</p>
<p>例如，排序操作符 &lt;-&gt; 可以找到距指定点最近的机场：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> airports_data <span class="hljs-keyword">USING</span> gist(coordinates);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> airports<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> coordinates <span class="hljs-operator">&lt;</span><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> point (<span class="hljs-number">43.578</span>,<span class="hljs-number">57.593</span>)<br>LIMIT <span class="hljs-number">3</span>;<br>                            QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Limit<br>   −<span class="hljs-operator">&gt;</span> Index Scan <span class="hljs-keyword">using</span> airports_data_coordinates_idx <span class="hljs-keyword">on</span> airpo...<br>       <span class="hljs-keyword">Order</span> <span class="hljs-keyword">By</span>: (coordinates <span class="hljs-operator">&lt;</span>−<span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;(43.578,57.593)&#x27;</span>::point)<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>
<p>RETURNABLE：无需访问表即可返回数据的能力 (支持仅索引扫描)。</p>
<p>这个属性定义了索引结构是否允许检索索引值。这并不总是可能的：例如，某些索引可能存储哈希码而不是实际的值。在这种情况下，CAN INCLUDE 属性也将不可用。</p>
<p>SEARCH ARRAY：支持在数组中搜索多个元素。</p>
<p>数组的显式使用并不是唯一可能需要的情况。例如，规划器将 IN (list) 表达式转换为数组扫描：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookings<br><span class="hljs-keyword">WHERE</span> book_ref <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;C7C821&#x27;</span>, <span class="hljs-string">&#x27;A5D060&#x27;</span>, <span class="hljs-string">&#x27;DDE1BB&#x27;</span>);<br>                 QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> bookings_pkey <span class="hljs-keyword">on</span> bookings<br>   Index Cond: (book_ref <span class="hljs-operator">=</span> <span class="hljs-keyword">ANY</span><br>   (<span class="hljs-string">&#x27;&#123;C7C821,A5D060,DDE1BB&#125;&#x27;</span>::bpchar[]))<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>如果索引方法不支持此类操作符，执行器可能不得不进行多次迭代来查找特定值 (这可能会降低索引扫描的效率)。</p>
<p>SEARCH NULLS ：搜索 IS NULL 和 IS NOT NULL 条件。</p>
<p>我们应该索引空值吗？一方面，这允许我们对 IS [NOT] NULL 等条件进行索引扫描，以及在没有提供过滤条件的情况下将索引用作覆盖索引 (在这种情况下，索引必须返回所有堆元组数据，包括那些包含空值的堆元组)。但另一方面，跳过空值可以减小索引的大小。</p>
<p>这个决定留给访问方法开发者自行决定，但通常空值确实会被索引。</p>
<p>如果不需要在索引中包含空值，你可以通过创建只覆盖所需行的部分索引 21 来排除它们。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> flights(actual_arrival)<br><span class="hljs-keyword">WHERE</span> actual_arrival <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT NULL</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights<br><span class="hljs-keyword">WHERE</span> actual_arrival <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2017-06-13 10:33:00+03&#x27;</span>;<br>                           QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> flights_actual_arrival_idx <span class="hljs-keyword">on</span> flights<br>   Index Cond: (actual_arrival <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2017−06−13 10:33:00+03&#x27;</span>::ti...<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>部分索引比完整索引小，并且仅当被索引的行发生变化时才会更新，这有时可以带来明显的性能提升。显然，除了空值检查之外，WHERE 子句可以提供任何条件 (可以与 IMMUTABLE 函数一起使用)。</p>
<p>建立部分索引的能力由索引引擎提供，因此不依赖于访问方法。</p>
<p>接口只包括索引方法的那些必须提前知道以做出正确决策的属性。例如，它没有列出任何支持谓词锁或非阻塞索引创建 (CONCURRENTLY) 等特性的属性。这些属性在实现接口的函数代码中定义。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/BOOK/" class="category-chain-item">BOOK</a>
  
  
    <span>></span>
    
  <a href="/categories/BOOK/PostgreSQL14-Internals/" class="category-chain-item">PostgreSQL14_Internals</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/book/" class="print-no-link">#book</a>
      
        <a href="/tags/database/" class="print-no-link">#database</a>
      
        <a href="/tags/transactions/" class="print-no-link">#transactions</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>ch19. Index Access Methods</div>
      <div>http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch19/ch19/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Smile</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/05/05/DB/PostgreSQL14_Internals/ch2/ch2/" title="ch2. Isolation">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ch2. Isolation</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/05/DB/PostgreSQL14_Internals/ch18/ch18/" title="ch18. Table Access Methods">
                        <span class="hidden-mobile">ch18. Table Access Methods</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
