

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Smile">
  <meta name="keywords" content="">
  
    <meta name="description" content="ch20. Index Scans本章主要内容如下：    Chapter Contents    20.1 Regular Index Scans   20.2 Index-Only Scans   20.3 Bitmap Scans   20.4 Parallel Index Scans   20.5 Comparison of Various Access Methods   20.1 Re">
<meta property="og:type" content="article">
<meta property="og:title" content="ch20. Index Scans">
<meta property="og:url" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/index.html">
<meta property="og:site_name" content="Smile">
<meta property="og:description" content="ch20. Index Scans本章主要内容如下：    Chapter Contents    20.1 Regular Index Scans   20.2 Index-Only Scans   20.3 Bitmap Scans   20.4 Parallel Index Scans   20.5 Comparison of Various Access Methods   20.1 Re">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/img.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/img_1.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/img_2.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/img_3.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/img_4.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/img_5.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/img_6.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/img_7.png">
<meta property="article:published_time" content="2025-05-05T12:24:14.604Z">
<meta property="article:modified_time" content="2025-05-24T08:21:47.749Z">
<meta property="article:author" content="Smile">
<meta property="article:tag" content="book">
<meta property="article:tag" content="database">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/img.png">
  
  
  
  <title>ch20. Index Scans - Smile</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"smilemzy.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Smile</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="ch20. Index Scans"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-05 20:24" pubdate>
          2025年5月5日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          54 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">ch20. Index Scans</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="ch20-Index-Scans"><a href="#ch20-Index-Scans" class="headerlink" title="ch20. Index Scans"></a>ch20. Index Scans</h2><p>本章主要内容如下：</p>
<table>
<thead>
<tr>
<th>Chapter Contents</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#cp1">20.1 Regular Index Scans</a></td>
</tr>
<tr>
<td><a href="#cp2">20.2 Index-Only Scans</a></td>
</tr>
<tr>
<td><a href="#cp3">20.3 Bitmap Scans</a></td>
</tr>
<tr>
<td><a href="#cp4">20.4 Parallel Index Scans</a></td>
</tr>
<tr>
<td><a href="#cp5">20.5 Comparison of Various Access Methods</a></td>
</tr>
</tbody></table>
<h3 id="20-1-Regular-Index-Scans"><a href="#20-1-Regular-Index-Scans" class="headerlink" title="20.1 Regular Index Scans"></a><a name="cp1"></a>20.1 Regular Index Scans</h3><p>索引提供了两种基本的访问 TIDS 的方式。第一种是执行索引扫描。大多数索引访问方法 (但不是全部) 都具有 INDEX SCAN 属性以支持这种操作。</p>
<p>索引扫描在计划中由 Index Scan 1 节点表示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookings<br><span class="hljs-keyword">WHERE</span> book_ref <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;9AC0C6&#x27;</span> <span class="hljs-keyword">AND</span> total_amount <span class="hljs-operator">=</span> <span class="hljs-number">48500.00</span>;<br>                 QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> bookings_pkey <span class="hljs-keyword">on</span> bookings<br>   (cost<span class="hljs-operator">=</span><span class="hljs-number">0.43</span>.<span class="hljs-number">.8</span><span class="hljs-number">.45</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">21</span>)<br>   Index Cond: (book_ref <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;9AC0C6&#x27;</span>::bpchar)<br>   <span class="hljs-keyword">Filter</span>: (total_amount <span class="hljs-operator">=</span> <span class="hljs-number">48500.00</span>)<br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>索引扫描期间，访问方法逐个返回 TIDS 2。接收到 TID 之后，索引引擎访问此 TID 引用的堆页面，获取相应的元组，如果满足可见性规则，则返回所请求的该元组相关字段。这个过程会持续进行，直到访问方法没有更多匹配查询的 TIDS 为止。</p>
<p>Index Cond 行仅包括可以使用索引检查的过滤条件。其他需要根据堆重新检查的条件将在 Filter 行中单独列出。</p>
<p>如本例所示，索引和堆访问操作均由一个共同的 Index Scan 节点处理，而不是由两个不同的节点处理。但是，还有一个单独的 Tid Scan 节点 3，如果提前知道元组 ID，便可从堆中获取元组：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookings <span class="hljs-keyword">WHERE</span> ctid <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;(0,1)&#x27;</span>::tid;<br>                       QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Tid Scan <span class="hljs-keyword">on</span> bookings (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.4</span><span class="hljs-number">.01</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">21</span>)<br>   TID Cond: (ctid <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;(0,1)&#x27;</span>::tid)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<h4 id="20-1-1-成本估算"><a href="#20-1-1-成本估算" class="headerlink" title="20.1.1 成本估算"></a>20.1.1 成本估算</h4><p>索引扫描的成本估算包括索引访问操作和堆页面读取的预估成本。</p>
<p>显然，索引相关的估算部分完全取决于特定的访问方法。对于 B 树，成本主要由获取索引页和处理其条目所产生。要读取的页数和行数可以通过数据总量和应用的过滤条件的选择率来确定。索引页是随机访问的 (在逻辑结构上相邻的页面在磁盘上是物理分散的) 。从根节点到叶节点并计算所有需要的表达式所花费的 CPU 资源进一步增加了预估成本。4</p>
<p>堆相关部分的估算包括堆页面访问的成本和处理所有获取的元组所需的 CPU 时间。需要注意的是，I&#x2F;O 估算取决于索引扫描的选择率以及磁盘上元组的物理顺序与访问方法返回其 ID 的顺序之间的相关性。</p>
<h4 id="20-1-2-良好场景：高相关性"><a href="#20-1-2-良好场景：高相关性" class="headerlink" title="20.1.2 良好场景：高相关性"></a>20.1.2 良好场景：高相关性</h4><p>如果元组在磁盘上的物理顺序与索引中 TIDS 的逻辑顺序完美相关，那么每个页面只会被访问一次：Index Scan 节点将顺序地从一个页面跳到另一个页面，逐个读取元组。</p>
<p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/img.png" srcset="/img/loading.gif" lazyload alt="img.png"></p>
<p>PostgreSQL 会收集相关性的统计信息：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> attname, correlation<br>   <span class="hljs-keyword">FROM</span> pg_stats <span class="hljs-keyword">WHERE</span> tablename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bookings&#x27;</span><br>   <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">abs</span>(correlation) <span class="hljs-keyword">DESC</span>;<br>attname    <span class="hljs-operator">|</span> correlation<br>−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−<br> book_ref     <span class="hljs-operator">|</span>            <span class="hljs-number">1</span><br> total_amount <span class="hljs-operator">|</span> <span class="hljs-number">0.0026738467</span><br> book_date    <span class="hljs-operator">|</span>  <span class="hljs-number">8.02188</span>e−<span class="hljs-number">05</span><br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>如果相应的绝对值接近于 1，那么相关性很高 (如 book_ref 的情况)；接近于零的值表示数据分布是混乱的。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">在这个特定例子中，book_ref 列的高相关性当然是因为数据是基于该列升序加载到表中的，并且还没有更新。如果我们对这一列上创建的索引执行 CLUSTER 命令，我们也会看到相同的结果。<br><br>但是，完美的相关性并不能保证所有的查询都将按照 book_ref 值的升序返回结果。首先，任何更新都会将生成的元组移动到表的末尾。其次，依赖于其他列的索引扫描的计划将以不同的顺序返回结果。即使是顺序扫描也可能不从表的开头开始。因此，如果你需要特定的顺序，你应该在 ORDER BY 子句中明确定义它。<br></code></pre></td></tr></table></figure>
<p>此处是一个处理大量行的索引扫描示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookings <span class="hljs-keyword">WHERE</span> book_ref <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;100000&#x27;</span>;<br>                 QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> bookings_pkey <span class="hljs-keyword">on</span> bookings<br>   (cost<span class="hljs-operator">=</span><span class="hljs-number">0.43</span>.<span class="hljs-number">.4638</span><span class="hljs-number">.91</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">132999</span> width<span class="hljs-operator">=</span><span class="hljs-number">21</span>)<br>   Index Cond: (book_ref <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;100000&#x27;</span>::bpchar)<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>条件的选择率估算结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">132999</span>::<span class="hljs-type">numeric</span><span class="hljs-operator">/</span>reltuples::<span class="hljs-type">numeric</span>, <span class="hljs-number">4</span>)<br><span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bookings&#x27;</span>;<br> round<br>−−−−−−−−<br> <span class="hljs-number">0.0630</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>这个值接近 1&#x2F;16，我们可以根据 book_ref 值的范围是从 000000 到 FFFFFF 猜到。</p>
<p>对于 B 树，I&#x2F;O 成本估算中与索引相关的部分包括读取所有所需页面的成本。任何满足 B 树支持条件的索引条目均存储在有序列表的页面中，因此要读取的索引页面数量按索引大小乘以选择率进行估算。但由于这些页面物理上并不有序，因此以随机模式读取页面。</p>
<p>CPU 资源用于处理所有读取的索引条目 (处理单个条目的成本按 cpu_index_tuple_cost 估算) 和计算每个条目的条件 (在本例中，条件包含单个运算符；其成本按 cpu_operator_cost 估算）。</p>
<p>表访问视为顺序读取所需的页面。在完美相关性的情况下，堆元组在磁盘上连续存储，因此页面数量按表的大小乘以选择率进行估算。</p>
<p>元组处理产生的开销会进一步增大 I&#x2F;O 成本；按每条元组花费 cpu_tuple_cost 进行估算。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WITH</span> costs(idx_cost, tbl_cost) <span class="hljs-keyword">AS</span> (<br>  <span class="hljs-keyword">SELECT</span><br>    (<br>      <span class="hljs-keyword">SELECT</span> round(<br>        current_setting(<span class="hljs-string">&#x27;random_page_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> pages <span class="hljs-operator">+</span><br>        current_setting(<span class="hljs-string">&#x27;cpu_index_tuple_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> tuples <span class="hljs-operator">+</span><br>        current_setting(<span class="hljs-string">&#x27;cpu_operator_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> tuples<br>      )<br>      <span class="hljs-keyword">FROM</span> (<br>        <span class="hljs-keyword">SELECT</span> relpages <span class="hljs-operator">*</span> <span class="hljs-number">0.0630</span> <span class="hljs-keyword">AS</span> pages, reltuples <span class="hljs-operator">*</span> <span class="hljs-number">0.0630</span> <span class="hljs-keyword">AS</span> tuples<br>        <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bookings_pkey&#x27;</span><br>      ) c<br>    ),<br>    (		<br>      <span class="hljs-keyword">SELECT</span> round(<br>        current_setting(<span class="hljs-string">&#x27;seq_page_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> pages <span class="hljs-operator">+</span><br>        current_setting(<span class="hljs-string">&#x27;cpu_tuple_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> tuples<br>      )<br>      <span class="hljs-keyword">FROM</span> (<br>        <span class="hljs-keyword">SELECT</span> relpages <span class="hljs-operator">*</span> <span class="hljs-number">0.0630</span> <span class="hljs-keyword">AS</span> pages, reltuples <span class="hljs-operator">*</span> <span class="hljs-number">0.0630</span> <span class="hljs-keyword">AS</span> tuples<br>        <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bookings&#x27;</span><br>      ) c<br>    )<br>)<br><span class="hljs-keyword">SELECT</span> idx_cost, tbl_cost, idx_cost <span class="hljs-operator">+</span> tbl_cost <span class="hljs-keyword">AS</span> total<br><span class="hljs-keyword">FROM</span> costs;<br> idx_cost <span class="hljs-operator">|</span> tbl_cost <span class="hljs-operator">|</span> total<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br> <span class="hljs-number">2457</span>     <span class="hljs-operator">|</span>     <span class="hljs-number">2177</span> <span class="hljs-operator">|</span>  <span class="hljs-number">4634</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>这些计算说明了成本估算背后的逻辑，因此结果与规划器提供的估算一致，即使是近似值。获得准确值将需要考虑其他细节，这些我们在这里不讨论。</p>
<h4 id="20-1-3-不良场景：低相关性"><a href="#20-1-3-不良场景：低相关性" class="headerlink" title="20.1.3 不良场景：低相关性"></a>20.1.3 不良场景：低相关性</h4><p>如果相关性低，一切都变了。让我们在 book_date 列上创建一个索引，该列与这个索引的相关性几乎为零，然后观察一下获取与前一个示例中几乎相同比例行的查询。索引访问的成本太高，以至于规划器只有在其他所有可替代的方案都被明确禁止的情况下才会选择索引扫描：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> bookings(book_date);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> enable_seqscan <span class="hljs-operator">=</span> off;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> enable_bitmapscan <span class="hljs-operator">=</span> off;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookings<br><span class="hljs-keyword">WHERE</span> book_date <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2016-08-23 12:00:00+03&#x27;</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> bookings_book_date_idx <span class="hljs-keyword">on</span> bookings<br>   (cost<span class="hljs-operator">=</span><span class="hljs-number">0.43</span>.<span class="hljs-number">.56957</span><span class="hljs-number">.48</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">132403</span> width<span class="hljs-operator">=</span><span class="hljs-number">21</span>)<br>   Index Cond: (book_date <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2016−08−23 12:00:00+03&#x27;</span>::<span class="hljs-type">timestamp</span> w...<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>问题在于，低相关性增加了访问方法返回的下一个元组位于不同页面的可能性。因此，Index Scan 节点必须在页面之间跳转，而不是顺序读取它们；在最坏的情况下，访问的页面数量会达到获取的元组数量。</p>
<p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/img_1.png" srcset="/img/loading.gif" lazyload alt="img_1.png"></p>
<p>然而，我们不能简单地将良好场景的计算中的 seq_page_cost 替换为 random_page_cost，relpages 替换为 reltuples。我们在计划中看到的成本远低于我们按这种方式估算的值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WITH</span> costs(idx_cost, tbl_cost) <span class="hljs-keyword">AS</span> (<br>  <span class="hljs-keyword">SELECT</span><br>    ( <span class="hljs-keyword">SELECT</span> round(<br>        current_setting(<span class="hljs-string">&#x27;random_page_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> pages <span class="hljs-operator">+</span><br>        current_setting(<span class="hljs-string">&#x27;cpu_index_tuple_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> tuples <span class="hljs-operator">+</span><br>        current_setting(<span class="hljs-string">&#x27;cpu_operator_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> tuples<br>      )<br>      <span class="hljs-keyword">FROM</span> (<br>        <span class="hljs-keyword">SELECT</span> relpages <span class="hljs-operator">*</span> <span class="hljs-number">0.0630</span> <span class="hljs-keyword">AS</span> pages, reltuples <span class="hljs-operator">*</span> <span class="hljs-number">0.0630</span> <span class="hljs-keyword">AS</span> tuples<br>        <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bookings_pkey&#x27;</span><br>      ) c<br>    ),<br>    ( <span class="hljs-keyword">SELECT</span> round(<br>        current_setting(<span class="hljs-string">&#x27;random_page_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> tuples <span class="hljs-operator">+</span><br>        current_setting(<span class="hljs-string">&#x27;cpu_tuple_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> tuples<br>      )<br>      <span class="hljs-keyword">FROM</span> (<br>        <span class="hljs-keyword">SELECT</span> relpages <span class="hljs-operator">*</span> <span class="hljs-number">0.0630</span> <span class="hljs-keyword">AS</span> pages, reltuples <span class="hljs-operator">*</span> <span class="hljs-number">0.0630</span> <span class="hljs-keyword">AS</span> tuples<br>        <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bookings&#x27;</span><br>      ) c<br>    )<br>)<br><span class="hljs-keyword">SELECT</span> idx_cost, tbl_cost, idx_cost <span class="hljs-operator">+</span> tbl_cost <span class="hljs-keyword">AS</span> total <span class="hljs-keyword">FROM</span> costs;<br> idx_cost <span class="hljs-operator">|</span> tbl_cost <span class="hljs-operator">|</span> total<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<br>     <span class="hljs-number">2457</span> <span class="hljs-operator">|</span>   <span class="hljs-number">533330</span> <span class="hljs-operator">|</span> <span class="hljs-number">535787</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>原因是代价模型考虑了缓存。频繁使用的页面保存在缓冲区缓存 (和操作系统缓存) 中，因此缓存大小越大，在其中找到所需页面的机会就越大，从而避免了额外的磁盘访问操作。出于规划目的，缓存大小由 effective_cache_size 参数定义。值越小，预估读取的页面就越多。</p>
<p>下图展示了要读取的页面数量预估值与表大小之间的依赖关系 (对于选择率为 1&#x2F;2 且页面包含 10 行的情况) 5。虚线显示了最佳情况下的访问计数 (如果相关性完美，则为页面计数的一半) 和最坏情况下的访问计数 (如果相关性为零且没有缓存，则为行计数的一半) 。</p>
<p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/img_2.png" srcset="/img/loading.gif" lazyload alt="img_2.png"></p>
<p>effective_cache_size 值表示可用于缓存的内存总量 (包括 PostgreSQL 缓冲区缓存和操作系统缓存)。但由于该参数仅用于估算目的，并不会影响到内存分配本身，因此在更改此设置时，不必考虑实际数字。</p>
<p>如果将 effective_cache_size 减少到最小，计划的估算结果将接近上述无缓存情况的低端值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> effective_cache_size <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;8kB&#x27;</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookings<br><span class="hljs-keyword">WHERE</span> book_date <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2016-08-23 12:00:00+03&#x27;</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> bookings_book_date_idx <span class="hljs-keyword">on</span> bookings<br>   (cost<span class="hljs-operator">=</span><span class="hljs-number">0.43</span>.<span class="hljs-number">.532745</span><span class="hljs-number">.48</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">132403</span> width<span class="hljs-operator">=</span><span class="hljs-number">21</span>)<br>   Index Cond: (book_date <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2016−08−23 12:00:00+03&#x27;</span>::<span class="hljs-type">timestamp</span> w...<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br>               <br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> RESET effective_cache_size;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> RESET enable_seqscan;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> RESET enable_bitmapscan;<br></code></pre></td></tr></table></figure>

<p>规划器计算了最坏情况和最好情况场景下的表 I&#x2F;O 成本，然后根据实际的相关性取一个中间值。6</p>
<p>因此，如果只需要读取一小部分行，索引扫描可能是一个不错的选择。如果堆元组与访问方法返回的 ID 顺序相关性高，那么需要读取的行数可以相对较多。然而，如果相关性低，对于选择率低的查询，索引扫描便会变得不那么吸引人。</p>
<h3 id="20-2-Index-Only-Scans"><a href="#20-2-Index-Only-Scans" class="headerlink" title="20.2 Index-Only Scans"></a><a name="cp2"></a>20.2 Index-Only Scans</h3><p>如果一个索引包含所有查询所需的堆数据，那么它被称为这个特定查询的覆盖索引。如果这样的索引可用，便可以避免额外的表访问：访问方法可以直接返回实际数据，而不是 TIDS。这种类型的索引扫描称为仅索引扫描。7 它可以被支持 RETURNABLE 属性的访问方法使用。</p>
<p>在计划中，这个操作由 Index Only Scan 8 节点表示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> book_ref <span class="hljs-keyword">FROM</span> bookings <span class="hljs-keyword">WHERE</span> book_ref <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;100000&#x27;</span>;<br>                   QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index <span class="hljs-keyword">Only</span> Scan <span class="hljs-keyword">using</span> bookings_pkey <span class="hljs-keyword">on</span> bookings<br>   (cost<span class="hljs-operator">=</span><span class="hljs-number">0.43</span>.<span class="hljs-number">.3791</span><span class="hljs-number">.91</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">132999</span> width<span class="hljs-operator">=</span><span class="hljs-number">7</span>)<br>   Index Cond: (book_ref <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;100000&#x27;</span>::bpchar)<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>顾名思义，这个节点不需要访问堆，但事实却并非如此。在 PostgreSQL 中，索引不包含元组可见性的信息，因此访问方法返回所有满足过滤条件的堆元组数据，即使当前事务看不到它们。然后由索引引擎检查它们的可见性。</p>
<p>然而，如果此方法必须访问表以检查每条元组的可见性，那么它与常规的索引扫描没有任何区别。因此，它使用了为表提供的可见性映射，在其中，vacuum 进程会标记仅包含所有元组都可见的页面 (即所有事务均可访问的那些元组，无论使用的快照如何) 。如果索引访问方法返回的 TID 属于这样的页面，则无需检查其可见性。</p>
<p>仅索引扫描的成本估算取决于堆中页面全部可见的比例。PostgreSQL 会收集这样的统计信息：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> relpages, relallvisible<br><span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bookings&#x27;</span>;<br> relpages <span class="hljs-operator">|</span> relallvisible<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<br>    <span class="hljs-number">13447</span> <span class="hljs-operator">|</span>         <span class="hljs-number">13446</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>仅索引扫描的成本估算与常规索引扫描的成本估算不同：其与表访问相关的 I&#x2F;O 成本是按照未出现在可见性映射中的页面比例来计算的。(元组处理的成本估算是相同的)</p>
<p>由于在这个特定示例中，所有页面只包含全部可见的元组，因此堆 I&#x2F;O 的成本实际上排除在了成本估算之外：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WITH</span> costs(idx_cost, tbl_cost) <span class="hljs-keyword">AS</span> (<br>  <span class="hljs-keyword">SELECT</span><br>    (<br>      <span class="hljs-keyword">SELECT</span> round(<br>        current_setting(<span class="hljs-string">&#x27;random_page_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> pages <span class="hljs-operator">+</span><br>        current_setting(<span class="hljs-string">&#x27;cpu_index_tuple_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> tuples <span class="hljs-operator">+</span><br>        current_setting(<span class="hljs-string">&#x27;cpu_operator_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> tuples<br>      )<br>      <span class="hljs-keyword">FROM</span> (<br>        <span class="hljs-keyword">SELECT</span> relpages <span class="hljs-operator">*</span> <span class="hljs-number">0.0630</span> <span class="hljs-keyword">AS</span> pages,<br>              reltuples <span class="hljs-operator">*</span> <span class="hljs-number">0.0630</span> <span class="hljs-keyword">AS</span> tuples<br>        <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bookings_pkey&#x27;</span><br>      ) c<br>    ) <span class="hljs-keyword">AS</span> idx_cost,<br>    (<br>      <span class="hljs-keyword">SELECT</span> round(<br>        (<span class="hljs-number">1</span> <span class="hljs-operator">-</span> frac_visible) <span class="hljs-operator">*</span> <span class="hljs-comment">-- fraction of non-all-visible pages</span><br>        current_setting(<span class="hljs-string">&#x27;seq_page_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> pages <span class="hljs-operator">+</span><br>        current_setting(<span class="hljs-string">&#x27;cpu_tuple_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> tuples<br>      )<br>      <span class="hljs-keyword">FROM</span> (<br>        <span class="hljs-keyword">SELECT</span> relpages <span class="hljs-operator">*</span> <span class="hljs-number">0.0630</span> <span class="hljs-keyword">AS</span> pages,<br>              reltuples <span class="hljs-operator">*</span> <span class="hljs-number">0.0630</span> <span class="hljs-keyword">AS</span> tuples,<br>          relallvisible::<span class="hljs-type">real</span><span class="hljs-operator">/</span>relpages::<span class="hljs-type">real</span> <span class="hljs-keyword">AS</span> frac_visible<br>        <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bookings&#x27;</span><br>      ) c<br>    ) <span class="hljs-keyword">AS</span> tbl_cost<br>)<br><span class="hljs-keyword">SELECT</span> idx_cost, tbl_cost, idx_cost <span class="hljs-operator">+</span> tbl_cost <span class="hljs-keyword">AS</span> total<br><span class="hljs-keyword">FROM</span> costs;<br> idx_cost <span class="hljs-operator">|</span> tbl_cost <span class="hljs-operator">|</span> total<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br>     <span class="hljs-number">2457</span> <span class="hljs-operator">|</span>     <span class="hljs-number">1330</span> <span class="hljs-operator">|</span> <span class="hljs-number">3787</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>任何未清理的变更，如果还没有消失在数据库的视界之外，都会增加计划的预估成本 (因此，使这个计划对优化器来说变得不那么有吸引力) 。EXPLAIN ANALYZE 命令可以显示实际的堆访问计数。</p>
<p>在新创建的表中，PostgreSQL 必须检查所有元组的可见性：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> TEMP <span class="hljs-keyword">TABLE</span> bookings_tmp<br><span class="hljs-keyword">WITH</span> (autovacuum_enabled <span class="hljs-operator">=</span> off) <span class="hljs-keyword">AS</span><br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookings<br>  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> book_ref;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER TABLE</span> bookings_tmp <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY KEY</span>(book_ref);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> ANALYZE bookings_tmp;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> book_ref <span class="hljs-keyword">FROM</span> bookings_tmp <span class="hljs-keyword">WHERE</span> book_ref <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;100000&#x27;</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index <span class="hljs-keyword">Only</span> Scan <span class="hljs-keyword">using</span> bookings_tmp_pkey <span class="hljs-keyword">on</span> bookings_tmp<br>   (cost<span class="hljs-operator">=</span><span class="hljs-number">0.43</span>.<span class="hljs-number">.4638</span><span class="hljs-number">.91</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">132999</span> width<span class="hljs-operator">=</span><span class="hljs-number">7</span>) (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">132109</span> l...<br>   Index Cond: (book_ref <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;100000&#x27;</span>::bpchar)<br>   Heap Fetches: <span class="hljs-number">132109</span><br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>但是一旦表被清理之后，这样的检查就会变得多余，只要所有页面保持全部可见，就不会执行这样的检查。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> VACUUM bookings_tmp;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> book_ref <span class="hljs-keyword">FROM</span> bookings_tmp <span class="hljs-keyword">WHERE</span> book_ref <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;100000&#x27;</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index <span class="hljs-keyword">Only</span> Scan <span class="hljs-keyword">using</span> bookings_tmp_pkey <span class="hljs-keyword">on</span> bookings_tmp<br>   (cost<span class="hljs-operator">=</span><span class="hljs-number">0.43</span>.<span class="hljs-number">.3787</span><span class="hljs-number">.91</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">132999</span> width<span class="hljs-operator">=</span><span class="hljs-number">7</span>) (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">132109</span> l...<br>   Index Cond: (book_ref <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;100000&#x27;</span>::bpchar)<br>   Heap Fetches: <span class="hljs-number">0</span><br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<h4 id="20-2-1-包含-INCLUDE-子句的索引"><a href="#20-2-1-包含-INCLUDE-子句的索引" class="headerlink" title="20.2.1 包含 INCLUDE 子句的索引"></a>20.2.1 包含 INCLUDE 子句的索引</h4><p>然而，并不总是可以使用查询所需的所有列来扩展索引：</p>
<pre><code class="hljs">对于唯一索引，添加新列会破坏原始键列的唯一性。

索引访问方法可能没有为要添加的列的数据类型提供操作符类。
</code></pre>
<p>在这种情况下，你仍然可以将列包含进索引中，而无需让它们成为索引键的一部分。当然，基于包含列进行索引扫描是不可能的，但如果查询引用了这些列，那么索引将作为覆盖索引。</p>
<p>以下示例展示了如何用另一个包含列的索引替换自动创建的主键索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX <span class="hljs-keyword">ON</span> bookings(book_ref) INCLUDE (book_date);<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER TABLE</span> bookings<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> bookings_pkey CASCADE;<br>NOTICE: <span class="hljs-keyword">drop</span> cascades <span class="hljs-keyword">to</span> <span class="hljs-keyword">constraint</span> tickets_book_ref_fkey <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span><br>tickets<br><span class="hljs-keyword">ALTER TABLE</span><br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER TABLE</span> bookings <span class="hljs-keyword">ADD CONSTRAINT</span> bookings_pkey <span class="hljs-keyword">PRIMARY KEY</span><br>  <span class="hljs-keyword">USING</span> INDEX bookings_book_ref_book_date_idx; <span class="hljs-comment">-- a new index</span><br>NOTICE: <span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-operator">/</span> <span class="hljs-keyword">ADD CONSTRAINT</span> <span class="hljs-keyword">USING</span> INDEX will rename index<br>&quot;bookings_book_ref_book_date_idx&quot; <span class="hljs-keyword">to</span> &quot;bookings_pkey&quot;<br><span class="hljs-keyword">ALTER TABLE</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER TABLE</span> tickets<br>  <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">FOREIGN KEY</span> (book_ref) <span class="hljs-keyword">REFERENCES</span> bookings(book_ref);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> book_ref, book_date<br><span class="hljs-keyword">FROM</span> bookings <span class="hljs-keyword">WHERE</span> book_ref <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;100000&#x27;</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index <span class="hljs-keyword">Only</span> Scan <span class="hljs-keyword">using</span> bookings_pkey <span class="hljs-keyword">on</span> bookings (cost<span class="hljs-operator">=</span><span class="hljs-number">0.43</span>.<span class="hljs-number">.437</span>...<br>   Index Cond: (book_ref <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;100000&#x27;</span>::bpchar)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">这种索引通常被称为覆盖索引，但这种说法并不完全正确。如果一个索引的列集合覆盖了特定查询所需的所有列，那么该索引被认为是覆盖索引。无论是涉及通过 INCLUDE 子句添加的任何列，还是仅使用键列都无关紧要。此外，同一个索引对于一个查询可能是覆盖的，但对于另一个查询则可能不是<br></code></pre></td></tr></table></figure>
<h3 id="20-3-Bitmap-Scans"><a href="#20-3-Bitmap-Scans" class="headerlink" title="20.3 Bitmap Scans"></a><a name="cp3"></a>20.3 Bitmap Scans</h3><p>索引扫描的效率是有限的：随着相关性的降低，对堆页面的访问次数增加，扫描变得随机而不是顺序的。为了克服这一限制，PostgreSQL 可以在访问表之前获取所有的 TIDS，并根据它们的页面编号按升序对它们进行排序 9。这正是位图扫描的工作原理，位图扫描是另一种处理 TIDS 的常见方式。它可以被那些支持 BITMAP SCAN 属性的访问方法使用。</p>
<p>与常规索引扫描不同，此操作在查询计划中由两个节点表示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> bookings(total_amount);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookings <span class="hljs-keyword">WHERE</span> total_amount <span class="hljs-operator">=</span> <span class="hljs-number">48500.00</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Bitmap Heap Scan <span class="hljs-keyword">on</span> bookings (cost<span class="hljs-operator">=</span><span class="hljs-number">54.63</span>.<span class="hljs-number">.7040</span><span class="hljs-number">.42</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">2865</span> wid...<br>   Recheck Cond: (total_amount <span class="hljs-operator">=</span> <span class="hljs-number">48500.00</span>)<br>   −<span class="hljs-operator">&gt;</span> Bitmap Index Scan <span class="hljs-keyword">on</span> bookings_total_amount_idx<br>       (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.53</span><span class="hljs-number">.92</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">2865</span> width<span class="hljs-operator">=</span><span class="hljs-number">0</span>)<br>       Index Cond: (total_amount <span class="hljs-operator">=</span> <span class="hljs-number">48500.00</span>)<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>
<p>Bitmap Index Scan 10 节点从访问方法中获取所有 TIDS 11 的位图。</p>
<p>位图由单独的段组成，每个段对应一个堆页面。这些段的大小都是一样的，足以容纳所有页面元组，无论实际上有多少元组。页面元组这个数字是有限的，因为元组头非常大；标准大小的页面最多可以容纳 256 条元组，这些元组占 32 个字节 12。</p>
<p>然后，Bitmap Heap Scan 13 逐段遍历位图，读取相应的页面，并检查所有标记为全部可见的元组。这样的话，页面根据页号以升序读取，每个页面仅被读取一次。</p>
<p>尽管如此，这个过程与顺序扫描不同，因为访问的页面很少相邻。操作系统执行的常规预取在这种情况下无济于事，因此 Bitmap Heap Scan 节点通过异步读取 effective_io_concurrency 个页面实现了自己的预取 — 并且它是唯一这样做的节点。这个机制依赖于某些操作系统实现的 posix_fadvise 函数。如果你的系统支持这个函数，那么根据硬件能力在表空间级别配置 effective_io_concurrency 参数是有意义的。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">异步预取也被其他一些内部进程所使用：<br><br>    1. 在删除堆行时用于索引页面 14<br>    <br>    2. 在分析期间用于堆页面 15<br><br>预取深度由 maintenance_io_concurrency 定义。<br></code></pre></td></tr></table></figure>

<h4 id="20-3-1-位图准确性"><a href="#20-3-1-位图准确性" class="headerlink" title="20.3.1 位图准确性"></a>20.3.1 位图准确性</h4><p>包含满足查询过滤条件的元组的页面越多，位图就越大。位图建立在后端进程的本地内存中，其大小受到 work_mem 参数限制。一旦达到允许的最大大小，一些位图段就会变得有损：有损段的每个位对应一个完整的页面，而段本身包含一系列页面。16 因此，位图的大小以牺牲其准确性为代价变得更小。</p>
<p>EXPLAIN ANALYZE 命令显示了所构建位图的准确性：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, costs off, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookings <span class="hljs-keyword">WHERE</span> total_amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">150000.00</span>;<br>QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Bitmap Heap Scan <span class="hljs-keyword">on</span> bookings (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">242691</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   Recheck Cond: (total_amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">150000.00</span>)<br>   Heap Blocks: exact<span class="hljs-operator">=</span><span class="hljs-number">13447</span><br>−<span class="hljs-operator">&gt;</span> Bitmap Index Scan <span class="hljs-keyword">on</span> bookings_total_amount_idx (actual rows...<br>       Index Cond: (total_amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">150000.00</span>)<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>此处，我们有足够的内存来构建一个精确的位图。</p>
<p>如果我们减少 work_mem 的值，一些位图段就会变得有损：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> work_mem <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;512kB&#x27;</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, costs off, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookings <span class="hljs-keyword">WHERE</span> total_amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">150000.00</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Bitmap Heap Scan <span class="hljs-keyword">on</span> bookings (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">242691</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   Recheck Cond: (total_amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">150000.00</span>)<br>   <span class="hljs-keyword">Rows</span> Removed <span class="hljs-keyword">by</span> Index Recheck: <span class="hljs-number">1145721</span><br>   Heap Blocks: exact<span class="hljs-operator">=</span><span class="hljs-number">5178</span> lossy<span class="hljs-operator">=</span><span class="hljs-number">8269</span><br>   −<span class="hljs-operator">&gt;</span> Bitmap Index Scan <span class="hljs-keyword">on</span> bookings_total_amount_idx (actual rows...<br>       Index Cond: (total_amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">150000.00</span>)<br>(<span class="hljs-number">6</span> <span class="hljs-keyword">rows</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> RESET work_mem;<br></code></pre></td></tr></table></figure>
<p>当读取有损位图段所对应的堆页面时，PostgreSQL 必须重新检查页面中每条元组的过滤条件。要重新检查的条件总是在计划中显示为 Recheck Cond，即使未执行这种检查也是如此。重新检查期间过滤掉的元组数会另外显示 (作为 Rows Removed by Index Recheck)。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">如果结果集的大小太大，位图可能不适合 work_mem 内存块，即使所有段都是有损的。这种情况下会忽略此限制，位图会占用所需的尽可能多的空间。PostgreSQL 既不会进一步降低位图的准确性，也不会将其任何段刷到磁盘。<br></code></pre></td></tr></table></figure>

<h4 id="20-3-2-位图操作"><a href="#20-3-2-位图操作" class="headerlink" title="20.3.2 位图操作"></a>20.3.2 位图操作</h4><p>如果查询将过滤条件应用于多列，并且这些列上分别创建了索引，那么位图扫描可以一起使用这些索引。17 所有这些索引都即时构建了自己的位图；然后使用逻辑与 (如果表达式通过 AND 连接) 或逻辑或 (如果表达式通过 OR 连接) 将位图按位合并。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookings<br><span class="hljs-keyword">WHERE</span> book_date <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2016-08-28&#x27;</span><br>	<span class="hljs-keyword">AND</span> total_amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">250000</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Bitmap Heap Scan <span class="hljs-keyword">on</span> bookings<br>   Recheck Cond: ((total_amount <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;250000&#x27;</span>::<span class="hljs-type">numeric</span>) <span class="hljs-keyword">AND</span> (book_da...<br>   −<span class="hljs-operator">&gt;</span> BitmapAnd<br>       −<span class="hljs-operator">&gt;</span> Bitmap Index Scan <span class="hljs-keyword">on</span> bookings_total_amount_idx<br>           Index Cond: (total_amount <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;250000&#x27;</span>::<span class="hljs-type">numeric</span>)<br>       −<span class="hljs-operator">&gt;</span> Bitmap Index Scan <span class="hljs-keyword">on</span> bookings_book_date_idx<br>           Index Cond: (book_date <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2016−08−28 00:00:00+03&#x27;</span>::tim...<br>(<span class="hljs-number">7</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>
<p>此处 BitmapAnd 节点使用按位与操作合并两个位图。</p>
<p>当两个位图合并为一个时，18 精确的段在合并时仍然保持精确 (如果新的位图适合 work_mem 内存块)，但如果一组位图中有任何段是有损的，那么生成的段也将是有损的。</p>
<h4 id="20-3-3-成本估算"><a href="#20-3-3-成本估算" class="headerlink" title="20.3.3 成本估算"></a>20.3.3 成本估算</h4><p>让我们观察一下使用位图扫描的查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookings <span class="hljs-keyword">WHERE</span> total_amount <span class="hljs-operator">=</span> <span class="hljs-number">28000.00</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Bitmap Heap Scan <span class="hljs-keyword">on</span> bookings (cost<span class="hljs-operator">=</span><span class="hljs-number">599.48</span>.<span class="hljs-number">.14444</span><span class="hljs-number">.96</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">31878</span> ...<br>   Recheck Cond: (total_amount <span class="hljs-operator">=</span> <span class="hljs-number">28000.00</span>)<br>   −<span class="hljs-operator">&gt;</span> Bitmap Index Scan <span class="hljs-keyword">on</span> bookings_total_amount_idx<br>       (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.591</span><span class="hljs-number">.51</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">31878</span> width<span class="hljs-operator">=</span><span class="hljs-number">0</span>)<br>       Index Cond: (total_amount <span class="hljs-operator">=</span> <span class="hljs-number">28000.00</span>)<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>规划器使用的条件的近似选择率等于</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">31878</span>::<span class="hljs-type">numeric</span><span class="hljs-operator">/</span>reltuples::<span class="hljs-type">numeric</span>, <span class="hljs-number">4</span>)<br><span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bookings&#x27;</span>;<br> round<br>−−−−−−−−<br> <span class="hljs-number">0.0151</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>Bitmap Index Scan 节点的总成本以与不考虑堆访问的常规索引扫描相同的方式进行估算：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> round(<br>  current_setting(<span class="hljs-string">&#x27;random_page_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> pages <span class="hljs-operator">+</span><br>  current_setting(<span class="hljs-string">&#x27;cpu_index_tuple_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> tuples <span class="hljs-operator">+</span><br>  current_setting(<span class="hljs-string">&#x27;cpu_operator_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> tuples<br>)<br><span class="hljs-keyword">FROM</span> (<br>  <span class="hljs-keyword">SELECT</span> relpages <span class="hljs-operator">*</span> <span class="hljs-number">0.0151</span> <span class="hljs-keyword">AS</span> pages, reltuples <span class="hljs-operator">*</span> <span class="hljs-number">0.0151</span> <span class="hljs-keyword">AS</span> tuples<br>  <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bookings_total_amount_idx&#x27;</span><br>) c;<br> round<br>−−−−−−−<br>   <span class="hljs-number">589</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>Bitmap Heap Scan 节点的 I&#x2F;O 成本估算不同于常规索引扫描完美相关性的情况。位图允许根据页号升序读取堆页，而不需要返回到同一页面，但满足过滤条件的元组不再相继出现。PostgreSQL 可能会访问更多页面，而不是读取一个非常紧凑的严格顺序的页面范围。</p>
<p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/img_3.png" srcset="/img/loading.gif" lazyload alt="img_3.png"></p>
<p>要读取的页面数通过以下公式估算：19</p>
<p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/img_4.png" srcset="/img/loading.gif" lazyload alt="img_4.png"></p>
<p>读取单个页面的估算成本介于 seq_page_cost 和 random_page_cost 之间，取决于获取的页面比例与表中页面总数的比率：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WITH</span> t <span class="hljs-keyword">AS</span> (<br>  <span class="hljs-keyword">SELECT</span> relpages,<br>    least(<br>      (<span class="hljs-number">2</span> <span class="hljs-operator">*</span> relpages <span class="hljs-operator">*</span> reltuples <span class="hljs-operator">*</span> <span class="hljs-number">0.0151</span>) <span class="hljs-operator">/</span><br>      (<span class="hljs-number">2</span> <span class="hljs-operator">*</span> relpages <span class="hljs-operator">+</span> reltuples <span class="hljs-operator">*</span> <span class="hljs-number">0.0151</span>),<br>      relpages<br>    ) <span class="hljs-keyword">AS</span> pages_fetched,<br>    round(reltuples <span class="hljs-operator">*</span> <span class="hljs-number">0.0151</span>) <span class="hljs-keyword">AS</span> tuples_fetched,<br>    current_setting(<span class="hljs-string">&#x27;random_page_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-keyword">AS</span> rnd_cost,<br>    current_setting(<span class="hljs-string">&#x27;seq_page_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-keyword">AS</span> seq_cost<br>  <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bookings&#x27;</span><br>)<br><span class="hljs-keyword">SELECT</span> pages_fetched,<br>  rnd_cost <span class="hljs-operator">-</span> (rnd_cost <span class="hljs-operator">-</span> seq_cost) <span class="hljs-operator">*</span><br>  <span class="hljs-built_in">sqrt</span>(pages_fetched <span class="hljs-operator">/</span> relpages) <span class="hljs-keyword">AS</span> cost_per_page,<br>  tuples_fetched<br><span class="hljs-keyword">FROM</span> t;<br> pages_fetched <span class="hljs-operator">|</span> cost_per_page <span class="hljs-operator">|</span> tuples_fetched<br>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−<br>         <span class="hljs-number">13447</span> <span class="hljs-operator">|</span>             <span class="hljs-number">1</span> <span class="hljs-operator">|</span>          <span class="hljs-number">31878</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>与往常一样，I&#x2F;O 估算值会因处理每条获取元组的成本而增加。如果使用精确位图，元组数估算为表中元组总数乘以过滤条件的选择率。但是，如果任何位图段是有损的，PostgreSQL 必须访问相应的页面以重新检查其中所有元组。</p>
<p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/img_5.png" srcset="/img/loading.gif" lazyload alt="img_5.png"></p>
<p>因此，估算考虑了有损位图段的预期比例 (可以基于所选行的总数和 work_mem 定义的位图大小限制来计算)。20</p>
<p>重新检查过滤条件的总成本也增加了估算值 (无论位图精度如何)。</p>
<p>Bitmap Heap Scan 节点的启动成本估算值基于 Bitmap Index Scan 节点的总成本，该成本还包括了位图处理的成本。</p>
<p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/img_6.png" srcset="/img/loading.gif" lazyload alt="img_6.png"></p>
<p>此处位图是准确的，成本估算大致如下：21</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WITH</span> t <span class="hljs-keyword">AS</span> (<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> cost_per_page,<br>         <span class="hljs-number">13447</span> <span class="hljs-keyword">AS</span> pages_fetched,<br>         <span class="hljs-number">31878</span> <span class="hljs-keyword">AS</span> tuples_fetched<br>),<br>costs(startup_cost, run_cost) <span class="hljs-keyword">AS</span> (<br>  <span class="hljs-keyword">SELECT</span><br>    ( <span class="hljs-keyword">SELECT</span> round(<br>        <span class="hljs-number">589</span> <span class="hljs-comment">/* cost estimation for the child node */</span> <span class="hljs-operator">+</span><br>        <span class="hljs-number">0.1</span> <span class="hljs-operator">*</span> current_setting(<span class="hljs-string">&#x27;cpu_operator_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span><br>        reltuples <span class="hljs-operator">*</span> <span class="hljs-number">0.0151</span><br>      )<br>      <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bookings_total_amount_idx&#x27;</span><br>    ),<br>    ( <span class="hljs-keyword">SELECT</span> round(<br>        cost_per_page <span class="hljs-operator">*</span> pages_fetched <span class="hljs-operator">+</span><br>        current_setting(<span class="hljs-string">&#x27;cpu_tuple_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> tuples_fetched <span class="hljs-operator">+</span><br>        current_setting(<span class="hljs-string">&#x27;cpu_operator_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">*</span> tuples_fetched<br>      )<br>      <span class="hljs-keyword">FROM</span> t<br>    )<br>)<br><span class="hljs-keyword">SELECT</span> startup_cost, run_cost,<br>  startup_cost <span class="hljs-operator">+</span> run_cost <span class="hljs-keyword">AS</span> total_cost<br><span class="hljs-keyword">FROM</span> costs;<br> startup_cost <span class="hljs-operator">|</span> run_cost <span class="hljs-operator">|</span> total_cost<br>−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br>          <span class="hljs-number">597</span> <span class="hljs-operator">|</span>    <span class="hljs-number">13845</span> <span class="hljs-operator">|</span>      <span class="hljs-number">14442</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>如果查询计划合并了多个位图，单独索引扫描的成本总和会增加一个 (较小) 合并它们的成本。22</p>
<h3 id="20-4-Parallel-Index-Scans"><a href="#20-4-Parallel-Index-Scans" class="headerlink" title="20.4 Parallel Index Scans"></a><a name="cp4"></a>20.4 Parallel Index Scans</h3><p>所有索引扫描的方式 — 常规索引扫描、仅索引扫描和位图扫描都有其各自的并行特点。</p>
<p>并行执行的成本以与顺序执行相同的方式进行估算，但是 (就像并行顺序扫描的情况一样) CPU 资源在所有并行进程之间分配，从而降低了总成本。成本的 I&#x2F;O 组成部分没有分摊，因为进程被同步以顺序执行页面访问。</p>
<p>现在让我在不分解成本估算的情况下展示几个并行计划的示例。</p>
<p>并行索引扫描：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(total_amount)<br><span class="hljs-keyword">FROM</span> bookings <span class="hljs-keyword">WHERE</span> book_ref <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;400000&#x27;</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Finalize Aggregate (cost<span class="hljs-operator">=</span><span class="hljs-number">19192.81</span>.<span class="hljs-number">.19192</span><span class="hljs-number">.82</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">32</span>)<br>   −<span class="hljs-operator">&gt;</span> Gather (cost<span class="hljs-operator">=</span><span class="hljs-number">19192.59</span>.<span class="hljs-number">.19192</span><span class="hljs-number">.80</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">2</span> width<span class="hljs-operator">=</span><span class="hljs-number">32</span>)<br>       Workers Planned: <span class="hljs-number">2</span><br>       −<span class="hljs-operator">&gt;</span> Partial Aggregate (cost<span class="hljs-operator">=</span><span class="hljs-number">18192.59</span>.<span class="hljs-number">.18192</span><span class="hljs-number">.60</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> widt...<br>           −<span class="hljs-operator">&gt;</span> Parallel Index Scan <span class="hljs-keyword">using</span> bookings_pkey <span class="hljs-keyword">on</span> bookings<br>               (cost<span class="hljs-operator">=</span><span class="hljs-number">0.43</span>.<span class="hljs-number">.17642</span><span class="hljs-number">.82</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">219907</span> width<span class="hljs-operator">=</span><span class="hljs-number">6</span>)<br>               Index Cond: (book_ref <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;400000&#x27;</span>::bpchar)<br>(<span class="hljs-number">7</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>
<p>当正在执行 B 树并行扫描时，当前索引页的 ID 保存在服务器的共享内存中。初始值由启动扫描的进程设置：它从根遍历树，到第一个合适的叶子页面并保存其 ID。工作进程根据需要访问后续索引页面，替换保存的 ID。获取页面后，工作进程遍历其所有合适的条目并读取相应的堆元组。当工作进程读取了满足查询过滤条件的整个值范围时，扫描完成。</p>
<p>并行仅索引扫描：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(total_amount)<br><span class="hljs-keyword">FROM</span> bookings <span class="hljs-keyword">WHERE</span> total_amount <span class="hljs-operator">&lt;</span> <span class="hljs-number">50000.00</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Finalize Aggregate (cost<span class="hljs-operator">=</span><span class="hljs-number">23370.60</span>.<span class="hljs-number">.23370</span><span class="hljs-number">.61</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">32</span>)<br>   −<span class="hljs-operator">&gt;</span> Gather (cost<span class="hljs-operator">=</span><span class="hljs-number">23370.38</span>.<span class="hljs-number">.23370</span><span class="hljs-number">.59</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">2</span> width<span class="hljs-operator">=</span><span class="hljs-number">32</span>)<br>       Workers Planned: <span class="hljs-number">2</span><br>       −<span class="hljs-operator">&gt;</span> Partial Aggregate (cost<span class="hljs-operator">=</span><span class="hljs-number">22370.38</span>.<span class="hljs-number">.22370</span><span class="hljs-number">.39</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> widt...<br>           −<span class="hljs-operator">&gt;</span> Parallel Index <span class="hljs-keyword">Only</span> Scan <span class="hljs-keyword">using</span> bookings_total_amoun...<br>               (cost<span class="hljs-operator">=</span><span class="hljs-number">0.43</span>.<span class="hljs-number">.21387</span><span class="hljs-number">.27</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">393244</span> width<span class="hljs-operator">=</span><span class="hljs-number">6</span>)<br>               Index Cond: (total_amount <span class="hljs-operator">&lt;</span> <span class="hljs-number">50000.00</span>)<br>(<span class="hljs-number">7</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>
<p>并行仅索引扫描跳过了页面全部可见的堆访问；这是它与并行索引扫描的唯一区别。</p>
<p>并行位图扫描：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(total_amount)<br><span class="hljs-keyword">FROM</span> bookings <span class="hljs-keyword">WHERE</span> book_date <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2016-10-01&#x27;</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Finalize Aggregate (cost<span class="hljs-operator">=</span><span class="hljs-number">21492.21</span>.<span class="hljs-number">.21492</span><span class="hljs-number">.22</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">32</span>)<br>   −<span class="hljs-operator">&gt;</span> Gather (cost<span class="hljs-operator">=</span><span class="hljs-number">21491.99</span>.<span class="hljs-number">.21492</span><span class="hljs-number">.20</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">2</span> width<span class="hljs-operator">=</span><span class="hljs-number">32</span>)<br>       Workers Planned: <span class="hljs-number">2</span><br>       −<span class="hljs-operator">&gt;</span> Partial Aggregate (cost<span class="hljs-operator">=</span><span class="hljs-number">20491.99</span>.<span class="hljs-number">.20492</span><span class="hljs-number">.00</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> widt...<br>           −<span class="hljs-operator">&gt;</span> Parallel Bitmap Heap Scan <span class="hljs-keyword">on</span> bookings<br>               (cost<span class="hljs-operator">=</span><span class="hljs-number">4891.17</span>.<span class="hljs-number">.20133</span><span class="hljs-number">.01</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">143588</span> width<span class="hljs-operator">=</span><span class="hljs-number">6</span>)<br>               Recheck Cond: (book_date <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2016−10−01 00:00:00+03...</span><br><span class="hljs-string">               −&gt; Bitmap Index Scan on bookings_book_date_idx</span><br><span class="hljs-string">                   (cost=0.00..4805.01 rows=344611 width=0)</span><br><span class="hljs-string">                   Index Cond: (book_date &lt; &#x27;</span><span class="hljs-number">2016</span>−<span class="hljs-number">10</span>−<span class="hljs-number">01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-operator">+</span>...<br></code></pre></td></tr></table></figure>

<p>位图扫描意味着位图总是由单个领导者进程顺序构建；因此，Bitmap Index Scan 节点的名称不包含 Parallel 一词。当位图准备就绪后，Parallel Bitmap Heap Scan 节点开始并行堆扫描。工作进程访问后续的堆页面并且并发处理它们。</p>
<h3 id="20-5-Comparison-of-Various-Access-Methods"><a href="#20-5-Comparison-of-Various-Access-Methods" class="headerlink" title="20.5 Comparison of Various Access Methods"></a><a name="cp5"></a>20.5 Comparison of Various Access Methods</h3><p>下图显示了过滤条件的选择率如何影响访问方法的成本：</p>
<p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/img_7.png" srcset="/img/loading.gif" lazyload alt="img_7.png"></p>
<p>这是一个定性图；实际数字当然取决于特定的表和服务器配置。</p>
<p>顺序扫描不依赖于选择率，从选定行的某个比例开始，它通常比其他方法更有效。</p>
<p>索引扫描的成本受到元组的物理顺序与访问方法返回的 ID 顺序之间的相关性的影响。如果相关性完美，即使所选行的比例很高，索引扫描也可以非常高效。然而，对于低相关性 (这更常见) ，它的成本很快甚至可能超过顺序扫描。尽管如此，在使用索引获取单行时 (通常是唯一索引)，索引扫描仍然是绝对领先者。</p>
<p>如果适用，仅索引扫描可以展现出极佳的性能，甚至在选择所有行时也能胜过顺序扫描。但是，其性能高度依赖于可见性映射，在最糟糕的情况下，仅索引扫描会降级为常规的索引扫描。</p>
<p>位图扫描的成本受可用内存大小的影响，但这种影响远小于索引扫描的成本对于相关性的依赖。如果相关性低，位图扫描的成本会更低。</p>
<p>每种访问方法都有其适用的使用场景；没有一种方法总是优于其他方法。规划器必须进行大量计算，以评估每种特定情况下每种方法的效率。显然，评估的准确性在很大程度上取决于所收集的统计信息的准确性。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/BOOK/" class="category-chain-item">BOOK</a>
  
  
    <span>></span>
    
  <a href="/categories/BOOK/PostgreSQL14-Internals/" class="category-chain-item">PostgreSQL14_Internals</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/book/" class="print-no-link">#book</a>
      
        <a href="/tags/database/" class="print-no-link">#database</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>ch20. Index Scans</div>
      <div>http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Smile</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/05/05/DB/PostgreSQL14_Internals/ch22/ch22/" title="ch22. Hashing">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ch22. Hashing</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/05/DB/PostgreSQL14_Internals/ch2/ch2/" title="ch2. Isolation">
                        <span class="hidden-mobile">ch2. Isolation</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
