

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Smile">
  <meta name="keywords" content="">
  
    <meta name="description" content="ch9. Buffer Cache本章主要内容如下：    Chapter Contents    9.1 Caching   9.2 Buffer Cache Design   9.3 Cache Hits   9.4 Cache Misses   9.5 Bulk Eviction   9.6 Choosing the Buffer Cache Size   9.7 Cache Warming">
<meta property="og:type" content="article">
<meta property="og:title" content="ch9. Buffer Cache">
<meta property="og:url" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch9/ch9/index.html">
<meta property="og:site_name" content="Smile">
<meta property="og:description" content="ch9. Buffer Cache本章主要内容如下：    Chapter Contents    9.1 Caching   9.2 Buffer Cache Design   9.3 Cache Hits   9.4 Cache Misses   9.5 Bulk Eviction   9.6 Choosing the Buffer Cache Size   9.7 Cache Warming">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch9/ch9/img.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch9/ch9/img_1.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch9/ch9/img_2.png">
<meta property="article:published_time" content="2025-05-05T12:24:14.682Z">
<meta property="article:modified_time" content="2025-05-06T11:53:13.527Z">
<meta property="article:author" content="Smile">
<meta property="article:tag" content="book">
<meta property="article:tag" content="database">
<meta property="article:tag" content="transactions">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch9/ch9/img.png">
  
  
  
  <title>ch9. Buffer Cache - Smile</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"smilemzy.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Smile</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="ch9. Buffer Cache"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-05 20:24" pubdate>
          2025年5月5日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.5k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          55 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">ch9. Buffer Cache</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="ch9-Buffer-Cache"><a href="#ch9-Buffer-Cache" class="headerlink" title="ch9. Buffer Cache"></a>ch9. Buffer Cache</h2><p>本章主要内容如下：</p>
<table>
<thead>
<tr>
<th>Chapter Contents</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#cp1">9.1 Caching</a></td>
</tr>
<tr>
<td><a href="#cp2">9.2 Buffer Cache Design</a></td>
</tr>
<tr>
<td><a href="#cp3">9.3 Cache Hits</a></td>
</tr>
<tr>
<td><a href="#cp4">9.4 Cache Misses</a></td>
</tr>
<tr>
<td><a href="#cp5">9.5 Bulk Eviction</a></td>
</tr>
<tr>
<td><a href="#cp6">9.6 Choosing the Buffer Cache Size</a></td>
</tr>
<tr>
<td><a href="#cp7">9.7 Cache Warming</a></td>
</tr>
<tr>
<td><a href="#cp8">9.8 Local Cache</a></td>
</tr>
</tbody></table>
<h3 id="9-1-Caching"><a href="#9-1-Caching" class="headerlink" title="9.1 Caching"></a><a name="cp1"></a>9.1 Caching</h3><p>在现代计算机系统中，缓存无处不在 — 不管是在硬件层面还是在软件层面。仅处理器自身就可能有多达三到四层缓存。RAID 控制器和磁盘也有它们自己的缓存。</p>
<p>缓存用于平衡高速与低速内存之间的性能差异。高速内存昂贵且容量更小，而低速内存更大且更便宜。因此，高速内存无法容纳所有存储在低速内存中的数据。但在大多数情况下，每个特定时刻只有一小部分数据被频繁使用，因此为缓存分配一些高速内存以保持热数据，可以显著减少低速内存访问所带来的开销。</p>
<p>在 PostgreSQL 中，缓冲区缓存 1 中保存着关系页面，以平衡对磁盘 (毫秒级) 和 RAM (纳秒级) 的访问时间。</p>
<p>出于同样目的，操作系统也有其自己的缓存。基于此，数据库系统通常被设计为要避免双缓存：通常直接查询存储在磁盘上的数据，绕过 OS 缓存。但是 PostgreSQL 使用了不同的方式：它通过缓冲区文件操作来读取和写入所有的数据。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">如果使用 Direct I/O ，那么便可以避免双缓存的问题。这将减少开销，因为 PostgreSQL 将使用直接内存访问 (DMA) 而不是将缓冲区页面复制到操作系统地址空间中；此外，你将直接控制磁盘上的物理写入。然而，Direct I/O 不支持数据预取 (Buffered I/O 支持预取)，因此你必须通过异步 I/O 单独实现它，这需要在 PostgreSQL 内核代码中进行大量的修改，以及处理操作系统在 Direct I/O 和异步 I/O 支持方面的不兼容问题。但一旦建立了异步通信，你便可以享受到无等待磁盘访问的额外好处。<br><br>PostgreSQL 社区已经开始了这项重大工程 2，但实际结果仍需要很长时间才能出现。<br><br>www.postgresql.org/message-id/flat/20210223100344.llw5an2aklengrmn%40alap3.anarazel.de<br></code></pre></td></tr></table></figure>

<h3 id="9-2-Buffer-Cache-Design"><a href="#9-2-Buffer-Cache-Design" class="headerlink" title="9.2 Buffer Cache Design"></a><a name="cp2"></a>9.2 Buffer Cache Design</h3><p>缓冲区缓存位于服务器的共享内存中，所有进程都可以访问。它占据了大部分的共享内存，并且无疑是 PostgreSQL 中最重要和最复杂的数据结构之一。理解缓存的工作原理本身就很重要，但更重要的是，许多其他结构 (例如子事务、CLOG 事务状态和 WAL 条目) 使用类似的缓存机制，尽管这些结构更简单一些。</p>
<p>这个缓存的名称受其内部结构的启发，因为它由一系列缓冲区组成。每个缓冲区保留了一个内存块，可以容纳单个数据页及其页头 3。</p>
<p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch9/ch9/img.png" srcset="/img/loading.gif" lazyload alt="img.png"></p>
<p>页头包含了一些关于缓冲区和其中页面的信息，比如：</p>
<pre><code class="hljs">页面的物理位置 (文件 ID、分支和分支中的块号)
用于显示页面中的数据已被修改，并且需要回写到磁盘的属性 (这样的页面被称为脏页)
缓冲区使用计数
锁定计数 (或者引用计数)
</code></pre>
<p>要访问表的数据页，进程会向缓冲区管理器 4 请求它，并接收包含该页的缓冲区 ID。然后，读取缓存数据并在需要时直接在缓存中修改它。当页面正在使用时，其缓冲区被锁定。锁定过程会禁止逐出缓存页面，并且可以与其他锁一起使用。每次锁定也会增加使用计数。</p>
<p>只要页面被缓存，它的使用就不会产生任何文件操作。</p>
<p>我们可以使用 pg_buffercache 扩展来窥探缓冲区缓存：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> EXTENSION pg_buffercache;<br></code></pre></td></tr></table></figure>

<p>让我们创建一个表并插入一行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE TABLE</span> cacheme(<br>  id <span class="hljs-type">integer</span><br>) <span class="hljs-keyword">WITH</span> (autovacuum_enabled <span class="hljs-operator">=</span> off);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> cacheme <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>现在缓冲区缓存包含一个带有新插入行的堆页面。你可以通过选择与特定表相关的所有缓冲区进行查看。由于需要多次执行这样的查询，所以让我们将其封装至一个函数中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> buffercache(rel regclass)<br><span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">TABLE</span>(<br>  bufferid <span class="hljs-type">integer</span>, relfork text, relblk <span class="hljs-type">bigint</span>,<br>  isdirty <span class="hljs-type">boolean</span>, usagecount <span class="hljs-type">smallint</span>, pins <span class="hljs-type">integer</span><br>) <span class="hljs-keyword">AS</span> $$<br><span class="hljs-keyword">SELECT</span> bufferid,<br>  <span class="hljs-keyword">CASE</span> relforknumber<br>    <span class="hljs-keyword">WHEN</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;main&#x27;</span><br>    <span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;fsm&#x27;</span><br>    <span class="hljs-keyword">WHEN</span> <span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;vm&#x27;</span><br>  <span class="hljs-keyword">END</span>,<br>  relblocknumber,<br>  isdirty,<br>  usagecount,<br>  pinning_backends<br><span class="hljs-keyword">FROM</span> pg_buffercache<br><span class="hljs-keyword">WHERE</span> relfilenode <span class="hljs-operator">=</span> pg_relation_filenode(rel)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> relforknumber, relblocknumber;<br>$$ <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">sql</span>;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> buffercache(<span class="hljs-string">&#x27;cacheme&#x27;</span>);<br> bufferid <span class="hljs-operator">|</span> relfork <span class="hljs-operator">|</span> relblk <span class="hljs-operator">|</span> isdirty <span class="hljs-operator">|</span> usagecount <span class="hljs-operator">|</span> pins<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>      <span class="hljs-number">268</span> <span class="hljs-operator">|</span> main    <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span> t       <span class="hljs-operator">|</span>          <span class="hljs-number">1</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>
<p>页面是脏的：它已经被修改，但尚未写入磁盘。它的使用计数设置为 1。</p>
<h3 id="9-3-Cache-Hits"><a href="#9-3-Cache-Hits" class="headerlink" title="9.3 Cache Hits"></a><a name="cp3"></a>9.3 Cache Hits</h3><p>当缓冲区管理器需要读取一个页面时 5，它首先会检查缓冲区缓存。</p>
<p>所有缓冲区 ID 都存储在一个哈希表中 6，用于加速它们的搜索。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">许多现代编程语言将哈希表作为基础数据类型之一。哈希表通常被称为关联数组，实际上，从用户的角度来看，它们确实看起来像一个数组。但是，它们的索引 (哈希键) 可以是任何数据类型，例如一个文本字符串，而不是一个整数。<br><br>虽然可能的键值范围会非常大，但哈希表一次性永远不会包含那么多不同的值。哈希的思想是使用哈希函数将键值转换为一个整数。这个数字 (或这个数字的某些位) 被用作常规数组的索引。这个数组的元素被称为哈希表桶。<br><br>一个好的哈希函数在桶之间或多或少均匀地分配哈希键，但它仍然可能为不同的键分配相同的数字，从而将它们放入到同一个桶中；这种情况被称为哈希碰撞。因此，值与哈希键一起存储在桶中；要通过其键访问哈希值，PostgreSQL 必须检查所有存储在桶中的键。<br></code></pre></td></tr></table></figure>

<p>哈希表有多种实现方式；在所有可能的选项中，缓冲区缓存使用的是可扩展哈希表，通过链解决哈希碰撞 7。</p>
<p>哈希键由表文件的 ID、分支类型和此分支文件中的页面 ID 组成。因此，知道页面后，PostgreSQL 便可以快速找到包含该页面的缓冲区，或确认该页面当前没有被缓存。</p>
<p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch9/ch9/img_1.png" srcset="/img/loading.gif" lazyload alt="img_1.png"></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">长期以来，缓冲区缓存的实现因依赖于哈希表而饱受批评：当需要查找某个特定关系的页面所占用的所有缓冲区时，这种结构是没有用的，因为在运行 DROP 和 TRUNCATE 命令，或在清理期间截断一个表时 8，需要从缓存中移除页面。然而，到目前为止还没有人提出适当的替代方案。<br></code></pre></td></tr></table></figure>

<p>如果哈希表包含所需的缓冲区 ID，缓冲区管理器会锁定此缓冲区并将其 ID 返回给进程。然后这个进程便可以开始使用缓存页面，而不会产生任何 I&#x2F;O 流量。</p>
<p>为了锁定一个缓冲区，PostgreSQL 必须在其头部增加锁定计数；一个缓冲区可以同时被多个进程锁定。当其锁定计数大于零时，表明该缓冲区正在使用，不允许对其内容进行根本性的更改。例如，可以出现一条新的元组 (按照可见性规则，它将是不可见的)，但页面本身不能被替换。</p>
<p>当使用 analyze 和 buffers 选项运行时，EXPLAIN 命令会执行所展示的执行计划，并显示使用的缓冲区数量：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, buffers, costs off, timing off, summary off)<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> cacheme;<br>                 QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> cacheme (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   Buffers: shared hit<span class="hljs-operator">=</span><span class="hljs-number">1</span><br> Planning:<br>   Buffers: shared hit<span class="hljs-operator">=</span><span class="hljs-number">12</span> read<span class="hljs-operator">=</span><span class="hljs-number">7</span><br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>此处 hit &#x3D; 1 意味着在缓存中找到了唯一需要读取的页面。</p>
<p>锁定缓冲区操作使得使用计数增加了 1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> buffercache(<span class="hljs-string">&#x27;cacheme&#x27;</span>);<br> bufferid <span class="hljs-operator">|</span> relfork <span class="hljs-operator">|</span> relblk <span class="hljs-operator">|</span> isdirty <span class="hljs-operator">|</span> usagecount <span class="hljs-operator">|</span> pins<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>      <span class="hljs-number">268</span> <span class="hljs-operator">|</span> main    <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span> t       <span class="hljs-operator">|</span>          <span class="hljs-number">2</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>
<p>为了在查询执行期间观察锁定行为，让我们打开一个游标 — 它将保持缓冲区锁定，因为它需要提供对结果集中下一行的快速访问：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DECLARE</span> c <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> cacheme;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FETCH</span> c;<br> id<br>−−−−<br>  <span class="hljs-number">1</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> buffercache(<span class="hljs-string">&#x27;cacheme&#x27;</span>);<br> bufferid <span class="hljs-operator">|</span> relfork <span class="hljs-operator">|</span> relblk <span class="hljs-operator">|</span> isdirty <span class="hljs-operator">|</span> usagecount <span class="hljs-operator">|</span> pins<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>      <span class="hljs-number">268</span> <span class="hljs-operator">|</span> main    <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span> t       <span class="hljs-operator">|</span>          <span class="hljs-number">3</span> <span class="hljs-operator">|</span>    <span class="hljs-number">1</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>如果某个进程无法使用被锁定的缓冲区，该进程通常会跳过它，并简单地选择另外一个缓冲区。我们可以在表清理期间看到这一点：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> VACUUM VERBOSE cacheme;<br>INFO: vacuuming &quot;public.cacheme&quot;<br>INFO: <span class="hljs-keyword">table</span> &quot;cacheme&quot;: found <span class="hljs-number">0</span> removable, <span class="hljs-number">0</span> nonremovable <span class="hljs-type">row</span><br>versions <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> <span class="hljs-keyword">out</span> <span class="hljs-keyword">of</span> <span class="hljs-number">1</span> pages<br>DETAIL: <span class="hljs-number">0</span> dead <span class="hljs-type">row</span> versions cannot be removed yet, oldest xmin:<br><span class="hljs-number">877</span><br>Skipped <span class="hljs-number">1</span> page due <span class="hljs-keyword">to</span> buffer pins, <span class="hljs-number">0</span> frozen pages.<br>CPU: <span class="hljs-keyword">user</span>: <span class="hljs-number">0.00</span> s, <span class="hljs-keyword">system</span>: <span class="hljs-number">0.00</span> s, elapsed: <span class="hljs-number">0.00</span> s.<br>VACUUM<br></code></pre></td></tr></table></figure>
<p>因为无法从被锁定的缓冲区中物理移除元组，所以页面被跳过了。</p>
<p>但如果的确需要这个缓冲区，那么进程将加入到队列中，并等待对这个缓冲区的独占访问。此操作的一个示例是带有 freeze 的清理操作 9。</p>
<p>一旦游标关闭或移动到另一个页面，缓冲区就会被取消锁定。在此示例中，这发生在事务结束时：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> buffercache(<span class="hljs-string">&#x27;cacheme&#x27;</span>);<br> bufferid <span class="hljs-operator">|</span> relfork <span class="hljs-operator">|</span> relblk <span class="hljs-operator">|</span> isdirty <span class="hljs-operator">|</span> usagecount <span class="hljs-operator">|</span> pins<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>      <span class="hljs-number">268</span> <span class="hljs-operator">|</span> main    <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span> t       <span class="hljs-operator">|</span>          <span class="hljs-number">3</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0</span><br>      <span class="hljs-number">310</span> <span class="hljs-operator">|</span> vm      <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span> f       <span class="hljs-operator">|</span>          <span class="hljs-number">2</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>页面修改也受相同的锁定机制保护。例如，让我们再向表中插入另一行 (它会进入同一页面)：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> cacheme <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> buffercache(<span class="hljs-string">&#x27;cacheme&#x27;</span>);<br> bufferid <span class="hljs-operator">|</span> relfork <span class="hljs-operator">|</span> relblk <span class="hljs-operator">|</span> isdirty <span class="hljs-operator">|</span> usagecount <span class="hljs-operator">|</span> pins<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>      <span class="hljs-number">268</span> <span class="hljs-operator">|</span> main    <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span> t       <span class="hljs-operator">|</span>          <span class="hljs-number">4</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0</span><br>      <span class="hljs-number">310</span> <span class="hljs-operator">|</span> vm      <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span> f       <span class="hljs-operator">|</span>          <span class="hljs-number">2</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>
<p>PostgreSQL 不会立即执行任何磁盘写入操作：页面会在缓冲区缓存中保持脏的状态一段时间，这为读取和写入操作带来了一些性能提升。</p>
<h3 id="9-4-Cache-Misses"><a href="#9-4-Cache-Misses" class="headerlink" title="9.4 Cache Misses"></a><a name="cp4"></a>9.4 Cache Misses</h3><p>如果哈希表中没有与查询页面相关的条目，那意味着这个页面没有被缓存。在此情况下，将分配一个新的缓冲区 (并立即锁定)，随后页面被读入此缓冲区中，哈希表引用也相应地被修改。</p>
<p>让我们重启实例以清除缓冲区缓存：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">pg_ctl restart -l /home/postgres/logfile</span><br></code></pre></td></tr></table></figure>

<p>尝试读取页面会导致缓存未命中，页面将被加载到一个新的缓冲区中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, buffers, costs off, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> cacheme;<br>QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> cacheme (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">2</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   Buffers: shared read<span class="hljs-operator">=</span><span class="hljs-number">1</span> dirtied<span class="hljs-operator">=</span><span class="hljs-number">1</span><br> Planning:<br>   Buffers: shared hit<span class="hljs-operator">=</span><span class="hljs-number">15</span> read<span class="hljs-operator">=</span><span class="hljs-number">7</span><br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>
<p>现在计划显示的是 read 状态，而不是 hit，这表明缓存未命中。此外，由于查询修改了一些提示位，这个页面已经变成了脏页。</p>
<p>缓冲区缓存查询显示，新添加页面的使用计数被设置为 1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> buffercache(<span class="hljs-string">&#x27;cacheme&#x27;</span>);<br> bufferid <span class="hljs-operator">|</span> relfork <span class="hljs-operator">|</span> relblk <span class="hljs-operator">|</span> isdirty <span class="hljs-operator">|</span> usagecount <span class="hljs-operator">|</span> pins<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>       <span class="hljs-number">98</span> <span class="hljs-operator">|</span> main    <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span> t       <span class="hljs-operator">|</span>          <span class="hljs-number">1</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>pg_statio_all_tables 视图包含表的缓冲区缓存使用情况的完整统计数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> heap_blks_read, heap_blks_hit<br><span class="hljs-keyword">FROM</span> pg_statio_all_tables<br><span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;cacheme&#x27;</span>;<br> heap_blks_read <span class="hljs-operator">|</span> heap_blks_hit<br>−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<br>              <span class="hljs-number">2</span> <span class="hljs-operator">|</span>             <span class="hljs-number">5</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>PostgreSQL 为索引和序列提供了类似的视图。它们还可以显示有关 I&#x2F;O 操作的统计数据，但前提是需要打开 track_io_timing 参数。</p>
<h4 id="9-4-1-缓冲区查找与逐出"><a href="#9-4-1-缓冲区查找与逐出" class="headerlink" title="9.4.1 缓冲区查找与逐出"></a>9.4.1 缓冲区查找与逐出</h4><p>为页面选择缓冲区并非易事 10。有两种可能的情况：</p>
<ol>
<li><p>服务器启动后，所有缓冲区都是空的，并被绑定到一个列表中。当一些缓冲区仍然空闲时，从磁盘读取的下一个页面将占用第一个缓冲区，并将其从列表中移除。缓冲区只有在其页面消失时才能返回到列表中 11，而不是被另一个页面替换。如果调用 DROP 或 TRUNCATE 命令，或者表在清理期间被截断，则可能会发生这种情况。</p>
</li>
<li><p>最终，所有空闲的缓冲区都将被用完 (因为数据库的大小通常大于为缓存分配的内存块)。那个时候，缓冲区管理器将不得不选择一个已经在使用的缓冲区，并从这个缓冲区中逐出缓存页面。逐出操作使用的是时钟扫描算法，时钟隐喻很好地说明了这一点。时钟指针指向一个缓冲区，开始绕着缓冲区缓存转动，并且在经过时将每个缓存页面的使用计数减一。时钟指针找到的第一个计数为零，并且未被锁定的缓冲区将被清除。因此，每次访问缓冲区 (即锁定) 时，使用计数都会增加，而当缓冲区管理器搜索要逐出的页面时，使用计数会减少。最终，最近最少使用的页面首先被逐出，而那些经常访问的页面将在缓存中保留更长时间。可以猜到，如果所有缓冲区的使用计数均不等于零，在它们中的任何一个计数变为零之前，时钟指针必须完成一次以上的完整循环。为了避免多次循环，PostgreSQL 将使用计数限制为 5 次。一旦找到了要逐出的缓冲区，便需要从哈希表中删除仍在该缓冲区中的页面引用。但是如果这个缓冲区是脏的，也就是说，它包含了一些修改过的数据，那么旧页面将不能被简单地丢弃 — 缓冲区管理器必须先将其写入到磁盘。</p>
</li>
</ol>
<p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch9/ch9/img_2.png" srcset="/img/loading.gif" lazyload alt="img_2.png"></p>
<p>然后缓冲区管理器将一个新页面读入所找到的缓冲区中 — 无论它是否需要被逐出或仍然是空闲的。此操作使用的是 Buffered I&#x2F;O，所以只有当操作系统无法在其自己的缓存中找到该页面时，才会从磁盘读取该页面。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">那些使用 Direct I/O 并且不依赖操作系统缓存的数据库系统区分逻辑读 (来自 RAM，即来自缓冲区缓存) 和物理读 (来自磁盘)。从 PostgreSQL 的角度来看，页面既可以从缓冲区缓存中读取，也可以从操作系统请求，但是在后一种情况下，无法判断页面是在 RAM 中找到的，还是从磁盘读取的。<br></code></pre></td></tr></table></figure>

<p>哈希表被更新以引用新页面，并且缓冲区被锁定。其使用次数增加，此刻设置为 1，这允许在时钟扫描算法遍历缓冲区缓存期间，页面至少能保留一整轮。</p>
<h3 id="9-5-Bulk-Eviction"><a href="#9-5-Bulk-Eviction" class="headerlink" title="9.5 Bulk Eviction"></a><a name="cp5"></a>9.5 Bulk Eviction</h3><p>如果执行批量读取或写入操作，存在一次性的数据从缓冲区缓存中挤出有用页面的风险。</p>
<p>作为预防措施，批量操作使用的是相对较小的环形缓冲区，并且驱逐操作在其边界内执行，不会影响其他缓冲区。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">除了 “buffer ring” 这个术语之外，代码中还使用了术语 “ring buffer”。 然而，这个同义词相当模糊，因为环形缓冲区本身由若干个缓冲区 (也属于缓冲区缓存) 组成。在这方面，术语 “buffer ring” 更为准确。<br></code></pre></td></tr></table></figure>

<p>特定大小的环形缓冲区由依次使用的一组缓冲区组成。起初，环形缓冲区是空的，各个缓冲区在以常规方式被从缓冲区缓存中选择后，逐个加入到环形缓冲区中。然后驱逐策略开始发挥作用，但是仅限于环内 12。</p>
<p>添加到环中的缓冲区不会从缓冲区缓存中排除，仍然可以被其他操作使用。因此，如果要重用的缓冲区被锁定了，或者它的使用计数高于 1，它将简单地被从环中剥离，并被另一个缓冲区替换。</p>
<p>PostgreSQL 支持三种逐出策略。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">**批量读取策略**用于对大表的顺序扫描，当大表的大小超过了缓冲区缓存的 1/4 时便会使用。环形缓冲区占用 256 kB (32 个标准页面)。<br><br>此策略不允许将脏页写入磁盘以释放缓冲区；相反，缓冲区从环中排除，并被另一个取代。因此，读取不必等待写入完成，因此执行得更快。<br><br>如果发现表已在扫描中，那么开始另一次扫描的进程会加入现有的环形缓冲区，并访问当前可用的数据，而不会产生额外的 I/O 操作 13。当第一个进程完成扫描后，第二个进程返回到表跳过的部分。<br><br></code></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">**批量写入策略** 由 COPY FROM、CREATE TABLE AS SELECT 和 CREATE MATERIALIZED VIEW 命令，以及那些导致表重写的 ALTER TABLE 变体应用。所分配的环形缓冲区很大，默认大小是 16 MB (2048 个标准页面)，但它永远不会超过缓冲区缓存总大小的 1/8。<br></code></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">**清理策略** 由清理进程在执行全表扫描而不考虑可见性映射时使用。环形缓冲区分配了 256 kB 的内存 (32 个标准页面)。<br></code></pre></td></tr></table></figure>

<p>环形缓冲区并不总是能防止不希望的驱逐。如果 UPDATE 或 DELETE 命令影响了大量行，执行的表扫描会应用批量读取策略，但由于页面不断被修改，环形缓冲区环实际上变得毫无用处。</p>
<p>另外一个值得一提的例子是在 TOAST 表中存储超大数据。尽管可能需要读取大量数据，但 TOAST 值始终通过索引访问，因此它们会绕过环形缓冲区。</p>
<p>让我们仔细看看批量读取策略。为方便起见，我们将创建一个表，使插入的行占据整个页面。 默认情况下，缓冲区缓存大小为 16384 个页面，每个 8 kB。 因此，表必须占用超过 4096 个页面，才能在扫描时使用环形缓冲区。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE TABLE</span> big(<br>  id <span class="hljs-type">integer</span> <span class="hljs-keyword">PRIMARY KEY</span> GENERATED ALWAYS <span class="hljs-keyword">AS</span> <span class="hljs-keyword">IDENTITY</span>,<br>  s <span class="hljs-type">char</span>(<span class="hljs-number">1000</span>)<br>) <span class="hljs-keyword">WITH</span> (fillfactor <span class="hljs-operator">=</span> <span class="hljs-number">10</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> big(s)<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;FOO&#x27;</span> <span class="hljs-keyword">FROM</span> generate_series(<span class="hljs-number">1</span>,<span class="hljs-number">4096</span><span class="hljs-operator">+</span><span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>让我们分析一下表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> ANALYZE big;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> relname, relfilenode, relpages<br><span class="hljs-keyword">FROM</span> pg_class<br><span class="hljs-keyword">WHERE</span> relname <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;big&#x27;</span>, <span class="hljs-string">&#x27;big_pkey&#x27;</span>);<br> relname  <span class="hljs-operator">|</span> relfilenode <span class="hljs-operator">|</span> relpages<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<br> big      <span class="hljs-operator">|</span>       <span class="hljs-number">16546</span> <span class="hljs-operator">|</span>     <span class="hljs-number">4097</span><br> big_pkey <span class="hljs-operator">|</span>       <span class="hljs-number">16551</span> <span class="hljs-operator">|</span>       <span class="hljs-number">14</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>重启服务器以清除缓存，因为现在它包含了在分析过程中读取的一些堆页面。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">pg_ctl restart -l /home/postgres/logfile</span><br></code></pre></td></tr></table></figure>

<p>重启服务器之后，让我们读取整个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, costs off, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> big;<br>                 QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> big (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">4097</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>堆页面只占用 32 个缓冲区，这些缓冲区构成了此操作的环形缓冲区：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">FROM</span> pg_buffercache<br><span class="hljs-keyword">WHERE</span> relfilenode <span class="hljs-operator">=</span> pg_relation_filenode(<span class="hljs-string">&#x27;big&#x27;</span>::regclass);<br> count<br>−−−−−−−<br>    <span class="hljs-number">32</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>但在索引扫描的情况下，并不使用环形缓冲区：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, costs off, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> big <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id;<br>                         QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> big_pkey <span class="hljs-keyword">on</span> big (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">4097</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>缓冲区缓存最终包含了整个表和整个索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> relfilenode, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">FROM</span> pg_buffercache<br><span class="hljs-keyword">WHERE</span> relfilenode <span class="hljs-keyword">IN</span> (<br>  pg_relation_filenode(<span class="hljs-string">&#x27;big&#x27;</span>),<br>  pg_relation_filenode(<span class="hljs-string">&#x27;big_pkey&#x27;</span>)<br>)<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> relfilenode;<br> relfilenode <span class="hljs-operator">|</span> count<br>−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br>       <span class="hljs-number">16546</span> <span class="hljs-operator">|</span>  <span class="hljs-number">4097</span><br>       <span class="hljs-number">16551</span> <span class="hljs-operator">|</span>    <span class="hljs-number">14</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<h3 id="9-6-Choosing-the-Buffer-Cache-Size"><a href="#9-6-Choosing-the-Buffer-Cache-Size" class="headerlink" title="9.6 Choosing the Buffer Cache Size"></a><a name="cp6"></a>9.6 Choosing the Buffer Cache Size</h3><p>缓冲区缓存的大小由 shared_buffers 参数定义。众所周知，其默认值很低，因此在安装 PostgreSQL 后增加这个值是有必要的。在此情况下，你需要重新加载服务器，因为在服务器启动时便为缓存分配了共享内存。</p>
<p>但我们如何确定一个合适的值呢？</p>
<p>即使是一个非常大的数据库，也有一组同时使用的有限热数据。在理想情况下，这个数据集必须适合缓冲区缓存 (为一次性的数据预留一些空间)。如果缓存大小太小，那么频繁使用的页面将一直相互驱逐，从而导致过多的 I&#x2F;O 操作。但是无脑增加缓存大小也不是一个好主意：RAM 是稀缺资源，此外，更大的缓存会带来更高的维护成本。</p>
<p>最佳的缓冲区缓存大小因系统而异：它取决于可用内存的总大小、数据概况和工作负载类型等因素。不幸的是，没有一个万能的值或公式能同等适合所有场景。</p>
<p>你还应该记住， PostgreSQL 中的缓存未命中不一定会触发物理 I&#x2F;O。如果缓冲区缓存非常小，操作系统缓存会使用剩余的空闲内存，并且可以在一定程度上有所缓解。但与数据库不同的是，操作系统对读取的数据一无所知，因此它采用了一种不同的驱逐策略。</p>
<p>一个典型的建议是从 1&#x2F;4 RAM 开始，然后根据需要调整这个设置。</p>
<p>最好的方式是不断试验：你可以增加或减少缓存大小，并比较系统性能。当然，这需要一个完全类似于生产系统的测试系统，并且能够重现典型的工作负载。</p>
<p>你还可以使用 pg_buffercache 扩展进行一些分析。例如，基于使用情况分析缓冲区的分布状况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> usagecount, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">FROM</span> pg_buffercache<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> usagecount<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> usagecount;<br> usagecount <span class="hljs-operator">|</span> count<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br>          <span class="hljs-number">1</span> <span class="hljs-operator">|</span>  <span class="hljs-number">4128</span><br>          <span class="hljs-number">2</span> <span class="hljs-operator">|</span>    <span class="hljs-number">50</span><br>          <span class="hljs-number">3</span> <span class="hljs-operator">|</span>     <span class="hljs-number">4</span><br>          <span class="hljs-number">4</span> <span class="hljs-operator">|</span>     <span class="hljs-number">4</span><br>          <span class="hljs-number">5</span> <span class="hljs-operator">|</span>    <span class="hljs-number">73</span><br>            <span class="hljs-operator">|</span> <span class="hljs-number">12125</span><br>(<span class="hljs-number">6</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>空的使用计数对应于空闲的缓冲区。在这种情况下，是完全可以预料的，因为服务器已重新启动，并且大部分时间都保持空闲状态。大多数使用的缓冲区包含后端进程读取的系统表页面，用于填充其系统表缓存并执行查询。</p>
<p>我们可以检查每个表的哪一部分被缓存，以及这些数据是否是热的 (如果一个页面的使用计数大于 1，那么此处便认为它是热的)：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> c.relname,<br>  <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) blocks,<br>  round( <span class="hljs-number">100.0</span> <span class="hljs-operator">*</span> <span class="hljs-number">8192</span> <span class="hljs-operator">*</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">/</span><br>    pg_table_size(c.oid) ) <span class="hljs-keyword">AS</span> &quot;% of rel&quot;,<br>  round( <span class="hljs-number">100.0</span> <span class="hljs-operator">*</span> <span class="hljs-number">8192</span> <span class="hljs-operator">*</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FILTER</span> (<span class="hljs-keyword">WHERE</span> b.usagecount <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>) <span class="hljs-operator">/</span><br>    pg_table_size(c.oid) ) <span class="hljs-keyword">AS</span> &quot;% hot&quot;<br>  <span class="hljs-keyword">FROM</span> pg_buffercache b<br>    <span class="hljs-keyword">JOIN</span> pg_class c <span class="hljs-keyword">ON</span> pg_relation_filenode(c.oid) <span class="hljs-operator">=</span> b.relfilenode<br>  <span class="hljs-keyword">WHERE</span> b.reldatabase <span class="hljs-keyword">IN</span> (<br>    <span class="hljs-number">0</span>, <span class="hljs-comment">-- cluster-wide objects</span><br>    (<span class="hljs-keyword">SELECT</span> oid <span class="hljs-keyword">FROM</span> pg_database <span class="hljs-keyword">WHERE</span> datname <span class="hljs-operator">=</span> current_database())<br>)<br><span class="hljs-keyword">AND</span> b.usagecount <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT NULL</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> c.relname, c.oid<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-number">2</span> <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">10</span>;<br>             relname             <span class="hljs-operator">|</span> blocks <span class="hljs-operator">|</span> <span class="hljs-operator">%</span> <span class="hljs-keyword">of</span> rel <span class="hljs-operator">|</span> <span class="hljs-operator">%</span> hot<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br> big                             <span class="hljs-operator">|</span> 	 <span class="hljs-number">4097</span> <span class="hljs-operator">|</span>      <span class="hljs-number">100</span> <span class="hljs-operator">|</span>     <span class="hljs-number">1</span><br> pg_attribute                    <span class="hljs-operator">|</span>     <span class="hljs-number">30</span> <span class="hljs-operator">|</span>       <span class="hljs-number">48</span> <span class="hljs-operator">|</span>    <span class="hljs-number">47</span><br> big_pkey                        <span class="hljs-operator">|</span>     <span class="hljs-number">14</span> <span class="hljs-operator">|</span>      <span class="hljs-number">100</span> <span class="hljs-operator">|</span>     <span class="hljs-number">0</span><br> pg_proc                         <span class="hljs-operator">|</span>     <span class="hljs-number">13</span> <span class="hljs-operator">|</span>       <span class="hljs-number">12</span> <span class="hljs-operator">|</span>     <span class="hljs-number">6</span><br> pg_operator                     <span class="hljs-operator">|</span>     <span class="hljs-number">11</span> <span class="hljs-operator">|</span>       <span class="hljs-number">61</span> <span class="hljs-operator">|</span>    <span class="hljs-number">50</span><br> pg_class                        <span class="hljs-operator">|</span>     <span class="hljs-number">10</span> <span class="hljs-operator">|</span>       <span class="hljs-number">59</span> <span class="hljs-operator">|</span>    <span class="hljs-number">59</span><br> pg_proc_oid_index               <span class="hljs-operator">|</span>      <span class="hljs-number">9</span> <span class="hljs-operator">|</span>       <span class="hljs-number">82</span> <span class="hljs-operator">|</span>    <span class="hljs-number">45</span><br> pg_attribute_relid_attnum_index <span class="hljs-operator">|</span>      <span class="hljs-number">8</span> <span class="hljs-operator">|</span>       <span class="hljs-number">73</span> <span class="hljs-operator">|</span>    <span class="hljs-number">64</span><br> pg_proc_proname_args_nsp_index  <span class="hljs-operator">|</span>      <span class="hljs-number">6</span> <span class="hljs-operator">|</span>       <span class="hljs-number">18</span> <span class="hljs-operator">|</span>     <span class="hljs-number">6</span><br> pg_amproc                       <span class="hljs-operator">|</span>      <span class="hljs-number">5</span> <span class="hljs-operator">|</span>       <span class="hljs-number">56</span> <span class="hljs-operator">|</span>    <span class="hljs-number">56</span><br>(<span class="hljs-number">10</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>这个例子表明大表及其索引已被完全缓存，但它们的页面并未被频繁使用。</p>
<p>从不同角度分析数据，你可以获得一些有用的见解。但是，在运行 pg_buffercache 查询时，请确保遵循以下简单规则：</p>
<pre><code class="hljs">多次重复这样的查询，因为返回的数据在一定程度上会有所不同。
不要连续不断地运行这样的查询，因为 pg_buffercache 扩展会锁定查看的缓冲区，即使只是短暂的。
</code></pre>
<h3 id="9-7-Cache-Warming"><a href="#9-7-Cache-Warming" class="headerlink" title="9.7 Cache Warming"></a><a name="cp7"></a>9.7 Cache Warming</h3><p>服务器重启后，缓存需要一段时间来预热，也就是积累频繁使用的数据。立即缓存某些表可能会有所帮助， pg_prewarm 扩展正是用于此目的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> EXTENSION pg_prewarm;<br></code></pre></td></tr></table></figure>

<p>除了将表加载到缓冲区缓存 (或仅加载到操作系统缓存) 之外，此扩展还可以将当前缓存状态写入磁盘，然后在服务器重新启动后恢复。要启用此功能，你需要将此扩展的库添加到 shared_preload_libraries 并重启服务器：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">SET</span> shared_preload_libraries <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;pg_prewarm&#x27;</span>;<br><br>postgres$ pg_ctl restart <span class="hljs-operator">-</span>l <span class="hljs-operator">/</span>home<span class="hljs-operator">/</span>postgres<span class="hljs-operator">/</span>logfile<br></code></pre></td></tr></table></figure>

<p>如果 pg_prewarm.autoprewarm 设置没有改变，服务器重新加载后会自动启动一个名为 autoprewarm leader 的进程；一旦达到 pg_prewarm.autoprewarm_interval 秒，这个进程便会将缓存页面的列表刷新到磁盘 (会使用一个 max_parallel_processes 槽)。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">ps -o pid,<span class="hljs-built_in">command</span> \</span><br><span class="language-bash">--ppid `<span class="hljs-built_in">head</span> -n 1 /usr/local/pgsql/data/postmaster.pid` | \</span><br><span class="language-bash">grep prewarm</span><br>  23124 postgres: autoprewarm leader<br></code></pre></td></tr></table></figure>

<p>现在服务器已经重启，大表没有被缓存：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">FROM</span> pg_buffercache<br><span class="hljs-keyword">WHERE</span> relfilenode <span class="hljs-operator">=</span> pg_relation_filenode(<span class="hljs-string">&#x27;big&#x27;</span>::regclass);<br> count<br>−−−−−−−<br>     <span class="hljs-number">0</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>如果你有充分的理由认为整个表将被频繁使用，并且磁盘访问使响应时间变得无法接受，那么你可以提前将这个表加载到缓冲区缓存中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_prewarm(<span class="hljs-string">&#x27;big&#x27;</span>);<br> pg_prewarm<br>−−−−−−−−−−−−<br>       <span class="hljs-number">4097</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">FROM</span> pg_buffercache<br><span class="hljs-keyword">WHERE</span> relfilenode <span class="hljs-operator">=</span> pg_relation_filenode(<span class="hljs-string">&#x27;big&#x27;</span>::regclass);<br> count<br>−−−−−−−<br>  <span class="hljs-number">4097</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>页面列表将转储到 PGDATA&#x2F;autoprewarm.blocks 文件中。你可以等到 autoprewarm leader 首次完成，但此处我们手动执行转储：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> autoprewarm_dump_now();<br> autoprewarm_dump_now<br>−−−−−−−−−−−−−−−−−−−−−−<br>                 <span class="hljs-number">4224</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>刷盘的页面数量大于 4097，因为考虑了所有正在使用的缓冲区。此文件以文本格式编写，它包含数据库、表空间和文件 ID，以及分支和段号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash"><span class="hljs-built_in">head</span> -n 10 /usr/local/pgsql/data/autoprewarm.blocks</span><br>&lt;&lt;4224&gt;&gt;<br>0,1664,1262,0,0<br>0,1664,1260,0,0<br>16391,1663,1259,0,0<br>16391,1663,1259,0,1<br>16391,1663,1259,0,2<br>16391,1663,1259,0,3<br>16391,1663,1249,0,0<br>16391,1663,1249,0,1<br>16391,1663,1249,0,2<br></code></pre></td></tr></table></figure>

<p>让我们再次重启服务器。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">pg_ctl restart -l /home/postgres/logfile</span><br></code></pre></td></tr></table></figure>

<p>此时，表立刻出现在了缓存中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">FROM</span> pg_buffercache<br><span class="hljs-keyword">WHERE</span> relfilenode <span class="hljs-operator">=</span> pg_relation_filenode(<span class="hljs-string">&#x27;big&#x27;</span>::regclass);<br> count<br>−−−−−−−<br>  <span class="hljs-number">4097</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>autoprewarm leader 也会完成所有初始工作：它读取文件，根据数据库对页面进行排序，重新排列它们 (以便磁盘读取尽可能顺序执行)，然后将它们传递给 autoprewarm worker 进行处理。</p>
<h3 id="9-8-Local-Cache"><a href="#9-8-Local-Cache" class="headerlink" title="9.8 Local Cache"></a><a name="cp8"></a>9.8 Local Cache</h3><p>临时表不遵循上述工作流程。由于临时数据仅对单个进程可见，因此没有必要将其加载到共享缓冲区缓存中。因此，临时数据使用的是拥有该表的进程的本地缓存 14。</p>
<p>一般来说，本地缓冲区缓存的工作方式类似于共享缓存：</p>
<pre><code class="hljs">通过哈希表进行页面搜索。
驱逐遵循标准算法 (除了不使用环形缓冲区)。
页面可以被锁定以避免被驱逐。
</code></pre>
<p>但是，本地缓存实现要简单得多，因为它既不需要处理内存结构上的锁 (缓冲区只能由单个进程访问)，也不需要容错机制 (临时数据最多存在至会话结束)。</p>
<p>由于通常只有少数会话使用临时表，因此本地缓存内存是按需分配的。会话可用的本地缓存的最大大小受到 temp_buffers 参数的限制。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">尽管名称相似，但 temp_file_limit 参数与临时表无关；它与可能在查询执行期间创建的文件有关，用于临时存储中间数据。<br></code></pre></td></tr></table></figure>

<p>在 EXPLAIN 命令的输出中，所有对本地缓冲区缓存的调用都标记为 local 而不是 shared：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> TEMPORARY <span class="hljs-keyword">TABLE</span> tmp <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, buffers, costs off, timing off, summary off)<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tmp;<br>               QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> tmp (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   Buffers: <span class="hljs-keyword">local</span> hit<span class="hljs-operator">=</span><span class="hljs-number">1</span><br> Planning:<br>   Buffers: shared hit<span class="hljs-operator">=</span><span class="hljs-number">12</span> read<span class="hljs-operator">=</span><span class="hljs-number">7</span><br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>



































                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/BOOK/" class="category-chain-item">BOOK</a>
  
  
    <span>></span>
    
  <a href="/categories/BOOK/PostgreSQL14-Internals/" class="category-chain-item">PostgreSQL14_Internals</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/book/" class="print-no-link">#book</a>
      
        <a href="/tags/database/" class="print-no-link">#database</a>
      
        <a href="/tags/transactions/" class="print-no-link">#transactions</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>ch9. Buffer Cache</div>
      <div>http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch9/ch9/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Smile</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/05/05/DB/PostgreSQL14_Internals/Conclusion/Conclusion/" title="Conclusion">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Conclusion</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/05/DB/PostgreSQL14_Internals/ch8/ch8/" title="ch8. Rebuilding Tables and Indexes">
                        <span class="hidden-mobile">ch8. Rebuilding Tables and Indexes</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
