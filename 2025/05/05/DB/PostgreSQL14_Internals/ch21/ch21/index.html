

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Smile">
  <meta name="keywords" content="">
  
    <meta name="description" content="ch21. Nested Loop本章主要内容如下：    Chapter Contents    21.1 Join Types and Methods   21.2 Nested Loop Joins   21.1 Join Types and Methods连接是 SQL 语言的关键特性；它们是其强大和灵活的基础。行集 (直接从表中检索或作为其他操作的结果接收) 始终成对连接。 连接有几种类">
<meta property="og:type" content="article">
<meta property="og:title" content="ch21. Nested Loop">
<meta property="og:url" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch21/ch21/index.html">
<meta property="og:site_name" content="Smile">
<meta property="og:description" content="ch21. Nested Loop本章主要内容如下：    Chapter Contents    21.1 Join Types and Methods   21.2 Nested Loop Joins   21.1 Join Types and Methods连接是 SQL 语言的关键特性；它们是其强大和灵活的基础。行集 (直接从表中检索或作为其他操作的结果接收) 始终成对连接。 连接有几种类">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch21/ch21/img.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch21/ch21/img_1.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch21/ch21/img_2.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch21/ch21/img_3.png">
<meta property="article:published_time" content="2025-05-05T12:24:14.608Z">
<meta property="article:modified_time" content="2025-05-25T07:27:26.187Z">
<meta property="article:author" content="Smile">
<meta property="article:tag" content="book">
<meta property="article:tag" content="database">
<meta property="article:tag" content="transactions">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch21/ch21/img.png">
  
  
  
  <title>ch21. Nested Loop - Smile</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"smilemzy.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Smile</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="ch21. Nested Loop"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-05 20:24" pubdate>
          2025年5月5日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          48 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">ch21. Nested Loop</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="ch21-Nested-Loop"><a href="#ch21-Nested-Loop" class="headerlink" title="ch21. Nested Loop"></a>ch21. Nested Loop</h2><p>本章主要内容如下：</p>
<table>
<thead>
<tr>
<th>Chapter Contents</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#cp1">21.1 Join Types and Methods</a></td>
</tr>
<tr>
<td><a href="#cp2">21.2 Nested Loop Joins</a></td>
</tr>
</tbody></table>
<h3 id="21-1-Join-Types-and-Methods"><a href="#21-1-Join-Types-and-Methods" class="headerlink" title="21.1 Join Types and Methods"></a><a name="cp1"></a>21.1 Join Types and Methods</h3><p>连接是 SQL 语言的关键特性；它们是其强大和灵活的基础。行集 (直接从表中检索或作为其他操作的结果接收) 始终成对连接。</p>
<p>连接有几种类型：</p>
<p>内连接。内连接 (指定为 INNER JOIN，或简称为 JOIN) 包括两个集合中满足特定连接条件的行。连接条件将一个行集的某些列与另一个行集的某些列结合；所有涉及的列构成连接键。如果连接条件要求两个集合的连接键相等，这样的连接称为等值连接；这是最常见的连接类型。两个集合的笛卡尔积 (CROSS JOIN) 包含这些集合所有可能的行对 — 这是具有 true 条件的内连接的一种特殊情况。</p>
<p>外连接。左外连接 (指定为 LEFT OUTER JOIN，或简称为 LEFT JOIN) 通过左集合中那些在右集合中没有相匹配的行来扩展内连接的结果 (右集合中相应的列被填充为空值)。右外连接 (RIGHT JOIN) 也是如此，只是交换了集合的位置。全外连接 (指定为 FULL JOIN) 包括左外连接和右外连接，它将两边未找到匹配项的行都添加进来。</p>
<p>反连接和半连接。半连接与内连接非常相似，但它只包括左侧集合中在右侧集合中有匹配项的那些行 (即使有多个匹配项，一行也仅包含一次)。反连接包括一个集合中在另一个集合中没有匹配项的行。SQL 语言没有明确的半连接和反连接，但可以使用像 EXISTS 和 NOT EXISTS 这样的谓词达到相同的结果。</p>
<p>所有这些连接都是逻辑操作。例如，内连接通常被描述为一个已清理不满足连接条件的行的笛卡尔积。但在物理层面，内连接通常是通过成本更低的方式实现的。</p>
<p>PostgreSQL 提供了多种连接方式：</p>
<pre><code class="hljs">嵌套循环连接
哈希连接
归并连接
</code></pre>
<p>连接方法是实现 SQL 连接逻辑操作的算法。这些基本算法经常有针对特定连接类型的特殊变体，尽管它们可能只支持其中一些。例如，嵌套循环支持内连接 (在计划中由 Nested Loop 节点表示) 和左外连接(由 Nested Loop Left Join 节点表示) ，但它不能用于全外连接。</p>
<p>同一算法的一些变体也可以被其他操作使用，如聚合。</p>
<p>不同的连接方法在不同条件下效果最佳；规划器的工作就是选择成本效益最高的连接方法。</p>
<h3 id="21-2-Nested-Loop-Joins"><a href="#21-2-Nested-Loop-Joins" class="headerlink" title="21.2 Nested Loop Joins"></a><a name="cp2"></a>21.2 Nested Loop Joins</h3><p>嵌套循环连接的基本算法如下。外循环遍历第一个集合中 (称为外集合) 所有的行。对于每一行，嵌套循环遍历第二个集合中 (称为内集合) 的行，以找到满足连接条件的行。每个找到的连接对作为查询结果的一部分立即返回。1</p>
<p>此算法访问内集合的次数与外集合中的行数一样多。因此，嵌套循环连接的效率取决于几个因素：</p>
<pre><code class="hljs">外集合中行的基数
可用的访问方法，可以有效获取内集合中所需的行
循环访问内集合中的同一行
</code></pre>
<h4 id="21-2-1-笛卡尔积"><a href="#21-2-1-笛卡尔积" class="headerlink" title="21.2.1 笛卡尔积"></a>21.2.1 笛卡尔积</h4><p>无论集合中的行数如何，嵌套循环连接都是查找笛卡尔积最有效的方式：</p>
<p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch21/ch21/img.png" srcset="/img/loading.gif" lazyload alt="img.png"></p>
<p>嵌套循环节点使用上述算法进行连接。它总是有两个子节点：计划中显示较高的节点对应于外集合，而较低的节点代表内集合。</p>
<p>在此例中，内集合由 Materialize 节点 2 表示。此节点返回从其子节点接收到的行，并保存它们以备将来使用 (这些行在内存中累积，直到它们的总大小达到 work_mem；然后 PostgreSQL 会将它们溢出到磁盘上的临时文件中)。如果再次访问，节点读取所累积的行而无需调用子节点。这样执行器就可以避免再次扫描全表，只读取满足条件的行即可。</p>
<p>对于使用常规等值连接的查询，也可以构建类似的计划：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> tickets t<br>  <span class="hljs-keyword">JOIN</span> ticket_flights tf <span class="hljs-keyword">ON</span> tf.ticket_no <span class="hljs-operator">=</span> t.ticket_no<br><span class="hljs-keyword">WHERE</span> t.ticket_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0005432000284&#x27;</span>;<br>                           QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Nested Loop (cost<span class="hljs-operator">=</span><span class="hljs-number">0.99</span>.<span class="hljs-number">.25</span><span class="hljs-number">.05</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">3</span> width<span class="hljs-operator">=</span><span class="hljs-number">136</span>)<br>   −<span class="hljs-operator">&gt;</span> Index Scan <span class="hljs-keyword">using</span> tickets_pkey <span class="hljs-keyword">on</span> tickets t<br>       (cost<span class="hljs-operator">=</span><span class="hljs-number">0.43</span>.<span class="hljs-number">.8</span><span class="hljs-number">.45</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">104</span>)<br>       Index Cond: (ticket_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0005432000284&#x27;</span>::bpchar)<br>   −<span class="hljs-operator">&gt;</span> Index Scan <span class="hljs-keyword">using</span> ticket_flights_pkey <span class="hljs-keyword">on</span> ticket_flights tf<br>       (cost<span class="hljs-operator">=</span><span class="hljs-number">0.56</span>.<span class="hljs-number">.16</span><span class="hljs-number">.58</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">3</span> width<span class="hljs-operator">=</span><span class="hljs-number">32</span>)<br>       Index Cond: (ticket_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0005432000284&#x27;</span>::bpchar)<br>(<span class="hljs-number">7</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>在识别两个值相等之后，规划器将连接条件 tf.ticket_no &#x3D; t.ticket_no 替换为 tf.ticket_no &#x3D; constant 的条件，这实际上将等值连接简化为了笛卡尔积。3</p>
<p><strong>基数估算。</strong> 笛卡尔积的基数预估为所连接数据集的基数乘积：3 &#x3D; 1 × 3。</p>
<p><strong>代价估算。</strong> 连接操作的启动成本包括了所有子节点的启动成本。</p>
<p>连接的全部成本包括以下部分：</p>
<pre><code class="hljs">获取外集合中所有行的成本
单次检索内集合中所有行的成本 (因为外集合的基数预估等于 1)
处理要返回的每一行的成本
</code></pre>
<p>此处是成本估算的依赖图：</p>
<p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch21/ch21/img_1.png" srcset="/img/loading.gif" lazyload alt="img_1.png"></p>
<p>连接的成本计算如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">0.43</span> <span class="hljs-operator">+</span> <span class="hljs-number">0.56</span> <span class="hljs-keyword">AS</span> startup_cost,<br>  round((<br>    <span class="hljs-number">8.45</span> <span class="hljs-operator">+</span> <span class="hljs-number">16.57</span> <span class="hljs-operator">+</span><br>    <span class="hljs-number">3</span> <span class="hljs-operator">*</span> current_setting(<span class="hljs-string">&#x27;cpu_tuple_cost&#x27;</span>)::<span class="hljs-type">real</span><br>  )::<span class="hljs-type">numeric</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> total_cost;<br> startup_cost <span class="hljs-operator">|</span> total_cost<br>−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br>         <span class="hljs-number">0.99</span> <span class="hljs-operator">|</span>      <span class="hljs-number">25.05</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>现在让我们回到之前的例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> aircrafts_data a1<br>  <span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> aircrafts_data a2<br><span class="hljs-keyword">WHERE</span> a2.range <span class="hljs-operator">&gt;</span> <span class="hljs-number">5000</span>;<br>                    QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Nested Loop (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.2</span><span class="hljs-number">.78</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">45</span> width<span class="hljs-operator">=</span><span class="hljs-number">144</span>)<br>   −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> aircrafts_data a1<br>       (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.1</span><span class="hljs-number">.09</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">9</span> width<span class="hljs-operator">=</span><span class="hljs-number">72</span>)<br>   −<span class="hljs-operator">&gt;</span> Materialize (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.1</span><span class="hljs-number">.14</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">5</span> width<span class="hljs-operator">=</span><span class="hljs-number">72</span>)<br>       −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> aircrafts_data a2<br>          (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.1</span><span class="hljs-number">.11</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">5</span> width<span class="hljs-operator">=</span><span class="hljs-number">72</span>)<br>          <span class="hljs-keyword">Filter</span>: (<span class="hljs-keyword">range</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">5000</span>)<br>(<span class="hljs-number">7</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>现在计划中包含了 Materialize 节点；在累积了从子节点接收到的行之后，Materialize 就能在所有后续调用中更快地返回它们。</p>
<p>总的来说，连接的总成本包括以下：4</p>
<pre><code class="hljs">获取外集合中所有行的成本

内集合中所有行的初始获取成本 (在此期间执行物化)

内集合中行重复获取成本的 (N-1) 倍 (此处 N 是外集合的行数)

处理要返回的每一行的成本
</code></pre>
<p>此处的依赖图如下：</p>
<p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch21/ch21/img_2.png" srcset="/img/loading.gif" lazyload alt="img_2.png"></p>
<p>在这个例子中，物化降低了重复获取数据的成本。计划中显示了第一次 Materialize 调用的成本，但没有列出所有后续的调用情况。我不会在此处提供任何计算说明，5 但在此特例下，估算值是 0.0125。</p>
<p>因此，这个例子中执行的连接成本计算如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">0.00</span> <span class="hljs-operator">+</span> <span class="hljs-number">0.00</span> <span class="hljs-keyword">AS</span> startup_cost,<br>  round((<br>    <span class="hljs-number">1.09</span> <span class="hljs-operator">+</span> (<span class="hljs-number">1.14</span> <span class="hljs-operator">+</span> <span class="hljs-number">8</span> <span class="hljs-operator">*</span> <span class="hljs-number">0.0125</span>) <span class="hljs-operator">+</span><br>    <span class="hljs-number">45</span> <span class="hljs-operator">*</span> current_setting(<span class="hljs-string">&#x27;cpu_tuple_cost&#x27;</span>)::<span class="hljs-type">real</span><br>  )::<span class="hljs-type">numeric</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> total_cost;<br> startup_cost <span class="hljs-operator">|</span> total_cost<br>−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br>         <span class="hljs-number">0.00</span> <span class="hljs-operator">|</span>       <span class="hljs-number">2.78</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<h4 id="21-2-2-参数化连接"><a href="#21-2-2-参数化连接" class="headerlink" title="21.2.2 参数化连接"></a>21.2.2 参数化连接</h4><p>现在让我们考虑一个更常见的例子，它不能归结为笛卡尔积：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> tickets(book_ref);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> tickets t<br>  <span class="hljs-keyword">JOIN</span> ticket_flights tf <span class="hljs-keyword">ON</span> tf.ticket_no <span class="hljs-operator">=</span> t.ticket_no<br><span class="hljs-keyword">WHERE</span> t.book_ref <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;03A76D&#x27;</span>;<br>                           QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Nested Loop (cost<span class="hljs-operator">=</span><span class="hljs-number">0.99</span>.<span class="hljs-number">.45</span><span class="hljs-number">.68</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">6</span> width<span class="hljs-operator">=</span><span class="hljs-number">136</span>)<br>   −<span class="hljs-operator">&gt;</span> Index Scan <span class="hljs-keyword">using</span> tickets_book_ref_idx <span class="hljs-keyword">on</span> tickets t<br>       (cost<span class="hljs-operator">=</span><span class="hljs-number">0.43</span>.<span class="hljs-number">.12</span><span class="hljs-number">.46</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">2</span> width<span class="hljs-operator">=</span><span class="hljs-number">104</span>)<br>       Index Cond: (book_ref <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;03A76D&#x27;</span>::bpchar)<br>   −<span class="hljs-operator">&gt;</span> Index Scan <span class="hljs-keyword">using</span> ticket_flights_pkey <span class="hljs-keyword">on</span> ticket_flights tf<br>       (cost<span class="hljs-operator">=</span><span class="hljs-number">0.56</span>.<span class="hljs-number">.16</span><span class="hljs-number">.58</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">3</span> width<span class="hljs-operator">=</span><span class="hljs-number">32</span>)<br>       Index Cond: (ticket_no <span class="hljs-operator">=</span> t.ticket_no)<br>(<span class="hljs-number">7</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>此处，Nested Loop 节点遍历外集合中 (tickets) 的行，对于其中的每一行，都会搜索内集合中 (flights) 相应的行，同时将票号作为参数 (t.ticket_no) 传递给条件。当调用内部节点 (Index Scan) 时，必须要处理条件 ticket_no &#x3D; constant。</p>
<p><strong>基数估算。</strong> 规划器预估外集合中有两行 (rows&#x3D;2) 满足按预订号过滤的条件，并且每行平均匹配内集合中的三行 (rows&#x3D;3)。</p>
<p>连接选择率是连接后剩余的两个集合的笛卡尔积的一部分。显然，我们必须排除两个集合中连接键中包含空值的行，因为它们永远不会满足等值条件。</p>
<p>预估基数等于笛卡尔积的基数 (即两个集合基数的乘积) 乘以选择率。6</p>
<p>此处第一个 (外) 集合的预估基数是两行。由于除了连接条件自身外，没有条件应用于第二个 (内) 集合，因此第二个集合的基数为 ticket_flights 表的基数。</p>
<p>由于连接的表通过外键连接，因此选择率的估算依赖于子表中的每一行恰好在父表中有一个匹配行的事实。因此，选择率被视为外键引用的表大小的倒数。7</p>
<p>这样的话，对于 ticket_no 列不包含空值的情况，估算如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">2</span> <span class="hljs-operator">*</span> tf.reltuples <span class="hljs-operator">*</span> (<span class="hljs-number">1.0</span> <span class="hljs-operator">/</span> t.reltuples)) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">rows</span><br><span class="hljs-keyword">FROM</span> pg_class t, pg_class tf<br><span class="hljs-keyword">WHERE</span> t.relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;tickets&#x27;</span><br>  <span class="hljs-keyword">AND</span> tf.relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ticket_flights&#x27;</span>;<br> <span class="hljs-keyword">rows</span><br>−−−−−−<br>    <span class="hljs-number">6</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>


<p>显然，不使用外键也可以连接表。那么选择率将取自特定连接条件的预估选择率。8</p>
<p>对于这个例子中的等值连接，假设值均匀分布，选择率估算的通用公式如下：</p>
<p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch21/ch21/img_3.png" srcset="/img/loading.gif" lazyload alt="img_3.png"></p>
<p>其中 nd1 和 nd2 分别表示第一个集合和第二个集合中连接键不同值的数量。9</p>
<p>非重复值的统计信息显示 tickets 表中的票号是唯一的 (这是意料之中的，因为 ticket_no 列是主键)，并且 ticket_flights 中每张票大约有三个匹配行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> t.n_distinct, tf.n_distinct<br><span class="hljs-keyword">FROM</span> pg_stats t, pg_stats tf<br><span class="hljs-keyword">WHERE</span> t.tablename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;tickets&#x27;</span> <span class="hljs-keyword">AND</span> t.attname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ticket_no&#x27;</span><br>  <span class="hljs-keyword">AND</span> tf.tablename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ticket_flights&#x27;</span> <span class="hljs-keyword">AND</span> tf.attname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ticket_no&#x27;</span>;<br> n_distinct <span class="hljs-operator">|</span> n_distinct<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−<br>         −<span class="hljs-number">1</span> <span class="hljs-operator">|</span> −<span class="hljs-number">0.30362356</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>结果将与外键连接的估算值相匹配：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">2</span> <span class="hljs-operator">*</span> tf.reltuples <span class="hljs-operator">*</span><br>  least(<span class="hljs-number">1.0</span><span class="hljs-operator">/</span>t.reltuples, <span class="hljs-number">1.0</span><span class="hljs-operator">/</span>tf.reltuples<span class="hljs-operator">/</span><span class="hljs-number">0.30362356</span>)<br>) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">rows</span><br><span class="hljs-keyword">FROM</span> pg_class t, pg_class tf<br><span class="hljs-keyword">WHERE</span> t.relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;tickets&#x27;</span> <span class="hljs-keyword">AND</span> tf.relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ticket_flights&#x27;</span>;<br> <span class="hljs-keyword">rows</span><br>−−−−−−<br>    <span class="hljs-number">6</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<p>规划器会尽可能尝试改进此基线预估。目前它还不能使用直方图，但如果两个表的连接键上收集了 MCV 列表这类统计信息，那么规划器会考虑这些信息。10 列表中出现的行的选择率可以更准确地估算，而剩余的行将不得不依赖于基于均匀分布的假设进行计算。</p>
<p>通常情况下，如果定义了外键，连接选择率的估算可能会更准确。对于复合连接键更是如此，因为在这种情况下，选择率通常都被大大低估了。</p>
<p>使用 EXPLAIN ANALYZE 命令，不仅可以查看到实际的行数，还可以看到内循环被执行的次数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, timing off, summary off) <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> tickets t<br>  <span class="hljs-keyword">JOIN</span> ticket_flights tf <span class="hljs-keyword">ON</span> tf.ticket_no <span class="hljs-operator">=</span> t.ticket_no<br><span class="hljs-keyword">WHERE</span> t.book_ref <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;03A76D&#x27;</span>;<br>                           QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Nested Loop (cost<span class="hljs-operator">=</span><span class="hljs-number">0.99</span>.<span class="hljs-number">.45</span><span class="hljs-number">.68</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">6</span> width<span class="hljs-operator">=</span><span class="hljs-number">136</span>)<br>   (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">8</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   −<span class="hljs-operator">&gt;</span> Index Scan <span class="hljs-keyword">using</span> tickets_book_ref_idx <span class="hljs-keyword">on</span> tickets t<br>       (cost<span class="hljs-operator">=</span><span class="hljs-number">0.43</span>.<span class="hljs-number">.12</span><span class="hljs-number">.46</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">2</span> width<span class="hljs-operator">=</span><span class="hljs-number">104</span>) (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">2</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>       Index Cond: (book_ref <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;03A76D&#x27;</span>::bpchar)<br>   −<span class="hljs-operator">&gt;</span> Index Scan <span class="hljs-keyword">using</span> ticket_flights_pkey <span class="hljs-keyword">on</span> ticket_flights tf<br>       (cost<span class="hljs-operator">=</span><span class="hljs-number">0.56</span>.<span class="hljs-number">.16</span><span class="hljs-number">.58</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">3</span> width<span class="hljs-operator">=</span><span class="hljs-number">32</span>) (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">4</span> loops<span class="hljs-operator">=</span><span class="hljs-number">2</span>)<br>       Index Cond: (ticket_no <span class="hljs-operator">=</span> t.ticket_no)<br>(<span class="hljs-number">8</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>外集合包含两行 (actual rows&#x3D;2)；估算是正确的。所以 Index Scan节点执行了两次 (loops&#x3D;2)，每次平均选取了四行 (actual rows&#x3D;4) 。因此找到的总行数是：actual rows&#x3D;8。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">为了让输出适应页面的有限宽度，我没有显示计划的每个阶段的执行时间 (TIMING OFF)；此外，在某些平台上，启用计时的输出可能会显著减慢查询的执行速度。但如果我们确实包括了它，PostgreSQL 会显示一个平均值，就像行数一样。要获取总执行时间，你需要将此值乘以迭代次数 (loops)。<br></code></pre></td></tr></table></figure>

<p><strong>成本估算。</strong> 此处的成本估算公式与之前的示例相同。</p>
<p>让我们回顾一下查询计划：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> tickets t<br>  <span class="hljs-keyword">JOIN</span> ticket_flights tf <span class="hljs-keyword">ON</span> tf.ticket_no <span class="hljs-operator">=</span> t.ticket_no<br><span class="hljs-keyword">WHERE</span> t.book_ref <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;03A76D&#x27;</span>;<br>                           QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Nested Loop (cost<span class="hljs-operator">=</span><span class="hljs-number">0.99</span>.<span class="hljs-number">.45</span><span class="hljs-number">.68</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">6</span> width<span class="hljs-operator">=</span><span class="hljs-number">136</span>)<br>   −<span class="hljs-operator">&gt;</span> Index Scan <span class="hljs-keyword">using</span> tickets_book_ref_idx <span class="hljs-keyword">on</span> tickets t<br>       (cost<span class="hljs-operator">=</span><span class="hljs-number">0.43</span>.<span class="hljs-number">.12</span><span class="hljs-number">.46</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">2</span> width<span class="hljs-operator">=</span><span class="hljs-number">104</span>)<br>       Index Cond: (book_ref <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;03A76D&#x27;</span>::bpchar)<br>   −<span class="hljs-operator">&gt;</span> Index Scan <span class="hljs-keyword">using</span> ticket_flights_pkey <span class="hljs-keyword">on</span> ticket_flights tf<br>       (cost<span class="hljs-operator">=</span><span class="hljs-number">0.56</span>.<span class="hljs-number">.16</span><span class="hljs-number">.58</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">3</span> width<span class="hljs-operator">=</span><span class="hljs-number">32</span>)<br>       Index Cond: (ticket_no <span class="hljs-operator">=</span> t.ticket_no)<br>(<span class="hljs-number">7</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>在这种情况下，内集合每次后续扫描的成本与第一次扫描的成本相同。因此，我们最终得到以下数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">0.43</span> <span class="hljs-operator">+</span> <span class="hljs-number">0.56</span> <span class="hljs-keyword">AS</span> startup_cost,<br>  round((<br>    <span class="hljs-number">12.46</span> <span class="hljs-operator">+</span> <span class="hljs-number">2</span> <span class="hljs-operator">*</span> <span class="hljs-number">16.57</span> <span class="hljs-operator">+</span><br>    <span class="hljs-number">6</span> <span class="hljs-operator">*</span> current_setting(<span class="hljs-string">&#x27;cpu_tuple_cost&#x27;</span>)::<span class="hljs-type">real</span><br>  )::<span class="hljs-type">numeric</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> total_cost;<br> startup_cost <span class="hljs-operator">|</span> total_cost<br>−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br>         <span class="hljs-number">0.99</span> <span class="hljs-operator">|</span>      <span class="hljs-number">45.66</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>

<h4 id="21-2-3-缓存行-Memoization"><a href="#21-2-3-缓存行-Memoization" class="headerlink" title="21.2.3 缓存行 (Memoization)"></a>21.2.3 缓存行 (Memoization)</h4><p>如果使用相同的参数值重复扫描内集合 (从而给出相同的结果)，那么缓存该集合的行可能会有益。</p>
<p>此类缓存由 Memoize 11 节点执行。与 Materialize 节点类似，旨在处理参数化连接，并且具有更复杂的实现：</p>
<pre><code class="hljs">Materialize 节点只是简单地保存所有子节点返回的行，而 Memoize 则确保不同参数值返回的行分开保存。

在发生溢出的情况下，Materialize 存储开始将行溢出到磁盘，而 Memoize 会将所有行保留在内存中 (否则缓存就没有意义了)。
</code></pre>
<p>此处是一个使用 Memoize 的查询示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> flights f<br>  <span class="hljs-keyword">JOIN</span> aircrafts_data a <span class="hljs-keyword">ON</span> f.aircraft_code <span class="hljs-operator">=</span> a.aircraft_code<br><span class="hljs-keyword">WHERE</span> f.flight_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;PG0003&#x27;</span>;<br>QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Nested Loop (cost<span class="hljs-operator">=</span><span class="hljs-number">5.44</span>.<span class="hljs-number">.387</span><span class="hljs-number">.10</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">113</span> width<span class="hljs-operator">=</span><span class="hljs-number">135</span>)<br>   −<span class="hljs-operator">&gt;</span> Bitmap Heap Scan <span class="hljs-keyword">on</span> flights f<br>       (cost<span class="hljs-operator">=</span><span class="hljs-number">5.30</span>.<span class="hljs-number">.382</span><span class="hljs-number">.22</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">113</span> width<span class="hljs-operator">=</span><span class="hljs-number">63</span>)<br>       Recheck Cond: (flight_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;PG0003&#x27;</span>::bpchar)<br>       −<span class="hljs-operator">&gt;</span> Bitmap Index Scan <span class="hljs-keyword">on</span> flights_flight_no_scheduled_depart...<br>           (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.5</span><span class="hljs-number">.27</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">113</span> width<span class="hljs-operator">=</span><span class="hljs-number">0</span>)<br>           Index Cond: (flight_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;PG0003&#x27;</span>::bpchar)<br>    −<span class="hljs-operator">&gt;</span> Memoize (cost<span class="hljs-operator">=</span><span class="hljs-number">0.15</span>.<span class="hljs-number">.0</span><span class="hljs-number">.27</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">72</span>)<br>       Cache Key: f.aircraft_code<br>       Cache Mode: logical<br>       −<span class="hljs-operator">&gt;</span> Index Scan <span class="hljs-keyword">using</span> aircrafts_pkey <span class="hljs-keyword">on</span> aircrafts_data a<br>           (cost<span class="hljs-operator">=</span><span class="hljs-number">0.14</span>.<span class="hljs-number">.0</span><span class="hljs-number">.26</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">72</span>)<br>           Index Cond: (aircraft_code <span class="hljs-operator">=</span> f.aircraft_code)<br>(<span class="hljs-number">13</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>用于存储缓存行的内存块大小等于 work_mem × hash_mem_multiplier。正如第二个参数名所暗示的那样，缓存行存储在哈希表中 (使用开放寻址) 12。哈希键 (在计划中显示为 Cache Key) 是参数值 (如果不止一个参数，则为多个值)。</p>
<p>所有哈希键绑定到一个列表中；其一端被认为是冷的 (因为它包含长时间未使用的键)，而另一端是热的 (它存储最近使用的键)。</p>
<p>如果对 Memoize 节点的调用显示传递的参数值对应于已缓存的行，那么这些行将被传递到父节点 (嵌套循环) 而无需检查子节点。然后使用过的哈希键被移动到列表的热端。</p>
<p>如果缓存中不包含所需的行，Memoize 节点将从其子节点中提取并缓存它们，然后传递给上层节点。相应的哈希键也会变热。</p>
<p>随着新数据被缓存，它可以填满所有可用的内存。为了释放一些空间，对应于冷键的行会被逐出。该逐出算法不同于缓冲区缓存中使用的算法，但目的相同。</p>
<p>某些参数值可能有太多匹配的行，即使所有其他行都已被逐出也不适合所分配的内存块。这样的参数会被跳过 — 只缓存一些行是没有意义的，因为下一次调用仍然必须从子节点获取所有的行。</p>
<p><strong>成本和基数估算。</strong> 这些计算与我们上面已看到的十分相似。我们只需要记住，计划中显示的 Memoize 节点的成本与其实际成本无关：它只是其子节点的成本增加了 cpu_tuple_cost 的值。13</p>
<p>对于 Materialize 节点，我们已经遇到过类似的情况：它的成本仅为后续扫描进行计算 14，且不会反映在计划中。</p>
<p>显然，只有当 Memoize 比其子节点成本更低时，才有意义使用。每次后续 Memoize 扫描的成本取决于预期的缓存访问概况以及可用于缓存的内存块大小。计算值在很大程度上取决于对扫描内层数据集时使用的不同参数值数量的准确估算。15 基于这个数字，你可以权衡行被缓存和从缓存中逐出的概率。预期的命中降低了估算成本，而潜在的逐出增加了成本。在此处我们将跳过这些计算细节。</p>
<p>为了弄清楚查询执行期间实际发生了什么，我们将像往常一样使用 EXPLAIN ANALYZE 命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, costs off, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights f<br>  <span class="hljs-keyword">JOIN</span> aircrafts_data a <span class="hljs-keyword">ON</span> f.aircraft_code <span class="hljs-operator">=</span> a.aircraft_code<br><span class="hljs-keyword">WHERE</span> f.flight_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;PG0003&#x27;</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Nested Loop (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">113</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   −<span class="hljs-operator">&gt;</span> Bitmap Heap Scan <span class="hljs-keyword">on</span> flights f<br>       (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">113</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>       Recheck Cond: (flight_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;PG0003&#x27;</span>::bpchar)<br>       Heap Blocks: exact<span class="hljs-operator">=</span><span class="hljs-number">2</span><br>   −<span class="hljs-operator">&gt;</span> Bitmap Index Scan <span class="hljs-keyword">on</span> flights_flight_no_scheduled_depart...<br>       (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">113</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>       Index Cond: (flight_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;PG0003&#x27;</span>::bpchar)<br>   −<span class="hljs-operator">&gt;</span> Memoize (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> loops<span class="hljs-operator">=</span><span class="hljs-number">113</span>)<br>       Cache Key: f.aircraft_code<br>       Cache Mode: logical<br>       Hits: <span class="hljs-number">112</span> Misses: <span class="hljs-number">1</span> Evictions: <span class="hljs-number">0</span> Overflows: <span class="hljs-number">0</span> Memory<br>       Usage: <span class="hljs-number">1</span>kB<br>       −<span class="hljs-operator">&gt;</span> Index Scan <span class="hljs-keyword">using</span> aircrafts_pkey <span class="hljs-keyword">on</span> aircrafts_data a<br>           (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>           Index Cond: (aircraft_code <span class="hljs-operator">=</span> f.aircraft_code)<br>(<span class="hljs-number">16</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>该查询选择沿相同航线并由特定类型的飞机执飞的航班，因此所有 Memoize 节点上的调用都使用相同的哈希键。第一行必须从表中获取第 (Misses: 1)，但后续所有的行都在缓存中找到 (Hits: 112)。整个操作只需要 1 kB 的内存。</p>
<p>其他两个显示的值为零：它们代表逐出的次数和由于无法缓存与特定参数集相关的所有行时发生的缓存溢出次数。较大的数字表示分配的缓存太小，这可能是由于对不同参数值的数量预估不准确造成的。那么使用 Memoize 节点可能会非常昂贵。在极端情况下，你可以通过关闭 enable_memoize 参数来禁止规划器使用缓存。</p>
<h4 id="21-2-4-外连接"><a href="#21-2-4-外连接" class="headerlink" title="21.2.4 外连接"></a>21.2.4 外连接</h4><p>嵌套循环连接可用于执行左外连接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> ticket_flights tf<br>  <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> boarding_passes bp <span class="hljs-keyword">ON</span> bp.ticket_no <span class="hljs-operator">=</span> tf.ticket_no<br><span class="hljs-keyword">AND</span> bp.flight_id <span class="hljs-operator">=</span> tf.flight_id<br><span class="hljs-keyword">WHERE</span> tf.ticket_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0005434026720&#x27;</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Nested Loop <span class="hljs-keyword">Left</span> <span class="hljs-keyword">Join</span> (cost<span class="hljs-operator">=</span><span class="hljs-number">1.12</span>.<span class="hljs-number">.33</span><span class="hljs-number">.35</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">3</span> width<span class="hljs-operator">=</span><span class="hljs-number">57</span>)<br>   <span class="hljs-keyword">Join</span> <span class="hljs-keyword">Filter</span>: ((bp.ticket_no <span class="hljs-operator">=</span> tf.ticket_no) <span class="hljs-keyword">AND</span> (bp.flight_id <span class="hljs-operator">=</span><br>   tf.flight_id))<br>   −<span class="hljs-operator">&gt;</span> Index Scan <span class="hljs-keyword">using</span> ticket_flights_pkey <span class="hljs-keyword">on</span> ticket_flights tf<br>       (cost<span class="hljs-operator">=</span><span class="hljs-number">0.56</span>.<span class="hljs-number">.16</span><span class="hljs-number">.58</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">3</span> width<span class="hljs-operator">=</span><span class="hljs-number">32</span>)<br>       Index Cond: (ticket_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0005434026720&#x27;</span>::bpchar)<br>   −<span class="hljs-operator">&gt;</span> Materialize (cost<span class="hljs-operator">=</span><span class="hljs-number">0.56</span>.<span class="hljs-number">.16</span><span class="hljs-number">.62</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">3</span> width<span class="hljs-operator">=</span><span class="hljs-number">25</span>)<br>       −<span class="hljs-operator">&gt;</span> Index Scan <span class="hljs-keyword">using</span> boarding_passes_pkey <span class="hljs-keyword">on</span> boarding_passe...<br>           (cost<span class="hljs-operator">=</span><span class="hljs-number">0.56</span>.<span class="hljs-number">.16</span><span class="hljs-number">.61</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">3</span> width<span class="hljs-operator">=</span><span class="hljs-number">25</span>)<br>           Index Cond: (ticket_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0005434026720&#x27;</span>::bpchar)<br>(<span class="hljs-number">10</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>此处连接操作由 Nested Loop Left Join 节点表示。规划器选择了一个带有过滤条件的非参数化连接：它对内层数据集执行相同的扫描 (因此该集合隐藏在 Materialize 节点后面) 并返回满足过滤条件 (Join Filter) 的行。</p>
<p>外连接的基数预估与内连接的基数一样，只是计算出来的预估值是和外层数据集的基数比较，并取较大值作为最终结果。16 换句话说，外连接永远不会减少行数 (但可以增加)。</p>
<p>成本估算与内连接类似。</p>
<p>我们还需记住，规划器可以为内连接和外连接选择不同的计划。如果规划器被迫使用嵌套循环连接，那么即使是这个简单的示例也会有不同的连接过滤条件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> enable_mergejoin <span class="hljs-operator">=</span> off;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> ticket_flights tf<br>  <span class="hljs-keyword">JOIN</span> boarding_passes bp <span class="hljs-keyword">ON</span> bp.ticket_no <span class="hljs-operator">=</span> tf.ticket_no<br>                         <span class="hljs-keyword">AND</span> bp.flight_id <span class="hljs-operator">=</span> tf.flight_id<br><span class="hljs-keyword">WHERE</span> tf.ticket_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0005434026720&#x27;</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Nested Loop (cost<span class="hljs-operator">=</span><span class="hljs-number">1.12</span>.<span class="hljs-number">.33</span><span class="hljs-number">.33</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">3</span> width<span class="hljs-operator">=</span><span class="hljs-number">57</span>)<br>   <span class="hljs-keyword">Join</span> <span class="hljs-keyword">Filter</span>: (tf.flight_id <span class="hljs-operator">=</span> bp.flight_id)<br>   −<span class="hljs-operator">&gt;</span> Index Scan <span class="hljs-keyword">using</span> ticket_flights_pkey <span class="hljs-keyword">on</span> ticket_flights tf<br>       (cost<span class="hljs-operator">=</span><span class="hljs-number">0.56</span>.<span class="hljs-number">.16</span><span class="hljs-number">.58</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">3</span> width<span class="hljs-operator">=</span><span class="hljs-number">32</span>)<br>       Index Cond: (ticket_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0005434026720&#x27;</span>::bpchar)<br>   −<span class="hljs-operator">&gt;</span> Materialize (cost<span class="hljs-operator">=</span><span class="hljs-number">0.56</span>.<span class="hljs-number">.16</span><span class="hljs-number">.62</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">3</span> width<span class="hljs-operator">=</span><span class="hljs-number">25</span>)<br>       −<span class="hljs-operator">&gt;</span> Index Scan <span class="hljs-keyword">using</span> boarding_passes_pkey <span class="hljs-keyword">on</span> boarding_passe...<br>           (cost<span class="hljs-operator">=</span><span class="hljs-number">0.56</span>.<span class="hljs-number">.16</span><span class="hljs-number">.61</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">3</span> width<span class="hljs-operator">=</span><span class="hljs-number">25</span>)<br>           Index Cond: (ticket_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0005434026720&#x27;</span>::bpchar)<br>(<span class="hljs-number">9</span> <span class="hljs-keyword">rows</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> RESET enable_mergejoin;<br></code></pre></td></tr></table></figure>

<p>总成本略有不同的原因是，如果外层数据集中没有匹配项，外连接还必须检查票号以获得正确的结果。</p>
<p>不支持右外连接，17 因为嵌套循环算法以不同方式处理内集合和外集合。外集合被完整扫描；至于内集合，索引访问只允许读取那些满足连接条件的行，因此可能完全跳过其中的一些行。</p>
<p>出于同样的原因，也不支持全外连接。</p>
<h4 id="21-2-5-反连接和半连接"><a href="#21-2-5-反连接和半连接" class="headerlink" title="21.2.5 反连接和半连接"></a>21.2.5 反连接和半连接</h4><p>反连接和半连接在某种意义上是相似的，对于第一个 (外) 集合的每一行，只需在第二个 (内) 集合中找到一个匹配项就足够了。</p>
<p>反连接只有在第二个数据集中没有匹配项的情况下才返回第一个数据集中的行：一旦执行器在第二个数据集中找到了第一个匹配的行，它就可以退出当前循环：第一个数据集中相应的行必须从结果中排除。</p>
<p>反连接可用于计算 NOT EXISTS 谓词。</p>
<p>例如，让我们查找未定义机舱配置的机型。对应的计划包含 Nested Loop Anti Join 节点：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> aircrafts a<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> seats s <span class="hljs-keyword">WHERE</span> s.aircraft_code <span class="hljs-operator">=</span> a.aircraft_code<br>);<br>                            QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Nested Loop Anti <span class="hljs-keyword">Join</span> (cost<span class="hljs-operator">=</span><span class="hljs-number">0.28</span>.<span class="hljs-number">.4</span><span class="hljs-number">.65</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">40</span>)<br>   −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> aircrafts_data ml (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.1</span><span class="hljs-number">.09</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">9</span> widt...<br>   −<span class="hljs-operator">&gt;</span> Index <span class="hljs-keyword">Only</span> Scan <span class="hljs-keyword">using</span> seats_pkey <span class="hljs-keyword">on</span> seats s<br>       (cost<span class="hljs-operator">=</span><span class="hljs-number">0.28</span>.<span class="hljs-number">.5</span><span class="hljs-number">.55</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">149</span> width<span class="hljs-operator">=</span><span class="hljs-number">4</span>)<br>       Index Cond: (aircraft_code <span class="hljs-operator">=</span> ml.aircraft_code)<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>一个没有 NOT EXISTS 谓词的替代查询含有相同的计划：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> a.<span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> aircrafts a<br>  <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> seats s <span class="hljs-keyword">ON</span> a.aircraft_code <span class="hljs-operator">=</span> s.aircraft_code<br><span class="hljs-keyword">WHERE</span> s.aircraft_code <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Nested Loop Anti <span class="hljs-keyword">Join</span> (cost<span class="hljs-operator">=</span><span class="hljs-number">0.28</span>.<span class="hljs-number">.4</span><span class="hljs-number">.65</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">40</span>)<br>   −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> aircrafts_data ml (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.1</span><span class="hljs-number">.09</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">9</span> widt...<br>   −<span class="hljs-operator">&gt;</span> Index <span class="hljs-keyword">Only</span> Scan <span class="hljs-keyword">using</span> seats_pkey <span class="hljs-keyword">on</span> seats s<br>       (cost<span class="hljs-operator">=</span><span class="hljs-number">0.28</span>.<span class="hljs-number">.5</span><span class="hljs-number">.55</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">149</span> width<span class="hljs-operator">=</span><span class="hljs-number">4</span>)<br>       Index Cond: (aircraft_code <span class="hljs-operator">=</span> ml.aircraft_code)<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>半连接会返回第一个数据集中至少在第二个数据集中有一条匹配项的行 (同样，也无需检查数据集中是否有其他匹配项 — 结果已经知道了)。</p>
<p>半连接可用于计算 EXISTS 谓词。让我们找出机舱内装有座椅的机型：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> aircrafts a<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> seats s<br>  <span class="hljs-keyword">WHERE</span> s.aircraft_code <span class="hljs-operator">=</span> a.aircraft_code<br>);<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Nested Loop Semi <span class="hljs-keyword">Join</span> (cost<span class="hljs-operator">=</span><span class="hljs-number">0.28</span>.<span class="hljs-number">.6</span><span class="hljs-number">.67</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">9</span> width<span class="hljs-operator">=</span><span class="hljs-number">40</span>)<br>   −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> aircrafts_data ml (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.1</span><span class="hljs-number">.09</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">9</span> widt...<br>   −<span class="hljs-operator">&gt;</span> Index <span class="hljs-keyword">Only</span> Scan <span class="hljs-keyword">using</span> seats_pkey <span class="hljs-keyword">on</span> seats s<br>       (cost<span class="hljs-operator">=</span><span class="hljs-number">0.28</span>.<span class="hljs-number">.5</span><span class="hljs-number">.55</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">149</span> width<span class="hljs-operator">=</span><span class="hljs-number">4</span>)<br>       Index Cond: (aircraft_code <span class="hljs-operator">=</span> ml.aircraft_code)<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>Nested Loop Semi Join 节点表示同名连接方法。该计划 (就像上面的反连接一样) 提供了 seats 表中行数的基本预估值 (rows&#x3D;149)，尽管只检索其中一个就足够了。当然，实际的查询执行在获取第一行后停止：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, costs off, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> aircrafts a<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> seats s<br>  <span class="hljs-keyword">WHERE</span> s.aircraft_code <span class="hljs-operator">=</span> a.aircraft_code<br>);<br>                         QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Nested Loop Semi <span class="hljs-keyword">Join</span> (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">9</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> aircrafts_data ml (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">9</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   −<span class="hljs-operator">&gt;</span> Index <span class="hljs-keyword">Only</span> Scan <span class="hljs-keyword">using</span> seats_pkey <span class="hljs-keyword">on</span> seats s<br>       (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> loops<span class="hljs-operator">=</span><span class="hljs-number">9</span>)<br>       Index Cond: (aircraft_code <span class="hljs-operator">=</span> ml.aircraft_code)<br>       Heap Fetches: <span class="hljs-number">0</span><br>(<span class="hljs-number">6</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p><strong>基数估算。</strong> 半连接的选择率以往常的方式进行估算，除了内集合的基数取 1。对于反连接，预估选择率从 1 中减去，就像取否操作一样。18</p>
<p><strong>成本估算。</strong> 对于反连接和半连接，成本估算反映了这样一个事实：一旦找到第一个匹配的行，对于第二个数据集的扫描就会停止。19</p>
<h4 id="21-2-6-非等值连接"><a href="#21-2-6-非等值连接" class="headerlink" title="21.2.6 非等值连接"></a>21.2.6 非等值连接</h4><p>嵌套循环算法允许根据任何连接条件进行连接。</p>
<p>显然，如果内集合是一个创建了索引的基础表，并且连接条件使用了属于该索引操作符类的操作符，那么对内集合的访问会非常高效。但是始终可以通过计算按某些条件过滤后的行的笛卡尔积来执行连接 — 在这种情况下，该条件可以是任意的。就像下面的查询一样，它选择了彼此靠近的机场：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> EXTENSION earthdistance CASCADE;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off) <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> airports a1<br>  <span class="hljs-keyword">JOIN</span> airports a2 <span class="hljs-keyword">ON</span> a1.airport_code <span class="hljs-operator">!=</span> a2.airport_code<br>                  <span class="hljs-keyword">AND</span> a1.coordinates <span class="hljs-operator">&lt;</span>@<span class="hljs-operator">&gt;</span> a2.coordinates <span class="hljs-operator">&lt;</span> <span class="hljs-number">100</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Nested Loop<br>   <span class="hljs-keyword">Join</span> <span class="hljs-keyword">Filter</span>: ((ml.airport_code <span class="hljs-operator">&lt;&gt;</span> ml_1.airport_code) <span class="hljs-keyword">AND</span><br>   ((ml.coordinates <span class="hljs-operator">&lt;</span>@<span class="hljs-operator">&gt;</span> ml_1.coordinates) <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;100&#x27;</span>::<span class="hljs-keyword">double</span> precisi...<br>   −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> airports_data ml<br>   −<span class="hljs-operator">&gt;</span> Materialize<br>       −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> airports_data ml_1<br>(<span class="hljs-number">6</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<h4 id="21-2-7-并行模式"><a href="#21-2-7-并行模式" class="headerlink" title="21.2.7 并行模式"></a>21.2.7 并行模式</h4><p>嵌套循环连接可以参与并行计划的执行。20</p>
<p>只有外集合可以并行处理，因为它可以由多个工作进程同时扫描。获取了外部行之后，每个工作进程必须顺序地搜索内集合中的匹配行。</p>
<p>下面显示的查询包括多个连接；它搜索持有特定航班机票的乘客：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off) <span class="hljs-keyword">SELECT</span> t.passenger_name<br><span class="hljs-keyword">FROM</span> tickets t<br>  <span class="hljs-keyword">JOIN</span> ticket_flights tf <span class="hljs-keyword">ON</span> tf.ticket_no <span class="hljs-operator">=</span> t.ticket_no<br>  <span class="hljs-keyword">JOIN</span> flights f <span class="hljs-keyword">ON</span> f.flight_id <span class="hljs-operator">=</span> tf.flight_id<br><span class="hljs-keyword">WHERE</span> f.flight_id <span class="hljs-operator">=</span> <span class="hljs-number">12345</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Nested Loop<br>   −<span class="hljs-operator">&gt;</span> Index <span class="hljs-keyword">Only</span> Scan <span class="hljs-keyword">using</span> flights_flight_id_status_idx <span class="hljs-keyword">on</span> fligh...<br>       Index Cond: (flight_id <span class="hljs-operator">=</span> <span class="hljs-number">12345</span>)<br>   −<span class="hljs-operator">&gt;</span> Gather<br>       Workers Planned: <span class="hljs-number">2</span><br>       −<span class="hljs-operator">&gt;</span> Nested Loop<br>           −<span class="hljs-operator">&gt;</span> Parallel Seq Scan <span class="hljs-keyword">on</span> ticket_flights tf<br>               <span class="hljs-keyword">Filter</span>: (flight_id <span class="hljs-operator">=</span> <span class="hljs-number">12345</span>)<br>           −<span class="hljs-operator">&gt;</span> Index Scan <span class="hljs-keyword">using</span> tickets_pkey <span class="hljs-keyword">on</span> tickets t<br>               Index Cond: (ticket_no <span class="hljs-operator">=</span> tf.ticket_no)<br>(<span class="hljs-number">10</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>

<p>在上层，嵌套循环连接顺序执行。外集合由 flights 表中通过唯一键获取的单行组成，因此即使内集合行数较多，使用嵌套循环也是合理的。</p>
<p>内集合的检索使用了并行计划。每个工作进程扫描 ticket_flights 表中属于自己份额的行，并使用嵌套循环算法将它们与 tickets 连接起来。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/BOOK/" class="category-chain-item">BOOK</a>
  
  
    <span>></span>
    
  <a href="/categories/BOOK/PostgreSQL14-Internals/" class="category-chain-item">PostgreSQL14_Internals</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/book/" class="print-no-link">#book</a>
      
        <a href="/tags/database/" class="print-no-link">#database</a>
      
        <a href="/tags/transactions/" class="print-no-link">#transactions</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>ch21. Nested Loop</div>
      <div>http://smilemzy.com/2025/05/05/DB/PostgreSQL14_Internals/ch21/ch21/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Smile</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/05/05/DB/PostgreSQL14_Internals/ch23/ch23/" title="ch23. Sorting and Merging">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ch23. Sorting and Merging</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/05/DB/PostgreSQL14_Internals/ch22/ch22/" title="ch22. Hashing">
                        <span class="hidden-mobile">ch22. Hashing</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
