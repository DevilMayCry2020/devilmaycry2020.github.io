

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5/fluid.png">
  <link rel="icon" href="/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Smile">
  <meta name="keywords" content="">
  
    <meta name="description" content="介绍ch2 深入理解事务管理和并发控制技术 内容2.1 在正确性和效率之间平衡理解并发控制技术，首先可以从使用锁的协议入手，讨论影响数据一致性的三种情况（不同事务之间对同一个数据项的读–写、写–读、写–写这三种情况。读–读不影响一致性不必考虑）。然后考虑并发的效率问题，采用多种并发控制技术、适度逐渐放宽并发度，从而理解各种各样的并发控制技术。 另外，为了提升数据库处理事务的效率，除了采用不同的并发">
<meta property="og:type" content="article">
<meta property="og:title" content="ch2 深入理解事务管理和并发控制技术">
<meta property="og:url" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/index.html">
<meta property="og:site_name" content="Smile">
<meta property="og:description" content="介绍ch2 深入理解事务管理和并发控制技术 内容2.1 在正确性和效率之间平衡理解并发控制技术，首先可以从使用锁的协议入手，讨论影响数据一致性的三种情况（不同事务之间对同一个数据项的读–写、写–读、写–写这三种情况。读–读不影响一致性不必考虑）。然后考虑并发的效率问题，采用多种并发控制技术、适度逐渐放宽并发度，从而理解各种各样的并发控制技术。 另外，为了提升数据库处理事务的效率，除了采用不同的并发">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_1.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_2.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_3.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_4.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_5.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_6.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_7.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_8.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_9.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_10.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_11.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_12.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_13.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_14.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_15.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_16.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_17.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_18.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_19.png">
<meta property="article:published_time" content="2025-05-05T12:24:15.498Z">
<meta property="article:modified_time" content="2025-05-05T13:24:33.841Z">
<meta property="article:author" content="Smile">
<meta property="article:tag" content="book">
<meta property="article:tag" content="database">
<meta property="article:tag" content="transactions">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img.png">
  
  
  
  <title>ch2 深入理解事务管理和并发控制技术 - Smile</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"smilemzy.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/内存泄漏排查/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Smile</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="ch2 深入理解事务管理和并发控制技术"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-05 20:24" pubdate>
          2025年5月5日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          96 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">ch2 深入理解事务管理和并发控制技术</h1>
            
            
              <div class="markdown-body">
                
                <h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch2 深入理解事务管理和并发控制技术</p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="2-1-在正确性和效率之间平衡"><a href="#2-1-在正确性和效率之间平衡" class="headerlink" title="2.1 在正确性和效率之间平衡"></a>2.1 在正确性和效率之间平衡</h5><p>理解并发控制技术，首先可以从使用锁的协议入手，讨论影响数据一致性的三种情况（不同事务之间对同一个<br>数据项的读–写、写–读、写–写这三种情况。读–读不影响一致性不必考虑）。然后考虑并发的效率问题，<br>采用多种并发控制技术、适度逐渐放宽并发度，从而理解各种各样的并发控制技术。</p>
<p>另外，为了提升数据库处理事务的效率，除了采用不同的并发控制技术逐渐释放事务间的并发能力之外，还有一种思路就<br>是让用户自己判断所发起的操作是否影响到了数据的一致性，如果用户认为不影响数据一致性，则可以控制数据库的事务管理器，<br>放松对事务调度的限制（程序员必须慎重选择隔离级别），以提高并发程度。这样的技术就是“隔离级别”。</p>
<h6 id="2-1-1-隔离级别"><a href="#2-1-1-隔离级别" class="headerlink" title="2.1.1　隔离级别"></a>2.1.1　隔离级别</h6><p>三种异常现象，是在并发情况下发生的，数据库系统使用不同的隔离级别，分别隔离了并发情况下对数据读写的三种异常 ，<br>使得异常不存在，这就是隔离的含义，即隔离异常现象杜绝了异常现象。</p>
<p>SQL标准（American National Standards Institute，ANSI）提出四种隔离级别，分别是在三种读数据异常现象前后插入四个点，<br>形成了四种隔离地带，不同程度地禁止了三种读数据的异常现象的产生。参见表2-1。</p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img.png"></p>
<p>并发执行的事务能够看到存储的信息（即数据），好似事务之间是串行执行（生成的数据）。<br>这样，因为等价于串行执行，所以数据的一致性不会被破坏，但是这个“隔离性”是隔离级别中最高的级别，<br>其他的隔离级别不能保证“一致性”但却能提高事务的运行效率。</p>
<p>SQL标准对于隔离级别定义如下：</p>
<p>1）Serializable（串行化，或称为可串行化）</p>
<p>一个事务在执行过程中完全看不到其他事务对数据库所做的更新</p>
<p>2）Repeatable Read（可重复读）</p>
<p>一个事务在执行过程中可以看到其他事务已经提交的新插入的元组（读已经提交的，其实是读早于本事务开始且已经提交的），<br>但是不能看到其他事务对已有元组的更新（即晚于本事务开始的），并且，该事务不要求与其他事务是“可串行化”的。</p>
<p>3）Read Commited（已提交读）</p>
<p>一个事务在执行过程中可以看到已经提交的其他事务新插入的元组，而且能看到已经提交的其他事务对已有元组的更新。</p>
<p>4）Read Uncommitted（未提交读）</p>
<p>一个事务在执行过程中可以看到没有提交的其他事务新插入的元组，而且能看到没有提交的其他事务对已有元组的更新。</p>
<p>这四种隔离级别，都不允许“脏写（dirty write，参见1.1.4节）”发生。</p>
<p>下面以并发控制技术采用封锁的方式来概要地了解一下并发控制技术和隔离级别之间的关系，如表2-2所示。</p>
<p>表2-2　各种隔离级别在基于锁的并发控制技术下的实现情况<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_1.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img_1.png"></p>
<h6 id="2-1-2-快照隔离"><a href="#2-1-2-快照隔离" class="headerlink" title="2.1.2　快照隔离"></a>2.1.2　快照隔离</h6><p>一种常用的隔离技术，称为“快照隔离（Snapshot Isolation，简称SI）”。</p>
<p><strong>1.什么是“快照隔离”？</strong></p>
<p>快照隔离是一种保证，即事务中的所有读取操作都将看到数据库的一个一致的快照<br>（实际上，它读取的是事务开始时存在的最后一个已提交值），并且该事务只有在其所做的更新与自该快照以来的任<br>何并发更新不冲突的情况下才能成功提交。</p>
<p>我们可以认为：</p>
<pre><code class="hljs">（1）使用了快照隔离技术的事务中的所有读操作，读到的数据一定是一致的。
（2）一条实际上避免了ANSI SQL标准定义的“幻象/幻读”等各种读异常现象 （具体分析参见表2-3）。
各种读异常的详细讨论参见1.1.3和2.1.2节。
（3）这样的事务如果没有写–写冲突发生，则会提交成功。这意味着，不会发生读–写和写–读冲突。所以并发效率会更高。
（4）第一和第三条结果得以保障，是因为从事务开始时，处于当时的并发事务的状态 （多个事务的状态，称为快照 ，即snapshot ）被保存，
利用这个快照可以判断本事务和其他事务之间启动的先后顺序、事务的读写数据情况等，以确定是否存在写–写冲突。
（5）这就是“快照隔离”技术的本质，其实，也是“快照隔离”技术要达到的目的。
</code></pre>
<p>修正后的SQL标准定义的三种读数据异常现象与快照隔离的比较表：<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_2.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img_2.png"></p>
<p><strong>2.“快照隔离”的技术实现手段</strong></p>
<p>“快照隔离”是MVCC技术的一种实现方式（详情参见2.2.4节）。MVCC技术的本质，是为每个对象在写操作发生时，生成<br>一个新的版本；在读操作发生时，读出最近的一个版本。这样同一个元组因有多个版本（传说中的分身术）、且并发的事务有生<br>命周期存在，每个事务读到的元组（实则是元组的某个版本）是不一样的，相当于并发事务在操作不同的元组对象，因此看起来“<br>不存在并发”（除了写–写冲突一定要操作同一个对象，如同孙大圣被金钹扣住的一定是真身），不满足1.2.2节提到的“冲突<br>行为”的定义。</p>
<p>存在有多个版本的元组级的对象，物理组织通常有两种：一是磁盘类型的数据库，MVCC冗余了磁盘页内部的元组；<br>二是内存类型的数据库，MVCC冗余了内存中的元组，两者所不同的，是元组存放的位置不同，前者是位于页面内部，<br>后者是直接在内存中组成一个链表。前者典型的实现如PostgreSQL和InnoDB，后者典型的实现如阿里的OceanBase、<br>微软的Hekaton。</p>
<p><strong>3.“快照隔离”的实现技术是如何解决各种冲突的？</strong></p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_3.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img_3.png"></p>
<p>首先，如图2-1所示，有5个并发执行的事务，分别是T1到T5。</p>
<p>其次，事务所能读取的数据，一定是已经提交了的事务的、最新的数据。</p>
<p>“最新的”含义表明，假设事务T1和T3都修改了同一个数据项X，则事务T5所能看到的数据项X一定是事务T3生成的版本，<br>因为事务T3生成的版本新于事务T1生成的版本。</p>
<p>再次，因为一个数据项有多个版本，以事务的开始时间戳为获取版本的基准，并发间的事务看到的是不同的版本。</p>
<p>第四，并发事务同时写同一个数据项，要遵循“First-Committer-Wins”，即：首个提交者获胜原则。<br>这是在说，并发的、同时写同一个数据项的事务只能有一个成功，另外一个必须回滚，这种情况相当于并发不存在 。<br>所以解决了写–写冲突。</p>
<p>第五，与“先提交获胜”原则相似的是“先写者获胜”，即“First-writer-wins”。</p>
<p><strong>4.“快照隔离”实现技术的弊端</strong></p>
<p>尽管MVCC并发效率很高，但是“快照隔离”不能保证并发事务是可串行化的，所以，无法保证数据的一致性。<br>这样的问题，被称为“写偏序（Write skew）”，参见1.1.5节。</p>
<p><strong>5.“快照隔离”实现技术的弊端的解决方式</strong></p>
<p>使用“快照隔离”实现MVCC的技术引发了写偏序的问题，其实是这种技术因多个版本存在使得用户定义在数据项<br>上的语义不能得到保证（在每个版本上判断语义相当于在不同的逻辑时空内同时操作不同的分身而不能保证语义施加在同<br>一个物理真身上）而导致的。解决方式是采用“Serializable snapshot isolation”技术，详情参见2.2.5节。<br>还有一种技术，叫作“write-snapshot isolation”，曾在第1章提及。</p>
<p><strong>6.“快照隔离”的其他一些问题</strong></p>
<p>在商业数据库Oracle（如10g、11g这些版本）和开源的数据库PostgreSQL中，<br>快照隔离被称为“可串行化（serializable）隔离级别”，这是一种错误的叫法。错误之处在于：</p>
<pre><code class="hljs">一是把“快照隔离”的概念等同了ANSI SQL标准中的四种隔离级别中最高的隔离级别。
从前述的定义看，显然“快照隔离”和“可串行化（serializable）隔离级别”是明显不同的。

二是混淆了二者的真实含义。“快照隔离”不能确保“可串行化（serializable）”这个事务的属性 
要求；而“可串行化（serializable）隔离级别”却要确保在这个隔离级别下，事务被事务管理器调度时，
必须是可串行化的。

三是在工程实现中，Oracle没有在“可串行化（serializable）隔离级别”下真正实现“ 可串行化”属性 。
而PostgreSQL早期版本也不是一个真的“可串行化（serializable）”的事务，存在写偏序异常；
只是在9.1版通过“Serializable snapshot isolation”技术实现了真正的可序列化。
</code></pre>
<p><strong>7.“快照隔离”的实际应用</strong></p>
<p>在PostgreSQL和MySQL实现中，都使用快照隔离技术实现了MVCC协议。其中，PostgreSQL使用“transaction snapshot”表示快照隔离，<br>MySQL使用“read view”表示快照隔离，都是用快照来隔离并发事务对相同数据项的操作。</p>
<p><strong>8.“快照隔离”阅读进阶</strong></p>
<p>论文《Database Replication Using Generalized Snapshot Isolation》给出了快照隔离的定义，<br>称之为“Generalized Snapshot Isolation（GSI）”。并基于GSI提出了“Prefix-Consistent Snapshot<br>Isolation（PCSI）”用于分布式环境中的复制数据库的事务处理（分布式相关的本书不作讨论，期待有关分<br>布式相关内容将来有机会另述）。</p>
<p>·论文《Generalized Snapshot Isolation and a Prefix-Consistent Implementation》对GSI和PCSI做了<br>更多阐述（两篇论文的作者相同）。</p>
<h6 id="2-1-3-理解可见性"><a href="#2-1-3-理解可见性" class="headerlink" title="2.1.3　理解可见性"></a>2.1.3　理解可见性</h6><p>首先，可见性，是指某个数据项对于不同事务，是否可以被并行操作（即数据项对于某个事务是否可见可操作）。<br>这是从并发的角度而言的，很自然，这就与并发控制算法有关。</p>
<p>其次，为了提高并发度，ANSI SQL标准定义了四种隔离级别，“SERIALIZABLE”使得数据项不可被其他并发<br>事务可见而被操作（读-读除外，但这么说已经和基于锁的并发控制技术关联，因此严格地说，这样的说法也是不严谨的）。其<br>他隔离级别放松了管制，在某些情况下使得数据项被其他事务可见。这表明可见性与隔离级别紧密相关。</p>
<p>在PostgreSQL和MySQL这样的数据库系统中，因都实现了MVCC机制的时候，其中就经常提到“可见性”判断。<br>一个元组对谁可见，意味着这个元组可以被什么样的事务获取（读取、改写或删除），这和数据库引擎使用的<br>并发控制技术、ACID中隔离性的定义、ANSI SQL标准定义的隔离级别等紧密相关。</p>
<p>对于基于锁的并发控制技术，如果隔离级别是“SERIALIZABLE”则一条元组在读锁的情况下，<br>对于其他并发事务的读操作是可见的。否则，不可见。<br>如果隔离级别是其他的级别，则根据加锁情况排斥或不排斥其他并发事务的读或写操作，使得数据项对其他事务表现出可见或不可见。</p>
<p>如果数据库引擎使用了MVCC机制和快照隔离技术，则因为一个元组有了多个版本，所以隔离技术使得不同并发事务对同一个数据项的操作相<br>互“隔离”（各自作用在同一个数据项的不同的版本上），此时，除了写-写操作外（此句话的背景是MVCC+锁实现并发控制），<br>其他的操作都不互斥，因此在读或写操作这个层面，版本对于事务而言都因不互斥而可见。<br>但是，这不是决定元组可见性的唯一标准，还有三个标准就是数据项的状态，即是否提交<br>（对应READ COMMITTED、READ UNCOMMITTED隔离级别）、是否符合事务语义（对应REPEATABLE READ隔离级别，<br>语义是在一个事务内前后阶段看到的数据应该是一致的），如果满足当前事务的隔离级别设置，才能说是满足可见性。</p>
<p>综上所述，Innodb使用的ReadView，就是MVCC机制中常用的快照隔离，在这种情况下，判断元组对某个事务的可见性，不仅仅指的是ACID中的隔离性。</p>
<h5 id="2-2-并发控制"><a href="#2-2-并发控制" class="headerlink" title="2.2　并发控制"></a>2.2　并发控制</h5><p>从检测是否存在冲突的时机的角度看，主要包括乐观的、悲观的以及介于两者之间半乐观的方法；<br>从控制冲突的时机角度看，主要包括：基于锁的、基于时间的、基于提交顺序的、基于串行化图测试验证的等各种方法，<br>另外还有一些其他的方法诸如多版本并发控制技术等。</p>
<p><strong>并发控制的技术有很多，多种技术之间进行组合又创造出更多的并发控制技术。但怎么理解这些技术？为什么多种技术之间可以组合？这些技术之间是否存在内在的关联？</strong></p>
<p>深入剖析各种并发控制技术是怎么消除数据不一致的、是怎么提高并发效率的。</p>
<p>首先，我们来明确：<strong>并发的事务是怎么引发数据不一致的？</strong></p>
<p>可串行化概念的作用在于保证并发的事务调度方式既能满足数据一致性需求，又能提高并发事务的执行效率。</p>
<p>讨论“可串行化”“可恢复性”“严格性”这几个概念之间的关系，是十分必要的：</p>
<pre><code class="hljs">可串行化：从理论上保证了并发事务的调度等价于一个串行调度，避免了数据的不一致现象。

可恢复性：描述了需要避免了脏读异常现象，但没有提出实施措施。

避免级联回滚：描述了事务调度机制在“不可恢复性”发生作用时，
为了保证数据的一致性不得不降低事务调度机制的效率（所以，这样的事情应该避免）。

严格性：提出通过控制并发事务的提交/中止操作的顺序，来直接避免脏读现象，这样进一步避免了数据的不一致现象。
</code></pre>
<p>以上都满足，才能确保一致性。</p>
<p>其次，我们来讨论：并发的事务调度方法是怎么提高并发度的？</p>
<p>下面我们结合各种并发控制方法，结合本节提出的两个问题，剖析不同的并发控制技术是怎样解决这两个问题的。但是，请注意，2.2节的各个子节当中讨论<br>的多种并发控制技术，只涉及隔离级别是“Serializable（串行化，或称为可串行化）”的级别，因为只有这个级别才能<br>真正保证数据的一致性。在2.4节，我们再结合其他隔离级别讨论并发控制的技术。</p>
<h6 id="2-2-1-基于锁的并发控制方法"><a href="#2-2-1-基于锁的并发控制方法" class="headerlink" title="2.2.1　基于锁的并发控制方法"></a>2.2.1　基于锁的并发控制方法</h6><p>在数据库系统的实现过程中，我们常使用“spinlock”和“latch”来保护共享资源不被并<br>发地写操作同时修改；在编程中，我们引入了对象互斥锁“mutex”的概念，来保证共享数据操作的完整性。<br>通过事前加锁、事后释放锁，避免了共享资源被不同对象同时修改。所以，封锁技术能够抑制并发，即能避免数据不一致的问题。</p>
<p>但是，如果只是简单的加锁，对于数据库系统而言，一个事务内如果需要读写很多与其他事务共享的数据项，<br>那么这个锁怎么加、加在哪里就是一个问题？</p>
<p>那么，我们是否可以定义多个锁？如果定义了多个锁，又如何知道该给哪些事务使用哪些锁呢？</p>
<p>如果把锁加在数据项上，则能解决哪些事务该使用哪些锁的问题。但是，<br>封锁导致不能并发则使得执行效率降低（读–读操作式的并发也被禁止）。而且，需要在一个事务的<br>所有操作完成后才能释放锁，这使得即使多个事务能够并发但执行效率也不高。</p>
<p>多粒度封锁，解决了只使用一种锁导致并发效率低下的问题；两阶段封锁协议，<br>解决了引入多粒度锁之后导致事务调度机制不能保证事务间的并发调度是“可串行化”的。</p>
<p><strong>1.锁的粒度</strong></p>
<p>锁被分为两种粒度后，即区分为读锁（共享锁）和写锁（排它锁），则并发操作可以被区分为四种：<br>读–读、读–写、写–读、写–写，这样，至少读–读操作的并发可被允许进行，使得在用锁保证数据一致性的情况下，<br>并发能力得以提高。可以得到我们通常所说的“锁的相容性矩阵”。</p>
<p>如果进一步把锁的种类再细化，增加意向锁等，则可以得到如表2-4所示锁的相容性矩阵表，这个表是用于多个事务之间<br>进行事务间加锁时互斥操作使用的（锁的互斥使得并发的事务间遵循了可串行性）。但是，在实际的编程实战中，还有如<br>表2-5所示锁的升级图，用于在一个事务内对本事务的多个加锁操作进行锁升级的。具体说明，参看表2-4和表2-5。</p>
<p>锁的相容性矩阵表（不同的事务间新锁的申请）：<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_4.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img_4.png"></p>
<p>“Granted Mode”表示已经赋予的锁。N表示不存在锁，IS共享意向锁，IX排它意向锁，S共享锁，SIX共享排它意向锁，U更新锁，X排它锁。<br>对于“Granted Mode”，从N到X这些锁，存在一个排斥的过程，IS排斥其他并发操作的力度最弱，X最强，现实中数据库的事务调度器实现实<br>例中在为事务加锁时，就遵循着这样的一个顺序依序比较，如Informix、PostgreSQL等系统。</p>
<p>由于可以有多种粒度的锁存在，多粒度封锁协议（multiple-granularity locking protocol） [《数据库系统概念》，第六版，Abraham Siberschatz等著。]<br>被提出，<br>可以增强并发度，减少锁的开销，本节不再多述，请参阅相关书籍。</p>
<p>锁的合并图（同一个事务内锁的升级）：<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_5.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img_5.png"></p>
<pre><code class="hljs">本图表明在同一个事务内对同一个数据项的加锁操作的升级（多种粒度的锁，为了提升并发度，
当同一个对象上发生第二次锁申请时，则允许锁进行转换（lock conversion），就是锁的升级和降级。
升级（upgrade）：表示从共享到排他的转换，发生在锁增长阶段；降级（downgrade）；表示从排他到
的共享转换，发生在锁缩减阶段，多数的数据库不实现降级。）后的结果。

“Lock Held”表示已经授予的锁。

“Lock Requested”表示将要申请的锁。

在同一个数据项上已经授予了S锁，如果再申请IX锁，则在这个数据项上持有的锁就变为SIX锁。

在同一个数据项上已经授予了SIX锁，如果再申请U锁，则在这个数据项上持有的锁就变为X锁。其他升级方式不再举例，余者参见表2-5所示。
</code></pre>
<p><strong>2.两阶段锁</strong></p>
<p>两阶段封锁协议（two-phase locking protocol，2PL），要求每个事务分为两个阶段：</p>
<pre><code class="hljs">增长阶段（growing phase）：第一个阶段，事务可以获得锁，但不释放锁。

缩减阶段（shrinking phase）：第二个阶段，事务可以释放锁，但不能获得新锁。
</code></pre>
<p>两阶段封锁协议可以保证可串行性 [可用反证法证明两阶段封锁协议执行的事务过程一定是可串行化的] ，<br>但不满足可恢复性，因而不能避免级联回滚；两阶段封锁协议更不满足严格性，所以不能完全保证数据的一致性。</p>
<p>于是，两阶段封锁协议有了新的变种，即：</p>
<pre><code class="hljs">严格两阶段封锁协议 （strict two-phase locking protocol，S2PL）：
除了封锁满足两阶段封锁之外，还要求持有的排它锁必须在事务提交后才能释放。这个要求保证未提交事
务所写的任何数据在该事务提交之前均以排它方式加锁，从而能够避免级联回滚。如表2-6（源自表1-14）所示，
对于case3，事务T2的W（X）和Commit操作，在S2PL协议下，已经不可能发生（事务T1在X上持有的写锁一直不释放），
所以当事务T1执行Abort时，级联回滚就不存在。

强两阶段封锁协议 （rigorous/strong two-phase locking protocol，SS2PL）：除了封锁满足两阶段之外，
还要求事务提交之前不得释放任何锁。这样就满足了严格性的要求（严格性要求先发生写操作的事务提交或中止的
操作优先于其他事务）。
</code></pre>
<p>表2-6　可恢复性示例：<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_6.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img_6.png"></p>
<p>主流数据库系统实现的两阶段封锁协议，实际上指的是SS2PL而非2PL。因为只有SS2PL才能保证数据的一致性。</p>
<p>使用SS2PL实现事务调度的主流数据库系统有Informix。开源的PostgreSQL和MySQL不仅使用了SS2PL，而且还使用MVCC来提高事<br>务并发调度的效率。Oracle、DB2、SQL Server也是基于SS2PL和MVCC实现的事务并发调度。</p>
<p><strong>3.封锁技术是怎样解决各种读异常的？</strong></p>
<p>对于脏读和不可重复读，封锁技术不会发生这两种读异常现象，原因如表2-7所示。</p>
<p>表2-7　修正后的SQL标准定义的三种读数据异常现象与封锁技术的比较表：<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_7.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img_7.png"></p>
<p>对于幻象，需要分为几种情况讨论：</p>
<p>（1）没有索引，使用表或页面级锁：因为锁的粒度大，锁把一些不相关的元组也囊括在锁定的范围内，<br>这使得其他事务的WHERE条件不能获取被锁住的表或页面（这相当于锁住了WHERE条件指定的数据对象和对象的外延范围，<br>这个外延范围被称为间隙“gap”），因而可以避免幻象异常。</p>
<p>（2）没有索引，锁的粒度是元组级：因为锁的粒度到了元组一级，即操作多少元组就锁定<br>多少元组对象，所以其他事务的WHERE条件能够不受已经加锁的影响，因而可能存在幻象。解决方式是锁的粒度升级为表级或页级。</p>
<p>（3）有索引：在索引上采取“谓词锁（predicate lock）”来解决。</p>
<p><strong>4.死锁相关</strong></p>
<p>如果只有一种锁，并发的事务只有等待该锁被释放后才能有加锁的机会，这样并发的事务处于等待状态。<br>但如果至少存在读写锁，则会发生R（X）W（Y）-R（Y）W（X）这样的死锁现象，<br>导致并发事务谁也不能继续执行下去。</p>
<p>PostgreSQL使用等待图的死锁判断机制，自动检测并预防死锁现象的产生，即把其中将引发死锁的事务中止掉，<br>从而避免死锁现象。Informix可以设置等待时间，如果等待超时，则自动把引发死锁的事务中止掉，从而避免死锁现象。<br>InnoDB除了提供等待超时机制外，还使用等待图的算法检测死锁并回滚引发死锁的当前或其他事务。</p>
<p><strong>5.锁的并发度的问题</strong></p>
<p>假设锁不区分为多种粒度，只有一种锁存在，则并发度为0；而如果只有读写锁，只有读–读操作被允许同时进行，并发度为25%。<br>之后讨论的SCO（参见2.3.4节）技术，使得读–写操作不阻塞，即只有写–读、写–写操作不能并发，并发度被提高到50%。之后讨论的MVCC<br>结合封锁（参见2.2.4节）技术，使得读–写、写–读操作互不阻塞，即只有写–写操作不能并发，<br>并发度被提高到75%（这就是MVCC被广为使用的原因）。</p>
<p>另外，锁的封锁范围，也影响了封锁协议的并发度。</p>
<p>在数据库系统编程实现中，锁可以施加在一个表对象上，也可以施加在一个页面上，<br>还可以施加在一个元组上，分别对应的就是我们常说的表级锁、页级锁、行级锁。</p>
<h6 id="2-2-2-基于时间戳的并发控制方法"><a href="#2-2-2-基于时间戳的并发控制方法" class="headerlink" title="2.2.2　基于时间戳的并发控制方法"></a>2.2.2　基于时间戳的并发控制方法</h6><p>基于时间戳的并发控制技术，是根据事务开始的时间戳值和其他事务的读写操作的时间戳值做比较来决定<br>冲突发生时事务该如何处理。时间戳排序协议保证任何有冲突的Read和Write操作按时间戳顺序执行。<br>而时间戳的值，是事务开始时，由数据库事务管理器直接赋予的（物理时间值或递增的数值），这个时间戳值不再发生变化。</p>
<p>基于时间戳的并发控制技术分为几种情况处理读操作或写操作：</p>
<p>另外，基于时间戳的并发控制协议，不会产生死锁，这是为什么呢？</p>
<p>基于前面的分析，我们可以看到，当有冲突发生的时候，新进入事务调度器被判断为存<br>在冲突的事务立即被回滚，所以不会存在事务形成互为等待的环，因此，死锁现象不会发生。</p>
<p><strong>1.基于时间戳的并发调度算法</strong></p>
<p>在实践中，基于时间戳的并发调度算法[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Timestamp-based_concurrency_control]">https://en.wikipedia.org/wiki/Timestamp-based_concurrency_control]</a><br>实现如下，基本原理如上，不再详细描述</p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_8.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img_8.png"></p>
<p><strong>2.Thomas写法则</strong></p>
<p>在基于时间戳的并发控制技术中，有一项改进措施，称为“Thomas写法则”，其对应的情况如表2-8所示。</p>
<p>表2-8　Thomas write rule：<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_9.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img_9.png"></p>
<p>“Thomas写法则”有助于改进基于时间戳的并发控制效率，使得特定情况的写操作被“节省”因而提高了执行效率。<br>但是，如果事务T2在t7时刻不提交而是中止，则会存在一个潜在的问题：被中止的事务T2覆盖了数据项Z的旧值，Z的旧值和旧的写时间戳应该被恢复。<br>需要调度器保存数据项Z的旧值以便需要恢复时使用，这为事务调度器增加了负担。<strong>现实的数据库管理系统中，<br>几乎没有单纯使用基于时间戳排序的并发控制方法的（T0和其他算法常结合使用）。</strong></p>
<h6 id="2-2-3-基于有效性检查的并发控制方法"><a href="#2-2-3-基于有效性检查的并发控制方法" class="headerlink" title="2.2.3　基于有效性检查的并发控制方法"></a>2.2.3　基于有效性检查的并发控制方法</h6><p>在上一节，我们讨论了基于时间戳排序的并发控制技术，基于有效性检查的并发控制技术和基于时间戳的技术有很大相似之处，<br>所以本节我们换一种讨论方式，先讨论这两种技术的相同点和差异，借助时间戳排序技术理解有效性检查的并发控制技术。<br>如表2-9所示。</p>
<p>表2-9　基于时间戳排序的并发控制技术与基于有效性检查的并发控制技术的比较表<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_10.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img_10.png"></p>
<p>基于有效性检查的并发控制技术（validation protocol），对于每一个事务，在其生命周期中被划分为两个或三个阶段，<br>每个事务必须按如下顺序依次执行：<br>读阶段（read phase）、有效性检查阶段（validation phase）、写阶段（write phase）</p>
<h6 id="2-2-4-基于MVCC的并发控制方法"><a href="#2-2-4-基于MVCC的并发控制方法" class="headerlink" title="2.2.4　基于MVCC的并发控制方法"></a>2.2.4　基于MVCC的并发控制方法</h6><p>多版本并发控制（Multiversion concurrency control，MVCC）技术，核心思想是：</p>
<p>（1）当事务Ti执行一个读操作，并发控制器选择一个版本进行读取，这个版本的获取，依赖于事务Ti所能读取的数据的<br>上下文；这个上下文（有个通俗名称，叫做事务的快照，快照要和多版本相配合）是事务Ti在数据库系统里的当前并发执<br>行的诸多事务的状态的一份拷贝，其中的信息能够帮助判断：获取到的元组是否对本事务是可读取的 （元组可见性判断）？</p>
<p>（2）多版本并发控制技术不是一个可独立使用的事务并发控制技术，而是需要基于其他并发控制技术，如基于时间戳<br>的称为“多版本时间戳排序机制（multiversion timestamp-ordering scheme）”，基于两阶段封锁协议的称<br>为“多版本两阶段封锁协议（multiversion two-phase locking protocol）”。如下分别讨论这两种并发控制技术，<br>并如表2-10所示进行比较。</p>
<p>表2-10　两种MVCC并发控制技术比较表<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_11.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img_11.png"></p>
<p><strong>1.多版本时间戳排序机制</strong></p>
<p>首先，数据库系统在事务开始前赋予一个时间戳，记为TS（Ti），这个时间戳则决定了并发的事务的调度顺序。</p>
<p>其次，对于每个数据项X，多版本体现在：X有一个版本序列&lt;X1，X2，…，Xn&gt;，其中，每个版本Xi包括三个字段，分别是：</p>
<pre><code class="hljs">·Xi=value，value是数据项X的第i个版本的值，每个版本是由一个写操作生成的。
·W-timestamp（Xi）是创建Xi这个版本的事务的时间戳（不是当前时间戳值），即表明此数据项是被谁在什么时候创建的。
·R-timestamp（Xi）是所有成功读取Xi这个版本的事务的时间戳。
</code></pre>
<p>再次，多版本时间戳排序机制通过如下规则，保证可串行性：</p>
<pre><code class="hljs">如果事务Ti执行Read操作或Write操作，假设Xm表示X满足如下条件的版本，其写时间戳是小于或等于TS（Ti）的最大写时间戳（确保了在所有版本中找到一个“最近版本”）。

如果事务Ti执行读操作Read（X），返回给事务Ti的值为Xm。读永远不会被阻塞 。

如果事务Ti执行写操作Write（X）：

（1）且如果TS（Ti）&lt;R-timestamp（Xm），则中止事务Ti，这表明即将执行的这个写操作之后的时间上已经发生
过了一个读操作，如果允许写操作成功，则可能发生不可重复读异常现象。这是写–读冲突，事务Ti被中止。注意这一点
，发生此种情况的时候，是因为事务Ti的写操作本来在物理时间上早于对Xm这个版本的其他事务的读操作，但因为并发
执行是无序的，导致调度器在判断“TS（Ti）&lt;R-timestamp（Xm）”时刻之前，R-timestamp（Xm）已经发生了。所以才
能有“TS（Ti）&lt;R-timestamp（Xm）”这种现象发生。

（2）且如果TS（Ti）=W-timestamp（Xm），则系统更新事务Ti的值Xm为新值，这表明本事务多次写过同一个数据项，新值覆盖旧值。

（3）且如果TS（Ti）&gt;W-timestamp（Xm），则系统为事务Ti的数据项X创建一个新值。这说明后发生的事务才创建新的版本。这是写–写冲突，导致产生新版本。
</code></pre>
<p><strong>2.多版本两阶段封锁协议</strong></p>
<p>首先，每个数据项X，其多版本体现在：X有一个版本序列&lt;X1，X2，…，Xn&gt;，其中，每个版本Xi包括一个时间戳，<br>多数数据库中，这个时间戳对应的是唯一的一个事务标识，叫做事务号。</p>
<p>其次，事务分为两种类型，一种是只读事务（有的数据库系统号称支持“只读事务”，就是因为使用了多版本两阶段封锁协议。如PostgreSQL<br>的事务并发控制技术采取的就是多版本两阶段封锁协议，然后对只读事务做了优化。） ，另外一种是更新事务。这意味着需要事先知道事务的读写请求、<br>进而告知事务管理器，事务管理器才能区分事务的类型然后根据类型做出一定的优化<br>（多数多版本两阶段封锁协议的事务管理器都采取了一定措施为只读事务做了优化）。</p>
<p>在表2-10中，我们提到的读操作，对应着SQL语句的SELECT操作，这样的操作，在快照隔离技术中，<br>可以做到读不加锁。但是，“读”操作的另外一层含义，是“获取”，即某SQL语句需要先获取到数据，<br>然后才能操作数据，这样的获取，又很多时候，也被称为“读”操作，这算是一种不严谨的说法。例如在MVCC并<br>发控制方法中，不严谨的说法里“读”操作可以细分为两种情况：</p>
<pre><code class="hljs">快照读（snapshot read）：读取的是元组的可见版本（可见的含义是获取在快照允许的事务范围内的版本，这样的版本可能是历史版本），
不用加锁。如InnoDB使用UNDO日志帮助获取快照范围内的历史版本以支持简单的SELECT查询操作。

当前读（current read）：读取的是记录的最新版本，被当前读返回的元组会加上锁，保证其他事务不会再并发修改这条元组。
如InnoDB中把UPDATE、INSERT、DELETE操作视为特殊操作，这样的操作需要读取数据，
属于当前读，也属于前面谈及的不严谨的“读”操作。
</code></pre>
<h6 id="2-2-5-基于MVCC的可串行化快照隔离并发控制方法"><a href="#2-2-5-基于MVCC的可串行化快照隔离并发控制方法" class="headerlink" title="2.2.5　基于MVCC的可串行化快照隔离并发控制方法"></a>2.2.5　基于MVCC的可串行化快照隔离并发控制方法</h6><p>Serializable Snapshot Isolation，可串行化的快照隔离，简称SSI。</p>
<p>首先，这种技术，基于MVCC中的多版本，也基于快照隔离的思想。</p>
<p>其次，为了解决快照隔离的写偏序异常问题，引入了本项改进技术。</p>
<p>第三，SSI因基于SI（快照隔离）所以整体流程与SI相同，只是增加了一些“book-keeping”记录下事务的一些信息以便动态地检测是否有<br>写偏序现象的发生（工程实现中是检测可能有写偏序发生而不是一定 是写偏序发生，所以存在误判的可能，<br>这么做是为了提高检测的效率），如果有，则回滚引发写偏序异常的事务。</p>
<p>可序列化的快照隔离技术的主要内容，参见论文《Serializable Isolation for Snapshot Databases》。下面我们分三个方面，来探讨SSI的具体技术实现。</p>
<p><strong>1.理论基础</strong></p>
<p>检测写偏序的理论基础依赖于两篇论文：</p>
<pre><code class="hljs">·《Weak Consistency：A Generalized Theory and Optimistic Implementations for Distributed Transactions》：
定义了“读写依赖（rw-dependency）”，通过读写依赖表明不可串行化 必然是一个环内存在两个读写边于多版本可串行化图
（the multiversion serialization graph，简称MVSG）中。

·《Making snapshot isolation serializable》：定义了“读写依赖（rw-dependency）”的扩展形式，表明前
述的两条边相邻且每条边的两个端点代表着不同的活动状态下的事务。
</code></pre>
<p>上述两篇论文，实则在表明并发事务之间的读写操作是怎么造成事务的“冲突行为”（1.2.2节）之间的逻辑关系的。</p>
<p>利用上述两篇论文，可以构造出并发事务如何形成一个环，环存在表明事务之间相互依赖以至于形成了写偏序异常，<br>所以解决写偏序异常的方式就是打破环，回滚使环形成的新加入事务，从而破解写偏序异常现象。</p>
<p>xxxxxxxxxxxxxxxxxxx</p>
<h6 id="2-2-6-再深入探讨三种读数据异常现象"><a href="#2-2-6-再深入探讨三种读数据异常现象" class="headerlink" title="2.2.6　再深入探讨三种读数据异常现象"></a>2.2.6　再深入探讨三种读数据异常现象</h6><p>Q6：表1-11中，不可重复读现象中的事务T2在t2时刻执行“提交Commit”或不执行“Commit”会有什么差别吗？<br>或者对于幻象现象，事务T2在t2时刻没有执行“Commit”，这一点与不可重复读有差别吗？</p>
<pre><code class="hljs">对于“不可重复读异常”现象，如果并发控制技术使用的是两阶段封锁协议，事务T2在t1时刻不会被阻塞，所以事务T2能够在t2时刻提交。而事务T1在t3时刻读取数据的操作如果被允许，则会发生“不可重复读异常”现象，所以“可重复读”隔离级别下事务T1在t3时刻读取数据的操作将失败（即用事务T1的失败来避免“不可重复读异常”现象发生） 。
但是如果使用了多版本并发控制协议，事务T1读取的数据是旧版本的数据不受事务T2在t1时刻写的新版本的数据影响，
因而能避免“不可重复读异常”现象。

对于“幻象异常”现象，在t1时刻，因为事务T2已经在相同数据项上施加了写锁（更新锁或排它锁），事务T1被阻塞不能在
t2时刻执行读操作。但如果是基于多版本的封锁并发控制技术（参见2.2.4节），t2时刻事务T1的这个读操作不会被阻塞，
通常情况下，不被阻塞的读操作会出现“不可重复读异常”现象，但是因为使用了多版本，即事务T1读取的数据是旧版本的
数据不受事务T2在t1时刻写的新版本的数据影响，因而能避免“幻象异常”现象。
</code></pre>
<p>在商业或开源的数据库系统实现中，对于幻象的处理，还需要细分上一段文字所述的情况：</p>
<p>Q7：表2-5中，row是一个什么级别的数据？</p>
<p>对于行存数据库，row可以是以行为单位的行或行中的某些列。其含义是一个“数据项”。</p>
<p>Q8：表2-5中，幻象一定要带有WHERE条件子句吗？</p>
<p>不是。没有WHERE相当于WHERE<TRUE>即表示所有行满足条件。</TRUE></p>
<h5 id="2-3-并发控制技术的比较"><a href="#2-3-并发控制技术的比较" class="headerlink" title="2.3　并发控制技术的比较"></a>2.3　并发控制技术的比较</h5><p>事务的并发调度，主要包括两个方面和一个效果：</p>
<pre><code class="hljs">一是事务的读操作和写操作等之间的关系、即如何解决（阻塞还是允许）冲突行为（读–写、写–读、写–写）。

二是并发事务间的提交/中止的顺序。

一个效果是指每一种并发控制技术所讨论的就是在上面的两条规则限定下，并发度如何被提高。
即并发执行的效率问题。
</code></pre>
<h6 id="2-3-1-并发控制技术整体比较"><a href="#2-3-1-并发控制技术整体比较" class="headerlink" title="2.3.1　并发控制技术整体比较"></a>2.3.1　并发控制技术整体比较</h6><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_12.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img_12.png"></p>
<p>①协议改进后（在事务的末尾执行写操作，在写操作正在执行时，其他事务不允许访问已经写过的数据项）可保证可恢复性。</p>
<p>②协议改进后（在事务的末尾执行写操作，在写操作正在执行时，其他事务不允许访问已经写过的数据项）可保证无级联性。</p>
<p>③写操作可能引起事务的回滚。</p>
<p>④某个版本的写时间戳小于最老的事务的时间戳，则可被删除。</p>
<p>⑤与两阶段封锁协议的差别在于，树形协议需要事先知道访问数据项的顺序，如适用于执行存储过程。</p>
<p>⑥有多种技术可以改进多粒度封锁协议，使得减少死锁发生的频度，或者消除死锁（H.F.Korth“Deadlock Freedom Using Edge Locks”）。</p>
<p>⑦写操作可能导致封锁等待或死锁。</p>
<p>⑧某个版本的写时间戳小于等于最老的只读事务的时间戳，则可被删除。</p>
<p>⑨一系列冲突的短事务会引起长事务反复重启。</p>
<p>⑩事务回滚后又被自动重启。重启是有效性检查协议明显地区别于其他并发控制技术的特点之一。</p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_13.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img_13.png"><br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_14.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img_14.png"></p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_15.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img_15.png"></p>
<p>①更新锁步被共享锁阻塞，所以更新带来的写操作可以执行；插入操作需要检查是否满足谓词锁如满足谓词锁则在可串行化隔离级别下被阻塞，所以表格中写为“不一定”。</p>
<p>②读–写冲突中，写操作被回滚或不被回滚都有可能，取决于写事务的时间戳值与读操作的时间戳的比较，详情参见2.2.2节。</p>
<p>③写–读冲突中，读操作被回滚或不被回滚都有可能，取决于读事务的时间戳值与写操作的时间戳的比较，详情参见2.2.2节。</p>
<h6 id="2-3-2-S2PL和SS2PL的比较"><a href="#2-3-2-S2PL和SS2PL的比较" class="headerlink" title="2.3.2　S2PL和SS2PL的比较"></a>2.3.2　S2PL和SS2PL的比较</h6><p>在2.2.1节，我们讨论了S2PL和SS2PL的基本内容，本节对这两项技术参照图2-6做一个详细对比。</p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_16.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img_16.png"></p>
<h6 id="2-3-3-事务属性与并发控制技术的关系"><a href="#2-3-3-事务属性与并发控制技术的关系" class="headerlink" title="2.3.3　事务属性与并发控制技术的关系"></a>2.3.3　事务属性与并发控制技术的关系</h6><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_17.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img_17.png"></p>
<p>图分为上下两部分，上面的部分写有“noninherently blocking properties”，表明不存在因并发而致使某些<br>操作被阻塞。下面的部分写有“inherently blocking properties”，表明存在因并发而致使某些操作被阻塞。</p>
<h6 id="2-3-4-SCO和SS2PL的比较"><a href="#2-3-4-SCO和SS2PL的比较" class="headerlink" title="2.3.4　SCO和SS2PL的比较"></a>2.3.4　SCO和SS2PL的比较</h6><p>还有一种并发控制技术，提交排序（Commitment ordering，CO）详情参见1.4.2节和<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Commitment_ordering">https://en.wikipedia.org/wiki/Commitment_ordering</a> 。SCO就是CO技术的一个变种。如图2-8所示。</p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_18.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img_18.png"></p>
<p>SS2PL：强两阶段封锁协议Strong strict two-phase locking protocol，事务T1先于事务T2，两者可以并发执行，对于同一个数据项X事务T1的读操作r1（X）先于事务T2的写操作w2（X）发生，事务T2的写操作被延迟，即只有事务T1提交&#x2F;撤销后，事务T2才能提交。所以读操作会阻塞写操作（“读–写”操作）。这样并发度被降低 （如图，<br>事务T2的写操作被延迟，等事务T1结束后，事务T2用了一段时间为t的提交时间段才能完成提交&#x2F;撤销）。</p>
<p>SCO：严格提交排序Strict Commitment Ordering，事务T1先于事务T2，两者可以并发执行，对于同一个数据项X事务T1的读操作r1（X）先于事务T2的写操作w2（X）发生，但是，事务T2的写操作被允许执行，只是事务T2的提交&#x2F;撤销操作被延迟，等到事务T1提交&#x2F;撤销后，事务T2才能提交或撤销。所以读操作不会阻塞写操作。这样并发度被提高。</p>
<h6 id="2-3-5-TO和SS2PL的比较"><a href="#2-3-5-TO和SS2PL的比较" class="headerlink" title="2.3.5　TO和SS2PL的比较"></a>2.3.5　TO和SS2PL的比较</h6><p>在2.2.1节我们讨论了基于封锁的机制SS2PL，在2.2.2节讨论了基于时间戳的排序协议TO，这是两种并发控制技术，都可以用于并发事务间保证数据一致性。但是，这两种技术之间，有什么不同呢？</p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_19.png" srcset="/内存泄漏排查/loading.gif" lazyload alt="img_19.png"></p>
<p>所以，SS2PL满足“可恢复性”而TO不满足“可恢复性”。《数据库系统概念（第六版）》一书15.4.2节谈到了一些弥补TO不具备“可恢复性”缺陷的技术，以保证事务的调度是可恢复的，本书不再赘述，请参阅相关书籍和资料。</p>
<h5 id="2-4-深入探讨隔离级别"><a href="#2-4-深入探讨隔离级别" class="headerlink" title="2.4　深入探讨隔离级别"></a>2.4　深入探讨隔离级别</h5><p>2.1节讲述了ANSI SQL标准定义的四种隔离级别，这四种隔离级别应对的是1.1.3节探讨的ANSI SQL标准定义的三种读数据异常现象，而且ANSI SQL标准是在数据库的基于锁的并发控制技<br>术下定义的，所以三种读数据异常、四种隔离级别和基于锁的并发控制技术之间的关系着密不可分。</p>
<p>2.2节讲述了多种并发控制技术，这些技术首先要保证并发事务的可串行性，其次要提升并发事务的执行效率，各种并发控制技术从不同角度提出了以上两个问题的解决方式。从可串行性的角度看，各种并发控制技术实则确保的是隔离级别中的最高级别“可串行化”。</p>
<p>除“可串行化”隔离级别外的其他的隔离级别，目的在于降低数据一致性的严格要求，提高并发事务的并发度。我们在2.2节讲述并发控制技术中没有提及，本节从其他隔离级别的角度来探讨各种并发控制技术是如何实现这些隔离级别的。</p>
<h6 id="2-4-1-隔离级别与基于锁的并发控制方法"><a href="#2-4-1-隔离级别与基于锁的并发控制方法" class="headerlink" title="2.4.1　隔离级别与基于锁的并发控制方法"></a>2.4.1　隔离级别与基于锁的并发控制方法</h6>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/BOOK/" class="category-chain-item">BOOK</a>
  
  
    <span>></span>
    
  <a href="/categories/BOOK/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/" class="category-chain-item">数据库事务处理的艺术</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/book/" class="print-no-link">#book</a>
      
        <a href="/tags/database/" class="print-no-link">#database</a>
      
        <a href="/tags/transactions/" class="print-no-link">#transactions</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>ch2 深入理解事务管理和并发控制技术</div>
      <div>http://smilemzy.com/2025/05/05/DB/数据库事务处理的艺术/ch02/ch2/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Smile</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch03/ch03/" title="ch3. Informix事务管理与并发控制">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ch3. Informix事务管理与并发控制</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/" title="ch1. 数据库管理系统的事务原理">
                        <span class="hidden-mobile">ch1. 数据库管理系统的事务原理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
