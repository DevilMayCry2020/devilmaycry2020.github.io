

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Smile">
  <meta name="keywords" content="">
  
    <meta name="description" content="介绍ch1. 数据库管理系统的事务原理 数据库管理系统（DataBase Management System，DBMS，以下简称“数据库”），是位于用户与操作系统之间的一层数据管理软件，功能主要包括：数据定义、数据操纵、数据库的运行管理、数据库的建立和维护等。 数据库的事务处理机制，是数据库技术的基石。掌握数据库技术，必须要掌握事务处理的技术，这样才能把握数据库的核心技术。同时，也必须了解数据库为">
<meta property="og:type" content="article">
<meta property="og:title" content="ch1. 数据库管理系统的事务原理">
<meta property="og:url" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/index.html">
<meta property="og:site_name" content="Smile">
<meta property="og:description" content="介绍ch1. 数据库管理系统的事务原理 数据库管理系统（DataBase Management System，DBMS，以下简称“数据库”），是位于用户与操作系统之间的一层数据管理软件，功能主要包括：数据定义、数据操纵、数据库的运行管理、数据库的建立和维护等。 数据库的事务处理机制，是数据库技术的基石。掌握数据库技术，必须要掌握事务处理的技术，这样才能把握数据库的核心技术。同时，也必须了解数据库为">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_1.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_2.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_3.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_4.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_5.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_6.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_7.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_8.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_9.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_10.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_11.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_12.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_13.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_14.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_15.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_16.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_17.png">
<meta property="og:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_18.png">
<meta property="article:published_time" content="2025-05-05T12:24:15.464Z">
<meta property="article:modified_time" content="2025-05-05T13:24:33.841Z">
<meta property="article:author" content="Smile">
<meta property="article:tag" content="book">
<meta property="article:tag" content="database">
<meta property="article:tag" content="transactions">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://smilemzy.com/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img.png">
  
  
  
  <title>ch1. 数据库管理系统的事务原理 - Smile</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"smilemzy.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Smile</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="ch1. 数据库管理系统的事务原理"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-05 20:24" pubdate>
          2025年5月5日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          8.2k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          69 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">ch1. 数据库管理系统的事务原理</h1>
            
            
              <div class="markdown-body">
                
                <h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch1. 数据库管理系统的事务原理</p>
<p>数据库管理系统（DataBase Management System，DBMS，以下简称“数据库”），是位于用户与操作系统之间的一层数据管理软件，<br>功能主要包括：数据定义、数据操纵、数据库的运行管理、数据库的建立和维护等。</p>
<p>数据库的事务处理机制，是数据库技术的基石。掌握数据库技术，必须要掌握事务处理的技术，这样才能把握数据库的核心技术。<br>同时，也必须了解数据库为什么会需要事务处理技术，即事务处理技术要解决的问题，<br>这一点，就是我们在第一章第一节开门见山地提出的问题。</p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-1-事务模型要解决的问题"><a href="#1-1-事务模型要解决的问题" class="headerlink" title="1.1 事务模型要解决的问题"></a>1.1 事务模型要解决的问题</h5><h6 id="1-1-1-为什么需要事务处理机制"><a href="#1-1-1-为什么需要事务处理机制" class="headerlink" title="1.1.1 为什么需要事务处理机制"></a>1.1.1 为什么需要事务处理机制</h6><p><strong>数据库为什么需要事务处理机制？</strong></p>
<p>我们先回避问题，绕道看如下的一个实际用户操作，从A账户转账50元到B账户，其过程如表1-1所示。</p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img.png" srcset="/img/loading.gif" lazyload alt="img.png"></p>
<p><strong>事务处理机制，就是要保证用户的数据操作动作对数据是“安全的”。</strong><br>那么，什么样的操作是安全的呢？数据只有在带有“ACID”四个特性的事务处理机制的保障下，才可以认为是“安全的”。</p>
<h6 id="1-1-2-事务机制要处理的问题——事务故障、系统故障、介质故障"><a href="#1-1-2-事务机制要处理的问题——事务故障、系统故障、介质故障" class="headerlink" title="1.1.2　事务机制要处理的问题——事务故障、系统故障、介质故障"></a>1.1.2　事务机制要处理的问题——事务故障、系统故障、介质故障</h6><h6 id="1-1-3-并发带来的问题——三种常见的读数据异常现象"><a href="#1-1-3-并发带来的问题——三种常见的读数据异常现象" class="headerlink" title="1.1.3　并发带来的问题——三种常见的读数据异常现象"></a>1.1.3　并发带来的问题——三种常见的读数据异常现象</h6><p>数据不在ACID特性的保护下会发生不一致的现象，那么：</p>
<p><strong>在ACID的保护下，是不是数据就一定不会产生不一致的现象呢？</strong></p>
<p>在关系数据库系统中，多个会话（session）可以访问同一个数据库的同一个表的同一行数据。<br>这样，对于数据而言，就意味着在同一个时间段内，有多个会话可以对其施加操作（或读操作或写操作），<br>读写操作施加的顺序不同以及事务中A特性对事务结果的影响（或成功或失败，即要么提交要么中止），<br>这三种因素叠加在一起，会存在几种对数据有不同影响的情况：</p>
<pre><code class="hljs">读–读操作 ：如果同时只存在多个读操作，对于数据自身则没有影响；既读和读操作互不影响数据的一致性，
读读操作可以并发执行。

读–写操作 ：如果读写操作都存在，因写在前读在后（如脏读 现象）、读在前写在后（如不可重复读现象），
或者读在前写在后然后又读（如幻象 现象），就可能因数据被写而导致另外一个读操作的会话读到错误的数据 。
这个操作可以根据动作发生的先后顺序被细分为读–写操作、写–读操作。

写–写操作 ：如果同时存在多个写操作，写–写操作直接改变了数据在同一时刻的语义，这就更不被允许，
所以写–写操作通常不允许被并发执行。但是，如果不做并发控制，写–写并发操作也会带来数据异常现象
（1.1.4节探讨写–写操作引发的异常）。
</code></pre>
<p>这三种情况的第二种，对应了SQL标准中定义的三种数据异常的现象，注意这三种异常都是针对某个事务（第2.2.1节称这样的事务为“主事务”）的读操作而言的。<br>SQL2003标准对于数据异常现象的定义如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">隔离级别指定了在并发SQL事务执行过程中可能发生的现象类型。以下是可能出现的现象：<br><br>1) P1（“脏读”）：SQL事务T1修改了一行数据。随后，SQL事务T2在T1执行COMMIT之前读取了该行。<br>如果T1之后执行了ROLLBACK，那么T2将读取到一个从未被提交的数据行，因此可以认为这条记录实际上从未存在过。<br><br>2) P2（“不可重复读”）：SQL事务T1读取了一行数据。接着，SQL事务T2修改或删除了这行数据并执行了COMMIT。<br>当T1尝试再次读取该行时，它可能会得到修改后的值，或者发现该行已经被删除。<br><br>3) P3（“幻读”）：SQL事务T1读取满足某些&lt;搜索条件&gt;的一组数据行N。然后，SQL事务T2执行了一些SQL语句，<br>生成了一个或多个也满足T1所用&lt;搜索条件&gt;的新行。如果T1使用相同的&lt;搜索条件&gt;重复最初的读取操作，<br>它会获得一组不同的数据行。<br></code></pre></td></tr></table></figure>

<p>下面，我们把SQL标准的话语转为一个表格（如表1-2所示），以更好地理解一下三种异常现象。</p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_1.png" srcset="/img/loading.gif" lazyload alt="img_1.png"></p>
<p>脏读现象 ：按照时间顺序，T1事务在t0时刻对row进行了修改（更新），T2事务在t1时刻先读取了被T1修改了的row的值，<br>但是T1在t2时刻中止使得对row的修改失效。如果数据库引擎不支持因并发操作避免数据异常，<br>则T2在t1时刻读到的就是T1修改后的数据，但是这个数据在现实世界中不存在，对于事务T2而言，<br>读取了被回滚掉的数据，即事务T2发生了脏读异常现象。另外，对于脏读现象，还存在如表1-3的两种变形情况。</p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_2.png" srcset="/img/loading.gif" lazyload alt="img_2.png"></p>
<p>不可重复读现象 ：事务T1在t0时刻先读取row的旧值，事务T2在t1时刻对row进行了修改（更新或删除）<br>然后提交事务使得修改生效，此时row因更新变为了新值或因删除而不再存在。接下来，事务T1在t3时刻再次读取<br>row对象的值但是row的值已经是新值或者不存在了。对于事务T1而言，物是（同样是读row这个对象）人非（值已经和<br>t0时刻读到的值不同），事务T1发生了不可重复读异常现象。</p>
<p>幻象现象 ：事务T1在t0时刻带有特定条件地读取了row对象的数据，事务T2在t1时刻插入新的数据或更新其他旧数据但满<br>足事务T1的特定WHERE条件，新的数据满足与事务T1同样的条件，当事务T1在t3时刻再次以同样的条件读取数据的时候，<br>rows对象的值已经有新加入的行（因插入而比第一次读多出了数据）。对于事务T1而言，物是<br>（同样是读满足“<condition>”条件的多个row对象）人非（值已经和t0时刻读到的值不同），<br>事务T1发生了幻象异常现象。幻象又称为幻读，即第二次读操作读取了第一次读操作没有读到的rows（一行或多行）。</condition></p>
<p><strong>在ACID的保护 下，是不是数据就一定不会产生不一致的现象呢？</strong></p>
<p>答案已经很明确：即使数据库系统提供ACID，除非我们使用“可串行化（SERIALIZABLE）”隔离级别，<br>否则数据在其他不同的隔离级别下还会产生数据不一致的现象。</p>
<h6 id="1-1-4-并发带来的问题——写–写并发操作引发的数据异常现象"><a href="#1-1-4-并发带来的问题——写–写并发操作引发的数据异常现象" class="headerlink" title="1.1.4　并发带来的问题——写–写并发操作引发的数据异常现象"></a>1.1.4　并发带来的问题——写–写并发操作引发的数据异常现象</h6><p>上一节，我们探讨了三种读数据异常现象，请注意，异常现象发生在一个事务中后面的READ读操作上。<br>这三种读数据异常现象被SQL标准定义。那么：</p>
<p><strong>是不是对数据的并发操作只会产生上述的三种读数据异常现象？</strong></p>
<p>事务概念的奠基人，Jim Grey先生，在其著作《事务处理：概念与技术》中提到了一个“Lost Update”异常的概念，<br>字面含义是“更新丢失”，这是一个写操作的异常，与上一节提到的三种读操作异常不同。</p>
<p>除了“Lost Update”异常外，这一节我们还将探讨另外一种异常，如表1-4所示。</p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_3.png" srcset="/img/loading.gif" lazyload alt="img_3.png"></p>
<p>脏写现象 ：按照时间顺序，事务T1在t0时刻对row进行了修改（更新），事务T2在t1时刻对row进行了修改（更新），<br>如果没有并发控制，T2对row的修改会生成新值，但是T1在t3时刻回滚使得T2对row的修改失效，<br>而T1的语义是：T1自身对row的修改失效，这就把T2修改的值回滚掉。对于事务T1而言，回滚掉了不是自己修改的数据，<br>即事务T1上发生了脏写现象。</p>
<p>丢失更新现象 ：按照时间顺序，事务T2在t1时刻对row进行了修改（更新），事务T1在t2时刻对row进行了修改（更新），<br>如果没有并发控制，T1对row的修改会生成新值，但是T1在t3时刻提交使得T2对row的修改失效。对于事务T1而言，<br>覆盖掉了不是自己修改的数据，即事务T1上引发了丢失更新现象（t3时刻如果是事务T2提交而不是事务T1提交，<br>也是丢失更新，只是事务T2上引发了丢失更新现象）。</p>
<p>不管是读异常还是写异常，并发控制技术都要规避这些异常，保证数据在不同隔离级别下一致性不被破坏。</p>
<h6 id="1-1-5-语义约束引发的数据异常现象"><a href="#1-1-5-语义约束引发的数据异常现象" class="headerlink" title="1.1.5　语义约束引发的数据异常现象"></a>1.1.5　语义约束引发的数据异常现象</h6><p><strong>在ACID和快照隔离级别技术（多版本）的保护下，是不是数据就一定不再会产生不一致的现象呢？</strong></p>
<p>快照隔离并发技术是多版本并发控制（Multiversion concurrency control，MVCC）技术的一部分，其发生作用，<br>需基于“数据项存在多个版本”。</p>
<p>快照隔离并发控制技术的缺点，是并不能真正保证事务为“可串行化的”，即事务间的并发操作依旧会引发数据异常现象，<br>但是这里的数据异常现象有别于前面提到的各种异常现象，其异常现象是“业务的逻辑语义”引发的，即除了抽象的读写操作，<br>数据间还应该满足一定语义，即约束（constraint）。</p>
<p>在快照隔离并发控制技术中并发的事务因不满足约束而发生的异常，称为“写偏序（Write Skew）”，<br>这样的异常有两种，参见表1-5。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">Dan R. K. Ports，Kevin Grittner，Serializable Snapshot Isolation in PostgreSQL<br></code></pre></td></tr></table></figure>

<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_4.png" srcset="/img/loading.gif" lazyload alt="img_4.png"></p>
<p>二个事务引发的异常现象 （简单写偏序，Simple Write Skew）：按照时间顺序，T1事务在t0时刻读取了<br>在打电话的值班医生个数，T2事务在t1时刻也读取了在打电话的值班医生个数。事务T1在t2时刻进行判断：<br>如果在打电话的值班医生个数大于等于2人则请Alice停止打电话。事务T2在t3时刻进行判断：如果在打电话的值班医生个<br>数大于等于2人则请Bob停止打电话。然后事务T1和T2分别提交。如果在这种并发的情况下，允许事务T1和T2都提交成功，<br>则t6时刻，Alice和Bob都停止了打电话。如果串行执行事务，先执行事务T1后执行事务T2，Alice会停止打电话但Bob不<br>会停止，这与前一种情况的结果不同；如果先执行事务T2后执行事务T1，Bob会停止打电话但Alice不会停止，这与前一<br>种情况的结果也不同；这表明前一种并发执行是非序列化的，而此时，事务T1、T2并发时违反了约束（约束为：如果同<br>时打电话的人数大于等于2人则请Alice或Bob其中一个人停止打电话直到同时打电话的人数少于2人）发生了写偏序异常<br>现象。对于简单写偏序，可以用一个形象化的图表示，如图1-1所示。</p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_5.png" srcset="/img/loading.gif" lazyload alt="img_5.png"></p>
<p>三个事务引发的异常现象 （Batch Processing）：对于这种情况，后两个并发更新事务T3和T2是可串行化的且不存在<br>任何异常，但是一个只读事务T1出现在某个时刻却可能正好造成问题。所出现的问题是这样的，当事务T3提交时，T2处<br>于活跃状态，这时，事务T1启动要读取事务T2和T3涉及的数据（current_batch和receipts），这时，事务T1的快照包<br>括了事务T3的插入后的结果（因为T3已经提交）；但是，事务T2没有提交，它的插入操作数据不包含在事务T1的快照中。<br>在优先图（如图1-2所示）中会造成一个环（有关如何形成这样的环，参见2.2.5节），说明这样的调度是非可串行化的。</p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_6.png" srcset="/img/loading.gif" lazyload alt="img_6.png"></p>
<p>本节所述的这两种情况，如果使用优先图表示，都可以在参与操作的事务之间，画出一个环，存在环说明：调度是非可串行化的 。<br>为解决这样的问题，要求数据库引擎必须在事务提交时（甚至是环一形成即立刻回滚其中的一个事务）而不是在<br>快照上检查完整性约束，以避免本节所述的不一致现象。</p>
<p><a target="_blank" rel="noopener" href="https://wiki.postgresql.org/wiki/SSI#Read_Only_Transactions">https://wiki.postgresql.org/wiki/SSI#Read_Only_Transactions</a></p>
<h6 id="1-1-6-其他的异常"><a href="#1-1-6-其他的异常" class="headerlink" title="1.1.6　其他的异常"></a>1.1.6　其他的异常</h6><p>在《A Critique of ANSI SQL Isolation Levels》这篇论文中，除了上面提到的几种异常现象外，还提到了另外两种异常，如表1-6和表1-7所示。</p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_7.png" srcset="/img/loading.gif" lazyload alt="img_7.png"></p>
<p>事务T1在t0时刻读出数据x，事务T2在t1时刻对数据x和y进行了修改在t2时刻提交，事务T1在t3时刻读取y，y是被事务T2修改后的数据，<br>此时已经不是t0时刻事务T1读取x时对应的y值，数据形成了不一致状态（注意此时不是数据x处于不一致，而是y处于不一致）。</p>
<p>游标（Cursor），是数据库引擎提供的一种读取数据的方式。在数据库中，为了防止使用游标时其他事务并发<br>修改游标所包括的数据，定义了游标稳定性 （Cursor Stability）隔离级别 ，这样的隔离级别，是在读取当前数据<br>项的时刻，在数据项上加锁，当游标从当前数据项移走则解锁，此后曾经被读取过的数据项不再被并发保护（尽管使用<br>游标的事务没有提交或中止，还处于活动状态）。但是，在使用游标的时候，也会发生写–写异常，如表1-7所示。</p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_8.png" srcset="/img/loading.gif" lazyload alt="img_8.png"></p>
<p>游标丢失更新现象 ：按照时间顺序，事务T1在t0时刻读取row的值后，即释放了row上的锁使得row没有被并发保护，<br>事务T2在t1时刻对row进行了修改（更新），事务T1在t2时刻对row进行了修改（更新），如果没有并发控制，T1对row的<br>修改会生成新值，但是T1在t4时刻提交使得T2对row的修改失效。对于事务T1而言，覆盖掉了不是自己修改的数据，<br>即事务T1上引发了丢失更新现象。这样的现象，本质上就是丢失更新，只是发生在了游标上，所以称为游标丢失更新。</p>
<p>如下我们借用《A Critique of ANSI SQL Isolation Levels》这篇论文中的一张表，来简单总结一下前面几节所谈到的各种异常。</p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_9.png" srcset="/img/loading.gif" lazyload alt="img_9.png"></p>
<h6 id="1-1-7-深入探讨三种读数据异常现象"><a href="#1-1-7-深入探讨三种读数据异常现象" class="headerlink" title="1.1.7　深入探讨三种读数据异常现象"></a>1.1.7　深入探讨三种读数据异常现象</h6><p><strong>Q1：异常现象是发生在表1-2中的事务T1还是事务T2？</strong></p>
<p>数据异常现象，一定是发生在本事务当中的。我们统一以事务T1为本事务（也称为“主事务”），<br>观察本事务和其他并发事务之间因读写操作的先后次序不同而造成的不同的数据异常。因此，我们修正表1-2的内容如表1-9所示。</p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_10.png" srcset="/img/loading.gif" lazyload alt="img_10.png"></p>
<p>对于Q1问题的回答，依据表1-9，数据异常现象发生在表1-9中的主事务T1中。<br>其实，如上修改是为了明确并发事务的数据异常现象发生在哪里。即研究别的事务对于本事务的影响，<br>而不是讨论本事务对别的事务的影响。</p>
<p><strong>动作发生的主体，一定是主事务。而且，异常是发生在主事务的读操作这样的动作上（指三种读异常）。</strong></p>
<p><strong>Q2：从表1-9中看，对于脏读现象，写操作是事务T2执行UPDATE引发的，那么，事务T2的写操作可以是删除（DELETE）<br>或插入（INSERT）吗？</strong></p>
<p><strong>Q3：对于不可重复读现象，事务T2的写操作是否可以是插入操作？</strong></p>
<p><strong>Q4：不可重复读和幻象有什么区别？</strong></p>
<p>首先，这两种异常，对于主事务T1而言，都是先读取了数据，之后因事务T2“写”了数据而事务T1再次读取数据的时候，发生了异常。<br>不可重复读对于事务T1读取的是一个存在的确定的一行数据 （意味着这行数据是存在的数据）变；<br>而幻象对于事务T1读取的是满足条件“<condition>”的多行数据<br>（意味着“<condition>”是一个范围查找，结果集不确定）。</condition></condition></p>
<p>其次，不可重复读对于事务T2的写操作是更新或删除操作，而幻象对于事务T2的写操作是插入（插入的新数据满足条件）<br>或更新（使不满足条件的数据在更新后满足条件）操作。</p>
<p>第三，不可重复读和幻象最大的区别就是前者只需要“锁住”（考虑）已经读过的数据，而幻象需要对“还不存在的数据”做出预防。</p>
<p><strong>Q5：对于幻象现象，事务T2的写操作是否可以是更新操作或者删除操作？</strong></p>
<p>对于幻象现象中事务T2的W（rows）操作，如果操作是一个更新或删除操作，则表明这样的操作等同于（相似但不完全一样，<br>区别参见Q6）不可重复读（即是在多个行数据上进行更新或删除，即在多个行数据上批量化重演了不可重复读现象）。<br>实际上，幻象是不可重复读的一个特例。</p>
<p>表1-10　幻象的写操作改为更新则等同于不可重复读<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_11.png" srcset="/img/loading.gif" lazyload alt="img_11.png"></p>
<p><strong>Q6：表1-11中，不可重复读现象中的事务T2在t2时刻执行“Commit”或不执行“Commit”会有什么差别吗？或者对于幻象现象，<br>事务T2在t2时刻没有执行“Commit”，这一点与不可重复读有差别吗？</strong></p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_12.png" srcset="/img/loading.gif" lazyload alt="img_12.png"></p>
<h5 id="1-2-事务处理技术的原理"><a href="#1-2-事务处理技术的原理" class="headerlink" title="1.2 事务处理技术的原理"></a>1.2 事务处理技术的原理</h5><p>本节我们来讨论解决上述各种异常现象的事务模型及其相关技术，从整体上理解事务的概念以及相关的技术之间的联系。</p>
<h6 id="1-2-1-什么是事务"><a href="#1-2-1-什么是事务" class="headerlink" title="1.2.1　什么是事务"></a>1.2.1　什么是事务</h6><p>ANSI SQL标准:</p>
<p>SQL事务（transaction）是一系列SQL语句的执行序列，从恢复的角度来看它是原子性的。<br>也就是说：要么执行结果完全成功，要么它对任何SQL模式或SQL数据都没有影响。</p>
<p>Jim Gray:</p>
<p>事务是一组SQL命令，其结果将在事务提交时作为一个整体对系统其余部分可见——如果事务中止，<br>则这些结果完全不会对外部可见。事务预期具有原子性、一致性、隔离性和持久性。</p>
<p>ACID–</p>
<p>原子性（Atomicity）或是“all”或是“nothing”</p>
<p>一致性（Consistency）符合逻辑语义</p>
<p>隔离性（Isolation） “并发”看起来像是“串行”。“隔离级别”是为了提高并发度、<br>从而弱化了数据在并发读写下的“一致性”（如写偏序）</p>
<p>持久性（Durability）对于“committed”状态的数据，要能够永久保存</p>
<h6 id="1-2-2-事务的属性"><a href="#1-2-2-事务的属性" class="headerlink" title="1.2.2　事务的属性"></a>1.2.2　事务的属性</h6><p>如果说ACID是事务的特性，那么，可串行化（Serializability）、<br>可恢复性（Recoverability）、严格性（Strictness）则可以称为事务的属性。</p>
<p><strong>1.可串行化（Serializability）</strong></p>
<p>冲突行为 （Conflicting actions）又称为冲突动作，当有两个动作满足如下三个条件，则这两个动作是冲突的：</p>
<p>冲突等价 （Conflict equivalence）对于不同的事务调度方式S1和S2，如果满足如下两个条件，<br>则事务调度方式S1和S2是等价的：</p>
<pre><code class="hljs">S1和S2调度方式包括同样的事务集合（每一个事务中的操作的顺序是固定的，不能在不同的调度方式下发生变化）；
S1和S2调度方式包括同样的冲突操作集合。
</code></pre>
<p>冲突可串行化 （Conflict-serializable）当某个调度是一个“冲突等价”于一个或多个“串行调度”，则这个调度是“冲突可串行化”的。</p>
<p>可串行化概念的作用在于保证并发的事务调度方式既能满足数据一致性需求，又能提高并发事务的执行效率。</p>
<p><strong>2.可恢复性（Recoverability）</strong></p>
<p>可恢复性是并发的事务后期、表明提交阶段事务间相互影响的属性。即：已经提交的事务没有读过被中止的事务的写数据。<br>否则脏读异常发生，导致数据不一致。所以可恢复性属性保证的是多个事务并发调度后期的提交顺序对数据的一致性没有影响。</p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_13.png" srcset="/img/loading.gif" lazyload alt="img_13.png"></p>
<p>避免级联中止</p>
<p><strong>3.严格性（Strictness）</strong></p>
<p>严格性概念的作用在于保证：有冲突动作（前述的“冲突行为（Conflicting actions）”）的并发的事务中 ，<br>先发生写操作的事务提交或中止的操作优先于其他事务。 </p>
<p>前面讲述了事务的多个属性，这些属性从属于事务的调度方式，属性之间从概念上存在一个语义包含的关系，如图1-3所示。</p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_14.png" srcset="/img/loading.gif" lazyload alt="img_14.png"></p>
<pre><code class="hljs">从串行化的角度看，如图中纵向的方框，串行化的严格程度从松到严的次序为：all schedules→view serializable→conflict serializable→serial。
从可恢复性的角度看，如图中横向的方框，严格程度从松到严的次序为：recoverable→avoids cascading aborts→strictness→serial。
最核心的是“serial”，“serial”能够保证数据的一致性，但是其执行效率低。所以在确保数据一致性的前提下，不同的调度方式致力于提高并发执行的效率，使得数据库的事务管理器能够高效地运行。
各种并发技术，就是致力于保证在并发的事务调度正确性的前提下，提高事务管理器的事务并发调度的效率。多种并发控制技术含义就是针对并发事务的不同的调度方式。
</code></pre>
<h6 id="1-2-3-ACID的实现技术"><a href="#1-2-3-ACID的实现技术" class="headerlink" title="1.2.3　ACID的实现技术"></a>1.2.3　ACID的实现技术</h6><p><strong>请简洁地总结一下哪些技术是分别实现ACID中的A的？哪些是实现C、I、D的？</strong></p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_15.png" srcset="/img/loading.gif" lazyload alt="img_15.png"></p>
<h5 id="1-3-事务的模型"><a href="#1-3-事务的模型" class="headerlink" title="1.3 事务的模型"></a>1.3 事务的模型</h5><p>Jim Gray的《事务处理概念与技术》一书的第四章事务模型</p>
<p>平板事务（Flat Transactions）事务块中的所有SQL语句，构成一个逻辑单元，要么都成功，要么因之一失败都回滚。（PG不考虑savepoint）</p>
<p>带有保存点的平板事务（Flat Transactions With Savepoints）PostgreSQL、InnoDB、Informix在平板事务的基础上，支持了保存点技术。</p>
<p>链式事务（Chained Transactions）InnoDB的事务模型，就是链式事务的代表（这句话不是说InnoDB不支持平板事务，<br>实际上InnoDB支持平板事务、支持带有保存点的平板事务、支持链式事务，并通过XA技术支持下面谈到的分布式事务）</p>
<p>嵌套事务（Nested Transactions）PostgreSQL、MySQL（不是InnoDB，InnoDB是被Oracle收购之后才逐渐并入MySQL的）没有对嵌套事务通过支持。</p>
<p>分布式事务（Nested Transactions）</p>
<p>多层次事务（Multi-Level Transactions）</p>
<h5 id="1-4-并发控制技术"><a href="#1-4-并发控制技术" class="headerlink" title="1.4 并发控制技术"></a>1.4 并发控制技术</h5><p>并发控制技术是实现原子性、一致性和隔离性的重要技术之一，是本书的重点。</p>
<p>发控制技术的本质，就是要对并发的事务实现正确的（保证数据的一致性、保证事务操作的原子性）、<br>高效的（用“可串行性&#x2F;可恢复性&#x2F;严格性”实现可并发，部分情况下牺牲一致性，或用低级别的隔离性容忍不一致以提高并发执行效率）调度。</p>
<h6 id="1-4-1-并发控制技术的实现策略"><a href="#1-4-1-并发控制技术的实现策略" class="headerlink" title="1.4.1　并发控制技术的实现策略"></a>1.4.1　并发控制技术的实现策略</h6><p>并发控制技术，从实现的思路角度看，有两类，是事后检查还是提前预防。</p>
<p>乐观 （Optimistic concurrency control，OCC）：从一开始，每一项操作都允许进行，但在事务提交的时刻，<br>进行隔离性和完整性约束的检查，如果有违反则事务被中止。显然，如果并发冲突少的场景，乐观并发控制方法是适合的。<br>2.2.3节讨论的基于有效性确认的并发控制方法就是乐观的。</p>
<p>悲观 （Pessimistic concurrency control，PCC）：从一开始，即检查每一项操作是否会违反隔离性和完整性约束，<br>如果可能违反，则阻塞这样的操作。如两阶段封锁，用读锁来阻塞另外一个事务的写锁。就是因为另外一个事务的写操作可能<br>会造成如1.1.3节提到的读异常，因此两阶段封锁技术属于悲观的方法，提前对异常现象进行了预防。基于时间戳排序的并发控制技<br>术也是悲观的。</p>
<h6 id="1-4-2-并发控制技术的实现技术"><a href="#1-4-2-并发控制技术的实现技术" class="headerlink" title="1.4.2　并发控制技术的实现技术"></a>1.4.2　并发控制技术的实现技术</h6><p><strong>1、时间戳 （Timestamp ordering，TO）：基于时间戳对事务提交顺序排序的并发控制技术。</strong></p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_16.png" srcset="/img/loading.gif" lazyload alt="img_16.png"></p>
<p>时间戳并发控制技术用来确保在访问冲突的情况下，多个事务按照时间戳的顺序来访问数据项。 如果TS（Ti）&lt;TS（Tj），那么数据库事物<br>管理器必须保证所产生的调度等价于事务Ti出现在事务Tj之前的某个串行调度。</p>
<p><strong>2、Commitment ordering（或Commit ordering，CO）：提交排序是对提交操作的顺序进行排序，这种方式是“冲突可串行化”的一个特例：</strong></p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_17.png" srcset="/img/loading.gif" lazyload alt="img_17.png"></p>
<p>CO被主要用于分布式事务处理</p>
<p><strong>3、串行化图形检测 （Serialization graph checking）：也称为优先图&#x2F;冲突图&#x2F;串行化图（Precedence graph、conflict graph、serializability graph）检测</strong></p>
<p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_18.png" srcset="/img/loading.gif" lazyload alt="img_18.png"></p>
<p><strong>4、两阶段封锁 （Two-phase locking，2PL）</strong></p>
<p>首先，两阶段封锁强调的是“加锁（增长阶段，growing phase）和解锁（缩减阶段，shrinking phase）这两项操作，<br>且每项操作各自为一个阶段”，这就是说不管同一个事务 内需要在多少个数据项上加锁，所有的加锁操作都只能在同一个阶段完成，<br>在这个阶段内，不允许对对已经加锁的数据项进行解锁操作，即加锁和解锁操作不能交叉执行（同一个事务内） 。<br>这一条是说在同一个事务内部的事情。</p>
<p>其次，为了提高并发度，才对锁进行分类，分出共享锁（读锁）和排它锁（写锁），因这两种类型的锁，又产生加两种锁共四种事务因并发受影响的情况：</p>
<pre><code class="hljs">（1）第一种情况（两个事务并发读同一个数据项）
（2）读–写并发是不允许的，即第二种情况
（3）二是对数据项施加了排它锁，这使得其他事务在这个数据项上的读操作（第三种情况）或写操作（第四种情况）都被禁止
这一条是说在多个事务之间的事情。多个事务之间比较锁是否兼容，用到了锁的兼容性列表，就是上面的四种情况
只是当锁的类型被扩展后，增加了意向锁等类型，才使得锁的兼容性列表变大，不再是四种情况，而是更多种。
</code></pre>
<p>第三，共享锁是允许向排它锁升级的，排它锁是允许向共享锁降级的，升级（upgrade）和降级（downgrade）操作，称为锁转换（lock conversion）。</p>
<p>升降级发生在同一个事务内部，但目的也是为了提高多个事务之间的并发度。</p>
<p>两阶段的含义是指在同一个事务内，对所涉及的所有数据项进行先加锁，然后才对所有的数据项解锁。但两阶段封锁第一阶段加共享锁后影响了其他事务<br>的写操作、加排它锁后影响了其他事务的读操作（读受影响更不用提写），所以较大地影响了其他事务的运行<br>（如果不操作相同数据项则互不影响）。只有第二阶段释放了所有的数据项上的锁之后，才能运行其他要操作相同数据项的事务。</p>
<p>按提交操作的时机不同，两阶段锁可以分为S2PL和SS2PL两种方式。</p>
<p>并发控制技术，有一些不单独使用，而是配合其他并发控制技术一起使用，用以改善主并发控制技术以提高并发度<br>（所以需要特别注意这些技术的适用范围和缺点，其缺点正是需要使用其他并发控制技术弥补)。</p>
<p><strong>多版本并发控制技术 （Multiversion concurrency control（MCC or MVCC））</strong></p>
<p>事务管理器为写操作生成一个数据项的新版本；当有读操作发生时，按照读操作所在事务开始阶段获得的活动事务的快照、找出应该读取的该数据项的某个版本。<br>读–写操作或写–读操作不会互相阻塞，只留有写–写操作互相阻塞，进一步提高了并发度。<br>为了进一步提高并发的效率，多种并发控制技术协同使用效果更好。如封锁协议+MVCC，前者只有读–读不被阻塞，<br>后者只有写–写阻塞。这两个协议组合后使得基于封锁协议的读–写、写–读不被阻塞。</p>
<p>但是，这里描述的只有早期MVCC的技术（这些技术目前在PostgreSQL、InnoDB中被广泛使用），其关键点在于<br>解决“写–写”并发冲突，但是这样的MVCC技术不能避免“写偏序”数据异常。有一种较新的MVCC技术，<br>称为“write-snapshot isolation”的技术，致力于解决“读–写”冲突且能做到“可串行化”，比常规的MVCC技术<br>更加提升了并发度。详情可参阅论文《A Critique of Snapshot Isolation》。<br>分布式数据库CockrocachDB就采用了此篇论文提及的“write-snapshot isolation”技术。</p>
<p><strong>基于索引的并发控制技术 （Index concurrency control）</strong></p>
<p>索引树上对索引页采取封锁手段，以维护索引树的一致性；同时，可以确保避免幻象异常，如MySQL的InnoDB存储引擎以B+树作为存储的基本结构<br>（即索引组织表），可以在索引树上直接施加“next-key locking”进行范围锁定，以避免在谓词限定的“谓词空间”内新数据被<br>插入或旧数据被删除。</p>
<h5 id="1-5-日志技术与恢复子系统"><a href="#1-5-日志技术与恢复子系统" class="headerlink" title="1.5 日志技术与恢复子系统"></a>1.5 日志技术与恢复子系统</h5><p>日志技术是有效实现原子性和持久性的重要技术之一。</p>
<p>数据库引擎实现时，日志产生后被保存到日志缓存区，然后被刷出到外存，存放到日志文件中。</p>
<p>有的数据库系统，日志文件是不重用的，如PostgreSQL的日志文件名称是连续增长的，而使用文件组等概念的<br>数据库系统如Oracle、Informix，<br>它们的日志文件是重用的。不重用的日志文件，能够容忍长事务存在，而重用的日志文件因事务太长导致所有的日志文件用光了<br>的话，会因无日志文件可用导致数据库系统不得不挂起，如Informix。</p>
<p>在系统运行期间，REDO日志要求执行COMMIT操作的COMMIT日志的记录要先于被修改的数据项到达外存（即预写日志技术）。</p>
<p>在系统故障发生后，系统恢复期间，通常要使用REDO和UNDO日志来做恢复，这时，有两种策略可以选择：</p>
<p>策略一：恢复时，使用REDO日志只重做已经提交了的事务，如PostgreSQL如此实现，这样省却了UNDO日志（PostgreSQL没有实现UNDO日志）。</p>
<p>策略二：恢复时，使用REDO日志重做所有事务，包括未提交的事务和回滚了的事务，然后通过UNDO日志回滚那些未提交的事务<br>（未成功的事务一定不能以新值覆盖旧值，即撤销新值对旧值的影响），如InnoDB如此实现。</p>
<h5 id="1-6-本章小结"><a href="#1-6-本章小结" class="headerlink" title="1.6 本章小结"></a>1.6 本章小结</h5><p>本章初步讨论了事务模型要解决的问题以及所使用的技术。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/BOOK/" class="category-chain-item">BOOK</a>
  
  
    <span>></span>
    
  <a href="/categories/BOOK/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/" class="category-chain-item">数据库事务处理的艺术</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/book/" class="print-no-link">#book</a>
      
        <a href="/tags/database/" class="print-no-link">#database</a>
      
        <a href="/tags/transactions/" class="print-no-link">#transactions</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>ch1. 数据库管理系统的事务原理</div>
      <div>http://smilemzy.com/2025/05/05/DB/数据库事务处理的艺术/ch01/ch1/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Smile</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年5月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/" title="ch2 深入理解事务管理和并发控制技术">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ch2 深入理解事务管理和并发控制技术</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch13/ch13/" title="ch13. 不常见的数据类型">
                        <span class="hidden-mobile">ch13. 不常见的数据类型</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
