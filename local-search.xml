<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>跟我一起写Makefile</title>
    <link href="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/"/>
    <url>/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>跟我一起写Makefile</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="Chapter-1-概述"><a href="#Chapter-1-概述" class="headerlink" title="Chapter 1 概述"></a>Chapter 1 概述</h5><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image.png" alt="alt text"></p><h6 id="1-1-关于程序的编译和链接"><a href="#1-1-关于程序的编译和链接" class="headerlink" title="1.1 关于程序的编译和链接"></a>1.1 关于程序的编译和链接</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image1.png" alt="alt text"></p><h5 id="Chapter-2-makefile介绍"><a href="#Chapter-2-makefile介绍" class="headerlink" title="Chapter 2 makefile介绍"></a>Chapter 2 makefile介绍</h5><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-1.png" alt="alt text">  </p><h6 id="2-1-关于程序的编译和链接"><a href="#2-1-关于程序的编译和链接" class="headerlink" title="2.1 关于程序的编译和链接"></a>2.1 关于程序的编译和链接</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-3.png" alt="alt text"><br>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于  prerequistes 中的文件，其生成规则定义在command中。说白一点就是：  </p><p>prerequistes中如果有一个以上的文件比target文件要新的话，recipe所定义的命令就会被执行。<br>这就是makefile的规则，也就是makefile中最核心的内容。  </p><h6 id="2-2-一个示例"><a href="#2-2-一个示例" class="headerlink" title="2.2 一个示例"></a>2.2 一个示例</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-4.png" alt="alt text"><br><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-5.png" alt="alt text">  </p><h6 id="2-3-make-是如何工作的"><a href="#2-3-make-是如何工作的" class="headerlink" title="2.3 make 是如何工作的"></a>2.3 make 是如何工作的</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-6.png" alt="alt text">  </p><h6 id="2-4-make中使用变量"><a href="#2-4-make中使用变量" class="headerlink" title="2.4 make中使用变量"></a>2.4 make中使用变量</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-7.png" alt="alt text">  </p><h6 id="2-5-让make自动推导"><a href="#2-5-让make自动推导" class="headerlink" title="2.5 让make自动推导"></a>2.5 让make自动推导</h6><p>GNU的make很强大，它可以自动推导文件以及文件的依赖关系后面的命令。<br><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-8.png" alt="alt text">  </p><h6 id="2-6-makefile的另一种风格"><a href="#2-6-makefile的另一种风格" class="headerlink" title="2.6 makefile的另一种风格"></a>2.6 makefile的另一种风格</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-9.png" alt="alt text">  </p><h6 id="2-7-清空目录的规则"><a href="#2-7-清空目录的规则" class="headerlink" title="2.7 清空目录的规则"></a>2.7 清空目录的规则</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-10.png" alt="alt text">  </p><h6 id="2-8-Makefile里有什么"><a href="#2-8-Makefile里有什么" class="headerlink" title="2.8 Makefile里有什么"></a>2.8 Makefile里有什么</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-11.png" alt="alt text">  </p><h6 id="2-9-Makefile的文件名"><a href="#2-9-Makefile的文件名" class="headerlink" title="2.9 Makefile的文件名"></a>2.9 Makefile的文件名</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-12.png" alt="alt text">  </p><h6 id="2-10-包含其他Makefile"><a href="#2-10-包含其他Makefile" class="headerlink" title="2.10 包含其他Makefile"></a>2.10 包含其他Makefile</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-13.png" alt="alt text">  </p><h6 id="2-11-环境变量-MAKEFILES"><a href="#2-11-环境变量-MAKEFILES" class="headerlink" title="2.11 环境变量 MAKEFILES"></a>2.11 环境变量 MAKEFILES</h6><h6 id="2-12-make的工作方式"><a href="#2-12-make的工作方式" class="headerlink" title="2.12 make的工作方式"></a>2.12 make的工作方式</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-14.png" alt="alt text">  </p><h5 id="Chapter-3-书写规则"><a href="#Chapter-3-书写规则" class="headerlink" title="Chapter 3 书写规则"></a>Chapter 3 书写规则</h5><p>1、依赖关系<br>2、生成目标的方法<br><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-15.png" alt="alt text">  </p><h6 id="3-1-规则举例"><a href="#3-1-规则举例" class="headerlink" title="3.1 规则举例"></a>3.1 规则举例</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-16.png" alt="alt text">  </p><h6 id="3-2-规则的语法"><a href="#3-2-规则的语法" class="headerlink" title="3.2 规则的语法"></a>3.2 规则的语法</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-17.png" alt="alt text">  </p><h6 id="3-3-在规则中使用通配符"><a href="#3-3-在规则中使用通配符" class="headerlink" title="3.3 在规则中使用通配符"></a>3.3 在规则中使用通配符</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-18.png" alt="alt text"><br><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-19.png" alt="alt text">  </p><h6 id="3-4-文件搜寻"><a href="#3-4-文件搜寻" class="headerlink" title="3.4 文件搜寻"></a>3.4 文件搜寻</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-20.png" alt="alt text">  </p><h6 id="3-5-伪目标"><a href="#3-5-伪目标" class="headerlink" title="3.5 伪目标"></a>3.5 伪目标</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-21.png" alt="alt text"><br><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-22.png" alt="alt text"><br><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-23.png" alt="alt text">  </p><h6 id="3-6-多目标"><a href="#3-6-多目标" class="headerlink" title="3.6 多目标"></a>3.6 多目标</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-24.png" alt="alt text">  </p><h6 id="3-7-静态模式"><a href="#3-7-静态模式" class="headerlink" title="3.7 静态模式"></a>3.7 静态模式</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-25.png" alt="alt text"><br><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-26.png" alt="alt text">  </p><h6 id="3-8-自动生成依赖性"><a href="#3-8-自动生成依赖性" class="headerlink" title="3.8 自动生成依赖性"></a>3.8 自动生成依赖性</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-27.png" alt="alt text"><br><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-28.png" alt="alt text"><br><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-29.png" alt="alt text">  </p><h5 id="Chapter-4-书写命令"><a href="#Chapter-4-书写命令" class="headerlink" title="Chapter 4 书写命令"></a>Chapter 4 书写命令</h5><p>我们在 UNIX 下可能会使用不同的 Shell，但是 make 的命令默认是被 &#x2F;bin&#x2F;sh ——UNIX 的标准<br>Shell 解释执行的。除非你特别指定一个其它的 Shell。Makefile 中，# 是注释符，很像 C&#x2F;C++ 中的 &#x2F;&#x2F;<br>，其后的本行字符都被注释。  </p><h6 id="4-1-显示命令"><a href="#4-1-显示命令" class="headerlink" title="4.1 显示命令"></a>4.1 显示命令</h6><p>@echo 向屏幕显示消息<br>带入make参数 -n 或 –just-print，那么只是显示命令，但不会执行，这个功能有利于调试。<br>而参数 -s 或 –silent 或 –quiet 则是全面禁止命令的显示。  </p><h6 id="4-2-命令执行"><a href="#4-2-命令执行" class="headerlink" title="4.2 命令执行"></a>4.2 命令执行</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-30.png" alt="alt text">  </p><h6 id="4-3-命令出错"><a href="#4-3-命令出错" class="headerlink" title="4.3 命令出错"></a>4.3 命令出错</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-31.png" alt="alt text">  </p><h6 id="4-4-嵌套执行make"><a href="#4-4-嵌套执行make" class="headerlink" title="4.4 嵌套执行make"></a>4.4 嵌套执行make</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-32.png" alt="alt text"><br><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-33.png" alt="alt text"><br><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-34.png" alt="alt text">  </p><h6 id="4-5-定义命令包"><a href="#4-5-定义命令包" class="headerlink" title="4.5 定义命令包"></a>4.5 定义命令包</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-35.png" alt="alt text">  </p><h5 id="Chapter-5-使用变量"><a href="#Chapter-5-使用变量" class="headerlink" title="Chapter 5 使用变量"></a>Chapter 5 使用变量</h5><p>变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有: 、#、&#x3D;或是空字符（空格、回车等）。<br>变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile 的变量名是全大写的命名方式，<br>但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情</p><h6 id="5-1-变量的基础"><a href="#5-1-变量的基础" class="headerlink" title="5.1 变量的基础"></a>5.1 变量的基础</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-36.png" alt="alt text"><br><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-37.png" alt="alt text">  </p><h6 id="5-2-变量中的变量"><a href="#5-2-变量中的变量" class="headerlink" title="5.2 变量中的变量"></a>5.2 变量中的变量</h6><p>第一种方式，也就是简单的使用&#x3D;号，在&#x3D;左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，<br>也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。<br>另一种用变量来定义变量的方法。这种方法使用的是:&#x3D;操作符，，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。<br><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-38.png" alt="alt text">  </p><h6 id="5-3-变量高级用法"><a href="#5-3-变量高级用法" class="headerlink" title="5.3 变量高级用法"></a>5.3 变量高级用法</h6><p>第一种是变量值的替换。<br>我们可以替换变量中的共有的部分，其格式是$(var:a&#x3D;b) 或是 ${var:a&#x3D;b} ，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。<br>这里的“结尾”意思是“空格”或是“结束符”。<br><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-39.png" alt="alt text"><br>第二种高级用法是——“把变量的值再当成变量”。<br><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-40.png" alt="alt text">  </p><h6 id="5-4-追加变量值"><a href="#5-4-追加变量值" class="headerlink" title="5.4 追加变量值"></a>5.4 追加变量值</h6><p>+&#x3D;</p><h6 id="5-5-override-指令"><a href="#5-5-override-指令" class="headerlink" title="5.5 override 指令"></a>5.5 override 指令</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-41.png" alt="alt text">  </p><h6 id="5-6-多行变量"><a href="#5-6-多行变量" class="headerlink" title="5.6 多行变量"></a>5.6 多行变量</h6><p>define two-lines<br>echo foo<br>echo $(bar)<br>endef  </p><h6 id="5-7-环境变量"><a href="#5-7-环境变量" class="headerlink" title="5.7 环境变量"></a>5.7 环境变量</h6><p>如果我们在环境变量中设置了CFLAGS环境变量，那么我们就可以在所有的Makefile中使用<br>这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么<br>则会使用Makefile 中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很<br>像“全局变量”和“局部变量”的特性。<br>当make 嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变<br>量的方式传递到下层的Makefile 中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义<br>在文件中的变量，如果要向下层Makefile传递，则需要使用export关键字来声明。（参见前面章节）  </p><h6 id="5-8-目标变量"><a href="#5-8-目标变量" class="headerlink" title="5.8 目标变量"></a>5.8 目标变量</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-42.png" alt="alt text">  </p><h6 id="5-9-模式变量"><a href="#5-9-模式变量" class="headerlink" title="5.9 模式变量"></a>5.9 模式变量</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-43.png" alt="alt text">  </p><h5 id="Chapter-6-使用条件判断"><a href="#Chapter-6-使用条件判断" class="headerlink" title="Chapter 6 使用条件判断"></a>Chapter 6 使用条件判断</h5><h6 id="6-1-实例"><a href="#6-1-实例" class="headerlink" title="6.1 实例"></a>6.1 实例</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-44.png" alt="alt text">  </p><h6 id="6-2-语法"><a href="#6-2-语法" class="headerlink" title="6.2 语法"></a>6.2 语法</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-45.png" alt="alt text"><br><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-46.png" alt="alt text"><br>ifneq 其比较参数arg1和arg2的值是否相同，如果不同，则为真。<br>ifdef 如果变量<variable-name>的值非空，那到表达式为真。否则，表达式为假。当然，<variable-name><br>同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。<br><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-47.png" alt="alt text"><br>ifndef<br>你最好不要把自动化变量（如$@等）放入条件表达式中，因为自动化变量是在运行时才有的.<br>而且为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。  </variable-name></variable-name></p><h5 id="Chapter-7-使用函数"><a href="#Chapter-7-使用函数" class="headerlink" title="Chapter 7 使用函数"></a>Chapter 7 使用函数</h5><p>在Makefile 中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。<br>函数调用后，函数的返回值可以当做变量来使用。  </p><h5 id="Chapter-8-make的运行"><a href="#Chapter-8-make的运行" class="headerlink" title="Chapter 8 make的运行"></a>Chapter 8 make的运行</h5><h6 id="8-1-make的退出码"><a href="#8-1-make的退出码" class="headerlink" title="8.1 make的退出码"></a>8.1 make的退出码</h6><p>0 – 成功<br>1 – 出现任何错误，返回1<br>2 – 如果你使用了make的 -q 选项，并且make使得一些目标不需要更新，则返回2  </p><h6 id="8-2-指定makefile"><a href="#8-2-指定makefile" class="headerlink" title="8.2 指定makefile"></a>8.2 指定makefile</h6><p>make -f pgxs.mk  </p><h6 id="8-3-指定目标"><a href="#8-3-指定目标" class="headerlink" title="8.3 指定目标"></a>8.3 指定目标</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-48.png" alt="alt text">  </p><h6 id="8-4-检查规则"><a href="#8-4-检查规则" class="headerlink" title="8.4 检查规则"></a>8.4 检查规则</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-49.png" alt="alt text">  </p><h6 id="8-5-make的参数"><a href="#8-5-make的参数" class="headerlink" title="8.5 make的参数"></a>8.5 make的参数</h6><p><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-50.png" alt="alt text"><br><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-51.png" alt="alt text"><br><img src="/2025/05/05/DB/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile/Makefile/image-52.png" alt="alt text">  </p><h5 id="Chapter-9-隐含规则"><a href="#Chapter-9-隐含规则" class="headerlink" title="Chapter 9 隐含规则"></a>Chapter 9 隐含规则</h5>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>makefile</category>
      
    </categories>
    
    
    <tags>
      
      <tag>makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch2. 信息的表示和处理</title>
    <link href="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/"/>
    <url>/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch2. 信息的表示和处理</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>bit – 位<br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_1.png" alt="img_1.png"><br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img.png" alt="img.png">  </p><h5 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h5><p>虚拟内存<br>虚拟地址空间<br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_2.png" alt="img_2.png"></p><h6 id="2-1-1-十六进制表示法"><a href="#2-1-1-十六进制表示法" class="headerlink" title="2.1.1 十六进制表示法"></a>2.1.1 十六进制表示法</h6><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_3.png" alt="img_3.png">  </p><h6 id="2-1-2-字数据大小"><a href="#2-1-2-字数据大小" class="headerlink" title="2.1.2 字数据大小"></a>2.1.2 字数据大小</h6><p>字长 – 指明指针数据的标称大小，字长决定着虚拟地址空间的大小<br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_4.png" alt="img_4.png"></p><h6 id="2-1-3-寻址和字节顺序"><a href="#2-1-3-寻址和字节顺序" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h6><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_5.png" alt="img_5.png">  </p><h6 id="2-1-3-寻址和字节顺序-1"><a href="#2-1-3-寻址和字节顺序-1" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h6><h6 id="2-1-4-表示字符串"><a href="#2-1-4-表示字符串" class="headerlink" title="2.1.4 表示字符串"></a>2.1.4 表示字符串</h6><p>C语言的字符串被编码为一个以null(其值为0)字符结尾的字符数组。  </p><h6 id="2-1-5-表示代码"><a href="#2-1-5-表示代码" class="headerlink" title="2.1.5 表示代码"></a>2.1.5 表示代码</h6><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_6.png" alt="img_6.png"></p><h6 id="2-1-6-布尔代数简介"><a href="#2-1-6-布尔代数简介" class="headerlink" title="2.1.6 布尔代数简介"></a>2.1.6 布尔代数简介</h6><p>Boolean algebra<br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_7.png" alt="img_7.png"><br>位运算：<br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_8.png" alt="img_8.png">  </p><h6 id="2-1-7-C语言中的位级运算"><a href="#2-1-7-C语言中的位级运算" class="headerlink" title="2.1.7 C语言中的位级运算"></a>2.1.7 C语言中的位级运算</h6><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_9.png" alt="img_9.png">  </p><h6 id="2-1-8-C语言中的逻辑运算"><a href="#2-1-8-C语言中的逻辑运算" class="headerlink" title="2.1.8 C语言中的逻辑运算"></a>2.1.8 C语言中的逻辑运算</h6><p>与或非  </p><h6 id="2-1-8-C语言中的移位运算"><a href="#2-1-8-C语言中的移位运算" class="headerlink" title="2.1.8 C语言中的移位运算"></a>2.1.8 C语言中的移位运算</h6><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_10.png" alt="img_10.png">  </p><h5 id="2-2-整数表示"><a href="#2-2-整数表示" class="headerlink" title="2.2 整数表示"></a>2.2 整数表示</h5><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_11.png" alt="img_11.png">  </p><h6 id="2-2-1-整型数据类型"><a href="#2-2-1-整型数据类型" class="headerlink" title="2.2.1 整型数据类型"></a>2.2.1 整型数据类型</h6><p>C语言支持多种整型数据类型 – 表示有限范围的整数。<br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_12.png" alt="img_12.png"><br>负数的范围比整数的范围大1<br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_13.png" alt="img_13.png">  </p><h6 id="2-2-2-无符号数的编码"><a href="#2-2-2-无符号数的编码" class="headerlink" title="2.2.2 无符号数的编码"></a>2.2.2 无符号数的编码</h6><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_14.png" alt="img_14.png"></p><h6 id="2-2-3-补码编码"><a href="#2-2-3-补码编码" class="headerlink" title="2.2.3 补码编码"></a>2.2.3 补码编码</h6><p>补码 – two’s-complement<br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_15.png" alt="img_15.png"><br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_16.png" alt="img_16.png"><br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_17.png" alt="img_17.png"><br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_18.png" alt="img_18.png"></p><h6 id="2-2-4-有符号数和无符号数之间的转换"><a href="#2-2-4-有符号数和无符号数之间的转换" class="headerlink" title="2.2.4 有符号数和无符号数之间的转换"></a>2.2.4 有符号数和无符号数之间的转换</h6><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_19.png" alt="img_19.png"></p><h6 id="2-2-5-C语言中的有符号数与无符号数"><a href="#2-2-5-C语言中的有符号数与无符号数" class="headerlink" title="2.2.5 C语言中的有符号数与无符号数"></a>2.2.5 C语言中的有符号数与无符号数</h6><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_20.png" alt="img_20.png"><br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_21.png" alt="img_21.png"></p><h6 id="2-2-6-扩展一个数字的位表示"><a href="#2-2-6-扩展一个数字的位表示" class="headerlink" title="2.2.6 扩展一个数字的位表示"></a>2.2.6 扩展一个数字的位表示</h6><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_22.png" alt="img_22.png"></p><h6 id="2-2-7-截断数字"><a href="#2-2-7-截断数字" class="headerlink" title="2.2.7 截断数字"></a>2.2.7 截断数字</h6><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_23.png" alt="img_23.png"></p><h6 id="2-2-8-关于有符号数与无符号数的建议"><a href="#2-2-8-关于有符号数与无符号数的建议" class="headerlink" title="2.2.8 关于有符号数与无符号数的建议"></a>2.2.8 关于有符号数与无符号数的建议</h6><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_24.png" alt="img_24.png"><br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch02/ch2/img_25.png" alt="img_25.png">  </p><h5 id="2-3-整数运算"><a href="#2-3-整数运算" class="headerlink" title="2.3 整数运算"></a>2.3 整数运算</h5><p>计算机运算的有限性</p><h6 id="2-3-1-无符号加法"><a href="#2-3-1-无符号加法" class="headerlink" title="2.3.1 无符号加法"></a>2.3.1 无符号加法</h6><h6 id="2-3-2-补码加法"><a href="#2-3-2-补码加法" class="headerlink" title="2.3.2 补码加法"></a>2.3.2 补码加法</h6><h6 id="2-3-3-补码的非"><a href="#2-3-3-补码的非" class="headerlink" title="2.3.3 补码的非"></a>2.3.3 补码的非</h6><h6 id="2-3-4-无符号乘法"><a href="#2-3-4-无符号乘法" class="headerlink" title="2.3.4 无符号乘法"></a>2.3.4 无符号乘法</h6><h6 id="2-3-5-补码乘法"><a href="#2-3-5-补码乘法" class="headerlink" title="2.3.5 补码乘法"></a>2.3.5 补码乘法</h6><h6 id="2-3-6-乘以常数"><a href="#2-3-6-乘以常数" class="headerlink" title="2.3.6 乘以常数"></a>2.3.6 乘以常数</h6><h6 id="2-3-7-除以2的幂"><a href="#2-3-7-除以2的幂" class="headerlink" title="2.3.7 除以2的幂"></a>2.3.7 除以2的幂</h6><h6 id="2-3-8-关于整数运算的最后思考"><a href="#2-3-8-关于整数运算的最后思考" class="headerlink" title="2.3.8 关于整数运算的最后思考"></a>2.3.8 关于整数运算的最后思考</h6><h5 id="2-4-浮点数"><a href="#2-4-浮点数" class="headerlink" title="2.4 浮点数"></a>2.4 浮点数</h5><h6 id="2-4-1-二进制小数"><a href="#2-4-1-二进制小数" class="headerlink" title="2.4.1 二进制小数"></a>2.4.1 二进制小数</h6><h6 id="2-4-2-IEEE浮点表示"><a href="#2-4-2-IEEE浮点表示" class="headerlink" title="2.4.2 IEEE浮点表示"></a>2.4.2 IEEE浮点表示</h6><h6 id="2-4-3-数字实例"><a href="#2-4-3-数字实例" class="headerlink" title="2.4.3 数字实例"></a>2.4.3 数字实例</h6><h6 id="2-4-4-舍入"><a href="#2-4-4-舍入" class="headerlink" title="2.4.4 舍入"></a>2.4.4 舍入</h6><h6 id="2-4-5-浮点运算"><a href="#2-4-5-浮点运算" class="headerlink" title="2.4.5 浮点运算"></a>2.4.5 浮点运算</h6><h6 id="2-4-6-C语言中的浮点数"><a href="#2-4-6-C语言中的浮点数" class="headerlink" title="2.4.6 C语言中的浮点数"></a>2.4.6 C语言中的浮点数</h6>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>深入理解计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>system</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch1. 计算机系统漫游</title>
    <link href="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/"/>
    <url>/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch1. 计算机系统漫游</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。</p><h5 id="1-1-信息就是位-上下文"><a href="#1-1-信息就是位-上下文" class="headerlink" title="1.1 信息就是位 + 上下文"></a>1.1 信息就是位 + 上下文</h5><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img.png" alt="img.png"><br>hello.c这样只有ASCII字符构成的文件 – 文本文件<br>所有其他文件 – 二进制文件<br>区分不同数据对象的唯一方法 – 我们读到这些数据对象时的上下文  </p><h5 id="1-2-程序被其他程序翻译成不同的格式"><a href="#1-2-程序被其他程序翻译成不同的格式" class="headerlink" title="1.2 程序被其他程序翻译成不同的格式"></a>1.2 程序被其他程序翻译成不同的格式</h5><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_1.png" alt="img_1.png"><br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_2.png" alt="img_2.png">  </p><h5 id="1-3-了解编译系统如何工作是大有益处的"><a href="#1-3-了解编译系统如何工作是大有益处的" class="headerlink" title="1.3 了解编译系统如何工作是大有益处的"></a>1.3 了解编译系统如何工作是大有益处的</h5><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_3.png" alt="img_3.png">  </p><h5 id="1-4-处理器读并解释存储在内存中的指令"><a href="#1-4-处理器读并解释存储在内存中的指令" class="headerlink" title="1.4 处理器读并解释存储在内存中的指令"></a>1.4 处理器读并解释存储在内存中的指令</h5><p>shell</p><h6 id="1-4-1-系统的硬件组成"><a href="#1-4-1-系统的硬件组成" class="headerlink" title="1.4.1 系统的硬件组成"></a>1.4.1 系统的硬件组成</h6><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_4.png" alt="img_4.png"><br>1、总线<br>通常被设计成传送定长的字节快，即字(word)<br>字中的字节数，即字长，是一个基本的系统参数，现代大多4字节(32 bits)或8字节(64 bits).<br>2、I&#x2F;O设备<br>每个I&#x2F;O设备都通过一个控制器或适配器与I&#x2F;O总线相连。<br>控制器 – I&#x2F;O设备本身或系统的主印刷电路板(通常称作主板)上的芯片组<br>适配器 – 一块插在主板插槽上的卡<br>3、主存<br>DRAM – 动态随机存取存储器<br>4、处理器<br>CPU<br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_5.png" alt="img_5.png"><br>处理器看似是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。<br>因此，将处理器的指令集架构和处理器的微体系结构区分开来：<br>指令集架构 – 每条机器代码指令的效果<br>微体系结构 – 处理器实际上是如何实现的  </p><h6 id="1-4-2-运行hello程序"><a href="#1-4-2-运行hello程序" class="headerlink" title="1.4.2 运行hello程序"></a>1.4.2 运行hello程序</h6><p>整体上的描述。<br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_6.png" alt="img_6.png"><br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_7.png" alt="img_7.png"><br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_8.png" alt="img_8.png">  </p><h5 id="1-5-高速缓存至关重要"><a href="#1-5-高速缓存至关重要" class="headerlink" title="1.5 高速缓存至关重要"></a>1.5 高速缓存至关重要</h5><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_9.png" alt="img_9.png"><br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_10.png" alt="img_10.png">  </p><h5 id="1-6-存储设备形成层次结构"><a href="#1-6-存储设备形成层次结构" class="headerlink" title="1.6 存储设备形成层次结构"></a>1.6 存储设备形成层次结构</h5><p>在处理器和一个较大较慢的设备之间插入一个更小更快的存储设备的想法已经成为一个普遍的观念。<br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_11.png" alt="img_11.png">  </p><h5 id="1-7-操作系统管理硬件"><a href="#1-7-操作系统管理硬件" class="headerlink" title="1.7 操作系统管理硬件"></a>1.7 操作系统管理硬件</h5><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_12.png" alt="img_12.png"><br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_13.png" alt="img_13.png">  </p><h6 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h6><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_14.png" alt="img_14.png">  </p><h6 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h6><h6 id="1-7-3-虚拟内存"><a href="#1-7-3-虚拟内存" class="headerlink" title="1.7.3 虚拟内存"></a>1.7.3 虚拟内存</h6><p>虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用内存。<br>每个进程看到的内存都是一致的，成为虚拟内存空间。<br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_15.png" alt="img_15.png"><br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_16.png" alt="img_16.png"></p><h6 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h6><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_17.png" alt="img_17.png">  </p><h5 id="1-8-系统之间利用网络通信"><a href="#1-8-系统之间利用网络通信" class="headerlink" title="1.8 系统之间利用网络通信"></a>1.8 系统之间利用网络通信</h5><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_18.png" alt="img_18.png">  </p><h5 id="1-9-重要主题"><a href="#1-9-重要主题" class="headerlink" title="1.9 重要主题"></a>1.9 重要主题</h5><h6 id="1-9-1-Amdahl-定律"><a href="#1-9-1-Amdahl-定律" class="headerlink" title="1.9.1 Amdahl 定律"></a>1.9.1 Amdahl 定律</h6><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_19.png" alt="img_19.png"><br>要想显著加速整个系统，必须提升全系统中相当大的部分的速度。</p><h6 id="1-9-2-并发和并行"><a href="#1-9-2-并发和并行" class="headerlink" title="1.9.2 并发和并行"></a>1.9.2 并发和并行</h6><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_20.png" alt="img_20.png"><br><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_21.png" alt="img_21.png">  </p><h6 id="1-9-3-计算机系统中抽象的重要性"><a href="#1-9-3-计算机系统中抽象的重要性" class="headerlink" title="1.9.3 计算机系统中抽象的重要性"></a>1.9.3 计算机系统中抽象的重要性</h6><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_22.png" alt="img_22.png"></p><h5 id="1-10-小结"><a href="#1-10-小结" class="headerlink" title="1.10 小结"></a>1.10 小结</h5><p><img src="/2025/05/05/DB/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/ch01/ch1/img_23.png" alt="img_23.png"></p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>深入理解计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>system</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch6. Oracle事务管理与并发控制</title>
    <link href="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch06/ch06/"/>
    <url>/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch06/ch06/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch6. Oracle事务管理与并发控制</p><p>Oracle事务并发控制技术采用典型的SS2PL和基于快照的MVCC技术，以支持ACID，但是没有真正实现一致性。对于不同的特性，<br>分别使用了如下技术予以支持：</p><p>A：原子性，通过提供事务的完整管理模型，在系统的运行过程中实现事务的提交和回滚功能（回滚段），以支持运行原子性。<br>提供WAL日志和恢复机制，以支持恢复原子性。</p><p>C：一致性，通过提供基于封锁技术的SS2PL，以支持并发操作下元数据的一致；通过MVCC技术，以支持并发操作下用户数据的<br>一致；通过WAL日志和恢复机制以支持故障发生后的恢复一致（系统故障、介质故障）。</p><p>I：隔离性，通过“SET ISOLATION…”语句来设置满足ANSI SQL标准规定的四种隔离级别中的两种，以快照和多版本构成的<br>MVCC技术实现并发事务对同一个数据项的读写隔离，这样实现了一定的并发事务的不同场景的隔离，但没有真正实现可串行化<br>隔离级别。</p><p>D：持久性，通过预写日志（WAL）、恢复等技术实现了数据的持久化存储。</p><p>下面，将对事务管理和并发控制技术进行讨论，这些技术涉及了A、C、I这几个特性。事务管理技术与A紧密相关，<br>并发控制于C和I紧密关联。但是，我们不详细描述Oracle的并发控制技术和实现细节（Oracle数据库有着丰富的资料，<br>读者可自行搜索），而是着眼于主要的技术和内容，对比其他数据库，以期读者对事务管理和并发控制技术有更深入的认识。</p><p>《Oracle Core Essential Internals for DBAs and Developers》</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>数据库事务处理的艺术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch5. InnoDB事务管理与并发控制</title>
    <link href="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch05/ch05/"/>
    <url>/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch05/ch05/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch5. InnoDB事务管理与并发控制</p><p>InnoDB支持ACID，对于不同的特性，分别使用了如下技术予以支持：</p><p>A：原子性，通过提供事务的完整管理模型，实现事务的提交和回滚功能（回滚段），事务的自动提交功能，以支持原子性。</p><p>C：一致性，通过提供“doublewrite buffer”和“crash recovery”功能，以支持数据在运行期间的一致<br>（事务故障）和故障发生后的一致（用日志处理系统故障、介质故障）。另外，通过锁和MVCC机制来保证运行期间数据被并发修改情况下的一致。</p><p>I：隔离性，通过“SET ISOLATION LEVEL”语句来设置满足ANSI SQL标准规定的四种隔离级别，<br>实现并发事务的不同场景的隔离。通过MVCC的快照隔离实现并发事务对同一个数据项的读写隔离。</p><p>D：持久性，通过预写日志（WAL）、备份恢复、双写缓存（doublewrite buffer）等技术实现了数据的持久化存储。</p><p>下面，我们将对事务管理和并发控制技术进行讨论，这些技术涉及了A、C、I这几个特性。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>数据库事务处理的艺术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch3. PostgreSQL事务管理与并发控制</title>
    <link href="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch04/ch04/"/>
    <url>/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch04/ch04/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch4. PostgreSQL事务管理与并发控制</p><p>PostgreSQL支持ACID，对于不同的特性，分别使用了如下技术予以支持：</p><p>A：原子性，通过提供事务的完整管理模型，在系统的运行过程中实现事务的提交和回滚功能，以支持运行原子性。提供WAL日志和恢复机制，以支持恢复原子性。</p><p>C：一致性，通过提供基于封锁技术和MVCC与快照项结合的技术，以支持数据在运行期间数据被并发修改情况下的运行一致（事务故障通过回滚实现运行一致）、通过WAL日志和恢复机制以支持故障发生后的一致（系统故障、介质故障）。</p><p>I：隔离性，通过“SET TRANSACTION ISOLATION LEVEL…”语句来设置满足ANSI SQL标准规定的四种隔离级别中的三种（PostgreSQL不支持游标稳定隔离级别），实现并发事务的不同场景的隔离。通过封锁技术、以快照和多版本构成的MVCC技术实现并发事务对同一个数据项的读写隔离。</p><p>D：持久性，通过预写日志（WAL）、恢复等技术实现了数据的持久化存储。</p><p>如下，将对事务管理和并发控制技术进行讨论，这些技术涉及了A、C、I这几个特性。</p><h5 id="4-1-PostgreSQL事务操作"><a href="#4-1-PostgreSQL事务操作" class="headerlink" title="4.1　PostgreSQL事务操作"></a>4.1　PostgreSQL事务操作</h5><h6 id="4-1-1-开始事务"><a href="#4-1-1-开始事务" class="headerlink" title="4.1.1　开始事务"></a>4.1.1　开始事务</h6><p>1.开启主事务块</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span> [ WORK <span class="hljs-operator">|</span> TRANSACTION ] [ transaction_mode [, ...] ]<br>transaction_mode:<br>    ISOLATION LEVEL &#123; SERIALIZABLE <span class="hljs-operator">|</span> REPEATABLE READ <span class="hljs-operator">|</span> READ COMMITTED <span class="hljs-operator">|</span> READ UNCOMMITTED &#125;<br>    READ WRITE <span class="hljs-operator">|</span> READ <span class="hljs-keyword">ONLY</span><br>    [ <span class="hljs-keyword">NOT</span> ] DEFERRABLE<br></code></pre></td></tr></table></figure><p>开启一个新的事务，可以同时指定事务的隔离级别，指定事务的读写属性等。如果是只读的事务（READ ONLY）则可以为只读事务指定是否延迟（DEFERRABLE）的特性，这是PostgreSQL在用SSI（可串行化快照隔离）技术实现可串行化隔离级别时，<br>对只读事务所作的一个优化，详情可以参见9.4.2节。</p><h6 id="4-1-2-提交事务"><a href="#4-1-2-提交事务" class="headerlink" title="4.1.2　提交事务"></a>4.1.2　提交事务</h6><h6 id="4-1-3-回滚事务"><a href="#4-1-3-回滚事务" class="headerlink" title="4.1.3　回滚事务"></a>4.1.3　回滚事务</h6><h6 id="4-1-4-XA事务"><a href="#4-1-4-XA事务" class="headerlink" title="4.1.4　XA事务"></a>4.1.4　XA事务</h6><h6 id="4-1-5-自动控制事务"><a href="#4-1-5-自动控制事务" class="headerlink" title="4.1.5　自动控制事务"></a>4.1.5　自动控制事务</h6><p>DDL语句，如果处于一个事务块内部，<br>不会主动先提交事务DDL语句之前执行的语句，并隐式开启一个新的事务，而是随着事务块的提交或回滚而提交或回滚</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql">postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1;           <span class="hljs-operator">/</span><span class="hljs-operator">/</span>t1表中只有<span class="hljs-number">2</span>行数据<br> a <span class="hljs-operator">|</span> b <span class="hljs-operator">|</span>   c<br><span class="hljs-comment">---+---+-------</span><br> <span class="hljs-number">1</span> <span class="hljs-operator">|</span> <span class="hljs-number">1</span> <span class="hljs-operator">|</span>     <span class="hljs-number">1</span><br> <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-number">2</span> <span class="hljs-operator">|</span>     <span class="hljs-number">2</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br>postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">BEGIN</span>;                      <span class="hljs-operator">/</span><span class="hljs-operator">/</span>开启一个事务块<br><span class="hljs-keyword">BEGIN</span><br>postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> a<span class="hljs-operator">=</span><span class="hljs-number">2</span>;   <span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除一条数据<br><span class="hljs-keyword">DELETE</span> <span class="hljs-number">1</span><br>postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">CREATE TABLE</span> t3(a <span class="hljs-type">INT</span>);     <span class="hljs-operator">/</span><span class="hljs-operator">/</span>创建一个t3表成功<br><span class="hljs-keyword">CREATE TABLE</span>                         <br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>回滚事务，则创建表的DDL被回滚掉，而创建表的DDL没有隐式提交之前的删除操作<br>postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">ROLLBACK</span>;             <br><span class="hljs-keyword">ROLLBACK</span><br>postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1;     <span class="hljs-operator">/</span><span class="hljs-operator">/</span>创建表的DDL没有隐式提交之前的删除操作，数据依旧是<span class="hljs-number">2</span>行<br> a <span class="hljs-operator">|</span> b <span class="hljs-operator">|</span>   c<br><span class="hljs-comment">---+---+-------</span><br> <span class="hljs-number">1</span> <span class="hljs-operator">|</span> <span class="hljs-number">1</span> <span class="hljs-operator">|</span>     <span class="hljs-number">1</span><br> <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-number">2</span> <span class="hljs-operator">|</span>     <span class="hljs-number">2</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br><br>postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t3;     <span class="hljs-operator">/</span><span class="hljs-operator">/</span>回滚事务，则创建表的DDL被回滚掉，所以t3表不存在<br>ERROR:  relation &quot;t3&quot; does <span class="hljs-keyword">not</span> exist<br>LINE <span class="hljs-number">1</span>: <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t3;<br></code></pre></td></tr></table></figure><p>如果一个事务块内，一条SQL执行失败，PostgreSQL报告错误，则这个事务块会自动回滚。这是因为PostgreSQL的事务的模型实现的方式，<br>决定了一旦事务内部发生错误，系统自动隐含地调用了回滚函数处理错误，详情请参见7.3.4节的“3隐式的事务回滚”。</p><h5 id="4-2-SQL操作与锁"><a href="#4-2-SQL操作与锁" class="headerlink" title="4.2　SQL操作与锁"></a>4.2　SQL操作与锁</h5><p>PostgreSQL对于各种SQL操作，施加的事务锁是不同的，在第8章对事务锁有着详细的讨论，本节从示例的角度，分析PostgreSQL执行SQL加锁的初步情况。</p><h6 id="4-2-1-锁的研究准备"><a href="#4-2-1-锁的研究准备" class="headerlink" title="4.2.1　锁的研究准备"></a>4.2.1　锁的研究准备</h6><p>创建视图，用于查询数据对象上加锁的情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> active_locks <span class="hljs-keyword">AS</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>创建视图，用于查询数据对象上加锁的情况。PostgreSQL V9<span class="hljs-number">.6</span>验证通过<br><span class="hljs-keyword">SELECT</span> pg_class.relname, pg_locks.locktype, pg_locks.database,<br>       pg_locks.relation, pg_locks.page, pg_locks.tuple, pg_locks.virtualtransaction,<br>       pg_locks.pid, pg_locks.mode, pg_locks.granted, <br>       <span class="hljs-keyword">CASE</span><br>          <span class="hljs-keyword">WHEN</span> virtualxid <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">AND</span> transactionid <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT NULL</span><br>          <span class="hljs-keyword">THEN</span> virtualxid <span class="hljs-operator">||</span> <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-operator">||</span> transactionid<br>          <span class="hljs-keyword">WHEN</span> virtualxid::text <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT NULL</span><br>          <span class="hljs-keyword">THEN</span> virtualxid<br>          <span class="hljs-keyword">ELSE</span> transactionid::text<br>       <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> xid_lock<br><span class="hljs-keyword">FROM</span> pg_locks <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> pg_class <span class="hljs-keyword">ON</span> pg_locks.relation <span class="hljs-operator">=</span> pg_class.oid<br><span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">!</span><span class="hljs-operator">~</span> <span class="hljs-string">&#x27;^pg_&#x27;</span> <span class="hljs-keyword">and</span> relname <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;active_locks&#x27;</span>;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> active_locks;  <span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询视图<br></code></pre></td></tr></table></figure><h6 id="4-2-2-INSERT操作触发的锁"><a href="#4-2-2-INSERT操作触发的锁" class="headerlink" title="4.2.2　INSERT操作触发的锁"></a>4.2.2　INSERT操作触发的锁</h6><p>插入语句所加的锁“RowExclusiveLock”操作与隔离级别没有关系。</p><h6 id="4-2-3-SELECT操作触发的锁"><a href="#4-2-3-SELECT操作触发的锁" class="headerlink" title="4.2.3　SELECT操作触发的锁"></a>4.2.3　SELECT操作触发的锁</h6><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch04/ch04/img.png" alt="img.png"></p><h6 id="4-2-4-SELECT-FOR-UPDATE操作触发的锁"><a href="#4-2-4-SELECT-FOR-UPDATE操作触发的锁" class="headerlink" title="4.2.4　SELECT FOR UPDATE操作触发的锁"></a>4.2.4　SELECT FOR UPDATE操作触发的锁</h6><p>对例1～例7进行对比如表4-3所示，可以看出，带有FOR UPDATE操作的查询语句所加的锁与隔离级别有关系，<br>可串行化隔离级别使用谓词锁，其加锁多于已提交读。而且，与单纯的SELECT操作的查询语句相比，带有FOR UPDATE操作的<br>查询语句使用了“RowShareLock”锁，而单纯的SELECT操作的查询语句使用了“AccessShareLock”锁，<br>后者加锁的级别低于前者。</p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch04/ch04/img_1.png" alt="img_1.png"></p><h6 id="4-2-5-UPDATE操作触发的锁"><a href="#4-2-5-UPDATE操作触发的锁" class="headerlink" title="4.2.5　UPDATE操作触发的锁"></a>4.2.5　UPDATE操作触发的锁</h6><h6 id="4-2-6-DELETE操作触发的锁"><a href="#4-2-6-DELETE操作触发的锁" class="headerlink" title="4.2.6　DELETE操作触发的锁"></a>4.2.6　DELETE操作触发的锁</h6><h6 id="4-2-7-ANALYZE操作触发的锁"><a href="#4-2-7-ANALYZE操作触发的锁" class="headerlink" title="4.2.7　ANALYZE操作触发的锁"></a>4.2.7　ANALYZE操作触发的锁</h6><p>表明ANALYZE操作在表上和索引增加锁与不同的隔离级别没有关系</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">SET</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br>ANALYZE parent;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> active_locks;<br><span class="hljs-keyword">ROLLBACK</span>;<br><br>relname <span class="hljs-operator">|</span> locktype <span class="hljs-operator">|</span> database <span class="hljs-operator">|</span> relation <span class="hljs-operator">|</span> page <span class="hljs-operator">|</span> tuple <span class="hljs-operator">|</span> virtualtransaction <span class="hljs-operator">|</span> pid <span class="hljs-operator">|</span> mode<span class="hljs-operator">|</span> granted<br><span class="hljs-comment">------+--------+--------+--------+-----+-----+----------------+----+----+------</span><br>parent_pkey <span class="hljs-operator">|</span> relation <span class="hljs-operator">|</span> <span class="hljs-number">12401</span> <span class="hljs-operator">|</span> <span class="hljs-number">16392</span> <span class="hljs-operator">|</span> <span class="hljs-operator">|</span> <span class="hljs-operator">|</span> <span class="hljs-number">2</span><span class="hljs-operator">/</span><span class="hljs-number">7</span> <span class="hljs-operator">|</span> <span class="hljs-number">10460</span> <span class="hljs-operator">|</span> AccessShareLock   <span class="hljs-operator">|</span> t<br>parent <span class="hljs-operator">|</span> relation <span class="hljs-operator">|</span> <span class="hljs-number">12401</span> <span class="hljs-operator">|</span> <span class="hljs-number">16389</span> <span class="hljs-operator">|</span> <span class="hljs-operator">|</span> <span class="hljs-operator">|</span> <span class="hljs-number">2</span><span class="hljs-operator">/</span><span class="hljs-number">7</span> <span class="hljs-operator">|</span> <span class="hljs-number">10460</span> <span class="hljs-operator">|</span> ShareUpdateExclusiveLock <span class="hljs-operator">|</span> t<br></code></pre></td></tr></table></figure><h6 id="4-2-8-CREATE-INDEX操作触发的锁"><a href="#4-2-8-CREATE-INDEX操作触发的锁" class="headerlink" title="4.2.8　CREATE INDEX操作触发的锁"></a>4.2.8　CREATE INDEX操作触发的锁</h6><p>表明CREATE INDEX操作在表上和索引增加锁与不同的隔离级别没有关系</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">SET</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br><span class="hljs-keyword">CREATE</span> INDEX p_b1 <span class="hljs-keyword">ON</span> parent (b1);<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> active_locks;<br><span class="hljs-keyword">ROLLBACK</span>;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> active_locks;<br>relname <span class="hljs-operator">|</span> locktype <span class="hljs-operator">|</span> database <span class="hljs-operator">|</span> relation <span class="hljs-operator">|</span> page <span class="hljs-operator">|</span> tuple <span class="hljs-operator">|</span> virtualtransaction <span class="hljs-operator">|</span> pid <span class="hljs-operator">|</span> mode<span class="hljs-operator">|</span> granted<br><span class="hljs-comment">------+--------+--------+--------+-----+-----+----------------+----+----+------</span><br>parent <span class="hljs-operator">|</span> relation <span class="hljs-operator">|</span> <span class="hljs-number">12401</span> <span class="hljs-operator">|</span> <span class="hljs-number">16389</span> <span class="hljs-operator">|</span> <span class="hljs-operator">|</span>  <span class="hljs-operator">|</span> <span class="hljs-number">2</span><span class="hljs-operator">/</span><span class="hljs-number">9</span>  <span class="hljs-operator">|</span> <span class="hljs-number">10460</span> <span class="hljs-operator">|</span> ShareLock <span class="hljs-operator">|</span> t<br>p_b1   <span class="hljs-operator">|</span> relation <span class="hljs-operator">|</span> <span class="hljs-number">12401</span> <span class="hljs-operator">|</span> <span class="hljs-number">24576</span> <span class="hljs-operator">|</span> <span class="hljs-operator">|</span> <span class="hljs-operator">|</span> <span class="hljs-number">2</span><span class="hljs-operator">/</span><span class="hljs-number">9</span> <span class="hljs-operator">|</span> <span class="hljs-number">10460</span>   <span class="hljs-operator">|</span> AccessExclusiveLock <span class="hljs-operator">|</span> t<br></code></pre></td></tr></table></figure><h6 id="4-2-9-CREATE-TRIGGER操作触发的锁"><a href="#4-2-9-CREATE-TRIGGER操作触发的锁" class="headerlink" title="4.2.9　CREATE TRIGGER操作触发的锁"></a>4.2.9　CREATE TRIGGER操作触发的锁</h6><p>从创建触发器的代码可以看出，CREATE TRIGGER操作在表上增加锁与不同的隔离级别没有关系，所加的锁为“ShareRowExclusiveLock”.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">CreateTrigger(CreateTrigStmt *stmt, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *queryString, Oid relOid,<br>Oid refRelOid, Oid constraintOid, Oid indexOid, <span class="hljs-type">bool</span> isInternal)<br>&#123;...<br>    <span class="hljs-keyword">if</span> (OidIsValid(relOid))<br>        rel = heap_open(relOid, ShareRowExclusiveLock);<br>    <span class="hljs-keyword">else</span><br>        rel = heap_openrv(stmt-&gt;relation, ShareRowExclusiveLock);<br>...&#125;<br></code></pre></td></tr></table></figure><p>从创建主外键的代码可以看出，创建主外键操作在主键表上增加锁与不同的隔离级别没有关系，所加的锁为“ShareRowExclusiveLock”：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">ATAddForeignKeyConstraint(AlteredTableInfo *tab, Relation rel,<br>Constraint *fkconstraint, LOCKMODE lockmode)<br>&#123;...<br>    <span class="hljs-comment">// Grab ShareRowExclusiveLock on the pk table, so that someone doesn&#x27;t delete </span><br>    rows out from under us.<br>    <span class="hljs-keyword">if</span> (OidIsValid(fkconstraint-&gt;old_pktable_oid))<br>        pkrel = heap_open(fkconstraint-&gt;old_pktable_oid, ShareRowExclusiveLock);<br>    <span class="hljs-keyword">else</span><br>        pkrel = heap_openrv(fkconstraint-&gt;pktable, ShareRowExclusiveLock);<br>...&#125;<br></code></pre></td></tr></table></figure><h6 id="4-2-10-锁的相关参数"><a href="#4-2-10-锁的相关参数" class="headerlink" title="4.2.10　锁的相关参数"></a>4.2.10　锁的相关参数</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> name,setting,unit,category <span class="hljs-keyword">FROM</span> pg_settings <span class="hljs-keyword">WHERE</span> name<br><span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%lock%&#x27;</span> <span class="hljs-keyword">AND</span> name <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%block%&#x27;</span>;<br>              name              <span class="hljs-operator">|</span> setting <span class="hljs-operator">|</span> unit <span class="hljs-operator">|</span>                    category<br><span class="hljs-comment">--------------------------------+---------+------+------------------------------</span><br> deadlock_timeout               <span class="hljs-operator">|</span> <span class="hljs-number">1000</span> <span class="hljs-operator">|</span> ms   <span class="hljs-operator">|</span> Lock Management<br> lock_timeout      <span class="hljs-operator">|</span> <span class="hljs-number">0</span>   <span class="hljs-operator">|</span> ms   <span class="hljs-operator">|</span> Client Connection Defaults <span class="hljs-operator">/</span> Statement Behavior<br> log_lock_waits                 <span class="hljs-operator">|</span> off  <span class="hljs-operator">|</span>   <span class="hljs-operator">|</span> Reporting <span class="hljs-keyword">and</span> Logging <span class="hljs-operator">/</span> What <span class="hljs-keyword">to</span> Log<br> max_locks_per_transaction      <span class="hljs-operator">|</span> <span class="hljs-number">64</span>   <span class="hljs-operator">|</span>   <span class="hljs-operator">|</span> Lock Management<br> max_pred_locks_per_transaction <span class="hljs-operator">|</span> <span class="hljs-number">64</span>   <span class="hljs-operator">|</span>   <span class="hljs-operator">|</span> Lock Management<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>deadlock_timeout：死锁检测延时的控制参数，单位是毫秒，默认值为1秒。死锁检测的过程非常耗费时间，<br>增加死锁检测延时控制参数，以延缓死锁检测过程的执行。</p><p>lock_timeout：锁等待超时的控制参数，单位是毫秒，默认值是0秒，表示不进行超时控制。如果设置了此变量，<br>表示事务运行时间超过其值时，需要被回滚。</p><p>log_lock_waits：锁等待如果超时，是否记录一个日志信息。默认值为OFF，表示关闭此开关，<br>不记录一个锁等待超时信息。如果此开关打开，这样的信息很多，就需要追查系统产生锁等待的原因。</p><p>max_locks_per_transaction：平均每个事务的最大允许施加的锁（不包括谓词锁）的个数。此参数只是一个平均值，<br>不是单个事务被允许施加的最大锁个数的上限。默认值是64。<br>全系统所有的锁的总个数是：<br>max_locks_per_transaction*（max_connections+max_prepared_transactions）。<br>此参数只是一个平均值，不是单个事务被允许施加的最大锁个数的上限。</p><p>max_pred_locks_per_transaction：平均每个事务的最大允许施加的谓词锁的个数。此参数只是一个平均值，<br>不是单个事务被允许施加的最大谓词锁个数的上限。默认值是64。全系统所有的锁的总个数是：<br>max_pred_locks_per_transaction*（max_connections+max_prepared_transactions）。</p><h5 id="4-3-隔离级别与数据异常"><a href="#4-3-隔离级别与数据异常" class="headerlink" title="4.3　隔离级别与数据异常"></a>4.3　隔离级别与数据异常</h5><h6 id="4-3-1-SQL标准定义的三种读异常"><a href="#4-3-1-SQL标准定义的三种读异常" class="headerlink" title="4.3.1　SQL标准定义的三种读异常"></a>4.3.1　SQL标准定义的三种读异常</h6><p>这四种隔离级别，分别用于解决三种读异常现象和写偏序异常。符合2.2.1节我们讨论的基于锁的封锁并发控制技术。<br>但是，因为PostgreSQL使用了MVCC并发控制技术，使得PostgreSQL在不同隔离级别下的表现与基于锁的Informix<br>不完全相同，具体情况可以参见如下内容，分别验证了四种隔离级别的多事务并发情况。</p><h5 id="4-4-本章小结"><a href="#4-4-本章小结" class="headerlink" title="4.4　本章小结"></a>4.4　本章小结</h5><p>本章从三个角度，简略讲述了PostgreSQL的事务管理方式、封锁的相关内容，以及不同隔离级别与数据异常现象的关系，<br>为深入剖析PostgreSQL的事务管理技术和并发控制技术打下初步的基础。</p><p>在第7、8、9章，我们将详细讲述PostgreSQL的事务管理技术和并发控制技术，并剖析源码，深入探索实现原理与实现方式。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>数据库事务处理的艺术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch3. Informix事务管理与并发控制</title>
    <link href="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch03/ch03/"/>
    <url>/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch03/ch03/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch3. Informix事务管理与并发控制</p><p>Informix事务并发控制技术采用典型的SS2PL，即强两阶段封锁，以支持ACID。对于不同的特性，分别使用了如下技术予以支持：</p><p>A：原子性，通过提供事务的完整管理模型，在系统的运行过程中实现事务的提交和回滚功能（UNDO日志），以支持运行原子性。提供WAL日志和恢复机制，以支持恢复原子性。</p><p>C：一致性，通过提供基于封锁技术的SS2PL，以支持数据在运行期间数据被并发修改情况下的运行一致（读操作加锁配合SS2PL实现可串行化隔离级别确保数据的一致性）、通过WAL日志和恢复机制以支持故障发生后的恢复一致（系统故障、介质故障）。</p><p>I：隔离性，通过“SET ISOLATION…”语句来设置满足ANSI SQL标准规定的四种隔离级别，实现并发事务的不同场景的隔离。通过封锁技术实现并发事务对同一个数据项的读写隔离。</p><p>D：持久性，通过预写日志（WAL）、恢复等技术实现了数据的持久化存储。</p><p>如下，将对事务管理和并发控制技术进行讨论，这些技术涉及了A、C、I这几个特性。事务管理技术与A紧密相关，并发控制与C和I紧密关联。</p><p>Informix是典型的采用SS2PL技术的代表，而SS2PL技术又是使用的最为广泛的并发访问控制技术，其他许多的并发访问控制技<br>术都以SS2PL技术为基础，如PostgreSQL、InnoDB等在SS2PL技术基础上实现了MVCC技术，这为我们理解更多的并发控<br>制技术提供了基础；另外，SQL标准制定的并发控制相关的内容，原型始于封锁控制技术；所以在实例研究这一篇中，Informix<br>被列在了最前面。期望读者能够从中领悟技术之间的关联关系、并时刻用Informix来对比其他数据库的事务管理和并发访问控制<br>技术。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>数据库事务处理的艺术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch2 深入理解事务管理和并发控制技术</title>
    <link href="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/"/>
    <url>/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch2 深入理解事务管理和并发控制技术</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="2-1-在正确性和效率之间平衡"><a href="#2-1-在正确性和效率之间平衡" class="headerlink" title="2.1 在正确性和效率之间平衡"></a>2.1 在正确性和效率之间平衡</h5><p>理解并发控制技术，首先可以从使用锁的协议入手，讨论影响数据一致性的三种情况（不同事务之间对同一个<br>数据项的读–写、写–读、写–写这三种情况。读–读不影响一致性不必考虑）。然后考虑并发的效率问题，<br>采用多种并发控制技术、适度逐渐放宽并发度，从而理解各种各样的并发控制技术。</p><p>另外，为了提升数据库处理事务的效率，除了采用不同的并发控制技术逐渐释放事务间的并发能力之外，还有一种思路就<br>是让用户自己判断所发起的操作是否影响到了数据的一致性，如果用户认为不影响数据一致性，则可以控制数据库的事务管理器，<br>放松对事务调度的限制（程序员必须慎重选择隔离级别），以提高并发程度。这样的技术就是“隔离级别”。</p><h6 id="2-1-1-隔离级别"><a href="#2-1-1-隔离级别" class="headerlink" title="2.1.1　隔离级别"></a>2.1.1　隔离级别</h6><p>三种异常现象，是在并发情况下发生的，数据库系统使用不同的隔离级别，分别隔离了并发情况下对数据读写的三种异常 ，<br>使得异常不存在，这就是隔离的含义，即隔离异常现象杜绝了异常现象。</p><p>SQL标准（American National Standards Institute，ANSI）提出四种隔离级别，分别是在三种读数据异常现象前后插入四个点，<br>形成了四种隔离地带，不同程度地禁止了三种读数据的异常现象的产生。参见表2-1。</p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img.png" alt="img.png"></p><p>并发执行的事务能够看到存储的信息（即数据），好似事务之间是串行执行（生成的数据）。<br>这样，因为等价于串行执行，所以数据的一致性不会被破坏，但是这个“隔离性”是隔离级别中最高的级别，<br>其他的隔离级别不能保证“一致性”但却能提高事务的运行效率。</p><p>SQL标准对于隔离级别定义如下：</p><p>1）Serializable（串行化，或称为可串行化）</p><p>一个事务在执行过程中完全看不到其他事务对数据库所做的更新</p><p>2）Repeatable Read（可重复读）</p><p>一个事务在执行过程中可以看到其他事务已经提交的新插入的元组（读已经提交的，其实是读早于本事务开始且已经提交的），<br>但是不能看到其他事务对已有元组的更新（即晚于本事务开始的），并且，该事务不要求与其他事务是“可串行化”的。</p><p>3）Read Commited（已提交读）</p><p>一个事务在执行过程中可以看到已经提交的其他事务新插入的元组，而且能看到已经提交的其他事务对已有元组的更新。</p><p>4）Read Uncommitted（未提交读）</p><p>一个事务在执行过程中可以看到没有提交的其他事务新插入的元组，而且能看到没有提交的其他事务对已有元组的更新。</p><p>这四种隔离级别，都不允许“脏写（dirty write，参见1.1.4节）”发生。</p><p>下面以并发控制技术采用封锁的方式来概要地了解一下并发控制技术和隔离级别之间的关系，如表2-2所示。</p><p>表2-2　各种隔离级别在基于锁的并发控制技术下的实现情况<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_1.png" alt="img_1.png"></p><h6 id="2-1-2-快照隔离"><a href="#2-1-2-快照隔离" class="headerlink" title="2.1.2　快照隔离"></a>2.1.2　快照隔离</h6><p>一种常用的隔离技术，称为“快照隔离（Snapshot Isolation，简称SI）”。</p><p><strong>1.什么是“快照隔离”？</strong></p><p>快照隔离是一种保证，即事务中的所有读取操作都将看到数据库的一个一致的快照<br>（实际上，它读取的是事务开始时存在的最后一个已提交值），并且该事务只有在其所做的更新与自该快照以来的任<br>何并发更新不冲突的情况下才能成功提交。</p><p>我们可以认为：</p><pre><code class="hljs">（1）使用了快照隔离技术的事务中的所有读操作，读到的数据一定是一致的。（2）一条实际上避免了ANSI SQL标准定义的“幻象/幻读”等各种读异常现象 （具体分析参见表2-3）。各种读异常的详细讨论参见1.1.3和2.1.2节。（3）这样的事务如果没有写–写冲突发生，则会提交成功。这意味着，不会发生读–写和写–读冲突。所以并发效率会更高。（4）第一和第三条结果得以保障，是因为从事务开始时，处于当时的并发事务的状态 （多个事务的状态，称为快照 ，即snapshot ）被保存，利用这个快照可以判断本事务和其他事务之间启动的先后顺序、事务的读写数据情况等，以确定是否存在写–写冲突。（5）这就是“快照隔离”技术的本质，其实，也是“快照隔离”技术要达到的目的。</code></pre><p>修正后的SQL标准定义的三种读数据异常现象与快照隔离的比较表：<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_2.png" alt="img_2.png"></p><p><strong>2.“快照隔离”的技术实现手段</strong></p><p>“快照隔离”是MVCC技术的一种实现方式（详情参见2.2.4节）。MVCC技术的本质，是为每个对象在写操作发生时，生成<br>一个新的版本；在读操作发生时，读出最近的一个版本。这样同一个元组因有多个版本（传说中的分身术）、且并发的事务有生<br>命周期存在，每个事务读到的元组（实则是元组的某个版本）是不一样的，相当于并发事务在操作不同的元组对象，因此看起来“<br>不存在并发”（除了写–写冲突一定要操作同一个对象，如同孙大圣被金钹扣住的一定是真身），不满足1.2.2节提到的“冲突<br>行为”的定义。</p><p>存在有多个版本的元组级的对象，物理组织通常有两种：一是磁盘类型的数据库，MVCC冗余了磁盘页内部的元组；<br>二是内存类型的数据库，MVCC冗余了内存中的元组，两者所不同的，是元组存放的位置不同，前者是位于页面内部，<br>后者是直接在内存中组成一个链表。前者典型的实现如PostgreSQL和InnoDB，后者典型的实现如阿里的OceanBase、<br>微软的Hekaton。</p><p><strong>3.“快照隔离”的实现技术是如何解决各种冲突的？</strong></p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_3.png" alt="img_3.png"></p><p>首先，如图2-1所示，有5个并发执行的事务，分别是T1到T5。</p><p>其次，事务所能读取的数据，一定是已经提交了的事务的、最新的数据。</p><p>“最新的”含义表明，假设事务T1和T3都修改了同一个数据项X，则事务T5所能看到的数据项X一定是事务T3生成的版本，<br>因为事务T3生成的版本新于事务T1生成的版本。</p><p>再次，因为一个数据项有多个版本，以事务的开始时间戳为获取版本的基准，并发间的事务看到的是不同的版本。</p><p>第四，并发事务同时写同一个数据项，要遵循“First-Committer-Wins”，即：首个提交者获胜原则。<br>这是在说，并发的、同时写同一个数据项的事务只能有一个成功，另外一个必须回滚，这种情况相当于并发不存在 。<br>所以解决了写–写冲突。</p><p>第五，与“先提交获胜”原则相似的是“先写者获胜”，即“First-writer-wins”。</p><p><strong>4.“快照隔离”实现技术的弊端</strong></p><p>尽管MVCC并发效率很高，但是“快照隔离”不能保证并发事务是可串行化的，所以，无法保证数据的一致性。<br>这样的问题，被称为“写偏序（Write skew）”，参见1.1.5节。</p><p><strong>5.“快照隔离”实现技术的弊端的解决方式</strong></p><p>使用“快照隔离”实现MVCC的技术引发了写偏序的问题，其实是这种技术因多个版本存在使得用户定义在数据项<br>上的语义不能得到保证（在每个版本上判断语义相当于在不同的逻辑时空内同时操作不同的分身而不能保证语义施加在同<br>一个物理真身上）而导致的。解决方式是采用“Serializable snapshot isolation”技术，详情参见2.2.5节。<br>还有一种技术，叫作“write-snapshot isolation”，曾在第1章提及。</p><p><strong>6.“快照隔离”的其他一些问题</strong></p><p>在商业数据库Oracle（如10g、11g这些版本）和开源的数据库PostgreSQL中，<br>快照隔离被称为“可串行化（serializable）隔离级别”，这是一种错误的叫法。错误之处在于：</p><pre><code class="hljs">一是把“快照隔离”的概念等同了ANSI SQL标准中的四种隔离级别中最高的隔离级别。从前述的定义看，显然“快照隔离”和“可串行化（serializable）隔离级别”是明显不同的。二是混淆了二者的真实含义。“快照隔离”不能确保“可串行化（serializable）”这个事务的属性 要求；而“可串行化（serializable）隔离级别”却要确保在这个隔离级别下，事务被事务管理器调度时，必须是可串行化的。三是在工程实现中，Oracle没有在“可串行化（serializable）隔离级别”下真正实现“ 可串行化”属性 。而PostgreSQL早期版本也不是一个真的“可串行化（serializable）”的事务，存在写偏序异常；只是在9.1版通过“Serializable snapshot isolation”技术实现了真正的可序列化。</code></pre><p><strong>7.“快照隔离”的实际应用</strong></p><p>在PostgreSQL和MySQL实现中，都使用快照隔离技术实现了MVCC协议。其中，PostgreSQL使用“transaction snapshot”表示快照隔离，<br>MySQL使用“read view”表示快照隔离，都是用快照来隔离并发事务对相同数据项的操作。</p><p><strong>8.“快照隔离”阅读进阶</strong></p><p>论文《Database Replication Using Generalized Snapshot Isolation》给出了快照隔离的定义，<br>称之为“Generalized Snapshot Isolation（GSI）”。并基于GSI提出了“Prefix-Consistent Snapshot<br>Isolation（PCSI）”用于分布式环境中的复制数据库的事务处理（分布式相关的本书不作讨论，期待有关分<br>布式相关内容将来有机会另述）。</p><p>·论文《Generalized Snapshot Isolation and a Prefix-Consistent Implementation》对GSI和PCSI做了<br>更多阐述（两篇论文的作者相同）。</p><h6 id="2-1-3-理解可见性"><a href="#2-1-3-理解可见性" class="headerlink" title="2.1.3　理解可见性"></a>2.1.3　理解可见性</h6><p>首先，可见性，是指某个数据项对于不同事务，是否可以被并行操作（即数据项对于某个事务是否可见可操作）。<br>这是从并发的角度而言的，很自然，这就与并发控制算法有关。</p><p>其次，为了提高并发度，ANSI SQL标准定义了四种隔离级别，“SERIALIZABLE”使得数据项不可被其他并发<br>事务可见而被操作（读-读除外，但这么说已经和基于锁的并发控制技术关联，因此严格地说，这样的说法也是不严谨的）。其<br>他隔离级别放松了管制，在某些情况下使得数据项被其他事务可见。这表明可见性与隔离级别紧密相关。</p><p>在PostgreSQL和MySQL这样的数据库系统中，因都实现了MVCC机制的时候，其中就经常提到“可见性”判断。<br>一个元组对谁可见，意味着这个元组可以被什么样的事务获取（读取、改写或删除），这和数据库引擎使用的<br>并发控制技术、ACID中隔离性的定义、ANSI SQL标准定义的隔离级别等紧密相关。</p><p>对于基于锁的并发控制技术，如果隔离级别是“SERIALIZABLE”则一条元组在读锁的情况下，<br>对于其他并发事务的读操作是可见的。否则，不可见。<br>如果隔离级别是其他的级别，则根据加锁情况排斥或不排斥其他并发事务的读或写操作，使得数据项对其他事务表现出可见或不可见。</p><p>如果数据库引擎使用了MVCC机制和快照隔离技术，则因为一个元组有了多个版本，所以隔离技术使得不同并发事务对同一个数据项的操作相<br>互“隔离”（各自作用在同一个数据项的不同的版本上），此时，除了写-写操作外（此句话的背景是MVCC+锁实现并发控制），<br>其他的操作都不互斥，因此在读或写操作这个层面，版本对于事务而言都因不互斥而可见。<br>但是，这不是决定元组可见性的唯一标准，还有三个标准就是数据项的状态，即是否提交<br>（对应READ COMMITTED、READ UNCOMMITTED隔离级别）、是否符合事务语义（对应REPEATABLE READ隔离级别，<br>语义是在一个事务内前后阶段看到的数据应该是一致的），如果满足当前事务的隔离级别设置，才能说是满足可见性。</p><p>综上所述，Innodb使用的ReadView，就是MVCC机制中常用的快照隔离，在这种情况下，判断元组对某个事务的可见性，不仅仅指的是ACID中的隔离性。</p><h5 id="2-2-并发控制"><a href="#2-2-并发控制" class="headerlink" title="2.2　并发控制"></a>2.2　并发控制</h5><p>从检测是否存在冲突的时机的角度看，主要包括乐观的、悲观的以及介于两者之间半乐观的方法；<br>从控制冲突的时机角度看，主要包括：基于锁的、基于时间的、基于提交顺序的、基于串行化图测试验证的等各种方法，<br>另外还有一些其他的方法诸如多版本并发控制技术等。</p><p><strong>并发控制的技术有很多，多种技术之间进行组合又创造出更多的并发控制技术。但怎么理解这些技术？为什么多种技术之间可以组合？这些技术之间是否存在内在的关联？</strong></p><p>深入剖析各种并发控制技术是怎么消除数据不一致的、是怎么提高并发效率的。</p><p>首先，我们来明确：<strong>并发的事务是怎么引发数据不一致的？</strong></p><p>可串行化概念的作用在于保证并发的事务调度方式既能满足数据一致性需求，又能提高并发事务的执行效率。</p><p>讨论“可串行化”“可恢复性”“严格性”这几个概念之间的关系，是十分必要的：</p><pre><code class="hljs">可串行化：从理论上保证了并发事务的调度等价于一个串行调度，避免了数据的不一致现象。可恢复性：描述了需要避免了脏读异常现象，但没有提出实施措施。避免级联回滚：描述了事务调度机制在“不可恢复性”发生作用时，为了保证数据的一致性不得不降低事务调度机制的效率（所以，这样的事情应该避免）。严格性：提出通过控制并发事务的提交/中止操作的顺序，来直接避免脏读现象，这样进一步避免了数据的不一致现象。</code></pre><p>以上都满足，才能确保一致性。</p><p>其次，我们来讨论：并发的事务调度方法是怎么提高并发度的？</p><p>下面我们结合各种并发控制方法，结合本节提出的两个问题，剖析不同的并发控制技术是怎样解决这两个问题的。但是，请注意，2.2节的各个子节当中讨论<br>的多种并发控制技术，只涉及隔离级别是“Serializable（串行化，或称为可串行化）”的级别，因为只有这个级别才能<br>真正保证数据的一致性。在2.4节，我们再结合其他隔离级别讨论并发控制的技术。</p><h6 id="2-2-1-基于锁的并发控制方法"><a href="#2-2-1-基于锁的并发控制方法" class="headerlink" title="2.2.1　基于锁的并发控制方法"></a>2.2.1　基于锁的并发控制方法</h6><p>在数据库系统的实现过程中，我们常使用“spinlock”和“latch”来保护共享资源不被并<br>发地写操作同时修改；在编程中，我们引入了对象互斥锁“mutex”的概念，来保证共享数据操作的完整性。<br>通过事前加锁、事后释放锁，避免了共享资源被不同对象同时修改。所以，封锁技术能够抑制并发，即能避免数据不一致的问题。</p><p>但是，如果只是简单的加锁，对于数据库系统而言，一个事务内如果需要读写很多与其他事务共享的数据项，<br>那么这个锁怎么加、加在哪里就是一个问题？</p><p>那么，我们是否可以定义多个锁？如果定义了多个锁，又如何知道该给哪些事务使用哪些锁呢？</p><p>如果把锁加在数据项上，则能解决哪些事务该使用哪些锁的问题。但是，<br>封锁导致不能并发则使得执行效率降低（读–读操作式的并发也被禁止）。而且，需要在一个事务的<br>所有操作完成后才能释放锁，这使得即使多个事务能够并发但执行效率也不高。</p><p>多粒度封锁，解决了只使用一种锁导致并发效率低下的问题；两阶段封锁协议，<br>解决了引入多粒度锁之后导致事务调度机制不能保证事务间的并发调度是“可串行化”的。</p><p><strong>1.锁的粒度</strong></p><p>锁被分为两种粒度后，即区分为读锁（共享锁）和写锁（排它锁），则并发操作可以被区分为四种：<br>读–读、读–写、写–读、写–写，这样，至少读–读操作的并发可被允许进行，使得在用锁保证数据一致性的情况下，<br>并发能力得以提高。可以得到我们通常所说的“锁的相容性矩阵”。</p><p>如果进一步把锁的种类再细化，增加意向锁等，则可以得到如表2-4所示锁的相容性矩阵表，这个表是用于多个事务之间<br>进行事务间加锁时互斥操作使用的（锁的互斥使得并发的事务间遵循了可串行性）。但是，在实际的编程实战中，还有如<br>表2-5所示锁的升级图，用于在一个事务内对本事务的多个加锁操作进行锁升级的。具体说明，参看表2-4和表2-5。</p><p>锁的相容性矩阵表（不同的事务间新锁的申请）：<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_4.png" alt="img_4.png"></p><p>“Granted Mode”表示已经赋予的锁。N表示不存在锁，IS共享意向锁，IX排它意向锁，S共享锁，SIX共享排它意向锁，U更新锁，X排它锁。<br>对于“Granted Mode”，从N到X这些锁，存在一个排斥的过程，IS排斥其他并发操作的力度最弱，X最强，现实中数据库的事务调度器实现实<br>例中在为事务加锁时，就遵循着这样的一个顺序依序比较，如Informix、PostgreSQL等系统。</p><p>由于可以有多种粒度的锁存在，多粒度封锁协议（multiple-granularity locking protocol） [《数据库系统概念》，第六版，Abraham Siberschatz等著。]<br>被提出，<br>可以增强并发度，减少锁的开销，本节不再多述，请参阅相关书籍。</p><p>锁的合并图（同一个事务内锁的升级）：<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_5.png" alt="img_5.png"></p><pre><code class="hljs">本图表明在同一个事务内对同一个数据项的加锁操作的升级（多种粒度的锁，为了提升并发度，当同一个对象上发生第二次锁申请时，则允许锁进行转换（lock conversion），就是锁的升级和降级。升级（upgrade）：表示从共享到排他的转换，发生在锁增长阶段；降级（downgrade）；表示从排他到的共享转换，发生在锁缩减阶段，多数的数据库不实现降级。）后的结果。“Lock Held”表示已经授予的锁。“Lock Requested”表示将要申请的锁。在同一个数据项上已经授予了S锁，如果再申请IX锁，则在这个数据项上持有的锁就变为SIX锁。在同一个数据项上已经授予了SIX锁，如果再申请U锁，则在这个数据项上持有的锁就变为X锁。其他升级方式不再举例，余者参见表2-5所示。</code></pre><p><strong>2.两阶段锁</strong></p><p>两阶段封锁协议（two-phase locking protocol，2PL），要求每个事务分为两个阶段：</p><pre><code class="hljs">增长阶段（growing phase）：第一个阶段，事务可以获得锁，但不释放锁。缩减阶段（shrinking phase）：第二个阶段，事务可以释放锁，但不能获得新锁。</code></pre><p>两阶段封锁协议可以保证可串行性 [可用反证法证明两阶段封锁协议执行的事务过程一定是可串行化的] ，<br>但不满足可恢复性，因而不能避免级联回滚；两阶段封锁协议更不满足严格性，所以不能完全保证数据的一致性。</p><p>于是，两阶段封锁协议有了新的变种，即：</p><pre><code class="hljs">严格两阶段封锁协议 （strict two-phase locking protocol，S2PL）：除了封锁满足两阶段封锁之外，还要求持有的排它锁必须在事务提交后才能释放。这个要求保证未提交事务所写的任何数据在该事务提交之前均以排它方式加锁，从而能够避免级联回滚。如表2-6（源自表1-14）所示，对于case3，事务T2的W（X）和Commit操作，在S2PL协议下，已经不可能发生（事务T1在X上持有的写锁一直不释放），所以当事务T1执行Abort时，级联回滚就不存在。强两阶段封锁协议 （rigorous/strong two-phase locking protocol，SS2PL）：除了封锁满足两阶段之外，还要求事务提交之前不得释放任何锁。这样就满足了严格性的要求（严格性要求先发生写操作的事务提交或中止的操作优先于其他事务）。</code></pre><p>表2-6　可恢复性示例：<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_6.png" alt="img_6.png"></p><p>主流数据库系统实现的两阶段封锁协议，实际上指的是SS2PL而非2PL。因为只有SS2PL才能保证数据的一致性。</p><p>使用SS2PL实现事务调度的主流数据库系统有Informix。开源的PostgreSQL和MySQL不仅使用了SS2PL，而且还使用MVCC来提高事<br>务并发调度的效率。Oracle、DB2、SQL Server也是基于SS2PL和MVCC实现的事务并发调度。</p><p><strong>3.封锁技术是怎样解决各种读异常的？</strong></p><p>对于脏读和不可重复读，封锁技术不会发生这两种读异常现象，原因如表2-7所示。</p><p>表2-7　修正后的SQL标准定义的三种读数据异常现象与封锁技术的比较表：<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_7.png" alt="img_7.png"></p><p>对于幻象，需要分为几种情况讨论：</p><p>（1）没有索引，使用表或页面级锁：因为锁的粒度大，锁把一些不相关的元组也囊括在锁定的范围内，<br>这使得其他事务的WHERE条件不能获取被锁住的表或页面（这相当于锁住了WHERE条件指定的数据对象和对象的外延范围，<br>这个外延范围被称为间隙“gap”），因而可以避免幻象异常。</p><p>（2）没有索引，锁的粒度是元组级：因为锁的粒度到了元组一级，即操作多少元组就锁定<br>多少元组对象，所以其他事务的WHERE条件能够不受已经加锁的影响，因而可能存在幻象。解决方式是锁的粒度升级为表级或页级。</p><p>（3）有索引：在索引上采取“谓词锁（predicate lock）”来解决。</p><p><strong>4.死锁相关</strong></p><p>如果只有一种锁，并发的事务只有等待该锁被释放后才能有加锁的机会，这样并发的事务处于等待状态。<br>但如果至少存在读写锁，则会发生R（X）W（Y）-R（Y）W（X）这样的死锁现象，<br>导致并发事务谁也不能继续执行下去。</p><p>PostgreSQL使用等待图的死锁判断机制，自动检测并预防死锁现象的产生，即把其中将引发死锁的事务中止掉，<br>从而避免死锁现象。Informix可以设置等待时间，如果等待超时，则自动把引发死锁的事务中止掉，从而避免死锁现象。<br>InnoDB除了提供等待超时机制外，还使用等待图的算法检测死锁并回滚引发死锁的当前或其他事务。</p><p><strong>5.锁的并发度的问题</strong></p><p>假设锁不区分为多种粒度，只有一种锁存在，则并发度为0；而如果只有读写锁，只有读–读操作被允许同时进行，并发度为25%。<br>之后讨论的SCO（参见2.3.4节）技术，使得读–写操作不阻塞，即只有写–读、写–写操作不能并发，并发度被提高到50%。之后讨论的MVCC<br>结合封锁（参见2.2.4节）技术，使得读–写、写–读操作互不阻塞，即只有写–写操作不能并发，<br>并发度被提高到75%（这就是MVCC被广为使用的原因）。</p><p>另外，锁的封锁范围，也影响了封锁协议的并发度。</p><p>在数据库系统编程实现中，锁可以施加在一个表对象上，也可以施加在一个页面上，<br>还可以施加在一个元组上，分别对应的就是我们常说的表级锁、页级锁、行级锁。</p><h6 id="2-2-2-基于时间戳的并发控制方法"><a href="#2-2-2-基于时间戳的并发控制方法" class="headerlink" title="2.2.2　基于时间戳的并发控制方法"></a>2.2.2　基于时间戳的并发控制方法</h6><p>基于时间戳的并发控制技术，是根据事务开始的时间戳值和其他事务的读写操作的时间戳值做比较来决定<br>冲突发生时事务该如何处理。时间戳排序协议保证任何有冲突的Read和Write操作按时间戳顺序执行。<br>而时间戳的值，是事务开始时，由数据库事务管理器直接赋予的（物理时间值或递增的数值），这个时间戳值不再发生变化。</p><p>基于时间戳的并发控制技术分为几种情况处理读操作或写操作：</p><p>另外，基于时间戳的并发控制协议，不会产生死锁，这是为什么呢？</p><p>基于前面的分析，我们可以看到，当有冲突发生的时候，新进入事务调度器被判断为存<br>在冲突的事务立即被回滚，所以不会存在事务形成互为等待的环，因此，死锁现象不会发生。</p><p><strong>1.基于时间戳的并发调度算法</strong></p><p>在实践中，基于时间戳的并发调度算法[<a href="https://en.wikipedia.org/wiki/Timestamp-based_concurrency_control]">https://en.wikipedia.org/wiki/Timestamp-based_concurrency_control]</a><br>实现如下，基本原理如上，不再详细描述</p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_8.png" alt="img_8.png"></p><p><strong>2.Thomas写法则</strong></p><p>在基于时间戳的并发控制技术中，有一项改进措施，称为“Thomas写法则”，其对应的情况如表2-8所示。</p><p>表2-8　Thomas write rule：<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_9.png" alt="img_9.png"></p><p>“Thomas写法则”有助于改进基于时间戳的并发控制效率，使得特定情况的写操作被“节省”因而提高了执行效率。<br>但是，如果事务T2在t7时刻不提交而是中止，则会存在一个潜在的问题：被中止的事务T2覆盖了数据项Z的旧值，Z的旧值和旧的写时间戳应该被恢复。<br>需要调度器保存数据项Z的旧值以便需要恢复时使用，这为事务调度器增加了负担。<strong>现实的数据库管理系统中，<br>几乎没有单纯使用基于时间戳排序的并发控制方法的（T0和其他算法常结合使用）。</strong></p><h6 id="2-2-3-基于有效性检查的并发控制方法"><a href="#2-2-3-基于有效性检查的并发控制方法" class="headerlink" title="2.2.3　基于有效性检查的并发控制方法"></a>2.2.3　基于有效性检查的并发控制方法</h6><p>在上一节，我们讨论了基于时间戳排序的并发控制技术，基于有效性检查的并发控制技术和基于时间戳的技术有很大相似之处，<br>所以本节我们换一种讨论方式，先讨论这两种技术的相同点和差异，借助时间戳排序技术理解有效性检查的并发控制技术。<br>如表2-9所示。</p><p>表2-9　基于时间戳排序的并发控制技术与基于有效性检查的并发控制技术的比较表<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_10.png" alt="img_10.png"></p><p>基于有效性检查的并发控制技术（validation protocol），对于每一个事务，在其生命周期中被划分为两个或三个阶段，<br>每个事务必须按如下顺序依次执行：<br>读阶段（read phase）、有效性检查阶段（validation phase）、写阶段（write phase）</p><h6 id="2-2-4-基于MVCC的并发控制方法"><a href="#2-2-4-基于MVCC的并发控制方法" class="headerlink" title="2.2.4　基于MVCC的并发控制方法"></a>2.2.4　基于MVCC的并发控制方法</h6><p>多版本并发控制（Multiversion concurrency control，MVCC）技术，核心思想是：</p><p>（1）当事务Ti执行一个读操作，并发控制器选择一个版本进行读取，这个版本的获取，依赖于事务Ti所能读取的数据的<br>上下文；这个上下文（有个通俗名称，叫做事务的快照，快照要和多版本相配合）是事务Ti在数据库系统里的当前并发执<br>行的诸多事务的状态的一份拷贝，其中的信息能够帮助判断：获取到的元组是否对本事务是可读取的 （元组可见性判断）？</p><p>（2）多版本并发控制技术不是一个可独立使用的事务并发控制技术，而是需要基于其他并发控制技术，如基于时间戳<br>的称为“多版本时间戳排序机制（multiversion timestamp-ordering scheme）”，基于两阶段封锁协议的称<br>为“多版本两阶段封锁协议（multiversion two-phase locking protocol）”。如下分别讨论这两种并发控制技术，<br>并如表2-10所示进行比较。</p><p>表2-10　两种MVCC并发控制技术比较表<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_11.png" alt="img_11.png"></p><p><strong>1.多版本时间戳排序机制</strong></p><p>首先，数据库系统在事务开始前赋予一个时间戳，记为TS（Ti），这个时间戳则决定了并发的事务的调度顺序。</p><p>其次，对于每个数据项X，多版本体现在：X有一个版本序列&lt;X1，X2，…，Xn&gt;，其中，每个版本Xi包括三个字段，分别是：</p><pre><code class="hljs">·Xi=value，value是数据项X的第i个版本的值，每个版本是由一个写操作生成的。·W-timestamp（Xi）是创建Xi这个版本的事务的时间戳（不是当前时间戳值），即表明此数据项是被谁在什么时候创建的。·R-timestamp（Xi）是所有成功读取Xi这个版本的事务的时间戳。</code></pre><p>再次，多版本时间戳排序机制通过如下规则，保证可串行性：</p><pre><code class="hljs">如果事务Ti执行Read操作或Write操作，假设Xm表示X满足如下条件的版本，其写时间戳是小于或等于TS（Ti）的最大写时间戳（确保了在所有版本中找到一个“最近版本”）。如果事务Ti执行读操作Read（X），返回给事务Ti的值为Xm。读永远不会被阻塞 。如果事务Ti执行写操作Write（X）：（1）且如果TS（Ti）&lt;R-timestamp（Xm），则中止事务Ti，这表明即将执行的这个写操作之后的时间上已经发生过了一个读操作，如果允许写操作成功，则可能发生不可重复读异常现象。这是写–读冲突，事务Ti被中止。注意这一点，发生此种情况的时候，是因为事务Ti的写操作本来在物理时间上早于对Xm这个版本的其他事务的读操作，但因为并发执行是无序的，导致调度器在判断“TS（Ti）&lt;R-timestamp（Xm）”时刻之前，R-timestamp（Xm）已经发生了。所以才能有“TS（Ti）&lt;R-timestamp（Xm）”这种现象发生。（2）且如果TS（Ti）=W-timestamp（Xm），则系统更新事务Ti的值Xm为新值，这表明本事务多次写过同一个数据项，新值覆盖旧值。（3）且如果TS（Ti）&gt;W-timestamp（Xm），则系统为事务Ti的数据项X创建一个新值。这说明后发生的事务才创建新的版本。这是写–写冲突，导致产生新版本。</code></pre><p><strong>2.多版本两阶段封锁协议</strong></p><p>首先，每个数据项X，其多版本体现在：X有一个版本序列&lt;X1，X2，…，Xn&gt;，其中，每个版本Xi包括一个时间戳，<br>多数数据库中，这个时间戳对应的是唯一的一个事务标识，叫做事务号。</p><p>其次，事务分为两种类型，一种是只读事务（有的数据库系统号称支持“只读事务”，就是因为使用了多版本两阶段封锁协议。如PostgreSQL<br>的事务并发控制技术采取的就是多版本两阶段封锁协议，然后对只读事务做了优化。） ，另外一种是更新事务。这意味着需要事先知道事务的读写请求、<br>进而告知事务管理器，事务管理器才能区分事务的类型然后根据类型做出一定的优化<br>（多数多版本两阶段封锁协议的事务管理器都采取了一定措施为只读事务做了优化）。</p><p>在表2-10中，我们提到的读操作，对应着SQL语句的SELECT操作，这样的操作，在快照隔离技术中，<br>可以做到读不加锁。但是，“读”操作的另外一层含义，是“获取”，即某SQL语句需要先获取到数据，<br>然后才能操作数据，这样的获取，又很多时候，也被称为“读”操作，这算是一种不严谨的说法。例如在MVCC并<br>发控制方法中，不严谨的说法里“读”操作可以细分为两种情况：</p><pre><code class="hljs">快照读（snapshot read）：读取的是元组的可见版本（可见的含义是获取在快照允许的事务范围内的版本，这样的版本可能是历史版本），不用加锁。如InnoDB使用UNDO日志帮助获取快照范围内的历史版本以支持简单的SELECT查询操作。当前读（current read）：读取的是记录的最新版本，被当前读返回的元组会加上锁，保证其他事务不会再并发修改这条元组。如InnoDB中把UPDATE、INSERT、DELETE操作视为特殊操作，这样的操作需要读取数据，属于当前读，也属于前面谈及的不严谨的“读”操作。</code></pre><h6 id="2-2-5-基于MVCC的可串行化快照隔离并发控制方法"><a href="#2-2-5-基于MVCC的可串行化快照隔离并发控制方法" class="headerlink" title="2.2.5　基于MVCC的可串行化快照隔离并发控制方法"></a>2.2.5　基于MVCC的可串行化快照隔离并发控制方法</h6><p>Serializable Snapshot Isolation，可串行化的快照隔离，简称SSI。</p><p>首先，这种技术，基于MVCC中的多版本，也基于快照隔离的思想。</p><p>其次，为了解决快照隔离的写偏序异常问题，引入了本项改进技术。</p><p>第三，SSI因基于SI（快照隔离）所以整体流程与SI相同，只是增加了一些“book-keeping”记录下事务的一些信息以便动态地检测是否有<br>写偏序现象的发生（工程实现中是检测可能有写偏序发生而不是一定 是写偏序发生，所以存在误判的可能，<br>这么做是为了提高检测的效率），如果有，则回滚引发写偏序异常的事务。</p><p>可序列化的快照隔离技术的主要内容，参见论文《Serializable Isolation for Snapshot Databases》。下面我们分三个方面，来探讨SSI的具体技术实现。</p><p><strong>1.理论基础</strong></p><p>检测写偏序的理论基础依赖于两篇论文：</p><pre><code class="hljs">·《Weak Consistency：A Generalized Theory and Optimistic Implementations for Distributed Transactions》：定义了“读写依赖（rw-dependency）”，通过读写依赖表明不可串行化 必然是一个环内存在两个读写边于多版本可串行化图（the multiversion serialization graph，简称MVSG）中。·《Making snapshot isolation serializable》：定义了“读写依赖（rw-dependency）”的扩展形式，表明前述的两条边相邻且每条边的两个端点代表着不同的活动状态下的事务。</code></pre><p>上述两篇论文，实则在表明并发事务之间的读写操作是怎么造成事务的“冲突行为”（1.2.2节）之间的逻辑关系的。</p><p>利用上述两篇论文，可以构造出并发事务如何形成一个环，环存在表明事务之间相互依赖以至于形成了写偏序异常，<br>所以解决写偏序异常的方式就是打破环，回滚使环形成的新加入事务，从而破解写偏序异常现象。</p><p>xxxxxxxxxxxxxxxxxxx</p><h6 id="2-2-6-再深入探讨三种读数据异常现象"><a href="#2-2-6-再深入探讨三种读数据异常现象" class="headerlink" title="2.2.6　再深入探讨三种读数据异常现象"></a>2.2.6　再深入探讨三种读数据异常现象</h6><p>Q6：表1-11中，不可重复读现象中的事务T2在t2时刻执行“提交Commit”或不执行“Commit”会有什么差别吗？<br>或者对于幻象现象，事务T2在t2时刻没有执行“Commit”，这一点与不可重复读有差别吗？</p><pre><code class="hljs">对于“不可重复读异常”现象，如果并发控制技术使用的是两阶段封锁协议，事务T2在t1时刻不会被阻塞，所以事务T2能够在t2时刻提交。而事务T1在t3时刻读取数据的操作如果被允许，则会发生“不可重复读异常”现象，所以“可重复读”隔离级别下事务T1在t3时刻读取数据的操作将失败（即用事务T1的失败来避免“不可重复读异常”现象发生） 。但是如果使用了多版本并发控制协议，事务T1读取的数据是旧版本的数据不受事务T2在t1时刻写的新版本的数据影响，因而能避免“不可重复读异常”现象。对于“幻象异常”现象，在t1时刻，因为事务T2已经在相同数据项上施加了写锁（更新锁或排它锁），事务T1被阻塞不能在t2时刻执行读操作。但如果是基于多版本的封锁并发控制技术（参见2.2.4节），t2时刻事务T1的这个读操作不会被阻塞，通常情况下，不被阻塞的读操作会出现“不可重复读异常”现象，但是因为使用了多版本，即事务T1读取的数据是旧版本的数据不受事务T2在t1时刻写的新版本的数据影响，因而能避免“幻象异常”现象。</code></pre><p>在商业或开源的数据库系统实现中，对于幻象的处理，还需要细分上一段文字所述的情况：</p><p>Q7：表2-5中，row是一个什么级别的数据？</p><p>对于行存数据库，row可以是以行为单位的行或行中的某些列。其含义是一个“数据项”。</p><p>Q8：表2-5中，幻象一定要带有WHERE条件子句吗？</p><p>不是。没有WHERE相当于WHERE<TRUE>即表示所有行满足条件。</TRUE></p><h5 id="2-3-并发控制技术的比较"><a href="#2-3-并发控制技术的比较" class="headerlink" title="2.3　并发控制技术的比较"></a>2.3　并发控制技术的比较</h5><p>事务的并发调度，主要包括两个方面和一个效果：</p><pre><code class="hljs">一是事务的读操作和写操作等之间的关系、即如何解决（阻塞还是允许）冲突行为（读–写、写–读、写–写）。二是并发事务间的提交/中止的顺序。一个效果是指每一种并发控制技术所讨论的就是在上面的两条规则限定下，并发度如何被提高。即并发执行的效率问题。</code></pre><h6 id="2-3-1-并发控制技术整体比较"><a href="#2-3-1-并发控制技术整体比较" class="headerlink" title="2.3.1　并发控制技术整体比较"></a>2.3.1　并发控制技术整体比较</h6><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_12.png" alt="img_12.png"></p><p>①协议改进后（在事务的末尾执行写操作，在写操作正在执行时，其他事务不允许访问已经写过的数据项）可保证可恢复性。</p><p>②协议改进后（在事务的末尾执行写操作，在写操作正在执行时，其他事务不允许访问已经写过的数据项）可保证无级联性。</p><p>③写操作可能引起事务的回滚。</p><p>④某个版本的写时间戳小于最老的事务的时间戳，则可被删除。</p><p>⑤与两阶段封锁协议的差别在于，树形协议需要事先知道访问数据项的顺序，如适用于执行存储过程。</p><p>⑥有多种技术可以改进多粒度封锁协议，使得减少死锁发生的频度，或者消除死锁（H.F.Korth“Deadlock Freedom Using Edge Locks”）。</p><p>⑦写操作可能导致封锁等待或死锁。</p><p>⑧某个版本的写时间戳小于等于最老的只读事务的时间戳，则可被删除。</p><p>⑨一系列冲突的短事务会引起长事务反复重启。</p><p>⑩事务回滚后又被自动重启。重启是有效性检查协议明显地区别于其他并发控制技术的特点之一。</p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_13.png" alt="img_13.png"><br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_14.png" alt="img_14.png"></p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_15.png" alt="img_15.png"></p><p>①更新锁步被共享锁阻塞，所以更新带来的写操作可以执行；插入操作需要检查是否满足谓词锁如满足谓词锁则在可串行化隔离级别下被阻塞，所以表格中写为“不一定”。</p><p>②读–写冲突中，写操作被回滚或不被回滚都有可能，取决于写事务的时间戳值与读操作的时间戳的比较，详情参见2.2.2节。</p><p>③写–读冲突中，读操作被回滚或不被回滚都有可能，取决于读事务的时间戳值与写操作的时间戳的比较，详情参见2.2.2节。</p><h6 id="2-3-2-S2PL和SS2PL的比较"><a href="#2-3-2-S2PL和SS2PL的比较" class="headerlink" title="2.3.2　S2PL和SS2PL的比较"></a>2.3.2　S2PL和SS2PL的比较</h6><p>在2.2.1节，我们讨论了S2PL和SS2PL的基本内容，本节对这两项技术参照图2-6做一个详细对比。</p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_16.png" alt="img_16.png"></p><h6 id="2-3-3-事务属性与并发控制技术的关系"><a href="#2-3-3-事务属性与并发控制技术的关系" class="headerlink" title="2.3.3　事务属性与并发控制技术的关系"></a>2.3.3　事务属性与并发控制技术的关系</h6><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_17.png" alt="img_17.png"></p><p>图分为上下两部分，上面的部分写有“noninherently blocking properties”，表明不存在因并发而致使某些<br>操作被阻塞。下面的部分写有“inherently blocking properties”，表明存在因并发而致使某些操作被阻塞。</p><h6 id="2-3-4-SCO和SS2PL的比较"><a href="#2-3-4-SCO和SS2PL的比较" class="headerlink" title="2.3.4　SCO和SS2PL的比较"></a>2.3.4　SCO和SS2PL的比较</h6><p>还有一种并发控制技术，提交排序（Commitment ordering，CO）详情参见1.4.2节和<a href="https://en.wikipedia.org/wiki/Commitment_ordering">https://en.wikipedia.org/wiki/Commitment_ordering</a> 。SCO就是CO技术的一个变种。如图2-8所示。</p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_18.png" alt="img_18.png"></p><p>SS2PL：强两阶段封锁协议Strong strict two-phase locking protocol，事务T1先于事务T2，两者可以并发执行，对于同一个数据项X事务T1的读操作r1（X）先于事务T2的写操作w2（X）发生，事务T2的写操作被延迟，即只有事务T1提交&#x2F;撤销后，事务T2才能提交。所以读操作会阻塞写操作（“读–写”操作）。这样并发度被降低 （如图，<br>事务T2的写操作被延迟，等事务T1结束后，事务T2用了一段时间为t的提交时间段才能完成提交&#x2F;撤销）。</p><p>SCO：严格提交排序Strict Commitment Ordering，事务T1先于事务T2，两者可以并发执行，对于同一个数据项X事务T1的读操作r1（X）先于事务T2的写操作w2（X）发生，但是，事务T2的写操作被允许执行，只是事务T2的提交&#x2F;撤销操作被延迟，等到事务T1提交&#x2F;撤销后，事务T2才能提交或撤销。所以读操作不会阻塞写操作。这样并发度被提高。</p><h6 id="2-3-5-TO和SS2PL的比较"><a href="#2-3-5-TO和SS2PL的比较" class="headerlink" title="2.3.5　TO和SS2PL的比较"></a>2.3.5　TO和SS2PL的比较</h6><p>在2.2.1节我们讨论了基于封锁的机制SS2PL，在2.2.2节讨论了基于时间戳的排序协议TO，这是两种并发控制技术，都可以用于并发事务间保证数据一致性。但是，这两种技术之间，有什么不同呢？</p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch02/ch2/img_19.png" alt="img_19.png"></p><p>所以，SS2PL满足“可恢复性”而TO不满足“可恢复性”。《数据库系统概念（第六版）》一书15.4.2节谈到了一些弥补TO不具备“可恢复性”缺陷的技术，以保证事务的调度是可恢复的，本书不再赘述，请参阅相关书籍和资料。</p><h5 id="2-4-深入探讨隔离级别"><a href="#2-4-深入探讨隔离级别" class="headerlink" title="2.4　深入探讨隔离级别"></a>2.4　深入探讨隔离级别</h5><p>2.1节讲述了ANSI SQL标准定义的四种隔离级别，这四种隔离级别应对的是1.1.3节探讨的ANSI SQL标准定义的三种读数据异常现象，而且ANSI SQL标准是在数据库的基于锁的并发控制技<br>术下定义的，所以三种读数据异常、四种隔离级别和基于锁的并发控制技术之间的关系着密不可分。</p><p>2.2节讲述了多种并发控制技术，这些技术首先要保证并发事务的可串行性，其次要提升并发事务的执行效率，各种并发控制技术从不同角度提出了以上两个问题的解决方式。从可串行性的角度看，各种并发控制技术实则确保的是隔离级别中的最高级别“可串行化”。</p><p>除“可串行化”隔离级别外的其他的隔离级别，目的在于降低数据一致性的严格要求，提高并发事务的并发度。我们在2.2节讲述并发控制技术中没有提及，本节从其他隔离级别的角度来探讨各种并发控制技术是如何实现这些隔离级别的。</p><h6 id="2-4-1-隔离级别与基于锁的并发控制方法"><a href="#2-4-1-隔离级别与基于锁的并发控制方法" class="headerlink" title="2.4.1　隔离级别与基于锁的并发控制方法"></a>2.4.1　隔离级别与基于锁的并发控制方法</h6>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>数据库事务处理的艺术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch1. 数据库管理系统的事务原理</title>
    <link href="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/"/>
    <url>/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch1. 数据库管理系统的事务原理</p><p>数据库管理系统（DataBase Management System，DBMS，以下简称“数据库”），是位于用户与操作系统之间的一层数据管理软件，<br>功能主要包括：数据定义、数据操纵、数据库的运行管理、数据库的建立和维护等。</p><p>数据库的事务处理机制，是数据库技术的基石。掌握数据库技术，必须要掌握事务处理的技术，这样才能把握数据库的核心技术。<br>同时，也必须了解数据库为什么会需要事务处理技术，即事务处理技术要解决的问题，<br>这一点，就是我们在第一章第一节开门见山地提出的问题。</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-1-事务模型要解决的问题"><a href="#1-1-事务模型要解决的问题" class="headerlink" title="1.1 事务模型要解决的问题"></a>1.1 事务模型要解决的问题</h5><h6 id="1-1-1-为什么需要事务处理机制"><a href="#1-1-1-为什么需要事务处理机制" class="headerlink" title="1.1.1 为什么需要事务处理机制"></a>1.1.1 为什么需要事务处理机制</h6><p><strong>数据库为什么需要事务处理机制？</strong></p><p>我们先回避问题，绕道看如下的一个实际用户操作，从A账户转账50元到B账户，其过程如表1-1所示。</p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img.png" alt="img.png"></p><p><strong>事务处理机制，就是要保证用户的数据操作动作对数据是“安全的”。</strong><br>那么，什么样的操作是安全的呢？数据只有在带有“ACID”四个特性的事务处理机制的保障下，才可以认为是“安全的”。</p><h6 id="1-1-2-事务机制要处理的问题——事务故障、系统故障、介质故障"><a href="#1-1-2-事务机制要处理的问题——事务故障、系统故障、介质故障" class="headerlink" title="1.1.2　事务机制要处理的问题——事务故障、系统故障、介质故障"></a>1.1.2　事务机制要处理的问题——事务故障、系统故障、介质故障</h6><h6 id="1-1-3-并发带来的问题——三种常见的读数据异常现象"><a href="#1-1-3-并发带来的问题——三种常见的读数据异常现象" class="headerlink" title="1.1.3　并发带来的问题——三种常见的读数据异常现象"></a>1.1.3　并发带来的问题——三种常见的读数据异常现象</h6><p>数据不在ACID特性的保护下会发生不一致的现象，那么：</p><p><strong>在ACID的保护下，是不是数据就一定不会产生不一致的现象呢？</strong></p><p>在关系数据库系统中，多个会话（session）可以访问同一个数据库的同一个表的同一行数据。<br>这样，对于数据而言，就意味着在同一个时间段内，有多个会话可以对其施加操作（或读操作或写操作），<br>读写操作施加的顺序不同以及事务中A特性对事务结果的影响（或成功或失败，即要么提交要么中止），<br>这三种因素叠加在一起，会存在几种对数据有不同影响的情况：</p><pre><code class="hljs">读–读操作 ：如果同时只存在多个读操作，对于数据自身则没有影响；既读和读操作互不影响数据的一致性，读读操作可以并发执行。读–写操作 ：如果读写操作都存在，因写在前读在后（如脏读 现象）、读在前写在后（如不可重复读现象），或者读在前写在后然后又读（如幻象 现象），就可能因数据被写而导致另外一个读操作的会话读到错误的数据 。这个操作可以根据动作发生的先后顺序被细分为读–写操作、写–读操作。写–写操作 ：如果同时存在多个写操作，写–写操作直接改变了数据在同一时刻的语义，这就更不被允许，所以写–写操作通常不允许被并发执行。但是，如果不做并发控制，写–写并发操作也会带来数据异常现象（1.1.4节探讨写–写操作引发的异常）。</code></pre><p>这三种情况的第二种，对应了SQL标准中定义的三种数据异常的现象，注意这三种异常都是针对某个事务（第2.2.1节称这样的事务为“主事务”）的读操作而言的。<br>SQL2003标准对于数据异常现象的定义如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">隔离级别指定了在并发SQL事务执行过程中可能发生的现象类型。以下是可能出现的现象：<br><br>1) P1（“脏读”）：SQL事务T1修改了一行数据。随后，SQL事务T2在T1执行COMMIT之前读取了该行。<br>如果T1之后执行了ROLLBACK，那么T2将读取到一个从未被提交的数据行，因此可以认为这条记录实际上从未存在过。<br><br>2) P2（“不可重复读”）：SQL事务T1读取了一行数据。接着，SQL事务T2修改或删除了这行数据并执行了COMMIT。<br>当T1尝试再次读取该行时，它可能会得到修改后的值，或者发现该行已经被删除。<br><br>3) P3（“幻读”）：SQL事务T1读取满足某些&lt;搜索条件&gt;的一组数据行N。然后，SQL事务T2执行了一些SQL语句，<br>生成了一个或多个也满足T1所用&lt;搜索条件&gt;的新行。如果T1使用相同的&lt;搜索条件&gt;重复最初的读取操作，<br>它会获得一组不同的数据行。<br></code></pre></td></tr></table></figure><p>下面，我们把SQL标准的话语转为一个表格（如表1-2所示），以更好地理解一下三种异常现象。</p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_1.png" alt="img_1.png"></p><p>脏读现象 ：按照时间顺序，T1事务在t0时刻对row进行了修改（更新），T2事务在t1时刻先读取了被T1修改了的row的值，<br>但是T1在t2时刻中止使得对row的修改失效。如果数据库引擎不支持因并发操作避免数据异常，<br>则T2在t1时刻读到的就是T1修改后的数据，但是这个数据在现实世界中不存在，对于事务T2而言，<br>读取了被回滚掉的数据，即事务T2发生了脏读异常现象。另外，对于脏读现象，还存在如表1-3的两种变形情况。</p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_2.png" alt="img_2.png"></p><p>不可重复读现象 ：事务T1在t0时刻先读取row的旧值，事务T2在t1时刻对row进行了修改（更新或删除）<br>然后提交事务使得修改生效，此时row因更新变为了新值或因删除而不再存在。接下来，事务T1在t3时刻再次读取<br>row对象的值但是row的值已经是新值或者不存在了。对于事务T1而言，物是（同样是读row这个对象）人非（值已经和<br>t0时刻读到的值不同），事务T1发生了不可重复读异常现象。</p><p>幻象现象 ：事务T1在t0时刻带有特定条件地读取了row对象的数据，事务T2在t1时刻插入新的数据或更新其他旧数据但满<br>足事务T1的特定WHERE条件，新的数据满足与事务T1同样的条件，当事务T1在t3时刻再次以同样的条件读取数据的时候，<br>rows对象的值已经有新加入的行（因插入而比第一次读多出了数据）。对于事务T1而言，物是<br>（同样是读满足“<condition>”条件的多个row对象）人非（值已经和t0时刻读到的值不同），<br>事务T1发生了幻象异常现象。幻象又称为幻读，即第二次读操作读取了第一次读操作没有读到的rows（一行或多行）。</condition></p><p><strong>在ACID的保护 下，是不是数据就一定不会产生不一致的现象呢？</strong></p><p>答案已经很明确：即使数据库系统提供ACID，除非我们使用“可串行化（SERIALIZABLE）”隔离级别，<br>否则数据在其他不同的隔离级别下还会产生数据不一致的现象。</p><h6 id="1-1-4-并发带来的问题——写–写并发操作引发的数据异常现象"><a href="#1-1-4-并发带来的问题——写–写并发操作引发的数据异常现象" class="headerlink" title="1.1.4　并发带来的问题——写–写并发操作引发的数据异常现象"></a>1.1.4　并发带来的问题——写–写并发操作引发的数据异常现象</h6><p>上一节，我们探讨了三种读数据异常现象，请注意，异常现象发生在一个事务中后面的READ读操作上。<br>这三种读数据异常现象被SQL标准定义。那么：</p><p><strong>是不是对数据的并发操作只会产生上述的三种读数据异常现象？</strong></p><p>事务概念的奠基人，Jim Grey先生，在其著作《事务处理：概念与技术》中提到了一个“Lost Update”异常的概念，<br>字面含义是“更新丢失”，这是一个写操作的异常，与上一节提到的三种读操作异常不同。</p><p>除了“Lost Update”异常外，这一节我们还将探讨另外一种异常，如表1-4所示。</p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_3.png" alt="img_3.png"></p><p>脏写现象 ：按照时间顺序，事务T1在t0时刻对row进行了修改（更新），事务T2在t1时刻对row进行了修改（更新），<br>如果没有并发控制，T2对row的修改会生成新值，但是T1在t3时刻回滚使得T2对row的修改失效，<br>而T1的语义是：T1自身对row的修改失效，这就把T2修改的值回滚掉。对于事务T1而言，回滚掉了不是自己修改的数据，<br>即事务T1上发生了脏写现象。</p><p>丢失更新现象 ：按照时间顺序，事务T2在t1时刻对row进行了修改（更新），事务T1在t2时刻对row进行了修改（更新），<br>如果没有并发控制，T1对row的修改会生成新值，但是T1在t3时刻提交使得T2对row的修改失效。对于事务T1而言，<br>覆盖掉了不是自己修改的数据，即事务T1上引发了丢失更新现象（t3时刻如果是事务T2提交而不是事务T1提交，<br>也是丢失更新，只是事务T2上引发了丢失更新现象）。</p><p>不管是读异常还是写异常，并发控制技术都要规避这些异常，保证数据在不同隔离级别下一致性不被破坏。</p><h6 id="1-1-5-语义约束引发的数据异常现象"><a href="#1-1-5-语义约束引发的数据异常现象" class="headerlink" title="1.1.5　语义约束引发的数据异常现象"></a>1.1.5　语义约束引发的数据异常现象</h6><p><strong>在ACID和快照隔离级别技术（多版本）的保护下，是不是数据就一定不再会产生不一致的现象呢？</strong></p><p>快照隔离并发技术是多版本并发控制（Multiversion concurrency control，MVCC）技术的一部分，其发生作用，<br>需基于“数据项存在多个版本”。</p><p>快照隔离并发控制技术的缺点，是并不能真正保证事务为“可串行化的”，即事务间的并发操作依旧会引发数据异常现象，<br>但是这里的数据异常现象有别于前面提到的各种异常现象，其异常现象是“业务的逻辑语义”引发的，即除了抽象的读写操作，<br>数据间还应该满足一定语义，即约束（constraint）。</p><p>在快照隔离并发控制技术中并发的事务因不满足约束而发生的异常，称为“写偏序（Write Skew）”，<br>这样的异常有两种，参见表1-5。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">Dan R. K. Ports，Kevin Grittner，Serializable Snapshot Isolation in PostgreSQL<br></code></pre></td></tr></table></figure><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_4.png" alt="img_4.png"></p><p>二个事务引发的异常现象 （简单写偏序，Simple Write Skew）：按照时间顺序，T1事务在t0时刻读取了<br>在打电话的值班医生个数，T2事务在t1时刻也读取了在打电话的值班医生个数。事务T1在t2时刻进行判断：<br>如果在打电话的值班医生个数大于等于2人则请Alice停止打电话。事务T2在t3时刻进行判断：如果在打电话的值班医生个<br>数大于等于2人则请Bob停止打电话。然后事务T1和T2分别提交。如果在这种并发的情况下，允许事务T1和T2都提交成功，<br>则t6时刻，Alice和Bob都停止了打电话。如果串行执行事务，先执行事务T1后执行事务T2，Alice会停止打电话但Bob不<br>会停止，这与前一种情况的结果不同；如果先执行事务T2后执行事务T1，Bob会停止打电话但Alice不会停止，这与前一<br>种情况的结果也不同；这表明前一种并发执行是非序列化的，而此时，事务T1、T2并发时违反了约束（约束为：如果同<br>时打电话的人数大于等于2人则请Alice或Bob其中一个人停止打电话直到同时打电话的人数少于2人）发生了写偏序异常<br>现象。对于简单写偏序，可以用一个形象化的图表示，如图1-1所示。</p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_5.png" alt="img_5.png"></p><p>三个事务引发的异常现象 （Batch Processing）：对于这种情况，后两个并发更新事务T3和T2是可串行化的且不存在<br>任何异常，但是一个只读事务T1出现在某个时刻却可能正好造成问题。所出现的问题是这样的，当事务T3提交时，T2处<br>于活跃状态，这时，事务T1启动要读取事务T2和T3涉及的数据（current_batch和receipts），这时，事务T1的快照包<br>括了事务T3的插入后的结果（因为T3已经提交）；但是，事务T2没有提交，它的插入操作数据不包含在事务T1的快照中。<br>在优先图（如图1-2所示）中会造成一个环（有关如何形成这样的环，参见2.2.5节），说明这样的调度是非可串行化的。</p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_6.png" alt="img_6.png"></p><p>本节所述的这两种情况，如果使用优先图表示，都可以在参与操作的事务之间，画出一个环，存在环说明：调度是非可串行化的 。<br>为解决这样的问题，要求数据库引擎必须在事务提交时（甚至是环一形成即立刻回滚其中的一个事务）而不是在<br>快照上检查完整性约束，以避免本节所述的不一致现象。</p><p><a href="https://wiki.postgresql.org/wiki/SSI#Read_Only_Transactions">https://wiki.postgresql.org/wiki/SSI#Read_Only_Transactions</a></p><h6 id="1-1-6-其他的异常"><a href="#1-1-6-其他的异常" class="headerlink" title="1.1.6　其他的异常"></a>1.1.6　其他的异常</h6><p>在《A Critique of ANSI SQL Isolation Levels》这篇论文中，除了上面提到的几种异常现象外，还提到了另外两种异常，如表1-6和表1-7所示。</p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_7.png" alt="img_7.png"></p><p>事务T1在t0时刻读出数据x，事务T2在t1时刻对数据x和y进行了修改在t2时刻提交，事务T1在t3时刻读取y，y是被事务T2修改后的数据，<br>此时已经不是t0时刻事务T1读取x时对应的y值，数据形成了不一致状态（注意此时不是数据x处于不一致，而是y处于不一致）。</p><p>游标（Cursor），是数据库引擎提供的一种读取数据的方式。在数据库中，为了防止使用游标时其他事务并发<br>修改游标所包括的数据，定义了游标稳定性 （Cursor Stability）隔离级别 ，这样的隔离级别，是在读取当前数据<br>项的时刻，在数据项上加锁，当游标从当前数据项移走则解锁，此后曾经被读取过的数据项不再被并发保护（尽管使用<br>游标的事务没有提交或中止，还处于活动状态）。但是，在使用游标的时候，也会发生写–写异常，如表1-7所示。</p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_8.png" alt="img_8.png"></p><p>游标丢失更新现象 ：按照时间顺序，事务T1在t0时刻读取row的值后，即释放了row上的锁使得row没有被并发保护，<br>事务T2在t1时刻对row进行了修改（更新），事务T1在t2时刻对row进行了修改（更新），如果没有并发控制，T1对row的<br>修改会生成新值，但是T1在t4时刻提交使得T2对row的修改失效。对于事务T1而言，覆盖掉了不是自己修改的数据，<br>即事务T1上引发了丢失更新现象。这样的现象，本质上就是丢失更新，只是发生在了游标上，所以称为游标丢失更新。</p><p>如下我们借用《A Critique of ANSI SQL Isolation Levels》这篇论文中的一张表，来简单总结一下前面几节所谈到的各种异常。</p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_9.png" alt="img_9.png"></p><h6 id="1-1-7-深入探讨三种读数据异常现象"><a href="#1-1-7-深入探讨三种读数据异常现象" class="headerlink" title="1.1.7　深入探讨三种读数据异常现象"></a>1.1.7　深入探讨三种读数据异常现象</h6><p><strong>Q1：异常现象是发生在表1-2中的事务T1还是事务T2？</strong></p><p>数据异常现象，一定是发生在本事务当中的。我们统一以事务T1为本事务（也称为“主事务”），<br>观察本事务和其他并发事务之间因读写操作的先后次序不同而造成的不同的数据异常。因此，我们修正表1-2的内容如表1-9所示。</p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_10.png" alt="img_10.png"></p><p>对于Q1问题的回答，依据表1-9，数据异常现象发生在表1-9中的主事务T1中。<br>其实，如上修改是为了明确并发事务的数据异常现象发生在哪里。即研究别的事务对于本事务的影响，<br>而不是讨论本事务对别的事务的影响。</p><p><strong>动作发生的主体，一定是主事务。而且，异常是发生在主事务的读操作这样的动作上（指三种读异常）。</strong></p><p><strong>Q2：从表1-9中看，对于脏读现象，写操作是事务T2执行UPDATE引发的，那么，事务T2的写操作可以是删除（DELETE）<br>或插入（INSERT）吗？</strong></p><p><strong>Q3：对于不可重复读现象，事务T2的写操作是否可以是插入操作？</strong></p><p><strong>Q4：不可重复读和幻象有什么区别？</strong></p><p>首先，这两种异常，对于主事务T1而言，都是先读取了数据，之后因事务T2“写”了数据而事务T1再次读取数据的时候，发生了异常。<br>不可重复读对于事务T1读取的是一个存在的确定的一行数据 （意味着这行数据是存在的数据）变；<br>而幻象对于事务T1读取的是满足条件“<condition>”的多行数据<br>（意味着“<condition>”是一个范围查找，结果集不确定）。</condition></condition></p><p>其次，不可重复读对于事务T2的写操作是更新或删除操作，而幻象对于事务T2的写操作是插入（插入的新数据满足条件）<br>或更新（使不满足条件的数据在更新后满足条件）操作。</p><p>第三，不可重复读和幻象最大的区别就是前者只需要“锁住”（考虑）已经读过的数据，而幻象需要对“还不存在的数据”做出预防。</p><p><strong>Q5：对于幻象现象，事务T2的写操作是否可以是更新操作或者删除操作？</strong></p><p>对于幻象现象中事务T2的W（rows）操作，如果操作是一个更新或删除操作，则表明这样的操作等同于（相似但不完全一样，<br>区别参见Q6）不可重复读（即是在多个行数据上进行更新或删除，即在多个行数据上批量化重演了不可重复读现象）。<br>实际上，幻象是不可重复读的一个特例。</p><p>表1-10　幻象的写操作改为更新则等同于不可重复读<br><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_11.png" alt="img_11.png"></p><p><strong>Q6：表1-11中，不可重复读现象中的事务T2在t2时刻执行“Commit”或不执行“Commit”会有什么差别吗？或者对于幻象现象，<br>事务T2在t2时刻没有执行“Commit”，这一点与不可重复读有差别吗？</strong></p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_12.png" alt="img_12.png"></p><h5 id="1-2-事务处理技术的原理"><a href="#1-2-事务处理技术的原理" class="headerlink" title="1.2 事务处理技术的原理"></a>1.2 事务处理技术的原理</h5><p>本节我们来讨论解决上述各种异常现象的事务模型及其相关技术，从整体上理解事务的概念以及相关的技术之间的联系。</p><h6 id="1-2-1-什么是事务"><a href="#1-2-1-什么是事务" class="headerlink" title="1.2.1　什么是事务"></a>1.2.1　什么是事务</h6><p>ANSI SQL标准:</p><p>SQL事务（transaction）是一系列SQL语句的执行序列，从恢复的角度来看它是原子性的。<br>也就是说：要么执行结果完全成功，要么它对任何SQL模式或SQL数据都没有影响。</p><p>Jim Gray:</p><p>事务是一组SQL命令，其结果将在事务提交时作为一个整体对系统其余部分可见——如果事务中止，<br>则这些结果完全不会对外部可见。事务预期具有原子性、一致性、隔离性和持久性。</p><p>ACID–</p><p>原子性（Atomicity）或是“all”或是“nothing”</p><p>一致性（Consistency）符合逻辑语义</p><p>隔离性（Isolation） “并发”看起来像是“串行”。“隔离级别”是为了提高并发度、<br>从而弱化了数据在并发读写下的“一致性”（如写偏序）</p><p>持久性（Durability）对于“committed”状态的数据，要能够永久保存</p><h6 id="1-2-2-事务的属性"><a href="#1-2-2-事务的属性" class="headerlink" title="1.2.2　事务的属性"></a>1.2.2　事务的属性</h6><p>如果说ACID是事务的特性，那么，可串行化（Serializability）、<br>可恢复性（Recoverability）、严格性（Strictness）则可以称为事务的属性。</p><p><strong>1.可串行化（Serializability）</strong></p><p>冲突行为 （Conflicting actions）又称为冲突动作，当有两个动作满足如下三个条件，则这两个动作是冲突的：</p><p>冲突等价 （Conflict equivalence）对于不同的事务调度方式S1和S2，如果满足如下两个条件，<br>则事务调度方式S1和S2是等价的：</p><pre><code class="hljs">S1和S2调度方式包括同样的事务集合（每一个事务中的操作的顺序是固定的，不能在不同的调度方式下发生变化）；S1和S2调度方式包括同样的冲突操作集合。</code></pre><p>冲突可串行化 （Conflict-serializable）当某个调度是一个“冲突等价”于一个或多个“串行调度”，则这个调度是“冲突可串行化”的。</p><p>可串行化概念的作用在于保证并发的事务调度方式既能满足数据一致性需求，又能提高并发事务的执行效率。</p><p><strong>2.可恢复性（Recoverability）</strong></p><p>可恢复性是并发的事务后期、表明提交阶段事务间相互影响的属性。即：已经提交的事务没有读过被中止的事务的写数据。<br>否则脏读异常发生，导致数据不一致。所以可恢复性属性保证的是多个事务并发调度后期的提交顺序对数据的一致性没有影响。</p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_13.png" alt="img_13.png"></p><p>避免级联中止</p><p><strong>3.严格性（Strictness）</strong></p><p>严格性概念的作用在于保证：有冲突动作（前述的“冲突行为（Conflicting actions）”）的并发的事务中 ，<br>先发生写操作的事务提交或中止的操作优先于其他事务。 </p><p>前面讲述了事务的多个属性，这些属性从属于事务的调度方式，属性之间从概念上存在一个语义包含的关系，如图1-3所示。</p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_14.png" alt="img_14.png"></p><pre><code class="hljs">从串行化的角度看，如图中纵向的方框，串行化的严格程度从松到严的次序为：all schedules→view serializable→conflict serializable→serial。从可恢复性的角度看，如图中横向的方框，严格程度从松到严的次序为：recoverable→avoids cascading aborts→strictness→serial。最核心的是“serial”，“serial”能够保证数据的一致性，但是其执行效率低。所以在确保数据一致性的前提下，不同的调度方式致力于提高并发执行的效率，使得数据库的事务管理器能够高效地运行。各种并发技术，就是致力于保证在并发的事务调度正确性的前提下，提高事务管理器的事务并发调度的效率。多种并发控制技术含义就是针对并发事务的不同的调度方式。</code></pre><h6 id="1-2-3-ACID的实现技术"><a href="#1-2-3-ACID的实现技术" class="headerlink" title="1.2.3　ACID的实现技术"></a>1.2.3　ACID的实现技术</h6><p><strong>请简洁地总结一下哪些技术是分别实现ACID中的A的？哪些是实现C、I、D的？</strong></p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_15.png" alt="img_15.png"></p><h5 id="1-3-事务的模型"><a href="#1-3-事务的模型" class="headerlink" title="1.3 事务的模型"></a>1.3 事务的模型</h5><p>Jim Gray的《事务处理概念与技术》一书的第四章事务模型</p><p>平板事务（Flat Transactions）事务块中的所有SQL语句，构成一个逻辑单元，要么都成功，要么因之一失败都回滚。（PG不考虑savepoint）</p><p>带有保存点的平板事务（Flat Transactions With Savepoints）PostgreSQL、InnoDB、Informix在平板事务的基础上，支持了保存点技术。</p><p>链式事务（Chained Transactions）InnoDB的事务模型，就是链式事务的代表（这句话不是说InnoDB不支持平板事务，<br>实际上InnoDB支持平板事务、支持带有保存点的平板事务、支持链式事务，并通过XA技术支持下面谈到的分布式事务）</p><p>嵌套事务（Nested Transactions）PostgreSQL、MySQL（不是InnoDB，InnoDB是被Oracle收购之后才逐渐并入MySQL的）没有对嵌套事务通过支持。</p><p>分布式事务（Nested Transactions）</p><p>多层次事务（Multi-Level Transactions）</p><h5 id="1-4-并发控制技术"><a href="#1-4-并发控制技术" class="headerlink" title="1.4 并发控制技术"></a>1.4 并发控制技术</h5><p>并发控制技术是实现原子性、一致性和隔离性的重要技术之一，是本书的重点。</p><p>发控制技术的本质，就是要对并发的事务实现正确的（保证数据的一致性、保证事务操作的原子性）、<br>高效的（用“可串行性&#x2F;可恢复性&#x2F;严格性”实现可并发，部分情况下牺牲一致性，或用低级别的隔离性容忍不一致以提高并发执行效率）调度。</p><h6 id="1-4-1-并发控制技术的实现策略"><a href="#1-4-1-并发控制技术的实现策略" class="headerlink" title="1.4.1　并发控制技术的实现策略"></a>1.4.1　并发控制技术的实现策略</h6><p>并发控制技术，从实现的思路角度看，有两类，是事后检查还是提前预防。</p><p>乐观 （Optimistic concurrency control，OCC）：从一开始，每一项操作都允许进行，但在事务提交的时刻，<br>进行隔离性和完整性约束的检查，如果有违反则事务被中止。显然，如果并发冲突少的场景，乐观并发控制方法是适合的。<br>2.2.3节讨论的基于有效性确认的并发控制方法就是乐观的。</p><p>悲观 （Pessimistic concurrency control，PCC）：从一开始，即检查每一项操作是否会违反隔离性和完整性约束，<br>如果可能违反，则阻塞这样的操作。如两阶段封锁，用读锁来阻塞另外一个事务的写锁。就是因为另外一个事务的写操作可能<br>会造成如1.1.3节提到的读异常，因此两阶段封锁技术属于悲观的方法，提前对异常现象进行了预防。基于时间戳排序的并发控制技<br>术也是悲观的。</p><h6 id="1-4-2-并发控制技术的实现技术"><a href="#1-4-2-并发控制技术的实现技术" class="headerlink" title="1.4.2　并发控制技术的实现技术"></a>1.4.2　并发控制技术的实现技术</h6><p><strong>1、时间戳 （Timestamp ordering，TO）：基于时间戳对事务提交顺序排序的并发控制技术。</strong></p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_16.png" alt="img_16.png"></p><p>时间戳并发控制技术用来确保在访问冲突的情况下，多个事务按照时间戳的顺序来访问数据项。 如果TS（Ti）&lt;TS（Tj），那么数据库事物<br>管理器必须保证所产生的调度等价于事务Ti出现在事务Tj之前的某个串行调度。</p><p><strong>2、Commitment ordering（或Commit ordering，CO）：提交排序是对提交操作的顺序进行排序，这种方式是“冲突可串行化”的一个特例：</strong></p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_17.png" alt="img_17.png"></p><p>CO被主要用于分布式事务处理</p><p><strong>3、串行化图形检测 （Serialization graph checking）：也称为优先图&#x2F;冲突图&#x2F;串行化图（Precedence graph、conflict graph、serializability graph）检测</strong></p><p><img src="/2025/05/05/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%89%BA%E6%9C%AF/ch01/ch1/img_18.png" alt="img_18.png"></p><p><strong>4、两阶段封锁 （Two-phase locking，2PL）</strong></p><p>首先，两阶段封锁强调的是“加锁（增长阶段，growing phase）和解锁（缩减阶段，shrinking phase）这两项操作，<br>且每项操作各自为一个阶段”，这就是说不管同一个事务 内需要在多少个数据项上加锁，所有的加锁操作都只能在同一个阶段完成，<br>在这个阶段内，不允许对对已经加锁的数据项进行解锁操作，即加锁和解锁操作不能交叉执行（同一个事务内） 。<br>这一条是说在同一个事务内部的事情。</p><p>其次，为了提高并发度，才对锁进行分类，分出共享锁（读锁）和排它锁（写锁），因这两种类型的锁，又产生加两种锁共四种事务因并发受影响的情况：</p><pre><code class="hljs">（1）第一种情况（两个事务并发读同一个数据项）（2）读–写并发是不允许的，即第二种情况（3）二是对数据项施加了排它锁，这使得其他事务在这个数据项上的读操作（第三种情况）或写操作（第四种情况）都被禁止这一条是说在多个事务之间的事情。多个事务之间比较锁是否兼容，用到了锁的兼容性列表，就是上面的四种情况只是当锁的类型被扩展后，增加了意向锁等类型，才使得锁的兼容性列表变大，不再是四种情况，而是更多种。</code></pre><p>第三，共享锁是允许向排它锁升级的，排它锁是允许向共享锁降级的，升级（upgrade）和降级（downgrade）操作，称为锁转换（lock conversion）。</p><p>升降级发生在同一个事务内部，但目的也是为了提高多个事务之间的并发度。</p><p>两阶段的含义是指在同一个事务内，对所涉及的所有数据项进行先加锁，然后才对所有的数据项解锁。但两阶段封锁第一阶段加共享锁后影响了其他事务<br>的写操作、加排它锁后影响了其他事务的读操作（读受影响更不用提写），所以较大地影响了其他事务的运行<br>（如果不操作相同数据项则互不影响）。只有第二阶段释放了所有的数据项上的锁之后，才能运行其他要操作相同数据项的事务。</p><p>按提交操作的时机不同，两阶段锁可以分为S2PL和SS2PL两种方式。</p><p>并发控制技术，有一些不单独使用，而是配合其他并发控制技术一起使用，用以改善主并发控制技术以提高并发度<br>（所以需要特别注意这些技术的适用范围和缺点，其缺点正是需要使用其他并发控制技术弥补)。</p><p><strong>多版本并发控制技术 （Multiversion concurrency control（MCC or MVCC））</strong></p><p>事务管理器为写操作生成一个数据项的新版本；当有读操作发生时，按照读操作所在事务开始阶段获得的活动事务的快照、找出应该读取的该数据项的某个版本。<br>读–写操作或写–读操作不会互相阻塞，只留有写–写操作互相阻塞，进一步提高了并发度。<br>为了进一步提高并发的效率，多种并发控制技术协同使用效果更好。如封锁协议+MVCC，前者只有读–读不被阻塞，<br>后者只有写–写阻塞。这两个协议组合后使得基于封锁协议的读–写、写–读不被阻塞。</p><p>但是，这里描述的只有早期MVCC的技术（这些技术目前在PostgreSQL、InnoDB中被广泛使用），其关键点在于<br>解决“写–写”并发冲突，但是这样的MVCC技术不能避免“写偏序”数据异常。有一种较新的MVCC技术，<br>称为“write-snapshot isolation”的技术，致力于解决“读–写”冲突且能做到“可串行化”，比常规的MVCC技术<br>更加提升了并发度。详情可参阅论文《A Critique of Snapshot Isolation》。<br>分布式数据库CockrocachDB就采用了此篇论文提及的“write-snapshot isolation”技术。</p><p><strong>基于索引的并发控制技术 （Index concurrency control）</strong></p><p>索引树上对索引页采取封锁手段，以维护索引树的一致性；同时，可以确保避免幻象异常，如MySQL的InnoDB存储引擎以B+树作为存储的基本结构<br>（即索引组织表），可以在索引树上直接施加“next-key locking”进行范围锁定，以避免在谓词限定的“谓词空间”内新数据被<br>插入或旧数据被删除。</p><h5 id="1-5-日志技术与恢复子系统"><a href="#1-5-日志技术与恢复子系统" class="headerlink" title="1.5 日志技术与恢复子系统"></a>1.5 日志技术与恢复子系统</h5><p>日志技术是有效实现原子性和持久性的重要技术之一。</p><p>数据库引擎实现时，日志产生后被保存到日志缓存区，然后被刷出到外存，存放到日志文件中。</p><p>有的数据库系统，日志文件是不重用的，如PostgreSQL的日志文件名称是连续增长的，而使用文件组等概念的<br>数据库系统如Oracle、Informix，<br>它们的日志文件是重用的。不重用的日志文件，能够容忍长事务存在，而重用的日志文件因事务太长导致所有的日志文件用光了<br>的话，会因无日志文件可用导致数据库系统不得不挂起，如Informix。</p><p>在系统运行期间，REDO日志要求执行COMMIT操作的COMMIT日志的记录要先于被修改的数据项到达外存（即预写日志技术）。</p><p>在系统故障发生后，系统恢复期间，通常要使用REDO和UNDO日志来做恢复，这时，有两种策略可以选择：</p><p>策略一：恢复时，使用REDO日志只重做已经提交了的事务，如PostgreSQL如此实现，这样省却了UNDO日志（PostgreSQL没有实现UNDO日志）。</p><p>策略二：恢复时，使用REDO日志重做所有事务，包括未提交的事务和回滚了的事务，然后通过UNDO日志回滚那些未提交的事务<br>（未成功的事务一定不能以新值覆盖旧值，即撤销新值对旧值的影响），如InnoDB如此实现。</p><h5 id="1-6-本章小结"><a href="#1-6-本章小结" class="headerlink" title="1.6 本章小结"></a>1.6 本章小结</h5><p>本章初步讨论了事务模型要解决的问题以及所使用的技术。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>数据库事务处理的艺术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch13. 不常见的数据类型</title>
    <link href="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch13/ch13/"/>
    <url>/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch13/ch13/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch13. 不常见的数据类型</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="13-1-结构体"><a href="#13-1-结构体" class="headerlink" title="13.1 结构体"></a>13.1 结构体</h5><h5 id="CHECKLIST"><a href="#CHECKLIST" class="headerlink" title="CHECKLIST"></a>CHECKLIST</h5><h5 id="Key-Points"><a href="#Key-Points" class="headerlink" title="Key Points"></a>Key Points</h5>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>代码大全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>code</tag>
      
      <tag>programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch12. 基本数据类型</title>
    <link href="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/"/>
    <url>/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch12. 基本数据类型</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="12-1-数值概论"><a href="#12-1-数值概论" class="headerlink" title="12.1 数值概论"></a>12.1 数值概论</h5><p>使用数时少分错误的建议：<br>1、避免使用神秘数值(magic number)<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image.png" alt="Alt text"><br>2、如果需要，可以使用硬编码的0和1<br>程序主体中仅能出现的文字量就是0和1<br>3、预防除零错误<br>使类型转换变得明显<br>4、避免混合类型的比较<br>5、注意编译器的警告  </p><h5 id="12-2-整数"><a href="#12-2-整数" class="headerlink" title="12.2 整数"></a>12.2 整数</h5><p>1、检查整数除法<br>2、检查整数溢出<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-1.png" alt="Alt text"><br>3、检查中间结果溢出  </p><h5 id="12-3-浮点数"><a href="#12-3-浮点数" class="headerlink" title="12.3 浮点数"></a>12.3 浮点数</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-2.png" alt="Alt text"><br>1、避免数量级相差巨大的数之间的加减运算<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-3.png" alt="Alt text"><br>2、避免等量判断<br>很多应该相等的浮点数值并不一定相等。<br>方案：先确定可接受的精确度范围，然后用布尔函数判断数值是否接近。<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-4.png" alt="Alt text"><br>3、处理舍入误差问题<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-5.png" alt="Alt text"><br>4、检查语言和函数库对特定数据类型的支持  </p><h5 id="12-4-字符和字符串"><a href="#12-4-字符和字符串" class="headerlink" title="12.4 字符和字符串"></a>12.4 字符和字符串</h5><p>1、避免使用神秘字符和神秘字符串<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-6.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-7.png" alt="Alt text"><br>2、避免off-by-one错误<br>偏差一<br>3、了解你的语言和开发环境是如何支持Unicode的<br>4、在程序声明期中尽早决定国际化&#x2F;本地化策略<br>5、如果你知道只需要支持一种文字的语言，请考虑使用ISO 8859字符集<br>6、如果你需要支持多种语言，请使用Unicode<br>7、采用某种一致的字符串类型转换策略  </p><h6 id="C语言中的字符串"><a href="#C语言中的字符串" class="headerlink" title="C语言中的字符串"></a>C语言中的字符串</h6><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-8.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-9.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-10.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-11.png" alt="Alt text"></p><h5 id="12-5-布尔变量"><a href="#12-5-布尔变量" class="headerlink" title="12.5 布尔变量"></a>12.5 布尔变量</h5><p>1、用布尔变量对程序加以文档说明<br>2、用布尔变量简化复杂的判断<br>3、如果需要的话，创建你自己的布尔类型  </p><h5 id="12-6-枚举类型"><a href="#12-6-枚举类型" class="headerlink" title="12.6 枚举类型"></a>12.6 枚举类型</h5><p>1、用枚举类型来提高可读性<br>2、用枚举类型来提高可靠性<br>3、用枚举类型来简化修改<br>4、用枚举类型作为布尔变量的替换方案<br>5、检查非法数值<br>6、定义出枚举的第一项和最后一项，以便用于循环边界<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-12.png" alt="Alt text"><br>7、把枚举类型的第一个元素留做非法值<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-13.png" alt="Alt text"><br>8、明确定义项目代码编写标准中第一个和最后一个元素的使用规则，并且在使用时保持一致<br>9、警惕给枚举元素明确赋值而带来的失误<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-14.png" alt="Alt text">  </p><h6 id="如果你的语言里没有枚举类型"><a href="#如果你的语言里没有枚举类型" class="headerlink" title="如果你的语言里没有枚举类型"></a>如果你的语言里没有枚举类型</h6><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-15.png" alt="Alt text"></p><h5 id="12-7-具名常量"><a href="#12-7-具名常量" class="headerlink" title="12.7 具名常量"></a>12.7 具名常量</h5><p>一旦赋值以后就不能再更改了。<br>单点控制！<br>1、在数组声明中使用具名变量<br>2、避免使用文字量，即使是安全的<br>3、用具有适当作用域的变量或类来模拟具名常量<br>4、统一地使用具名常量  </p><h5 id="12-8-数组"><a href="#12-8-数组" class="headerlink" title="12.8 数组"></a>12.8 数组</h5><p>1、确认所有的数组下标都没有超出数组的边界<br>2、考虑用容器来取代数组，或者将数组作为顺序话结构来处理<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-16.png" alt="Alt text"><br>3、检察数组边界点<br>4、如果数组是多维的，确认下标的使用顺序是正确的<br>5、提防下标串话<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-17.png" alt="Alt text"><br>6、在C中结合ARRAY_LENGTH()宏来使用数组<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-18.png" alt="Alt text">  </p><h5 id="12-9-创建你自己的类型-类型别名"><a href="#12-9-创建你自己的类型-类型别名" class="headerlink" title="12.9 创建你自己的类型(类型别名)"></a>12.9 创建你自己的类型(类型别名)</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-19.png" alt="Alt text"><br>指导原则：<br>1、给所创建的类型取功能导向的名字<br>2、避免使用预定义类型<br>3、不要重定义一个与定义的类型<br>4、定义替代类型以便于移植<br>5、考虑创建一个类而不是使用typedef<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-20.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-21.png" alt="Alt text"></p><h5 id="CHECKLIST"><a href="#CHECKLIST" class="headerlink" title="CHECKLIST"></a>CHECKLIST</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-22.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-23.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-24.png" alt="Alt text"></p><h5 id="Key-Points"><a href="#Key-Points" class="headerlink" title="Key Points"></a>Key Points</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch12/ch12/image-25.png" alt="Alt text"></p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>代码大全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>code</tag>
      
      <tag>programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch11. 变量名的力量</title>
    <link href="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/"/>
    <url>/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch11. 变量名的力量</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="11-1-选择好变量名的注意事项"><a href="#11-1-选择好变量名的注意事项" class="headerlink" title="11.1 选择好变量名的注意事项"></a>11.1 选择好变量名的注意事项</h5><p>可读、易记、恰如其分  </p><h6 id="最重要的命名注意事项"><a href="#最重要的命名注意事项" class="headerlink" title="最重要的命名注意事项"></a>最重要的命名注意事项</h6><p>该名字要完全准确的描述出该变量所代表的事物。  </p><h6 id="最适当的名字长度"><a href="#最适当的名字长度" class="headerlink" title="最适当的名字长度"></a>最适当的名字长度</h6><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image.png" alt="Alt text">  </p><h6 id="变量名对作用域的影响"><a href="#变量名对作用域的影响" class="headerlink" title="变量名对作用域的影响"></a>变量名对作用域的影响</h6><p>短 – 临时<br>长 – 全局<br>1、对位于全局命名空间中的名字加以限定词  </p><h6 id="变量名中的计算值限定词"><a href="#变量名中的计算值限定词" class="headerlink" title="变量名中的计算值限定词"></a>变量名中的计算值限定词</h6><p>把限定词加到名字的最后。<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-1.png" alt="Alt text">  </p><h6 id="变量名中的常用对仗词"><a href="#变量名中的常用对仗词" class="headerlink" title="变量名中的常用对仗词"></a>变量名中的常用对仗词</h6><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-2.png" alt="Alt text"></p><h5 id="11-2-为特定类型的数据命名"><a href="#11-2-为特定类型的数据命名" class="headerlink" title="11.2 为特定类型的数据命名"></a>11.2 为特定类型的数据命名</h5><h6 id="为循环下标命名"><a href="#为循环下标命名" class="headerlink" title="为循环下标命名"></a>为循环下标命名</h6><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-4.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-3.png" alt="Alt text">  </p><h6 id="为状态变量命名"><a href="#为状态变量命名" class="headerlink" title="为状态变量命名"></a>为状态变量命名</h6><p>状态变量用于描述你的程序的状态。<br>1、为状态变量取一个比flag更好的名字<br>如果需要猜测含义，就需要重新命名  </p><h6 id="为临时变量命名"><a href="#为临时变量命名" class="headerlink" title="为临时变量命名"></a>为临时变量命名</h6><p>更随意 – 增加出错的可能<br>1、警惕临时变量<br>2、</p><h6 id="为布尔变量命名"><a href="#为布尔变量命名" class="headerlink" title="为布尔变量命名"></a>为布尔变量命名</h6><p>1、谨记典型的布尔变量名<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-5.png" alt="Alt text"><br>2、给布尔变量赋予隐含 “真&#x2F;假” 含义的名字   </p><h6 id="为枚举类型命名"><a href="#为枚举类型命名" class="headerlink" title="为枚举类型命名"></a>为枚举类型命名</h6><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-6.png" alt="Alt text">  </p><h6 id="为常量命名"><a href="#为常量命名" class="headerlink" title="为常量命名"></a>为常量命名</h6><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-7.png" alt="Alt text"></p><h5 id="11-3-命名规则的力量"><a href="#11-3-命名规则的力量" class="headerlink" title="11.3 命名规则的力量"></a>11.3 命名规则的力量</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-8.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-9.png" alt="Alt text"></p><h5 id="11-4-非正式命名规则"><a href="#11-4-非正式命名规则" class="headerlink" title="11.4 非正式命名规则"></a>11.4 非正式命名规则</h5><h6 id="与语言无关的命名规则的指导原则"><a href="#与语言无关的命名规则的指导原则" class="headerlink" title="与语言无关的命名规则的指导原则"></a>与语言无关的命名规则的指导原则</h6><p>1、区分变量名和子程序名字<br>2、区分类和对象<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-10.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-11.png" alt="Alt text"><br>3、标识全局变量<br>4、标识成员变量<br>5、标识类型声明<br>6、标识具名变量<br>7、表示枚举类型的元素<br>8、在不能保证输入参数只读的语言里表示只读参数<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-12.png" alt="Alt text"><br>9、格式化命名以提高可读性<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-13.png" alt="Alt text">  </p><h6 id="与语言相关的命名规则的指导原则"><a href="#与语言相关的命名规则的指导原则" class="headerlink" title="与语言相关的命名规则的指导原则"></a>与语言相关的命名规则的指导原则</h6><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-14.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-15.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-16.png" alt="Alt text">  </p><h6 id="混合语言编程的注意事项"><a href="#混合语言编程的注意事项" class="headerlink" title="混合语言编程的注意事项"></a>混合语言编程的注意事项</h6><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-17.png" alt="Alt text"></p><h6 id="命名规则示例"><a href="#命名规则示例" class="headerlink" title="命名规则示例"></a>命名规则示例</h6><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-18.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-19.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-20.png" alt="Alt text">  </p><h5 id="11-5-标准前缀"><a href="#11-5-标准前缀" class="headerlink" title="11.5 标准前缀"></a>11.5 标准前缀</h5><p>两部分组成：用户自定义类型的缩写和语义前缀</p><h6 id="用户自定义类型缩写"><a href="#用户自定义类型缩写" class="headerlink" title="用户自定义类型缩写"></a>用户自定义类型缩写</h6><p>…</p><h5 id="11-6-创建具备可读性的假名字"><a href="#11-6-创建具备可读性的假名字" class="headerlink" title="11.6 创建具备可读性的假名字"></a>11.6 创建具备可读性的假名字</h5><h6 id="缩写的一般指导原则"><a href="#缩写的一般指导原则" class="headerlink" title="缩写的一般指导原则"></a>缩写的一般指导原则</h6><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-21.png" alt="Alt text">  </p><h6 id="语言缩写"><a href="#语言缩写" class="headerlink" title="语言缩写"></a>语言缩写</h6><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-22.png" alt="Alt text">  </p><h6 id="有关缩写的评论"><a href="#有关缩写的评论" class="headerlink" title="有关缩写的评论"></a>有关缩写的评论</h6><p>1、不要用从每个单词中删除一个字符的方式来缩写<br>2、缩写要一致<br>3、创建你能读出来的名字<br>4、避免使用容易看错或读错的字符组合<br>5、使用词典来解决命名冲突<br>6、在代码里用缩写对照表解释极短的名字的含义<br>7、在一份项目级的标准缩写文档中说明所有的缩写<br>8、记住，名字对于代码读者的意义要比对作者更重要  </p><h5 id="11-7-应该避免的名字"><a href="#11-7-应该避免的名字" class="headerlink" title="11.7 应该避免的名字"></a>11.7 应该避免的名字</h5><p>1、避免使用令人误解的名字或缩写<br>2、避免使用具有相似含义的名字<br>3、避免使用具有不同含义但却有相似名字的变量<br>4、避免使用发音相近的名字<br>5、避免在名字中使用数字<br>6、避免在名字中拼错单词<br>7、避免使用英语中常常拼错的单词<br>8、不要仅靠大小写来区分变量名<br>9、避免使用多种自然语言<br>10、避免使用标准类型、变量和子程序的名字<br>11、不要使用与变量含义完全无关的名字<br>12、避免在名字中包含易混淆的字符  </p><h5 id="CHECKLIST"><a href="#CHECKLIST" class="headerlink" title="CHECKLIST"></a>CHECKLIST</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-23.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-24.png" alt="Alt text">  </p><h5 id="Key-Points"><a href="#Key-Points" class="headerlink" title="Key Points"></a>Key Points</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch11/ch11/image-25.png" alt="Alt text"></p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>代码大全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>code</tag>
      
      <tag>programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch10. 使用变量的一般事项</title>
    <link href="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch10/ch10/"/>
    <url>/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch10/ch10/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch10. 使用变量的一般事项</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="10-1-数据认知"><a href="#10-1-数据认知" class="headerlink" title="10.1 数据认知"></a>10.1 数据认知</h5><h5 id="10-2-轻松掌握变量定义"><a href="#10-2-轻松掌握变量定义" class="headerlink" title="10.2 轻松掌握变量定义"></a>10.2 轻松掌握变量定义</h5><p>加快变量定义的工作<br>隐式声明：<br>1、关闭隐式声明<br>2、声明全部变量<br>3、遵循某种命名规则<br>4、检查变量名  </p><h5 id="10-3-变量初始化原则"><a href="#10-3-变量初始化原则" class="headerlink" title="10.3 变量初始化原则"></a>10.3 变量初始化原则</h5><p>不合理的初始化数据是产生编程错误的常见根源之一。<br>避免产生初始化错误的建议：<br>1、在声明变量的时候初始化<br>2、在靠近变量第一次使用的位置初始化它<br>3、理想情况下，在靠近第一次使用变量的位置声明和定义该变量<br>4、在可能的情况下使用final或const<br>5、特别注意计数器和累加器<br>下一次使用忘记重置<br>6、在类的构造函数里初始化该类的数据成员<br>7、检查是否需要重新初始化<br>8、一次性初始化具名变量：用可执行代码来初始化变量<br>9、使用编译器设置来自动初始化所有变量<br>10、利用编译器的警告信息<br>11、检查输入参数的合法性<br>12、使用内存访问检查工具来检查错误的指针<br>13、在程序开始时初始化工作内存<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch10/ch10/image.png" alt="Alt text">  </p><h5 id="10-4-作用域"><a href="#10-4-作用域" class="headerlink" title="10.4 作用域"></a>10.4 作用域</h5><p>1、是变量引用局部化<br>2、尽可能缩短变量的存活时间<br>3、测量变量的生存时间<br>4、减小作用域的一般原则<br>(1) 在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序开始处初始化这些变量<br>(2) 直到变量即将被使用时再为其赋值<br>(3) 把相关语句放到一起<br>(4) 把相关的语句组提取成单独的子程序<br>(5) 开始时采用最严格的可见性，然后根据需要拓展变量的作用域<br>5、有关缩小变量作用域的说明  </p><h5 id="10-5-持续性"><a href="#10-5-持续性" class="headerlink" title="10.5 持续性"></a>10.5 持续性</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch10/ch10/image-1.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch10/ch10/image-2.png" alt="Alt text">  </p><h5 id="10-6-绑定时间"><a href="#10-6-绑定时间" class="headerlink" title="10.6 绑定时间"></a>10.6 绑定时间</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch10/ch10/image-3.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch10/ch10/image-4.png" alt="Alt text">  </p><h5 id="10-7-数据类型和控制结构之间的关系"><a href="#10-7-数据类型和控制结构之间的关系" class="headerlink" title="10.7 数据类型和控制结构之间的关系"></a>10.7 数据类型和控制结构之间的关系</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch10/ch10/image-5.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch10/ch10/image-6.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch10/ch10/image-7.png" alt="Alt text">  </p><h5 id="10-8-、为变量指定单一用途"><a href="#10-8-、为变量指定单一用途" class="headerlink" title="10.8 、为变量指定单一用途"></a>10.8 、为变量指定单一用途</h5><p>1、每个变量只用于单一用途<br>2、避免让代码具有隐含含义<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch10/ch10/image-8.png" alt="Alt text"><br>3、确保使用了所有已声明的变量</p><h5 id="CHECKLIST"><a href="#CHECKLIST" class="headerlink" title="CHECKLIST"></a>CHECKLIST</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch10/ch10/image-9.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch10/ch10/image-10.png" alt="Alt text"></p><h5 id="Key-Points"><a href="#Key-Points" class="headerlink" title="Key Points"></a>Key Points</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch10/ch10/image-11.png" alt="Alt text"></p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>代码大全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>code</tag>
      
      <tag>programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch9. 伪代码编程过程</title>
    <link href="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch09/ch9/"/>
    <url>/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch09/ch9/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch9. 伪代码编程过程</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>1、将从微观上关注编程过程 – 也就是关注创建单独的类及其子程序的特定步骤<br>2、讲述伪代码编程过程(PPP)  </p><h5 id="9-1-创建类和子程序的步骤概述"><a href="#9-1-创建类和子程序的步骤概述" class="headerlink" title="9.1 创建类和子程序的步骤概述"></a>9.1 创建类和子程序的步骤概述</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch09/ch9/image.png" alt="创建类">  </p><h6 id="创建一个类的步骤"><a href="#创建一个类的步骤" class="headerlink" title="创建一个类的步骤"></a>创建一个类的步骤</h6><p>1、创建类的总体设计<br>2、创建类中的子程序<br>3、复审并测试整个类  </p><h6 id="创建子程序的步骤"><a href="#创建子程序的步骤" class="headerlink" title="创建子程序的步骤"></a>创建子程序的步骤</h6><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch09/ch9/image-1.png" alt="Alt text"></p><h5 id="9-2-伪代码"><a href="#9-2-伪代码" class="headerlink" title="9.2 伪代码"></a>9.2 伪代码</h5><h6 id="使用伪代码的指导原则"><a href="#使用伪代码的指导原则" class="headerlink" title="使用伪代码的指导原则"></a>使用伪代码的指导原则</h6><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch09/ch9/image-2.png" alt="Alt text">  </p><h5 id="9-3-通过伪代码编程过程创建子程序"><a href="#9-3-通过伪代码编程过程创建子程序" class="headerlink" title="9.3 通过伪代码编程过程创建子程序"></a>9.3 通过伪代码编程过程创建子程序</h5><h6 id="设计子程序"><a href="#设计子程序" class="headerlink" title="设计子程序"></a>设计子程序</h6><p>1、检查先决条件<br>要做的工作是否已经定义好了，是否能够与整体设计相匹配<br>2、定义子程序要解决的问题<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch09/ch9/image-3.png" alt="Alt text"><br>3、为子程序命名<br>4、决定如何测试子程序<br>5、在标准库中搜寻可用的功能<br>6、考虑错误处理<br>7、考虑效率问题<br>8、研究算法和数据类型<br>9、编写伪代码<br>(1) 头部注释 – 描述这段程序做什么，如果很难描述，那么需要重新理解子程序<br>在高层次写伪代码<br>10、考虑数据<br>11、检查伪代码<br>想想如何向别人解释这些代码<br>伪代码错误更加明显<br>12、在伪代码中试验一些想法，留下最好的想法(迭代)  </p><h6 id="编写子程序的代码"><a href="#编写子程序的代码" class="headerlink" title="编写子程序的代码"></a>编写子程序的代码</h6><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch09/ch9/image-4.png" alt="Alt text"><br>1、写出子程序的声明<br>2、把伪代码转变为高层次的注释<br>3、在每条注释下面填充代码<br>4、检查代码是否需要进一步分解<br>几行伪代码展开为大量代码：<br>（1） 重构成一个新的子程序<br>（2） 递归地应用伪代码编程过程  </p><h6 id="检查代码"><a href="#检查代码" class="headerlink" title="检查代码"></a>检查代码</h6><p>1、在脑海里检查程序中的错误<br>2、编译子程序<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch09/ch9/image-5.png" alt="Alt text"><br>3、在调试器中逐行执行代码<br>4、测试代码<br>5、消除程序中的错误  </p><h6 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h6><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch09/ch9/image-6.png" alt="Alt text">  </p><h6 id="根据需要重复上述步骤"><a href="#根据需要重复上述步骤" class="headerlink" title="根据需要重复上述步骤"></a>根据需要重复上述步骤</h6><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch09/ch9/image-7.png" alt="Alt text"></p><h5 id="9-4-伪代码编程过程的替代方案"><a href="#9-4-伪代码编程过程的替代方案" class="headerlink" title="9.4 伪代码编程过程的替代方案"></a>9.4 伪代码编程过程的替代方案</h5><p>1、测试先行开发<br>2、重构<br>3、契约式设计<br>4、东拼西凑<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch09/ch9/image-8.png" alt="Alt text"></p><h5 id="CHECKLIST"><a href="#CHECKLIST" class="headerlink" title="CHECKLIST"></a>CHECKLIST</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch09/ch9/image-9.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch09/ch9/image-10.png" alt="Alt text"></p><h5 id="Key-Points"><a href="#Key-Points" class="headerlink" title="Key Points"></a>Key Points</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch09/ch9/image-11.png" alt="Alt text"></p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>代码大全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>code</tag>
      
      <tag>programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch8. 防御性编程</title>
    <link href="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch08/ch8/"/>
    <url>/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch08/ch8/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch8. 防御性编程</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。  </p><h5 id="8-1-保护程序免遭非法输入数据的破坏"><a href="#8-1-保护程序免遭非法输入数据的破坏" class="headerlink" title="8.1 保护程序免遭非法输入数据的破坏"></a>8.1 保护程序免遭非法输入数据的破坏</h5><p>garbage in， garbage out – 缺乏安全性代表  </p><h6 id="三种方法处理："><a href="#三种方法处理：" class="headerlink" title="三种方法处理："></a>三种方法处理：</h6><p>1、检查所有来源于外部的数据的值<br>2、检查子程序所有输入参数的值<br>3、决定如何处理错误的输入数据<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch08/ch8/image.png" alt="防御式编程"></p><h5 id="8-2-断言"><a href="#8-2-断言" class="headerlink" title="8.2 断言"></a>8.2 断言</h5><p>断言(assertion)是指在开发期间使用的、让程序在运行时进行自检的代码(通常是一个子程序或宏)<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch08/ch8/image-1.png" alt="断言的假定">  </p><h6 id="使用断言的指导性建议"><a href="#使用断言的指导性建议" class="headerlink" title="使用断言的指导性建议"></a>使用断言的指导性建议</h6><p>1、用错误处理代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况<br>错误处理 – 检查有害的输入数据<br>断言 – 检查代码中的bug<br>2、避免把需要执行的代码放到断言中<br>3、用断言来注解并验证前条件和后条件<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch08/ch8/image-2.png" alt="前条件后条件"><br>4、对于高健壮性的代码，应该先使用断言再处理错误  </p><h5 id="8-3-错误处理技术"><a href="#8-3-错误处理技术" class="headerlink" title="8.3 错误处理技术"></a>8.3 错误处理技术</h5><p>1、返回中立值<br>有时，处理错误数据的最佳做法就是继续执行操作并简单地返回一个没有危害的数值。<br>2、换用下一个正确的数据<br>在处理数据流的时候，有时只需返回下一个正确的数据即可。<br>3、返回与前次相同的数据<br>4、换用最接近的合法值<br>在有些情况下，你可以选择返回最接近的那个合法值。<br>5、把警告信息记录到日志文件中<br>在检测到错误数据的时候，你可以选择在日志文件中记录一条警告信息，然后继续执行。<br>6、返回一个错误码<br>你可以决定只让系统的某些部分处理错误。其他部分则不在本地(局部)处理错误，而只是<br>简单地报告说有错误发生，并信任调用链上游的某个子程序会处理该错误。<br>通知其余部分已经发生错误：<br>(1) 设置一个状态变量的值<br>(2) 用状态值作为函数的返回值<br>(3) 用语言内建的异常机制抛出一个异常<br>7、调用错误处理子程序或对象<br>把错误处理都集中在一个全局的错误处理子程序或对象中。<br>8、当错误发生时显示出错信息<br>9、用最妥当的方式在局部处理错误<br>10、关闭程序<br>有些系统一但检测到错误发生就会关闭。  </p><h6 id="健壮性与正确性"><a href="#健壮性与正确性" class="headerlink" title="健壮性与正确性"></a>健壮性与正确性</h6><p>正确性 – 永不返回不准确的结果，哪怕不返回结果也比返回不正确的结果好<br>健壮性 – 不断尝试采取某些措施，保证软件可以持续地运转下去，哪怕有时做出一些不够准确的结果  </p><h6 id="高层次设计对错误处理方式的影响"><a href="#高层次设计对错误处理方式的影响" class="headerlink" title="高层次设计对错误处理方式的影响"></a>高层次设计对错误处理方式的影响</h6><p>确定一种通用的处理错误参数的方法，是架构层次(或称高层次)的设计决策，需要在那里的某个层次上解决。</p><h5 id="8-4-异常"><a href="#8-4-异常" class="headerlink" title="8.4 异常"></a>8.4 异常</h5><p>1、用异常通知程序的其他部分，发生了不可忽略的错误<br>2、只在真正例外的情况下才抛出异常<br>用于处理不仅罕见甚至永远不该发生的情况<br>异常需要做出一个取舍：一方面它是一种强大的用来处理预料之外的情况的途径；另一方面程序的复杂度会因此增加。<br>3、不能用异常来推卸责任<br>4、避免在构造函数和析构函数中抛出异常，除非你在同一地方把它们捕获<br>5、在恰当的抽象层次抛出异常<br>6、在异常消息中加入关于导致异常发生的全部信息<br>7、避免使用空的catch语句<br>8、了解所用函数库可能抛出的异常<br>9、考虑创建一个集中的异常报告机制<br>10、把项目中对异常的使用标准化<br>11、考虑异常的替代方案  </p><h5 id="8-5-隔离程序，使之包容由错误造成的损害"><a href="#8-5-隔离程序，使之包容由错误造成的损害" class="headerlink" title="8.5 隔离程序，使之包容由错误造成的损害"></a>8.5 隔离程序，使之包容由错误造成的损害</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch08/ch8/image-3.png" alt="隔栏"><br>在输入数据时，将其转换为恰当的类型<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch08/ch8/image-4.png" alt="隔栏与断言"></p><h5 id="8-6-辅助调试的代码"><a href="#8-6-辅助调试的代码" class="headerlink" title="8.6 辅助调试的代码"></a>8.6 辅助调试的代码</h5><p>不要自动地把产品版的限制强加于开发板之上<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch08/ch8/image-5.png" alt="Alt text"><br>尽早引入辅助调试的代码<br><strong>采用进攻式编程</strong><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch08/ch8/image-6.png" alt="进攻式编程"><br><strong>计划移除调试辅助的代码</strong><br>1、使用类似ant、make这样的版本控制工具<br>2、使用内置的预处理器<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch08/ch8/image-7.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch08/ch8/image-8.png" alt="Alt text"><br>3、编写你自己的预处理器<br>4、使用调试存根 debuging stubs<br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch08/ch8/image-9.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch08/ch8/image-10.png" alt="Alt text">  </p><h5 id="8-7-确定在产品代码中该保留多少防御式代码"><a href="#8-7-确定在产品代码中该保留多少防御式代码" class="headerlink" title="8.7 确定在产品代码中该保留多少防御式代码"></a>8.7 确定在产品代码中该保留多少防御式代码</h5><p>哪些可以留，哪些应该排除在外<br>1、保留那些检查重要错误的代码<br>2、去掉检查细微错误的代码<br>3、去掉可以导致程序硬性崩溃的代码<br>4、保留可以让程序稳妥的崩溃的代码<br>5、为你的技术支持人员记录错误信息<br>6、确认留在代码中的错误消息是友好的  </p><h5 id="8-8-对防御式编程采取防御的姿态"><a href="#8-8-对防御式编程采取防御的姿态" class="headerlink" title="8.8 对防御式编程采取防御的姿态"></a>8.8 对防御式编程采取防御的姿态</h5><p>过度的防御式编程也会引起问题。  </p><h5 id="CHECKLIST"><a href="#CHECKLIST" class="headerlink" title="CHECKLIST"></a>CHECKLIST</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch08/ch8/image-11.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch08/ch8/image-12.png" alt="Alt text">  </p><h5 id="Key-Points"><a href="#Key-Points" class="headerlink" title="Key Points"></a>Key Points</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch08/ch8/image-13.png" alt="Alt text"></p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>代码大全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>code</tag>
      
      <tag>programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch7. 高质量的子程序</title>
    <link href="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch07/ch7/"/>
    <url>/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch07/ch7/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch7. 高质量的子程序</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="7-1-创建子程序的正当理由"><a href="#7-1-创建子程序的正当理由" class="headerlink" title="7.1 创建子程序的正当理由"></a>7.1 创建子程序的正当理由</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch07/ch7/image.png" alt="reason"></p><h5 id="7-2-在子程序层上设计"><a href="#7-2-在子程序层上设计" class="headerlink" title="7.2 在子程序层上设计"></a>7.2 在子程序层上设计</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch07/ch7/image-1.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch07/ch7/image-2.png"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch07/ch7/image-3.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch07/ch7/image-4.png" alt="Alt text">  </p><h5 id="7-3-好的子程序名字"><a href="#7-3-好的子程序名字" class="headerlink" title="7.3 好的子程序名字"></a>7.3 好的子程序名字</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch07/ch7/image-5.png" alt="Alt text">  </p><h5 id="7-4-子程序可以写多长"><a href="#7-4-子程序可以写多长" class="headerlink" title="7.4 子程序可以写多长"></a>7.4 子程序可以写多长</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch07/ch7/image-6.png" alt="Alt text">  </p><h5 id="7-5-如何使用子程序参数"><a href="#7-5-如何使用子程序参数" class="headerlink" title="7.5 如何使用子程序参数"></a>7.5 如何使用子程序参数</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch07/ch7/image-7.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch07/ch7/image-8.png" alt="Alt text"></p><h5 id="7-6-使用函数时要特别考虑的问题"><a href="#7-6-使用函数时要特别考虑的问题" class="headerlink" title="7.6 使用函数时要特别考虑的问题"></a>7.6 使用函数时要特别考虑的问题</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch07/ch7/image-9.png" alt="Alt text">  </p><h5 id="7-7-宏子程序和内联子程序"><a href="#7-7-宏子程序和内联子程序" class="headerlink" title="7.7 宏子程序和内联子程序"></a>7.7 宏子程序和内联子程序</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch07/ch7/image-10.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch07/ch7/image-11.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch07/ch7/image-12.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch07/ch7/image-13.png" alt="Alt text"><br><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch07/ch7/image-14.png" alt="Alt text">  </p><h5 id="CHECKLIST"><a href="#CHECKLIST" class="headerlink" title="CHECKLIST"></a>CHECKLIST</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch07/ch7/image-15.png" alt="Alt text">  </p><h5 id="KeyPoints"><a href="#KeyPoints" class="headerlink" title="KeyPoints"></a>KeyPoints</h5><p><img src="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch07/ch7/image-16.png" alt="Alt text"></p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>代码大全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>code</tag>
      
      <tag>programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch1. 欢迎进入软件构建的世界</title>
    <link href="/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch01/ch1/"/>
    <url>/2025/05/05/DB/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/ch01/ch1/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch1. 欢迎进入软件构建的世界</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-1-什么是软件构建"><a href="#1-1-什么是软件构建" class="headerlink" title="1.1 什么是软件构建"></a>1.1 什么是软件构建</h5>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>代码大全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>code</tag>
      
      <tag>programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch7. 隔离性的概念</title>
    <link href="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch7/ch7/"/>
    <url>/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch7/ch7/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch7. 隔离性的概念</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="7-7-幻像和谓词锁"><a href="#7-7-幻像和谓词锁" class="headerlink" title="7.7 幻像和谓词锁"></a>7.7 幻像和谓词锁</h5><p><img src="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch7/ch7/img.png" alt="img.png">  </p><h5 id="7-8-粒度锁"><a href="#7-8-粒度锁" class="headerlink" title="7.8 粒度锁"></a>7.8 粒度锁</h5><p><img src="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch7/ch7/img_1.png" alt="img_1.png"><br><img src="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch7/ch7/img_2.png" alt="img_2.png"><br><img src="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch7/ch7/img_3.png" alt="img_3.png"><br><img src="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch7/ch7/img_6.png" alt="img_6.png"><br><img src="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch7/ch7/img_4.png" alt="img_4.png"><br><img src="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch7/ch7/img_5.png" alt="img_5.png"><br><img src="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch7/ch7/img_7.png" alt="img_7.png"><br><img src="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch7/ch7/img_8.png" alt="img_8.png">  </p><h5 id="7-9-封锁的启发式算法"><a href="#7-9-封锁的启发式算法" class="headerlink" title="7.9 封锁的启发式算法"></a>7.9 封锁的启发式算法</h5>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>事务处理-概念与技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch1. 概述</title>
    <link href="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch1/ch1/"/>
    <url>/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch1/ch1/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch1. 概述</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-1-历史回顾"><a href="#1-1-历史回顾" class="headerlink" title="1.1 历史回顾"></a>1.1 历史回顾</h5><p>苏美尔人发明了事务处理的记录方法</p><h5 id="1-2-什么是事务处理系统"><a href="#1-2-什么是事务处理系统" class="headerlink" title="1.2 什么是事务处理系统"></a>1.2 什么是事务处理系统</h5><p><img src="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch1/ch1/img.png" alt="img.png"><br><img src="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch1/ch1/img_1.png" alt="img_1.png"><br>补偿事务：事务的逆操作序列。用于恢复时撤销该事务的运行对数据库产生的影响。<br>远程过程调用：一个进程调用另一个远程进程的程序的一种方式，好像远程进程上的子程序在本地一样。<br>事务型远程过程调用：把有多个客户和服务器的工作结合到一个单独的ACID执行单元中的一种方式。<br><img src="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch1/ch1/img_2.png" alt="img_2.png">  </p><h6 id="1-2-4-从资源管理器角度对事务处理系统的认识"><a href="#1-2-4-从资源管理器角度对事务处理系统的认识" class="headerlink" title="1.2.4 从资源管理器角度对事务处理系统的认识"></a>1.2.4 从资源管理器角度对事务处理系统的认识</h6><p>资源管理器互操作性的关键在于：<br>1、一种调用应用服务–RPC<br>2、资源管理器的标准方法<br><img src="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch1/ch1/img_3.png" alt="img_3.png"><br><img src="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch1/ch1/img_4.png" alt="img_4.png"><br><img src="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch1/ch1/img_5.png" alt="img_5.png"><br>事务的恢复相关：<br><img src="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch1/ch1/img_6.png" alt="img_6.png"><br>X&#x2F;OPEN 分布式事务处理模型：<br><img src="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch1/ch1/img_7.png" alt="img_7.png"></p><h6 id="1-2-5-TP系统的核心服务"><a href="#1-2-5-TP系统的核心服务" class="headerlink" title="1.2.5 TP系统的核心服务"></a>1.2.5 TP系统的核心服务</h6><p><img src="/2025/05/05/DB/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF/ch1/ch1/img_8.png" alt="img_8.png"></p><h5 id="1-3-事务处理系统特征列表"><a href="#1-3-事务处理系统特征列表" class="headerlink" title="1.3 事务处理系统特征列表"></a>1.3 事务处理系统特征列表</h5><h5 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h5>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>事务处理-概念与技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch9. WRITE AHEAD LOGGING (WAL)</title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/</url>
    
    <content type="html"><![CDATA[<h2 id="ch9-WRITE-AHEAD-LOGGING-WAL"><a href="#ch9-WRITE-AHEAD-LOGGING-WAL" class="headerlink" title="ch9. WRITE AHEAD LOGGING (WAL)"></a>ch9. WRITE AHEAD LOGGING (WAL)</h2><p>事务日志是数据库的重要组成部分,因为它们可以确保即使在系统故障的情况下也不会丢失任何数据。<br>它们是数据库系统中所有更改和操作的历史记录。这确保了即使出现电源故障或服务器崩溃等故障,<br>也不会丢失任何数据。</p><p>日志包含已执行的每个事务的足够信息,因此数据库服务器可以通过在事务日志中重放更改和操作来恢复数据库集群,<br>以应对服务器崩溃的情况。</p><p>在计算机科学领域,WAL是”预写式日志”(Write-Ahead Logging)的缩写,这是一种要求将更改和操作都写入事务<br>日志的协议或规则。但是,在PostgreSQL中,WAL也是”预写式日志”(Write Ahead Log)的缩写。<br>在PostgreSQL中,WAL一词可以与事务日志互换使用,它也指用于将操作写入事务日志的实现机制(WAL)。<br>尽管这可能会造成混淆,但本文将采用PostgreSQL的定义。</p><p>WAL机制是在7.1版本中首次实现的,用于减轻服务器崩溃的影响。它还使得实现时间点恢复(PITR)和流复制(SR)<br>成为可能,这两者分别在第10章和第11章中进行了描述。</p><p>尽管理解WAL机制对于使用PostgreSQL进行系统集成和管理至关重要,<br>但这种机制的复杂性使得无法简单概括其描述。因此,PostgreSQL中WAL的完整解释如下:</p><ol><li>WAL(事务日志)的逻辑和物理结构。  </li><li>WAL数据的内部布局。  </li><li>WAL数据的写入。  </li><li>WAL写入器进程。  </li><li>检查点处理。  </li><li>数据库恢复处理。  </li><li>WAL段文件的管理。  </li><li>连续归档。</li></ol><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#9-Overview">9.1. Overview</a></td></tr><tr><td><a href="#tlog-wal">9.2. Transaction Log and WAL Segment Files</a></td></tr><tr><td><a href="#wal-seg">9.3. Internal Layout of WAL Segment</a></td></tr><tr><td><a href="#xlog-record">9.4. Internal Layout of XLOG Record</a></td></tr><tr><td><a href="#write-xlog">9.5. Writing of XLOG Records</a></td></tr><tr><td><a href="#wal-writer">9.6. WAL Writer Process</a></td></tr><tr><td><a href="#checkpoint">9.7. Checkpoint Processing in PostgreSQL</a></td></tr><tr><td><a href="#recovery">9.8. Database Recovery in PostgreSQL</a></td></tr><tr><td><a href="#wal-file">9.9. WAL Segment Files Management</a></td></tr><tr><td><a href="#archive">9.10. Continuous Archiving and Archive Logs</a></td></tr></tbody></table><h3 id="9-1-Overview"><a href="#9-1-Overview" class="headerlink" title="9.1. Overview"></a><a name="9-Overview"></a>9.1. Overview</h3><p>让我们一起来了解一下WAL（Write-Ahead Log，预写式日志）机制的概览。为了阐明WAL解决的问题，<br>第一小节将展示如果PostgreSQL没有实现WAL，在发生崩溃时会发生什么情况。第二小节将介绍一些关键概念，<br>并展示本章主要主题的概览：WAL数据的写入与数据库恢复过程。最后一小节通过增加另一个关键概念来完善WAL的概览。</p><p>在本节中，为了简化描述，我们使用了一个仅包含一页的表TABLE_A作为示例。</p><h4 id="9-1-1-Insertion-Operations-without-WAL"><a href="#9-1-1-Insertion-Operations-without-WAL" class="headerlink" title="9.1.1. Insertion Operations without WAL"></a>9.1.1. Insertion Operations without WAL</h4><p><strong>不使用WAL的插入操作</strong></p><p>正如第8章所述，每个数据库管理系统都实现了共享缓冲池，以提供对关系页面的有效访问。</p><p>假设我们在未实现WAL特性的PostgreSQL中向TABLE_A插入一些数据元组。这种情况在图9.1中进行了说明。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img.png" alt="img.png"></p><ol><li>当我们发出第一条INSERT语句时，PostgreSQL会将TABLE_A页面从数据库集群加载到内存中的共享缓冲池，<br>并在页面中插入一个元组。页面不会立即写回到数据库集群中。（如第8章所述，修改过的页面通常被称为脏页面。）  </li><li>当我们发出第二条INSERT语句时，PostgreSQL会在缓冲池中的页面插入一个新的元组。该页面尚未被写入到存储中。  </li><li>如果操作系统或PostgreSQL服务器因任何原因（如电源故障）发生故障，所有插入的数据都将丢失。</li></ol><p>因此，没有WAL的数据库在系统故障面前是非常脆弱的。</p><blockquote><p>Historical Info</p><p>在引入WAL之前（7.0或更早版本），PostgreSQL为了确保数据的持久性，<br>每当内存中的页面发生变化时，就会发出sync系统调用来执行磁盘的同步写入。<br>这使得INSERT、UPDATE等修改命令的性能非常差。</p></blockquote><h4 id="9-1-2-Insertion-Operations-and-Database-Recovery"><a href="#9-1-2-Insertion-Operations-and-Database-Recovery" class="headerlink" title="9.1.2. Insertion Operations and Database Recovery"></a>9.1.2. Insertion Operations and Database Recovery</h4><p>为了解决上述系统故障问题而又不损害性能，PostgreSQL支持WAL。<br>在本小节中，将首先介绍一些关键词和关键概念，随后讲述WAL数据的写入与数据库的恢复过程。</p><p>PostgreSQL将所有修改作为历史数据写入持久化存储中，以便应对故障。在PostgreSQL中，这些历史数据被称为<br>XLOG记录或WAL数据。</p><p>XLOG记录由插入、删除或提交动作等变更操作写入内存中的WAL缓冲区。当事务提交或中止时，它们会立即被写入<br>到存储上的WAL段文件中。（准确地说，XLOG记录的写入可能发生在其他情况下。具体细节将在第9.5节中描述。）<br>XLOG记录的LSN（Log Sequence Number，日志序列号）代表其记录在事务日志上的写入位置。<br>记录的LSN用作XLOG记录的唯一ID。</p><p>在考虑数据库系统如何恢复时，可能会产生一个问题：PostgreSQL从哪个点开始恢复？答案是REDO点。<br>即最近一次检查点启动时刻XLOG记录被写入的位置。（PostgreSQL中的检查点在第9.7节中描述。）实际上，<br>数据库恢复过程与检查点过程紧密相关，这两个过程是不可分割的。</p><blockquote><p>Info</p><p>WAL和检查点进程是在7.1版本中同时实现的。</p></blockquote><p>随着主要关键词和概念的介绍刚刚结束，接下来将描述带有WAL的元组插入过程。请参考图9.2及其后续描述。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_1.png" alt="img_1.png"></p><blockquote><p>Notation</p><p>TABLE_A的LSN显示的是TABLE_A页面头部的pd_lsn值。<br>页面的LSN同理。</p></blockquote><ol><li>检查点进程作为后台进程，会周期性地执行检查点操作。每当检查点进程启动时，<br>它会在当前的WAL段中写入一个称为检查点记录的XLOG记录。这个记录包含了最新REDO点的位置。  </li><li>当我们发出第一条INSERT语句时，PostgreSQL会将TABLE_A页面加载到共享缓冲池中，<br>在页面中插入一个元组，创建并在这个语句的LSN_1位置向WAL缓冲区写入一条XLOG记录，<br>同时将TABLE_A的LSN从LSN_0更新到LSN_1。<br>在此例中，这条XLOG记录是由头数据和整个元组组成的一对。  </li><li>随着该事务的提交，PostgreSQL会创建并写入一条关于此提交动作的XLOG记录到WAL缓冲区，<br>然后从LSN_1开始，将WAL缓冲区中的所有XLOG记录写入并刷新到WAL段文件中。  </li><li>当我们发出第二条INSERT语句时，PostgreSQL在页面中插入一个新的元组，<br>创建并在此元组的LSN_2位置向WAL缓冲区写入XLOG记录，并将TABLE_A的LSN从LSN_1更新到LSN_2。  </li><li>当此语句的事务提交时，PostgreSQL的操作方式与步骤(3)相同。  </li><li>假设操作系统发生故障。尽管共享缓冲池中的所有数据都丢失了，<br>但对页面的所有修改都作为历史数据被写入到了WAL段文件中。</li></ol><p>下面的指示说明了如何将我们的数据库集群恢复到崩溃前的状态。<br>无需特别操作，因为通过重新启动，PostgreSQL会自动进入恢复模式。请参阅图9.3（以及此幻灯片）。<br>PostgreSQL将顺序读取并重放从REDO点开始的适当WAL段文件中的XLOG记录。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_2.png" alt="img_2.png"></p><ol><li>PostgreSQL从适当的WAL段文件中读取第一条INSERT语句的XLOG记录，<br>并将TABLE_A页面从数据库集群加载到共享缓冲池中。  </li><li>在尝试重放XLOG记录之前，PostgreSQL会将XLOG记录的LSN与对应页面的LSN进行比较。这样做的原因将在第9.8节中描述。<br>重放XLOG记录的规则如下： 如果XLOG记录的LSN大于页面的LSN，那么XLOG记录的数据部分会被插入到页面中，<br>并且页面的LSN会被更新为XLOG记录的LSN。 另一方面，如果XLOG记录的LSN较小，则除了读取下一条WAL记录外，<br>无需做其他操作。 在此例中，由于XLOG记录的LSN（LSN_1）大于TABLE_A的LSN（LSN_0）<br>，因此XLOG记录被重放。随后，TABLE_A的LSN从LSN_0更新为LSN_1。  </li><li>PostgreSQL以相同的方式重放剩余的XLOG记录。</li></ol><p>通过按时间顺序重放WAL段文件中写入的XLOG记录，PostgreSQL可以以这种方式自我恢复。<br>因此，PostgreSQL的XLOG记录是REDO日志。</p><blockquote><p>Note</p><p>PostgreSQL does not support UNDO log.</p></blockquote><p>虽然写入XLOG记录确实会消耗一定的成本，但这与写入整个修改过的页面相比微不足道。<br>我们确信，我们获得的利益，即系统故障容忍度，远大于我们的付出。</p><h4 id="9-1-3-Full-Page-Writes"><a href="#9-1-3-Full-Page-Writes" class="headerlink" title="9.1.3. Full-Page Writes"></a>9.1.3. Full-Page Writes</h4><p>假设由于操作系统在后台写入器进程正在写入脏页面时发生故障，导致存储上的TABLE_A页面数据损坏。<br>由于XLOG记录不能在损坏的页面上重放，我们需要额外的功能来处理这种情况。</p><p>PostgreSQL支持一种称为全页写入的特性来应对这类故障。如果启用此功能，PostgreSQL会在每次检查点后，<br>对每个页面的首次更改时，将页头数据和整个页面作为一个XLOG记录写入。（这是默认设置。）在PostgreSQL中，<br>包含整个页面的这种XLOG记录称为备份块（或全页映像）。</p><p>让我们再次描述元组的插入过程，但这次启用全页写入。请参阅图9.4及其后续描述。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_3.png" alt="img_3.png"></p><ol><li>检查点进程开始执行检查点操作。  </li><li>当我们插入第一条INSERT语句时，PostgreSQL的操作方式与上一小节类似，但这里的XLOG记录是该页面的备份块，<br>因为这是在最近一次检查点之后首次对该页面进行写入。（换句话说，它包含了整个页面的内容。）  </li><li>随着该事务的提交，PostgreSQL的操作方式与上一小节相同。    </li><li>当我们插入第二条INSERT语句时，PostgreSQL的操作方式与上一小节相同，因为这次的XLOG记录并不是备份块。  </li><li>当此语句的事务提交时，PostgreSQL的操作方式与上一小节相同。  </li><li>为了展示全页写入的有效性，让我们考虑这样一个场景：由于后台写入器在向存储（硬盘驱动器或固态硬盘）<br>写入TABLE_A页面时操作系统发生故障，导致存储上的TABLE_A页面数据损坏。</li></ol><p>重启PostgreSQL服务器以修复损坏的集群。请参阅图9.5及其后续描述。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_4.png" alt="img_4.png"></p><ol><li>PostgreSQL读取第一条INSERT语句的XLOG记录，并将损坏的TABLE_A页面从数据库集群加载到共享缓冲池中。<br>在此例中，XLOG记录是备份块， 因为根据全页写入的写入规则，每个页面的第一个XLOG记录始终是其备份块。  </li><li>当XLOG记录是其备份块时，将应用另一条重放规则：无论两个LSN的值如何，记录的数据部分（即页面本身）<br>都要覆盖写入到页面上，并将页面的LSN更新为XLOG记录的LSN。 在此例中，PostgreSQL将记录的数据部分<br>覆盖到损坏的页面上，并将TABLE_A的LSN更新为LSN_1。这样，损坏的页面就通过其备份块得到了恢复。  </li><li>由于第二条XLOG记录是非备份块，PostgreSQL的操作方式与前一小节中的说明相同。</li></ol><p>通过这种方式，即使由于进程或操作系统崩溃导致某些数据写入错误，PostgreSQL也能恢复数据库。</p><blockquote><p>WAL、备份与复制</p><p>如前所述，WAL可以防止由于进程或操作系统崩溃导致的数据丢失。然而，如果发生文件系统或介质故障，数据将会丢失。<br>为了解决这类故障，PostgreSQL提供了在线备份和复制功能。<br>如果定期进行在线备份，即使发生介质故障，也可以从最近的备份中恢复数据库。<br>但需要注意的是，最后一次备份之后所做的更改无法恢复。</p><p>同步复制功能可以实时地将所有更改存储到另一个存储或主机上。这意味着，<br>如果主服务器发生介质故障，可以从辅助服务器上恢复数据。</p><p>有关更多信息，请分别参阅第10章和第11章。</p></blockquote><h3 id="9-2-Transaction-Log-and-WAL-Segment-Files"><a href="#9-2-Transaction-Log-and-WAL-Segment-Files" class="headerlink" title="9.2. Transaction Log and WAL Segment Files"></a><a name="tlog-wal"></a>9.2. Transaction Log and WAL Segment Files</h3><p>逻辑上，PostgreSQL将XLOG记录写入一个长度为8字节的虚拟文件（理论上可达16 ExaBytes）。</p><p>由于事务日志的容量实际上是无限的，可以说8字节的地址空间是相当庞大的，我们不可能直接处理这么大的文件。<br>因此，PostgreSQL中的事务日志， 默认情况下被划分为多个16 megabytes大小的文件，每个这样的文件称为一个WAL段。<br>请参见图9.6。</p><blockquote><p>WAL段文件大小</p><p>在11或更高版本中，可以在使用initdb命令创建PostgreSQL集群时，通过–wal-segsize选项配置WAL段文件的大小。</p></blockquote><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_5.png" alt="img_5.png"></p><p>WAL段文件名采用十六进制24位数字表示，命名规则如下：</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_6.png" alt="img_6.png"></p><blockquote><p>timelineld</p><p>PostgreSQL的WAL中包含时间线ID（4字节无符号整数）的概念，<br>这在第10章描述的即时点恢复（Point-in-Time Recovery, PITR）<br>中使用。但在本章中，时间线ID固定为0x00000001，因为在以下描述中不需要这个概念。</p></blockquote><p>第一个WAL段文件名为000000010000000000000001。如果第一个文件已通过写入XLOG记录填满，那么将提供<br>第二个文件000000010000000000000002。文件按递增顺序依次使用。在0000000100000000000000FF填满后，<br>下一个文件将是000000010000000100000000。以此类推，每当最后两位数字进位时，中间的8位数字增加1。</p><p>同样，0000000100000001000000FF填满后，将提供000000010000000200000000，依此类推。</p><p><strong>pg_xlogfile_name &#x2F; pg_walfile_name</strong></p><p>使用内置函数pg_xlogfile_name（9.6或更早版本）或pg_walfile_name（10或更高版本），我们可以找到包含指定<br>LSN的WAL段文件名。下面是一个示例：</p><p>在PostgreSQL中，你可以通过这两个函数输入一个LSN值，函数会返回该LSN所在的WAL文件名。<br>这对于管理和恢复数据库时定位特定WAL段非常有用。例如，如果你需要知道某个特定事务日志记录所在的确切WAL文件，<br>就可以使用这些函数来获取该信息。在不同版本的PostgreSQL中，需选用相应的函数来进行查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> pg_xlogfile_name(<span class="hljs-string">&#x27;1/00002D3E&#x27;</span>);  # <span class="hljs-keyword">In</span> versions <span class="hljs-number">10</span> <span class="hljs-keyword">or</span> later, &quot;SELECT pg_walfile_name(&#x27;1/00002D3E&#x27;);&quot;<br>     pg_xlogfile_name     <br><span class="hljs-comment">--------------------------</span><br> <span class="hljs-number">000000010000000100000000</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><h3 id="9-3-Internal-Layout-of-WAL-Segment"><a href="#9-3-Internal-Layout-of-WAL-Segment" class="headerlink" title="9.3. Internal Layout of WAL Segment"></a><a name="wal-seg"></a>9.3. Internal Layout of WAL Segment</h3><p><strong>WAL段的内部结构</strong></p><p>WAL段默认是一个16MB大小的文件，其内部被划分为8192字节（8KB）大小的页面。<br>首页面包含一个由XLogLongPageHeaderData结构定义的页头数据，而所有其他页面的页头则包含由<br>XLogPageHeaderData结构定义的页面信息。在页头之后，XLOG记录按照从页首开始的降序在每个页面中写入。<br>请参见图9.7。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_7.png" alt="img_7.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> XLogPageHeaderData *XLogPageHeader;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * When the XLP_LONG_HEADER flag is set, we store additional fields in the</span><br><span class="hljs-comment"> * page header.  (This is ordinarily done just in the first page of an</span><br><span class="hljs-comment"> * XLOG file.)The additional fields serve to identify the file accurately.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XLogLongPageHeaderData</span></span><br><span class="hljs-class">&#123;</span><br>XLogPageHeaderData <span class="hljs-built_in">std</span>;<span class="hljs-comment">/* standard header fields */</span><br>uint64xlp_sysid;<span class="hljs-comment">/* system identifier from pg_control */</span><br>uint32xlp_seg_size;<span class="hljs-comment">/* just as a cross-check */</span><br>uint32xlp_xlog_blcksz;<span class="hljs-comment">/* just as a cross-check */</span><br>&#125; XLogLongPageHeaderData;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Each page of XLOG file has a header like this:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XLOG_PAGE_MAGIC 0xD113<span class="hljs-comment">/* can be used as WAL version indicator */</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XLogPageHeaderData</span></span><br><span class="hljs-class">&#123;</span><br>uint16xlp_magic;<span class="hljs-comment">/* magic value for correctness checks */</span><br>uint16xlp_info;<span class="hljs-comment">/* flag bits, see below */</span><br>TimeLineIDxlp_tli;<span class="hljs-comment">/* TimeLineID of first record on page */</span><br>XLogRecPtrxlp_pageaddr;<span class="hljs-comment">/* XLOG address of this page */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * When there is not enough space on current page for whole record, we</span><br><span class="hljs-comment"> * continue on the next page.  xlp_rem_len is the number of bytes</span><br><span class="hljs-comment"> * remaining from a previous page; it tracks xl_tot_len in the initial</span><br><span class="hljs-comment"> * header.  Note that the continuation data isn&#x27;t necessarily aligned.</span><br><span class="hljs-comment"> */</span><br>uint32xlp_rem_len;<span class="hljs-comment">/* total len of remaining data for record */</span><br>&#125; XLogPageHeaderData;<br></code></pre></td></tr></table></figure><p>XLogLongPageHeaderData结构和XLogPageHeaderData结构在src&#x2F;include&#x2F;access&#x2F;xlog_internal.h文件中定义。<br>这里省略了对这两个结构的详细解释，因为在接下来的描述中并不需要它们的具体细节。</p><h3 id="9-4-Internal-Layout-of-XLOG-Record"><a href="#9-4-Internal-Layout-of-XLOG-Record" class="headerlink" title="9.4. Internal Layout of XLOG Record"></a><a name="xlog-record"></a>9.4. Internal Layout of XLOG Record</h3><p>一条XLOG记录由通用的头部部分和相关的数据部分组成。第一个小节描述了头部结构。接下来的两个小节分别<br>解释了9.4及更早版本和9.5版本中数据部分的结构。(数据格式在9.5版本中发生了变化。)</p><h4 id="9-4-1-Header-Portion-of-XLOG-Record"><a href="#9-4-1-Header-Portion-of-XLOG-Record" class="headerlink" title="9.4.1. Header Portion of XLOG Record"></a>9.4.1. Header Portion of XLOG Record</h4><p><strong>XLOG 记录的头部部分</strong><br>所有的XLOG记录都有一个由XLogRecord结构定义的通用头部部分。<br>下面展示了9.4及更早版本的结构,尽管在9.5版本中已经发生了变化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XLogRecord</span></span><br><span class="hljs-class">&#123;</span><br>   uint32          xl_tot_len;   <span class="hljs-comment">/* total len of entire record */</span><br>   TransactionId   xl_xid;       <span class="hljs-comment">/* xact id */</span><br>   uint32          xl_len;       <span class="hljs-comment">/* total len of rmgr data. This variable was removed in ver.9.5. */</span><br>   uint8           xl_info;      <span class="hljs-comment">/* flag bits, see below */</span><br>   RmgrId          xl_rmid;      <span class="hljs-comment">/* resource manager for this record */</span><br>   <span class="hljs-comment">/* 2 bytes of padding here, initialize to zero */</span><br>   XLogRecPtr      xl_prev;      <span class="hljs-comment">/* ptr to previous record in log */</span><br>   pg_crc32        xl_crc;       <span class="hljs-comment">/* CRC for this record */</span><br>&#125; XLogRecord;<br></code></pre></td></tr></table></figure><blockquote><p> The Header Portion of XLOG Record in versions 9.5 or later.</p><p>在9.5及更高版本中,XLogRecord结构中移除了一个变量(xl_len),以优化XLOG记录格式,<br>从而减少了几个字节的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XLogRecord</span></span><br><span class="hljs-class">&#123;</span><br>  uint32          xl_tot_len;             <span class="hljs-comment">/* total len of entire record */</span><br>  TransactionId xl_xid;           <span class="hljs-comment">/* xact id */</span><br>  XLogRecPtr      xl_prev;                <span class="hljs-comment">/* ptr to previous record in log */</span><br>  uint8           xl_info;                <span class="hljs-comment">/* flag bits, see below */</span><br>  RmgrId          xl_rmid;                <span class="hljs-comment">/* resource manager for this record */</span><br>  <span class="hljs-comment">/* 2 bytes of padding here, initialize to zero */</span><br>  pg_crc32c       xl_crc;                 <span class="hljs-comment">/* CRC for this record */</span><br>  <span class="hljs-comment">/* XLogRecordBlockHeaders and XLogRecordDataHeader follow, no padding */</span><br>&#125; XLogRecord;<br></code></pre></td></tr></table></figure></blockquote><p>除了两个变量外，大多数变量都很明显,不需要进行描述。</p><p>xl_rmid和xl_info是与资源管理器相关的变量,资源管理器是与WAL特性相关的操作集合,<br>例如写入和重放XLOG记录。随着每个PostgreSQL版本的发展,资源管理器的数量也在增加。<br>PostgreSQL 10版本包含以下内容:</p><table><thead><tr><th>Operation</th><th>Resource manager</th></tr></thead><tbody><tr><td>Heap tuple operations</td><td>RM_HEAP, RM_HEAP2</td></tr><tr><td>Index operations</td><td>RM_BTREE, RM_HASH, RM_GIN, RM_GIST, RM_SPGIST, RM_BRIN</td></tr><tr><td>Sequence operations</td><td>RM_SEQ</td></tr><tr><td>Transaction operations</td><td>RM_XACT, RM_MULTIXACT, RM_CLOG, RM_XLOG, RM_COMMIT_TS</td></tr><tr><td>Tablespace operations</td><td>RM_SMGR, RM_DBASE, RM_TBLSPC, RM_RELMAP</td></tr><tr><td>replication and hot standby operations</td><td>RM_STANDBY, RM_REPLORIGIN, RM_GENERIC_ID, RM_LOGICALMSG_ID</td></tr></tbody></table><p>以下是一些代表性的资源管理器工作示例:</p><ol><li>如果发出了一条INSERT语句,其XLOG记录的头部变量xl_rmid和xl_info分别被设置<br>为’RM_HEAP’和’XLOG_HEAP_INSERT’。在恢复数据库集群时,根据xl_info选择RM_HEAP的heap_xlog_insert()<br>函数来重放这条XLOG记录。  </li><li>类似地,对于UPDATE语句,XLOG记录的头部变量xl_info被设置为’XLOG_HEAP_UPDATE’。在数据库恢复时,<br>RM_HEAP的heap_xlog_update()函数会重放这条记录。  </li><li>当事务提交时,其XLOG记录的头部变量xl_rmid和xl_info被设置为’RM_XACT’和’XLOG_XACT_COMMIT’。<br>在恢复数据库集群时,xact_redo_commit()函数会重放这条记录。</li></ol><blockquote><p>Info</p><p>XLogRecord structure in versions 9.4 or earlier is defined<br>in src&#x2F;include&#x2F;access&#x2F;xlog.h and that of versions 9.5 or later is<br>defined in src&#x2F;include&#x2F;access&#x2F;xlogrecord.h.</p><p>The heap_xlog_insert and heap_xlog_update are defined in<br>src&#x2F;backend&#x2F;access&#x2F;heap&#x2F;heapam.c; while the function xact_redo_commit<br>is defined in src&#x2F;backend&#x2F;access&#x2F;transam&#x2F;xact.c.</p></blockquote><h4 id="9-4-2-Data-Portion-of-XLOG-Record-versions-9-4-or-earlier"><a href="#9-4-2-Data-Portion-of-XLOG-Record-versions-9-4-or-earlier" class="headerlink" title="9.4.2. Data Portion of XLOG Record (versions 9.4 or earlier)"></a>9.4.2. Data Portion of XLOG Record (versions 9.4 or earlier)</h4><p><strong>XLOG 记录的数据部分 (9.4 版本或更早)</strong></p><p>XLOG 记录的数据部分可以分为两类:备份块(包含整个页面)<br>和非备份块(包含不同的数据,具体取决于操作)。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_8.png" alt="img_8.png"></p><p>XLOG 记录的内部布局如下所述,并给出一些具体示例。</p><h5 id="9-4-2-1-Backup-Block"><a href="#9-4-2-1-Backup-Block" class="headerlink" title="9.4.2.1. Backup Block"></a>9.4.2.1. Backup Block</h5><p>备份块的结构如图 9.8(a) 所示。它由两个数据结构和一个数据对象组成:</p><ol><li>XLogRecord 结构(头部部分)。  </li><li>BkpBlock 结构。  </li><li>整个页面,除了空闲空间。</li></ol><p>BkpBlock 结构包含标识数据库集群中页面的变量(即包含该页面的关系的 relfilenode<br>和 fork 号,以及页面的块号),以及页面空闲空间的起始位置和长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BkpBlock</span> @ <span class="hljs-title">include</span>/<span class="hljs-title">access</span>/<span class="hljs-title">xlog_internal</span>.<span class="hljs-title">h</span></span><br><span class="hljs-class">&#123;</span><br>  RelFileNode node;        <span class="hljs-comment">/* relation containing block */</span><br>  ForkNumber  fork;        <span class="hljs-comment">/* fork within the relation */</span><br>  BlockNumber block;       <span class="hljs-comment">/* block number */</span><br>  uint16      hole_offset; <span class="hljs-comment">/* number of bytes before &quot;hole&quot; */</span><br>  uint16      hole_length; <span class="hljs-comment">/* number of bytes in &quot;hole&quot; */</span><br><br>  <span class="hljs-comment">/* ACTUAL BLOCK DATA FOLLOWS AT END OF STRUCT */</span><br>&#125; BkpBlock;<br></code></pre></td></tr></table></figure><h5 id="9-4-2-2-Non-Backup-Block"><a href="#9-4-2-2-Non-Backup-Block" class="headerlink" title="9.4.2.2. Non-Backup Block"></a>9.4.2.2. Non-Backup Block</h5><p>对于非备份块,数据部分的布局根据操作的不同而有所不同。以 INSERT 语句的 XLOG 记录为例进行说明,<br>如图 9.8(b) 所示。在这种情况下, INSERT 语句的 XLOG 记录由两个数据结构和一个数据对象组成:</p><ol><li>XLogRecord (头部部分) 结构。  </li><li>xl_heap_insert 结构。  </li><li>插入的元组,除去了几个字节。</li></ol><p>xl_heap_insert 结构包含标识数据库集群中插入的元组的变量(即包含该元组的表的 relfilenode<br>和元组的 tid), 以及该元组的可见性标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BlockIdData</span></span><br><span class="hljs-class">&#123;</span><br>   uint16          bi_hi;<br>   uint16          bi_lo;<br>&#125; BlockIdData;<br><br><span class="hljs-keyword">typedef</span> uint16 OffsetNumber;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ItemPointerData</span></span><br><span class="hljs-class">&#123;</span><br>   BlockIdData     ip_blkid;<br>   OffsetNumber    ip_posid;<br>&#125;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RelFileNode</span></span><br><span class="hljs-class">&#123;</span><br>   Oid             spcNode;             <span class="hljs-comment">/* tablespace */</span><br>   Oid             dbNode;              <span class="hljs-comment">/* database */</span><br>   Oid             relNode;             <span class="hljs-comment">/* relation */</span><br>&#125; RelFileNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xl_heaptid</span></span><br><span class="hljs-class">&#123;</span><br>   RelFileNode     node;<br>   ItemPointerData tid;                 <span class="hljs-comment">/* changed tuple id */</span><br>&#125; xl_heaptid;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xl_heap_insert</span></span><br><span class="hljs-class">&#123;</span><br>   xl_heaptid      target;              <span class="hljs-comment">/* inserted tuple id */</span><br>   <span class="hljs-type">bool</span>            all_visible_cleared; <span class="hljs-comment">/* PD_ALL_VISIBLE was cleared */</span><br>&#125; xl_heap_insert;<br></code></pre></td></tr></table></figure><blockquote><p>info</p><p>从插入的元组中删除几个字节的原因在于 xl_heap_header 结构的源代码注释中有所描述:</p><p>“我们不会在 WAL 中存储插入或更新的元组的整个固定部分(HeapTupleHeaderData)；通过<br>重建 WAL 记录中其他地方可用的字段,或者可能根本不需要重建,我们可以节省几个字节。”</p></blockquote><p>再举一个例子。如图 9.8(c) 所示,检查点记录的 XLOG 记录非常简单,由两个数据结构组成:</p><ol><li>XLogRecord 结构(头部部分)。  </li><li>Checkpoint 结构,其中包含检查点信息(更多细节见第 9.7 节)。</li></ol><blockquote><p>info</p><p>The xl_heap_header structure is defined in src&#x2F;include&#x2F;access&#x2F;htup.h<br>while the CheckPoint structure is defined in src&#x2F;include&#x2F;catalog&#x2F;pg_control.h.</p></blockquote><h4 id="9-4-3-Data-Portion-of-XLOG-Record-versions-9-5-or-later"><a href="#9-4-3-Data-Portion-of-XLOG-Record-versions-9-5-or-later" class="headerlink" title="9.4.3. Data Portion of XLOG Record (versions 9.5 or later)"></a>9.4.3. Data Portion of XLOG Record (versions 9.5 or later)</h4><p>在 9.4 或更早的版本中,XLOG 记录没有通用格式,所以每个资源管理器都必须定义自己的格式。<br>这使得维护源代码和实现与 WAL 相关的新功能变得越来越困难。为了解决这个问题,<br>在 9.5 版本中引入了一种独立于资源管理器的通用结构化格式。</p><p>XLOG 记录的数据部分可以分为两部分:头部和数据部分,如图 9.9 所示。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_9.png" alt="img_9.png"></p><p>XLOG 记录的头部包含零个或多个 XLogRecordBlockHeaders 和零个或一个<br>XLogRecordDataHeaderShort(或 XLogRecordDataHeaderLong)。它至少必须包含这些之一。</p><p>当记录存储完整页面映像(即备份块)时,XLogRecordBlockHeader 包括<br>XLogRecordBlockImageHeader,如果该块被压缩,还包括 XLogRecordBlockCompressHeader。</p><p>XLogRecordBlockHeader<br>XLogRecordBlockImageHeader<br>XLogRecordBlockCompressHeader<br>XLogRecordDataHeader  </p><p>数据部分由零个或多个块数据和零个或一个主数据组成,分别对应于 XLogRecordBlockHeader(s)<br>和 XLogRecordDataHeader。</p><blockquote><p>WAL compression</p><p>在版本 9.5 或更高版本中,XLOG 记录中的全页图像可以通过设置参数 wal_compression &#x3D; enable 使用 LZ 压缩方法进行压缩。在这种情况下,将添加 XLogRecordBlockCompressHeader 结构。</p><p>这个特性有两个优点和一个缺点:</p><p>优点:<br>减少写入记录的 I&#x2F;O 成本。<br>抑制 WAL 段文件的消耗。</p><p>缺点:<br>消耗大量 CPU 资源进行压缩。</p></blockquote><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_10.png" alt="img_10.png"></p><h5 id="9-4-3-1-Backup-Block"><a href="#9-4-3-1-Backup-Block" class="headerlink" title="9.4.3.1. Backup Block"></a>9.4.3.1. Backup Block</h5><p>由 INSERT 语句创建的备份块如图 9.10(a) 所示。它由四个数据结构和一个数据对象组成:</p><ol><li>XLogRecord 结构(头部部分)。  </li><li>XLogRecordBlockHeader 结构,包括一个 XLogRecordBlockImageHeader 结构。  </li><li>XLogRecordDataHeaderShort 结构。  </li><li>备份块(块数据)。  </li><li>xl_heap_insert 结构(主数据)。</li></ol><p>XLogRecordBlockHeader 结构包含了标识数据库集群中块的变量(relfilenode、<br>fork 编号和块编号)。XLogRecordImageHeader 结构包含了这个块的长度和偏移量。<br>(这两个头部结构together可以存储与 9.4 版本之前使用的 BkBlock 结构相同的数据。)</p><p>XLogRecordDataHeaderShort 结构存储了 xl_heap_insert 结构的长度,这是记录的主要数据。<br>(见下文。)</p><blockquote><p>info</p><p>XLOG记录中的全页图像的主数据并不经常使用,除了在某些特殊情况下,如逻辑解码和投机性插入。<br>在重播记录时,这些主数据被忽略,因此是冗余数据。这一点未来可能会改进。</p><p>此外,备份块记录的主数据取决于创建它们的语句。例如,UPDATE语句会<br>附加xl_heap_lock或xl_heap_updated。</p></blockquote><h5 id="9-4-3-2-Non-Backup-Block"><a href="#9-4-3-2-Non-Backup-Block" class="headerlink" title="9.4.3.2. Non-Backup Block"></a>9.4.3.2. Non-Backup Block</h5><p>接下来,我将描述由INSERT语句创建的非备份块记录(见图9.10(b))。<br>它由四种数据结构和一个数据对象组成:</p><ol><li>XLogRecord结构(头部部分)  </li><li>XLogRecordBlockHeader结构  </li><li>XLogRecordDataHeaderShort结构  </li><li>插入的元组(准确地说,是一个xl_heap_header结构和一个插入的数据整体)  </li><li>xl_heap_insert结构(主要数据)</li></ol><p>XLogRecordBlockHeader结构包含三个值(relfilenode、fork number和block number)来<br>指定插入元组的块,以及插入元组数据部分的长度。XLogRecordDataHeaderShort结构包含新的<br>xl_heap_insert结构的长度,这是该记录的主要数据。</p><p>新的xl_heap_insert结构只包含两个值:该元组在块内的偏移量和可见性标志。它变得非常简单,<br>因为XLogRecordBlockHeader结构存储了旧的xl_heap_insert结构中的大部分数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xl_heap_insert</span></span><br><span class="hljs-class">&#123;</span><br>        OffsetNumberoffnum;            <span class="hljs-comment">/* inserted tuple&#x27;s offset */</span><br>        uint8           flags;<br><br>        <span class="hljs-comment">/* xl_heap_header &amp; TUPLE DATA in backup block 0 */</span><br>&#125; xl_heap_insert;<br></code></pre></td></tr></table></figure><p>作为最后一个示例,图9.10(c)中显示了一个checkpoint记录。它由三种数据结构组成:</p><ol><li>XLogRecord结构(头部部分)</li><li>XLogRecordDataHeaderShort结构(包含主要数据长度)</li><li>CheckPoint结构(主要数据)</li></ol><blockquote><p>info</p><p>xl_heap_header 结构体被定义在 src&#x2F;include&#x2F;access&#x2F;htup.h 中,而 CheckPoint 结构体被定义在 src&#x2F;include&#x2F;catalog&#x2F;pg_control.h 中。</p></blockquote><p>虽然新的格式对我们来说有些复杂,但它对资源管理器的解析器来说设计得很好。<br>此外,许多类型的 XLOG 记录的大小通常比之前的小。主要结构体的大小如图 9.8 和 9.10 所示,<br>您可以计算这些记录的大小并进行比较。(新检查点的大小大于以前的,但它包含更多变量。)</p><h3 id="9-5-Writing-of-XLOG-Records"><a href="#9-5-Writing-of-XLOG-Records" class="headerlink" title="9.5. Writing of XLOG Records"></a><a name="write-xlog"></a>9.5. Writing of XLOG Records</h3><p>很好,我们已经完成了热身练习,现在准备开始学习 XLOG 记录的写入了。<br>我将尽可能详细地解释该部分内容。</p><p>首先,请执行以下语句来探索 PostgreSQL 的内部机制:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">INSERT INTO</span> tbl <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;A&#x27;</span>);<br></code></pre></td></tr></table></figure><p>好的,通过执行上述语句,内部函数 exec_simple_query() 被调用。<br>exec_simple_query() 的伪代码如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">exec_simple_query() @postgres.c<br><br>(<span class="hljs-number">1</span>) ExtendCLOG() @<span class="hljs-built_in">clog</span>.c                  <span class="hljs-comment">/* Write the state of this transaction</span><br><span class="hljs-comment">                                           * &quot;IN_PROGRESS&quot; to the CLOG.</span><br><span class="hljs-comment">                                           */</span><br>(<span class="hljs-number">2</span>) heap_insert()@heapam.c                <span class="hljs-comment">/* Insert a tuple, creates a XLOG record,</span><br><span class="hljs-comment">                                           * and invoke the function XLogInsert.</span><br><span class="hljs-comment">                                           */</span><br>(<span class="hljs-number">3</span>)   XLogInsert() @xloginsert.c (<span class="hljs-number">9.4</span> or earlier, xlog.c)<br>                                          <span class="hljs-comment">/* Write the XLOG record of the inserted tuple</span><br><span class="hljs-comment">                                           *  to the WAL buffer, and update page&#x27;s pd_lsn.</span><br><span class="hljs-comment">                                           */</span><br>(<span class="hljs-number">4</span>) finish_xact_command() @postgres.c     <span class="hljs-comment">/* Invoke commit action.*/</span>   <br>      XLogInsert() @xloginsert.c (<span class="hljs-number">9.4</span> or earlier, xlog.c)<br>                                          <span class="hljs-comment">/* Write a XLOG record of this commit action </span><br><span class="hljs-comment">                                           * to the WAL buffer.</span><br><span class="hljs-comment">                                           */</span><br>(<span class="hljs-number">5</span>)   XLogWrite() @xloginsert.c (<span class="hljs-number">9.4</span> or earlier, xlog.c)<br>                                          <span class="hljs-comment">/* Write and flush all XLOG records on</span><br><span class="hljs-comment">                                           * the WAL buffer to WAL segment.</span><br><span class="hljs-comment">                                           */</span><br>(<span class="hljs-number">6</span>) TransactionIdCommitTree() @transam.c  <span class="hljs-comment">/* Change the state of this transaction </span><br><span class="hljs-comment">                                           * from &quot;IN_PROGRESS&quot; to &quot;COMMITTED&quot;</span><br><span class="hljs-comment">                                           * on the CLOG.</span><br><span class="hljs-comment">                                           */</span><br></code></pre></td></tr></table></figure><p>在以下段落中,将逐行解释伪代码,以帮助您理解 XLOG 记录的写入过程。也请参考图 9.11 和 9.12。</p><p>(1) 函数 ExtendCLOG() 将该事务的状态写入(内存中的) CLOG 中,状态为 ‘IN_PROGRESS’。</p><p>(2) 函数 heap_insert() 将一个堆元组插入到共享缓冲池中的目标页面,<br>创建该页面的 XLOG 记录,并调用函数 XLogInsert()。</p><p>(3) 函数 XLogInsert() 将 heap_insert() 创建的 XLOG 记录写入 WAL 缓冲区,<br>位置为 LSN_1,然后将修改页面的 pd_lsn 从 LSN_0 更新为 LSN_1。</p><p>(4) 函数 finish_xact_command()被调用来提交该事务,它创建提交操作的 XLOG 记录,<br>然后函数 XLogInsert() 将此记录写入 WAL 缓冲区,位置为 LSN_2。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_11.png" alt="img_11.png"></p><p>(5) 函数 XLogWrite() 将 WAL 缓冲区中的所有 XLOG 记录写入并刷新到 WAL 段文件中。<br>如果参数 wal_sync_method 设置为 ‘open_sync’ 或 ‘open_datasync’，这些记录将被同步写入,<br>因为该函数使用 open() 系统调用,并设置 ‘O_SYNC’ 或 ‘O_DSYNC’ 标志进行写入。<br>如果参数设置为 ‘fsync’、’fsync_writethrough’ 或 ‘fdatasync’，将执行相应的系统<br>调用 - fsync()、带 F_FULLFSYNC 选项的 fcntl() 或 fdatasync()。无论如何,<br>所有 XLOG 记录都被确保写入存储介质。</p><p>(6) 函数 TransactionIdCommitTree() 将该事务的状态从 ‘IN_PROGRESS’ 更改为 ‘COMMITTED’<br>状态,写入 CLOG。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_12.png" alt="img_12.png"></p><p>在上述示例中,提交操作导致将 XLOG 记录写入 WAL 段,但也可能由以下任何情况触发写入:</p><ol><li>一个正在运行的事务已提交或中止。  </li><li>WAL 缓冲区已被填满大量元组。(WAL 缓冲区大小由参数 wal_buffers 设置。)  </li><li>WAL 写入进程定期执行写入操作。(参见下一节。)</li></ol><p>如果发生上述任何情况,WAL 缓冲区中的所有 WAL 记录都将写入 WAL 段文件,无论它们所属的事务<br>是否已提交。</p><p>毫无疑问,DML(数据操作语言)操作会写入 XLOG 记录,但非 DML 操作也会如此。<br>如前所述,提交操作会写入一条包含已提交事务 ID 的 XLOG 记录。另一个例子是检查点操作,<br>它会写入一条包含检查点相关信息的 XLOG 记录。</p><p>此外,SELECT 语句在特殊情况下会创建 XLOG 记录,尽管它通常不会创建这些记录。<br>例如,如果在 SELECT 语句期间通过 HOT (Heap Only Tuple) 删除了不必要的元组并对<br>必要的元组进行了页面碎片整理,那么被修改页面的 XLOG 记录就会被写入 WAL 缓冲区。</p><blockquote><p>Direct I&#x2F;O</p><p>PostgreSQL 15 及之前的版本都不支持直接 I&#x2F;O,尽管这个功能一直在讨论中。<br>可以参考 pgsql-ML 上的这个讨论以及这篇文章。</p><p>在 16 版本中,新增了 debug-io-direct 选项。这个选项是为开发人员准备的,<br>用于改进 PostgreSQL 中对直接 I&#x2F;O 的使用。如果开发进展顺利,未来不久直接 I&#x2F;O 功能将<br>得到正式支持。</p></blockquote><h3 id="9-6-WAL-Writer-Process"><a href="#9-6-WAL-Writer-Process" class="headerlink" title="9.6. WAL Writer Process"></a><a name="wal-writer"></a>9.6. WAL Writer Process</h3><p><strong>WAL 写入进程</strong></p><p>WAL 写入进程是一个后台进程,它会定期检查 WAL 缓冲区并将所有未写入的 XLOG 记录写入<br>到 WAL 段中。这个进程可以帮助避免 XLOG 记录写入的突发情况。如果没有启用 WAL 写入进程,<br>当大量数据同时被提交时,XLOG 记录的写入可能会成为瓶颈。</p><p>WAL 写入进程默认是启用的,不能被禁用。检查间隔由配置参数 wal_writer_delay 设置,<br>默认值为 200 毫秒。</p><h3 id="9-7-Checkpoint-Processing-in-PostgreSQL"><a href="#9-7-Checkpoint-Processing-in-PostgreSQL" class="headerlink" title="9.7. Checkpoint Processing in PostgreSQL"></a><a name="checkpoint"></a>9.7. Checkpoint Processing in PostgreSQL</h3><p>在PostgreSQL中，检查点进程（后台进程）负责执行检查点操作。当以下任一情况发生时，检查点进程将启动：</p><ol><li>自上一个检查点以来，设置的checkpoint_timeout间隔时间已经过去（默认间隔为300秒）。  </li><li>在9.4或更早版本中，自上一个检查点以来，已使用的WAL段文件数量达到了checkpoint_segments设置的数量<br>（默认为3个段）。  </li><li>在9.5或更高版本中，pg_wal目录（在9.6或更早版本中为pg_xlog目录）中WAL段文件的总大小超过了<br>max_wal_size参数设定的值（默认值为1GB（64个文件））。  </li><li>PostgreSQL服务器以smart或fast模式停止。  </li><li>超级用户手动执行CHECKPOINT命令。</li></ol><blockquote><p>info</p><p>在9.1或更早的版本中，如第8.6节所述，后台写入器进程同时负责检查点处理和脏页写入。</p></blockquote><p>在接下来的小节中，将概述检查点的流程以及保存当前检查点元数据的pg_control文件。</p><h4 id="9-7-1-Outline-of-the-Checkpoint-Processing"><a href="#9-7-1-Outline-of-the-Checkpoint-Processing" class="headerlink" title="9.7.1. Outline of the Checkpoint Processing"></a>9.7.1. Outline of the Checkpoint Processing</h4><p>检查点过程有两个方面：为数据库恢复做准备，以及清理共享缓冲池中的脏页。<br>在本小节中，我们将重点关注前者方面，并描述其内部处理过程。请参见图9.13以获得概览。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_13.png" alt="img_13.png"></p><p>(1) 当检查点进程启动时，REDO点被存储在内存中。REDO点是最新检查点启动时刻写入的日志记录的位置，<br>它是数据库恢复的起始点。</p><p>(2) 该检查点的XLOG记录（即，检查点记录）被写入WAL缓冲区。该记录的数据部分由CheckPoint结构定义，<br>该结构包含多个变量，如步骤(1)中存储的REDO点。<br>检查点记录被写入的位置也称为检查点。</p><p>(3) 共享内存中的所有数据（例如，clog的内容等）都被刷新到存储器中。</p><p>(4) 共享缓冲池中的所有脏页都会逐渐被写入并刷新到存储器中。</p><p>(5) 更新pg_control文件。这个文件包含了诸如检查点记录写入位置（即，检查点位置）等基本信息。<br>我们将在后面更详细地讨论这个文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CheckPoint</span></span><br><span class="hljs-class">&#123;</span><br>  XLogRecPtr      redo;           <span class="hljs-comment">/* next RecPtr available when we began to</span><br><span class="hljs-comment">                                   * create CheckPoint (i.e. REDO start point) */</span><br>  TimeLineID      ThisTimeLineID; <span class="hljs-comment">/* current TLI */</span><br>  TimeLineID      PrevTimeLineID; <span class="hljs-comment">/* previous TLI, if this record begins a new</span><br><span class="hljs-comment">                                   * timeline (equals ThisTimeLineID otherwise) */</span><br>  <span class="hljs-type">bool</span>            fullPageWrites; <span class="hljs-comment">/* current full_page_writes */</span><br>  uint32          nextXidEpoch;   <span class="hljs-comment">/* higher-order bits of nextXid */</span><br>  TransactionId   nextXid;        <span class="hljs-comment">/* next free XID */</span><br>  Oid             nextOid;        <span class="hljs-comment">/* next free OID */</span><br>  MultiXactId     nextMulti;      <span class="hljs-comment">/* next free MultiXactId */</span><br>  MultiXactOffset nextMultiOffset;<span class="hljs-comment">/* next free MultiXact offset */</span><br>  TransactionId   oldestXid;      <span class="hljs-comment">/* cluster-wide minimum datfrozenxid */</span><br>  Oid             oldestXidDB;    <span class="hljs-comment">/* database with minimum datfrozenxid */</span><br>  MultiXactId     oldestMulti;    <span class="hljs-comment">/* cluster-wide minimum datminmxid */</span><br>  Oid             oldestMultiDB;  <span class="hljs-comment">/* database with minimum datminmxid */</span><br>  <span class="hljs-type">pg_time_t</span>       time;           <span class="hljs-comment">/* time stamp of checkpoint */</span><br><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  * Oldest XID still running. This is only needed to initialize hot standby</span><br><span class="hljs-comment">  * mode from an online checkpoint, so we only bother calculating this for</span><br><span class="hljs-comment">  * online checkpoints and only when wal_level is hot_standby. Otherwise</span><br><span class="hljs-comment">  * it&#x27;s set to InvalidTransactionId.</span><br><span class="hljs-comment">  */</span><br>  TransactionId oldestActiveXid;<br>&#125; CheckPoint;<br></code></pre></td></tr></table></figure><p>综上所述，从数据库恢复的角度来概括，检查点创建了一个包含REDO点的检查点记录，并在pg_control文件中存储了<br>检查点位置和其他信息。这样PostgreSQL就可以根据pg_control文件提供的REDO点（从检查点记录中获得），<br>通过重放WAL数据来自我恢复。</p><h4 id="9-7-2-pg-control-File"><a href="#9-7-2-pg-control-File" class="headerlink" title="9.7.2. pg_control File"></a>9.7.2. pg_control File</h4><p>由于pg_control文件包含了检查点的基本信息，对于数据库恢复至关重要。如果该文件被损坏或无法读取，<br>恢复过程将无法启动，因为它无法获取一个起始点。</p><p>尽管pg_control文件存储了超过40项内容，但以下是下一节将需要的三项内容：  </p><ol><li>状态（State）——在最近一次检查点启动时数据库服务器的状态。总共有七种状态：<br>‘start up’ 表示系统正在启动。<br>‘shut down’ 表示系统正在通过shutdown命令正常关闭。<br>‘in production’ 表示系统正在运行。等等。  </li><li>最新检查点位置（Latest checkpoint location）——最新检查点记录的LSN位置。</li><li>前一个检查点位置（Prior checkpoint location）——前一个检查点记录的LSN位置。<br>请注意，在版本11中，这一项已被弃用；具体细节在下方中描述。</li></ol><p>pg_control文件存储在基础目录下的global子目录中。可以使用pg_controldata工具显示其内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres&gt; </span><span class="language-bash">pg_controldata  /usr/local/pgsql/data</span><br>pg_control version number:            1300<br>Catalog version number:               202306141<br>Database system identifier:           7250496631638317596<br>Database cluster state:               in production<br>pg_control last modified:             Mon Jan 1 15:16:38 2024<br>Latest checkpoint location:           0/16AF0090<br>Latest checkpoint&#x27;s REDO location:    0/16AF0090<br>Latest checkpoint&#x27;s REDO WAL file:    000000010000000000000016<br><br>... snip ...<br></code></pre></td></tr></table></figure><blockquote><p>Removal of prior checkpoint in PostgreSQL 11</p><p>PostgreSQL 11及以上版本仅保留包含最新检查点或更新的日志段。为了减少用于保存pg_wal子目录下WAL<br>段文件的磁盘空间，不保留包含前一个检查点的较老日志段文件。详情可参考此线程讨论。</p><p><a href="http://www.postgresql-archive.org/Remove-secondary-checkpoint-tt5989050.html">http://www.postgresql-archive.org/Remove-secondary-checkpoint-tt5989050.html</a></p></blockquote><h3 id="9-8-Database-Recovery-in-PostgreSQL"><a href="#9-8-Database-Recovery-in-PostgreSQL" class="headerlink" title="9.8. Database Recovery in PostgreSQL"></a><a name="recovery"></a>9.8. Database Recovery in PostgreSQL</h3><p>PostgreSQL采用基于重做日志的恢复机制。如果数据库服务器崩溃，PostgreSQL可以通过顺序重放WAL<br>段文件中从REDO点开始的XLOG记录来恢复数据库集群。</p><p>到本节为止，我们已经多次谈到数据库恢复。在这里，我将描述关于恢复的两个尚未解释的事项。</p><p>第一件事是PostgreSQL如何启动恢复过程。当PostgreSQL启动时，它首先读取pg_control文件。<br>从那时起，以下是恢复过程的详细步骤。请参阅图9.14及以下描述。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_14.png" alt="img_14.png"></p><ol><li>PostgreSQL在启动时读取pg_control文件中的所有项目。如果状态项为’in production’，PostgreSQL会进入恢复模式 ，<br>因为这意味着数据库没有正常关闭。如果状态为’shut down’，PostgreSQL则进入常规启动模式。  </li><li>PostgreSQL根据pg_control文件中所写的最新检查点记录的位置，从相应的WAL段文件中读取该记录，<br>并从中获取REDO点。如果最新的检查点记录无效，PostgreSQL会尝试读取前一个记录。如果两个记录都不可读，<br>则放弃自我恢复。（注意，在PostgreSQL 11或之后的版本中，不再存储前一个检查点。）  </li><li>相应的资源管理器从REDO点开始，按顺序读取并重放XLOG记录，直到达到最新WAL段的末尾。当重放XLOG记录时，<br>如果它是备份块，则无论其LSN如何，都会覆盖到对应的表页面上。否则，对于非备份块的XLOG记录，<br>只有当记录的LSN大于对应页面的’pd_lsn’时，才会进行重放。</li></ol><p>第二点是关于LSN比较的问题：为什么需要比较非备份块的LSN和相应页面的pd_lsn。与之前的例子不同，<br>这里将通过一个具体示例来解释这一点，强调这种比较的必要性。请参阅图9.15和9.16。<br>（注意，为了简化描述，此处省略了WAL缓冲区。）</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_15.png" alt="img_15.png"></p><ol><li>PostgreSQL向TABLE_A插入一个元组，并在LSN_1处写入一条XLOG记录。  </li><li>后台写入进程将TABLE_A的页面写入到存储器中。此时，该页面的pd_lsn为LSN_1。  </li><li>PostgreSQL再次向TABLE_A插入一个新的元组，并在LSN_2处写入一条XLOG记录。<br>但是，修改后的页面尚未写入存储器。</li></ol><p>与概述中的示例不同，在此场景中，TABLE_A的页面已经至少被写入存储器一次。</p><p>接下来，立即模式下关闭数据库，然后重新启动数据库。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_16.png" alt="img_16.png"></p><ol><li>PostgreSQL加载第一条XLOG记录和TABLE_A的页面，但由于记录的LSN(LSN_1)不大于页面<br>的LSN（也是LSN_1），因此不会对其进行重放。实际上，显然没有必要重放它。  </li><li>接下来，PostgreSQL重放第二条XLOG记录，因为该记录的LSN(LSN_2)大于TABLE_A页面当前的LSN(LSN_1)。</li></ol><p>从这个例子可以看出，如果非备份块的重放顺序错误或非备份块被重放多次，<br>数据库集群将不再保持一致性。简而言之，非备份块的重做（重放）操作不是幂等的。因此，为了保持正确的重放顺序，<br>只有当非备份块记录的LSN大于对应页面的pd_lsn时，才应该对其进行重放。</p><p>另一方面，由于备份块的重做操作是幂等的，所以备份块可以不考虑其LSN而被重放任意次数。</p><h3 id="9-9-WAL-Segment-Files-Management"><a href="#9-9-WAL-Segment-Files-Management" class="headerlink" title="9.9. WAL Segment Files Management"></a><a name="wal-file"></a>9.9. WAL Segment Files Management</h3><p>PostgreSQL将XLOG记录写入存储在pg_wal子目录中的WAL段文件之一（在9.6或更早版本中为pg_xlog子目录）。<br>如果旧的WAL段文件已满，将切换到新的WAL段文件。WAL文件的数量取决于多个配置参数以及服务器活动。<br>此外，从9.5版本开始，对WAL段文件的管理策略得到了改进。</p><p>以下小节将描述WAL段文件是如何切换和管理的。</p><h4 id="9-9-1-WAL-Segment-Switches"><a href="#9-9-1-WAL-Segment-Switches" class="headerlink" title="9.9.1. WAL Segment Switches"></a>9.9.1. WAL Segment Switches</h4><p>WAL段的切换发生在以下任一事件发生时：</p><ol><li>WAL段已填满。  </li><li>调用了pg_switch_xlog函数。  </li><li>archive_mode参数被启用且archive_timeout参数设定的时间到期。</li></ol><p>当WAL段文件切换时，通常会对其进行回收（重命名并重新使用）以备将来使用。但是，如果不再需要，<br>可能会在之后将其删除。</p><h4 id="9-9-2-WAL-Segment-Management"><a href="#9-9-2-WAL-Segment-Management" class="headerlink" title="9.9.2. WAL Segment Management"></a>9.9.2. WAL Segment Management</h4><p>每当检查点开始时，PostgreSQL会估计并为下一个检查点周期准备所需的WAL段文件数量。这个估计基于前一个检查点周期中<br>消耗的WAL段文件数量。</p><p>WAL段文件的数量从包含前一个REDO点的段开始计数（在10或更早版本中；在11或更高版本中即为REDO点所在段），<br>并且该值必须位于min_wal_size参数（默认为80MB，或5个文件）和max_wal_size参数（默认为1GB，或64个文件）之间。</p><p>如果检查点开始，PostgreSQL将保留或回收必要的WAL段文件，并移除任何不必要的文件。</p><p>图9.17展示了一个具体示例。假设在检查点开始之前有六个WAL段文件，其中WAL_3包含前一个REDO点<br>（在10或更早版本中；在11或更高版本中即为当前REDO点），并且PostgreSQL估计将需要五个文件。<br>在这种情况下，WAL_1将被重命名为WAL_7以便回收，而WAL_2将被移除。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_17.png" alt="img_17.png"></p><p>如果由于WAL活动突增导致需要更多的WAL段文件，只要WAL段文件的总大小小于<br>max_wal_size参数，就会创建新的WAL段文件。例如，在图9.18中，如果WAL_7已经被填满，将会新创建WAL_8。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_18.png" alt="img_18.png"></p><p>WAL段文件的数量会根据服务器活动进行调整。如果WAL数据写入量持续增加，<br>预估所需的WAL段文件数量以及WAL段文件的总大小将逐渐增加。相反，如果WAL数据写入量减少，这些数值也会减少。</p><p>如果WAL段文件的总大小超过了max_wal_size参数设定的值，将启动一个检查点。图9.19说明了这种情况。<br>通过执行检查点操作，将创建一个新的REDO点并丢弃前一个REDO点；随后，不必要的旧WAL段文件将被回收。<br>这样一来，PostgreSQL将始终只保留数据库恢复所需WAL段文件。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_19.png" alt="img_19.png"></p><p>wal_keep_size参数（在12或更早版本中为wal_keep_segments）和复制槽（replication slot）特性也会影响WAL段文件的数量。</p><h3 id="9-10-Continuous-Archiving-and-Archive-Logs"><a href="#9-10-Continuous-Archiving-and-Archive-Logs" class="headerlink" title="9.10. Continuous Archiving and Archive Logs"></a><a name="archive"></a>9.10. Continuous Archiving and Archive Logs</h3><p>连续归档是一种特性，它在WAL（Write-Ahead Log）段文件切换时，将这些文件复制到归档区域。<br>此操作由归档（后台）进程执行。被复制的文件称为归档日志。此功能通常用于热物理备份和PITR（时间点恢复），<br>这些在第10章中有详细描述。</p><p>归档区域的路径由配置参数‘archive_command’设置。例如，以下参数配置会每当发生段切换时，<br>将WAL段文件复制到目录‘&#x2F;home&#x2F;postgres&#x2F;archives&#x2F;’：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">archive_command = &#x27;cp %p /home/postgres/archives/%f&#x27;<br></code></pre></td></tr></table></figure><p>在这个命令中，%p代表当前要归档的WAL段文件的完整路径，%f代表不包含路径的WAL段文件名</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch9/ch9/img_20.png" alt="img_20.png"></p><p>archive_command参数可以设置为任何Unix命令或工具。这意味着您可以使用scp命令或任何其他文件备份工具<br>将归档日志传输到另一台主机，而不仅仅局限于使用简单的复制命令。</p><blockquote><p>archive_library</p><p>在PostgreSQL 14或更早的版本中，连续归档只能使用shell命令来实现。</p><p>但从PostgreSQL 15开始，引入了一个可加载库功能，这使得您能够通过一个库来实现连续归档，为归档过程提供了更多灵活性和扩展性。</p><p>欲了解更多详情，请参考archive_library和basic_archive相关的文档说明。</p><p><a href="https://www.postgresql.org/docs/current/runtime-config-wal.html#GUC-ARCHIVE-LIBRARY">https://www.postgresql.org/docs/current/runtime-config-wal.html#GUC-ARCHIVE-LIBRARY</a><br><a href="https://www.postgresql.org/docs/current/basic-archive.html">https://www.postgresql.org/docs/current/basic-archive.html</a></p></blockquote><blockquote><p>Note</p><p>PostgreSQL不会自动清理产生的归档日志。因此，在使用此功能时，必须妥善管理这些日志。<br>如果不采取任何措施，归档日志的数量将会持续增长。</p><p>pg_archivecleanup实用程序是管理归档日志文件的有用工具之一。</p><p>您也可以使用find命令来删除归档日志。例如，以下命令会删除所有超过三天前创建的归档日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /home/postgres/archives/ -type f -name &#x27;*.wal&#x27; -mtime +3 -exec rm &#123;&#125; \;<br></code></pre></td></tr></table></figure><p>在这个命令中：</p><p>&#x2F;home&#x2F;postgres&#x2F;archives&#x2F; 是归档日志存放的目录路径。<br>-type f 表示只查找文件。<br>-name ‘*.wal’ 指定了查找以.wal结尾的文件，这是PostgreSQL归档日志的一般命名格式。<br>-mtime +3 表示查找修改时间超过3天的文件。<br>-exec rm {} ; 则是对找到的每个文件执行删除操作。<br>请谨慎使用此类删除命令，确保在执行之前有适当的备份或确认这些日志确实不再需要。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL指南：内幕探索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch8. Buffer Manager</title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/</url>
    
    <content type="html"><![CDATA[<h2 id="ch8-Buffer-Manager"><a href="#ch8-Buffer-Manager" class="headerlink" title="ch8. Buffer Manager"></a>ch8. Buffer Manager</h2><p>缓冲区管理器负责管理共享内存与持久化存储之间的数据传输，<br>对数据库管理系统(DBMS)的性能有重大影响。PostgreSQL的缓冲区管理器工作效率非常高。</p><p>本章将介绍PostgreSQL的缓冲区管理器。首先概述缓冲区管理器，随后的章节将详细介绍以下几个主题：</p><ol><li>缓冲区管理器结构  </li><li>缓冲区管理器锁  </li><li>缓冲区管理器的工作原理  </li><li>环形缓冲区  </li><li>脏页刷新</li></ol><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img.png" alt="img.png"></p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#8-Overview">8.1 Overview</a></td></tr><tr><td><a href="#buffer-ms">8.2 Buffer Manager Structure</a></td></tr><tr><td><a href="#buffer-ml">8.3 Buffer Manager Locks</a></td></tr><tr><td><a href="#buffer-mw">8.4 How the Buffer Manager Works</a></td></tr><tr><td><a href="#Ring-Buffer">8.5 Ring Buffer</a></td></tr><tr><td><a href="#Flush-DP">8.6 Flushing Dirty Pages</a></td></tr></tbody></table><h3 id="8-1-Overview"><a href="#8-1-Overview" class="headerlink" title="8.1 Overview"></a><a name="8-Overview"></a>8.1 Overview</h3><p>本节将介绍一些关键概念，这些概念对于理解后续章节的内容至关重要。</p><h4 id="8-1-1-Buffer-Manager-Structure"><a href="#8-1-1-Buffer-Manager-Structure" class="headerlink" title="8.1.1. Buffer Manager Structure"></a>8.1.1. Buffer Manager Structure</h4><p>PostgreSQL的缓冲区管理器包含缓冲区表、缓冲区描述符和缓冲池这几个关键部分，这些将在下一节详细描述。</p><p>缓冲池层负责存储数据文件页面，比如表和索引，以及空闲空间映射和可见性映射等。</p><p>缓冲池是一个数组结构，其中每个槽位存储一个数据文件的页面。缓冲池数组的索引被称为buffer_ids。</p><p>第8.2节和8.3节将进一步详述缓冲区管理器内部结构的具体细节。</p><h4 id="8-1-2-Buffer-Tag"><a href="#8-1-2-Buffer-Tag" class="headerlink" title="8.1.2. Buffer Tag"></a>8.1.2. Buffer Tag</h4><p>在PostgreSQL中，所有数据文件的每一页都可以被分配一个唯一的标签，即缓冲区标签（buffer tag）。<br>当缓冲区管理器接收到请求时，PostgreSQL会使用目标页面的buffer_tag来进行处理。</p><p>缓冲区标签（buffer_tag）包含五个值：</p><p>specOid：包含目标页面的关系所属表空间的OID。<br>dbOid：包含目标页面的关系所属数据库的OID。<br>relFileNode：包含目标页面的关系文件的文件节点号。<br>blockNum：目标页面在关系文件中的块编号。<br>forkNum：页面所属关系的分叉编号。表、空闲空间映射和可见性映射的分叉编号分别定义为0、1和2。  </p><p>通过这样的标签体系，PostgreSQL能精确地定位和管理数据库中任意页面的信息，提高数据访问的效率和准确性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Buffer tag identifies which disk block the buffer contains.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Note: the BufferTag data must be sufficient to determine where to write the</span><br><span class="hljs-comment"> * block, without reference to pg_class or pg_tablespace entries.  It&#x27;s</span><br><span class="hljs-comment"> * possible that the backend flushing the buffer doesn&#x27;t even believe the</span><br><span class="hljs-comment"> * relation is visible yet (its xact may have started before the xact that</span><br><span class="hljs-comment"> * created the rel).  The storage manager must be able to cope anyway.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Note: if there&#x27;s any pad bytes in the struct, InitBufferTag will have</span><br><span class="hljs-comment"> * to be fixed to zero them, since this struct is used as a hash key.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buftag</span></span><br><span class="hljs-class">&#123;</span><br>OidspcOid;<span class="hljs-comment">/* tablespace oid */</span><br>OiddbOid;<span class="hljs-comment">/* database oid */</span><br>RelFileNumber relNumber;<span class="hljs-comment">/* relation file number */</span><br>ForkNumberforkNum;<span class="hljs-comment">/* fork number */</span><br>BlockNumber blockNum;<span class="hljs-comment">/* blknum relative to begin of reln */</span><br>&#125; BufferTag;<br></code></pre></td></tr></table></figure><p>例如，缓冲区标签‘{16821, 16384, 37721, 0, 7}’标识了一个特定页面，该页面位于表空间OID为16821、<br>数据库OID为16384的数据库中，具体是OID为37721的表的第一个分叉（fork number为0）的第七个块。</p><p>同样，缓冲区标签‘{16821, 16384, 37721, 1, 3}’标识了另一个页面，该页面位于表空间OID为16821、<br>数据库OID为16384的数据库中，但这次是OID为37721的表的空闲空间映射分叉（fork number为1）的第三个块。</p><h4 id="8-1-3-How-a-Backend-Process-Reads-Pages"><a href="#8-1-3-How-a-Backend-Process-Reads-Pages" class="headerlink" title="8.1.3. How a Backend Process Reads Pages"></a>8.1.3. How a Backend Process Reads Pages</h4><p>本小节将描述后台进程如何从缓冲区管理器中读取页面（参见图8.2）。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_1.png" alt="img_1.png"></p><p>(1) 当需要读取表或索引页面时，后台进程会向缓冲区管理器发送一个请求，该请求包含了页面的缓冲区标签（buffer_tag）。</p><p>(2) 缓冲区管理器根据该标签返回存储请求页面的缓冲池槽位的缓冲区ID（buffer_ID）。如果请求的页面不在缓冲池中，缓冲区管理器会将页面从持久化存储加载到缓冲池的一个槽位中，然后返回该槽位的缓冲区ID。</p><p>(3) 后台进程根据得到的缓冲区ID访问相应的槽位（以读取所需页面）。</p><p>当后台进程修改缓冲池中的页面（例如，通过插入元组）时，那些尚未刷新到存储器中的已修改页面被称为脏页。</p><p>第8.4节将更详细地描述缓冲区管理器的工作方式。</p><h4 id="8-1-4-Page-Replacement-Algorithm"><a href="#8-1-4-Page-Replacement-Algorithm" class="headerlink" title="8.1.4. Page Replacement Algorithm"></a>8.1.4. Page Replacement Algorithm</h4><p>当缓冲池的所有槽位都被占用，且请求的页面不在缓冲池中时，<br>缓冲区管理器必须选择缓冲池中的一页来替换为请求的页面。在计算机科学领域，这种页面选择算法通常被称为页面置换算法，<br>而被选中的页面称为牺牲页（victim page）。</p><p>自从计算机科学诞生以来，页面置换算法的研究一直在进行。已经提出了许多置换算法，<br>而PostgreSQL自8.1版本起开始使用时钟扫描（clock sweep）算法。相比之前版本中使用<br>的LRU（Least Recently Used）算法，时钟扫描算法更为简单且效率更高。</p><p>第8.4.4节将详细描述时钟扫描算法的具体细节。</p><h4 id="8-1-5-Flushing-Dirty-Pages"><a href="#8-1-5-Flushing-Dirty-Pages" class="headerlink" title="8.1.5. Flushing Dirty Pages"></a>8.1.5. Flushing Dirty Pages</h4><p>脏页最终需要被刷新到存储器中。然而，缓冲区管理器本身并不能独立完成这项任务。在PostgreSQL中，有两个后台进程<br>负责处理此事：检查点进程（checkpointer）和后台写入器（background writer）。</p><p>第8.6节将详细介绍检查点进程和后台写入器的工作原理。</p><blockquote><p> Direct I&#x2F;O</p><p>PostgreSQL在15及更早的版本中并不支持直接I&#x2F;O（Direct I&#x2F;O），<br>尽管这个问题已被讨论过。可以参考pgsql-ML上的这篇文章和另一篇文章。(<a href="https://www.postgresql.org/message-id/529E267F.4050700@agliodbs.com">https://www.postgresql.org/message-id/529E267F.4050700@agliodbs.com</a>)<br>(<a href="https://lwn.net/Articles/580542/)(https://www.postgresql.org/docs/16/runtime-config-developer.html#GUC-DEBUG-IO-DIRECT)">https://lwn.net/Articles/580542/)(https://www.postgresql.org/docs/16/runtime-config-developer.html#GUC-DEBUG-IO-DIRECT)</a></p><p>在版本16中，新增了一个debug-io-direct选项。这个选项是为了让开发者能够<br>改进PostgreSQL中直接I&#x2F;O的使用。如果开发进展顺利，直接I&#x2F;O有望在不久的将来得到正式的支持。</p></blockquote><h3 id="8-2-Buffer-Manager-Structure"><a href="#8-2-Buffer-Manager-Structure" class="headerlink" title="8.2 Buffer Manager Structure"></a><a name="buffer-ms"></a>8.2 Buffer Manager Structure</h3><p>PostgreSQL的缓冲区管理器包含三层结构：“缓冲池”、“缓冲描述符”和“缓冲表”（如图8.3所示）：</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_2.png" alt="img_2.png"></p><ol><li><p>缓冲池：一个用于存储数据文件页面的数组。数组中的每个位置称为缓冲区ID（buffer_ids）。</p></li><li><p>缓冲描述符：一个缓冲描述符数组。每个描述符与缓冲池中的一个槽位一对一对应，并保存该槽位中存储页面的元数据。<br>注意，“缓冲描述符层”这一术语是出于方便而采用的，并且仅在此文档中使用。</p></li><li><p>缓冲表：一个哈希表，用于存储存储页面的缓冲区标签（buffer_tags）与其各自元数据所在的缓冲描述符的缓冲区<br>ID之间的关联关系。</p></li></ol><p>以下各小节将详细描述这些层次结构。</p><h4 id="8-2-1-Buffer-Table"><a href="#8-2-1-Buffer-Table" class="headerlink" title="8.2.1. Buffer Table"></a>8.2.1. Buffer Table</h4><p>缓冲表逻辑上可以分为三部分：哈希函数、哈希桶槽位和数据项（如图8.4所示）。</p><p>内置的哈希函数将缓冲区标签（buffer_tags）映射到哈希桶槽位。尽管哈希桶槽位的数量大于缓冲池槽位的数量，<br>但仍可能发生碰撞。因此，缓冲表使用带有链表的分离链接法来解决碰撞问题。当数据项被映射到同一个桶槽时，<br>该方法将这些项存储在同一链表中，如图8.4所示。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_3.png" alt="img_3.png"></p><p>数据条目由两个值组成：页面的buffer_tag和存储该页面元数据的描述符的buffer_id。<br>例如，数据条目‘Tag_A, id&#x3D;1’表示buffer_id为‘1’的缓冲描述符存储了标记为Tag_A的页面的元数据。</p><blockquote><p>Hash Function</p><p>哈希函数是calc_bucket()和hash()这两个函数的组合功能。<br>以下是它作为一个伪函数的表示形式。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">uint32 <span class="hljs-keyword">bucket_slot </span>= calc_bucket(unsigned hash(<span class="hljs-keyword">BufferTag </span><span class="hljs-keyword">buffer_tag), </span>uint32 <span class="hljs-keyword">bucket_size)</span><br></code></pre></td></tr></table></figure></blockquote><p>注意：基本操作（如数据条目的查找、插入和删除）在这里没有解释。<br>这些是非常常见的操作，并将在后续章节中进行说明。</p><h4 id="8-2-2-Buffer-Descriptor"><a href="#8-2-2-Buffer-Descriptor" class="headerlink" title="8.2.2. Buffer Descriptor"></a>8.2.2. Buffer Descriptor</h4><p>在9.6版本中，缓冲描述符的结构得到了改进。首先，我将解释9.5及更早版本中的缓冲描述符，<br>然后说明9.6及以后版本中的缓冲描述符与之前版本的不同之处。</p><p>缓冲描述符层的详细内容将在下一个小节中描述。</p><h5 id="8-2-2-1-Versions-9-5-or-earlier"><a href="#8-2-2-1-Versions-9-5-or-earlier" class="headerlink" title="8.2.2.1. Versions 9.5 or earlier"></a>8.2.2.1. Versions 9.5 or earlier</h5><p>在9.5及更早版本中，缓冲描述符结构保存了对应缓冲池槽位中存储页面的元数据。<br>缓冲描述符结构由BufferDesc结构定义。以下是其中一些主要字段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Flags for buffer descriptors</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Note: TAG_VALID essentially means that there is a buffer hashtable</span><br><span class="hljs-comment"> * entry associated with the buffer&#x27;s tag.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_DIRTY                (1 &lt;&lt; 0)    <span class="hljs-comment">/* data needs writing */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_VALID                (1 &lt;&lt; 1)    <span class="hljs-comment">/* data is valid */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_TAG_VALID            (1 &lt;&lt; 2)    <span class="hljs-comment">/* tag is assigned */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_IO_IN_PROGRESS       (1 &lt;&lt; 3)    <span class="hljs-comment">/* read or write in progress */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_IO_ERROR             (1 &lt;&lt; 4)    <span class="hljs-comment">/* previous I/O failed */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_JUST_DIRTIED         (1 &lt;&lt; 5)    <span class="hljs-comment">/* dirtied since write started */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_PIN_COUNT_WAITER     (1 &lt;&lt; 6)    <span class="hljs-comment">/* have waiter for sole pin */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_CHECKPOINT_NEEDED    (1 &lt;&lt; 7)    <span class="hljs-comment">/* must write for checkpoint */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_PERMANENT            (1 &lt;&lt; 8)    <span class="hljs-comment">/* permanent relation (not unlogged) */</span></span><br><br>src/include/storage/buf_internals.h<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sbufdesc</span><br>&#123;<br>   BufferTag    tag;                 <span class="hljs-comment">/* ID of page contained in buffer */</span><br>   BufFlags     flags;               <span class="hljs-comment">/* see bit definitions above */</span><br>   uint16       usage_count;         <span class="hljs-comment">/* usage counter for clock sweep code */</span><br>   <span class="hljs-type">unsigned</span>     refcount;            <span class="hljs-comment">/* # of backends holding pins on buffer */</span><br>   <span class="hljs-type">int</span>          wait_backend_pid;    <span class="hljs-comment">/* backend PID of pin-count waiter */</span><br>   <span class="hljs-type">slock_t</span>      buf_hdr_lock;        <span class="hljs-comment">/* protects the above fields */</span><br>   <span class="hljs-type">int</span>          buf_id;              <span class="hljs-comment">/* buffer&#x27;s index number (from 0) */</span><br>   <span class="hljs-type">int</span>          freeNext;            <span class="hljs-comment">/* link in freelist chain */</span><br><br>   LWLockId     io_in_progress_lock; <span class="hljs-comment">/* to wait for I/O to complete */</span><br>   LWLockId     content_lock;        <span class="hljs-comment">/* to lock access to buffer contents */</span><br>&#125; BufferDesc;<br></code></pre></td></tr></table></figure><p>tag字段保存了对应缓冲池槽位中存储页面的buffer_tag。(buffer_tag在8.1.2节中定义。)</p><p>buf_id用于标识描述符，它等同于相应缓冲池槽位的buffer_id。</p><p>refcount（也称为pin计数）持有当前正在访问关联存储页面的PostgreSQL进程数量。<br>当一个PostgreSQL进程访问存储页面时，refcount必须增加1（refcount++）。<br>访问页面后，refcount必须减少1（refcount–）。当refcount为零时，表示关联的存储页面未被固定<br>（即当前没有被访问）。否则，页面被视为已被固定。</p><p>usage_count记录了自页面加载到相应缓冲池槽以来被访问的次数，它用于页面置换算法（8.4.4节）。</p><p>content_lock和io_in_progress_lock是轻量级锁，用于控制对关联存储页面的访问。这些字段在8.3.2节中有描述。</p><p>flags可以保存关联存储页面的多种状态。主要状态包括：<br>dirty位表示存储页面已被修改（脏）。<br>valid位指示存储页面是否有效，意味着它可以被读取或写入。<br>如果此位有效，则相应的缓冲池槽存储了一个页面，且描述符持有页面元数据，<br>存储页面可读可写。如果此位无效，则描述符不持有任何元数据，存储页面不能被读写。<br>io_in_progress位表示缓冲区管理器是否正在从存储中读取或写入关联页面。  </p><p>buf_hdr_lock是一个自旋锁，用于保护flags、usage_count和refcount这些字段。  </p><p>freeNext是一个指针，指向用于生成空闲列表的下一个描述符，空闲列表的概念在下一小节中会有描述。</p><h5 id="8-2-2-2-Versions-9-6-or-later"><a href="#8-2-2-2-Versions-9-6-or-later" class="headerlink" title="8.2.2.2. Versions 9.6 or later"></a>8.2.2.2. Versions 9.6 or later</h5><p>The buffer descriptor structure is defined by the BufferDesc structure.</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Flags for buffer descriptors</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">Note:</span> BM_TAG_VALID essentially means that there is a buffer hashtable</span><br><span class="hljs-comment"> * entry associated with the buffer&#x27;s tag.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#define BM_LOCKED(1U &lt;&lt; 22)/* buffer header is locked */</span><br><span class="hljs-meta">#define BM_DIRTY(1U &lt;&lt; 23)/* data needs writing */</span><br><span class="hljs-meta">#define BM_VALID(1U &lt;&lt; 24)/* data is valid */</span><br><span class="hljs-meta">#define BM_TAG_VALID(1U &lt;&lt; 25)/* tag is assigned */</span><br><span class="hljs-meta">#define BM_IO_IN_PROGRESS(1U &lt;&lt; 26)/* read or write in progress */</span><br><span class="hljs-meta">#define BM_IO_ERROR(1U &lt;&lt; 27)/* previous I/O failed */</span><br><span class="hljs-meta">#define BM_JUST_DIRTIED(1U &lt;&lt; 28)/* dirtied since write started */</span><br><span class="hljs-meta">#define BM_PIN_COUNT_WAITER(1U &lt;&lt; 29)/* have waiter for sole pin */</span><br><span class="hljs-meta">#define BM_CHECKPOINT_NEEDED(1U &lt;&lt; 30)/* must write for checkpoint */</span><br><span class="hljs-meta">#define BM_PERMANENT(1U &lt;&lt; 31)/* permanent buffer (not unlogged,</span><br> * <span class="hljs-keyword">or</span> init fork) */<br><br><span class="hljs-meta">#define PG_HAVE_ATOMIC_U32_SUPPORT</span><br>typedef struct pg_atomic_uint32<br>&#123;<br><span class="hljs-keyword">volatile</span> uint32 <span class="hljs-keyword">value</span>;<br>&#125; pg_atomic_uint32;<br><br><br>typedef struct BufferDesc<br>&#123;<br>BufferTagtag;<span class="hljs-comment">/* ID of page contained in buffer */</span><br><span class="hljs-type">int</span>buf_id;<span class="hljs-comment">/* buffer&#x27;s index number (from 0) */</span><br><br><span class="hljs-comment">/* state of the tag, containing flags, refcount and usagecount */</span><br>pg_atomic_uint32 state;<br><br><span class="hljs-type">int</span>wait_backend_pgprocno;<span class="hljs-comment">/* backend of pin-count waiter */</span><br><span class="hljs-type">int</span>freeNext;<span class="hljs-comment">/* link in freelist chain */</span><br>LWLockcontent_lock;<span class="hljs-comment">/* to lock access to buffer contents */</span><br>&#125; BufferDesc;<br></code></pre></td></tr></table></figure><ol><li>tag字段保存了相应缓冲池槽位中存储页面的buffer_tag。  </li><li>buf_id用于标识描述符。  </li><li>content_lock是一个轻量级锁，用于控制对关联存储页面的访问。  </li><li>freeNext是一个指针，指向用于构建空闲链表的下一个描述符，空闲链表有助于管理缓冲区描述符的分配与回收。  </li><li>states（这里可能原意是指结构中的某些集合状态字段，尽管直接翻译为“状态”可能不够准确）可以保存关联存储页面的<br>多个状态和变量，例如refcount（引用计数）和usage_count（使用计数）。</li></ol><p>flags、usage_count和refcount这三个字段已被合并成一个单一的32位数据（称为states），以便使用CPU原子操作。<br>因此，由于不再需要保护这些值，io_in_progress_lock和自旋锁（buf_hdr_lock）已经被移除。</p><blockquote><p>Atomic Operations</p><p>原子操作不通过软件来独占控制数据，而是利用硬件强制的独占控制以及原子性的读改写操作来高效地执行。</p></blockquote><h5 id="8-2-2-3-Descriptor-States"><a href="#8-2-2-3-Descriptor-States" class="headerlink" title="8.2.2.3. Descriptor States"></a>8.2.2.3. Descriptor States</h5><p>为了简化以下描述，我们定义了三种描述符状态如下：</p><ol><li>空闲（Empty）：当相应的缓冲池槽位没有存储页面（即refcount和usage_count都为0时），这个描述符的状态为空闲。  </li><li>固定（Pinned）：当相应的缓冲池槽位存储了一个页面，并且有任意PostgreSQL进程正在访问该页面<br>（即refcount和usage_count都大于等于1时），这个缓冲描述符的状态为固定。  </li><li>未固定（Unpinned）：当相应的缓冲池槽位存储了一个页面，但没有PostgreSQL进程正在访问该页面<br>（即usage_count大于等于1，但refcount为0时），这个缓冲描述符的状态为未固定。</li></ol><p>每个描述符都将处于上述三种状态之一。描述符的状态会根据特定条件发生变化，这些条件在下一小节中描述。</p><p>在接下来的图示中，缓冲描述符的状态通过不同颜色的方框表示：</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_4.png" alt="img_4.png"></p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_5.png" alt="img_5.png"></p><h4 id="8-2-3-Buffer-Descriptors-Layer"><a href="#8-2-3-Buffer-Descriptors-Layer" class="headerlink" title="8.2.3. Buffer Descriptors Layer"></a>8.2.3. Buffer Descriptors Layer</h4><p>一组缓冲描述符构成了一个数组，在本文档中被称为缓冲描述符层。</p><p>当PostgreSQL服务器启动时，所有缓冲描述符的状态都是’空闲’。<br>在PostgreSQL中，这些描述符构成一个被称为空闲列表（freelist）的链表（图8.5）。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_6.png" alt="img_6.png"></p><blockquote><p>Note</p><p>重要的是要注意，PostgreSQL中的空闲列表（freelist）与Oracle中的空闲列表概念完全不同。<br>PostgreSQL中的空闲列表仅仅是<strong>空缓冲描述符</strong>的简单链表。而在PostgreSQL中，用于追踪块内可用空间的<br>自由空间映射（Freespace Maps，FSM），在5.3.4节中有描述，它们起到了与Oracle中空闲列表相似的作用。</p></blockquote><p>图8.6展示了如何加载第一个页面。</p><p>(1) 从空闲列表的顶部检索一个空闲的描述符，并对其进行固定（即增加其refcount和usage_count各1）。<br>(2) 在缓冲表中插入一条新记录，该记录将第一个页面的标签映射到检索到的描述符的buffer_id。<br>(3) 从存储中将新页面加载到相应的缓冲池槽位中。<br>(4) 将新页面的元数据保存到检索到的描述符中。  </p><p>第二页及之后的页面以类似的方式加载。更多细节在8.4.2节中提供。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_7.png" alt="img_7.png"></p><p>从空闲列表中检索过的描述符始终会持有页面的元数据。换句话说，一旦被使用过，<br>非空的描述符就不会再返回到空闲列表中。然而，当发生以下情况之一时，相应的描述符会被再次添加到空闲列表中，<br>并且描述符的状态会被设置为’空闲’：</p><ol><li>表或索引被删除。  </li><li>数据库被删除。  </li><li>使用VACUUM FULL命令清理表或索引。</li></ol><p>这样，那些不再需要的页面所对应的缓冲描述符就能被有效地回收并重新利用。</p><blockquote><p>为什么空闲描述符构成了空闲列表？<br>空闲列表的创建是为了允许立即获取首个描述符，这是动态内存资源分配中的一种常见做法。<br>想要了解更多相关信息，请参考这一描述。(<a href="https://en.wikipedia.org/wiki/Free_list">https://en.wikipedia.org/wiki/Free_list</a>)</p></blockquote><p>缓冲描述符层包含一个无符号的32位整型变量，即nextVictimBuffer。这个变量用于第8.4.4节所述的页面替换算法中。</p><h4 id="8-2-4-Buffer-Pool"><a href="#8-2-4-Buffer-Pool" class="headerlink" title="8.2.4. Buffer Pool"></a>8.2.4. Buffer Pool</h4><p>缓冲池是一个简单的数组，用于存储数据文件页面，如表和索引。缓冲池数组的索引称为buffer_ids。</p><p>缓冲池槽的大小为8 KB，这与页面的大小相等。因此，每个槽位可以存储整个页面。</p><h3 id="8-3-Buffer-Manager-Locks"><a href="#8-3-Buffer-Manager-Locks" class="headerlink" title="8.3 Buffer Manager Locks"></a><a name="buffer-ml"></a>8.3 Buffer Manager Locks</h3><p>缓冲区管理器为了多种目的使用了许多锁。本节将介绍在后续章节说明中必需的锁。</p><blockquote><p>Note</p><p>请注意，本节中描述的锁是缓冲区管理器同步机制的一部分，它们与任何SQL语句或SQL选项无关。</p></blockquote><h4 id="8-3-1-Buffer-Table-Locks"><a href="#8-3-1-Buffer-Table-Locks" class="headerlink" title="8.3.1. Buffer Table Locks"></a>8.3.1. Buffer Table Locks</h4><p>BufMappingLock用于保护整个缓冲表的数据完整性。它是一种轻量级锁，<br>既可用于共享模式也可用于排他模式。当在缓冲表中搜索条目时，后端进程持有共享的BufMappingLock。<br>而在插入或删除条目时，后端进程则持有排他的锁。</p><p>为了减少缓冲表中的竞争状况，BufMappingLock被分割成多个分区（默认为128个分区）。<br>每个BufMappingLock分区负责保护相应哈希桶槽位的一部分。</p><p>图8.7展示了一个典型的例子，说明了分割BufMappingLock的效果。两个后端进程可以同时<br>以排他模式持有各自的BufMappingLock分区来插入新的数据条目。如果BufMappingLock是一个单一的系统范围锁，<br>那么这两个进程就不得不根据哪个进程先开始而等待对方完成。通过分割，提高了并发性能，减少了锁竞争导致的等待时间。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_8.png" alt="img_8.png"><br>图8.7展示了两个进程同时以排他模式获取BufMappingLock的各自分区以插入新数据条目的场景。</p><p>缓冲表还需要许多其他锁。例如，缓冲表内部在删除条目时使用了自旋锁。<br>但是，这些其他锁的描述在此文档中被省略，因为它们不是本说明所需的内容。</p><blockquote><p>Info</p><p>在PostgreSQL 9.4版本之前，默认情况下BufMappingLock被分割成了16个独立的锁。</p></blockquote><h4 id="8-3-2-Locks-for-Each-Buffer-Descriptor"><a href="#8-3-2-Locks-for-Each-Buffer-Descriptor" class="headerlink" title="8.3.2. Locks for Each Buffer Descriptor"></a>8.3.2. Locks for Each Buffer Descriptor</h4><p>在9.5或更早的版本中，每个缓冲描述符使用了两个轻量级锁，即content_lock和io_in_progress_lock，来控制<br>对相应缓冲池槽位中存储页面的访问。<br>当检查或更改其自身字段的值（即usage_count、refcount、flags）时，会使用一个自旋锁（buf_hdr_lock）。</p><p>在9.6版本中，缓冲区访问方法得到了改进。io_in_progress_lock和自旋锁（buf_hdr_lock）被移除了。<br>9.6及以后的版本不再使用这些锁，而是利用CPU原子操作来检查和更改这些值。这样做提高了并发处理能力并减少<br>了锁带来的开销。</p><h5 id="8-3-2-1-content-lock"><a href="#8-3-2-1-content-lock" class="headerlink" title="8.3.2.1. content_lock"></a>8.3.2.1. content_lock</h5><p>content_lock是一个典型的用于实施访问限制的锁，它可以用于共享模式和排他模式。</p><p>当读取页面时，后台进程会获取存储该页面的缓冲描述符的共享content_lock。</p><p>在执行以下任一操作时，会获取排他content_lock：</p><ol><li>向存储页面中插入行（即元组）或更改存储页面中元组的t_xmin&#x2F;t_xmax字段。<br>（t_xmin和t_xmax字段在第5.2节中有描述；简单来说，在删除或更新行时，相关元组的这些字段会被修改。）</li><li>物理删除存储页面上的元组或压缩页面上的空闲空间。（这是由真空处理（vacuuming）和HOT（Heap Only Tuple）<br>实现的，分别在第6章和第7章中有描述。）  </li><li>对存储页面中的元组进行冻结操作。（冻结操作在第5.10.1节和第6.3节中有说明。）</li></ol><p>官方的README文件提供了更多详细信息。(src&#x2F;backend&#x2F;storage&#x2F;buffer&#x2F;README)</p><h5 id="8-3-2-2-io-in-progress-lock-versions-9-5-or-earlier"><a href="#8-3-2-2-io-in-progress-lock-versions-9-5-or-earlier" class="headerlink" title="8.3.2.2. io_in_progress_lock (versions 9.5 or earlier)"></a>8.3.2.2. io_in_progress_lock (versions 9.5 or earlier)</h5><p>在9.5或更早的版本中，io_in_progress锁用于等待缓冲区上I&#x2F;O操作的完成。<br>当一个PostgreSQL进程从存储加载或向存储写入页面数据时，该进程在访问存储期间会获取相应描述符的<br>排他io_in_progress锁。</p><h5 id="8-3-2-3-spinlock-versions-9-5-or-earlier"><a href="#8-3-2-3-spinlock-versions-9-5-or-earlier" class="headerlink" title="8.3.2.3. spinlock (versions 9.5 or earlier)"></a>8.3.2.3. spinlock (versions 9.5 or earlier)</h5><p>当检查或更改flags或其他字段（如refcount和usage_count）时，会使用自旋锁。以下是使用自旋锁的两个具体示例：</p><p>(1) 固定一个缓冲描述符：</p><ol><li>获取缓冲描述符的自旋锁。  </li><li>将其refcount和usage_count的值各增加1。  </li><li>释放自旋锁。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">LockBufHdr(bufferdesc);    <span class="hljs-comment">/* Acquire a spinlock */</span><br>bufferdesc-&gt;refcont++;<br>bufferdesc-&gt;usage_count++;<br>UnlockBufHdr(bufferdesc); <span class="hljs-comment">/* Release the spinlock */</span><br></code></pre></td></tr></table></figure><p>(2) 将脏位设置为‘1’：</p><ol><li>获取缓冲描述符的自旋锁。  </li><li>使用按位操作将脏位设置为‘1’。  </li><li>释放自旋锁。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_DIRTY             (1 &lt;&lt; 0)    <span class="hljs-comment">/* data needs writing */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_VALID             (1 &lt;&lt; 1)    <span class="hljs-comment">/* data is valid */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_TAG_VALID         (1 &lt;&lt; 2)    <span class="hljs-comment">/* tag is assigned */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_IO_IN_PROGRESS    (1 &lt;&lt; 3)    <span class="hljs-comment">/* read or write in progress */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BM_JUST_DIRTIED      (1 &lt;&lt; 5)    <span class="hljs-comment">/* dirtied since write started */</span></span><br><br>LockBufHdr(bufferdesc);<br>bufferdesc-&gt;flags |= BM_DIRTY;<br>UnlockBufHdr(bufferdesc);<br></code></pre></td></tr></table></figure><p>更改其他标志位也是按照同样的方式进行。</p><h3 id="8-4-How-the-Buffer-Manager-Works"><a href="#8-4-How-the-Buffer-Manager-Works" class="headerlink" title="8.4 How the Buffer Manager Works"></a><a name="buffer-mw"></a>8.4 How the Buffer Manager Works</h3><p>本节描述缓冲区管理器的工作原理。当后台进程需要访问期望的页面时，它会调用ReadBufferExtended()函数。</p><p>ReadBufferExtended()函数的行为依赖于三种逻辑情况。每种情况在以下小节中进行描述。<br>此外，最终小节将介绍PostgreSQL的时钟扫描页面替换算法。</p><h4 id="8-4-1-Accessing-a-Page-Stored-in-the-Buffer-Pool"><a href="#8-4-1-Accessing-a-Page-Stored-in-the-Buffer-Pool" class="headerlink" title="8.4.1. Accessing a Page Stored in the Buffer Pool"></a>8.4.1. Accessing a Page Stored in the Buffer Pool</h4><p><strong>访问缓冲池中已存储的页面</strong></p><p>首先，描述最简单的情况，即所需页面已经存储在缓冲池中。在这种情况下，缓冲区管理器执行以下步骤：</p><p>(1) 创建所需页面的buffer_tag（在此例中，buffer_tag为’Tag_C’），并使用哈希函数计算包含所创建buffer_tag关联条目的哈希桶槽位。</p><p>(2) 以共享模式获取覆盖所得哈希桶槽位的BufMappingLock分区（此锁将在步骤(5)中释放）。</p><p>(3) 查找标签为’Tag_C’的条目，并从该条目中获取buffer_id。在此例中，buffer_id为2。</p><p>(4) 为buffer_id为2的缓冲描述符设置固定（pin），将描述符的refcount和usage_count各增加1。（第8.3.2节描述了固定操作）</p><p>(5) 释放BufMappingLock。</p><p>(6) 访问buffer_id为2的缓冲池槽位。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_9.png" alt="img_9.png"></p><p>接着，当从缓冲池槽位的页面中读取行时，PostgreSQL进程会获取相应缓冲描述符的共享content_lock。<br>因此，多个进程可以同时读取缓冲池槽位中的页面。</p><p>当向页面中插入（以及更新或删除）行时，Postgres进程会获取相应缓冲描述符的排他content_lock。<br>（需要注意的是，页面的脏位必须设置为1。）</p><p>访问页面后，相应缓冲描述符的refcount值会减1。</p><h4 id="8-4-2-Loading-a-Page-from-Storage-to-Empty-Slot"><a href="#8-4-2-Loading-a-Page-from-Storage-to-Empty-Slot" class="headerlink" title="8.4.2. Loading a Page from Storage to Empty Slot"></a>8.4.2. Loading a Page from Storage to Empty Slot</h4><p><strong>从存储加载页面到空闲槽位</strong></p><p>在第二种情况下，假设所需的页面不在缓冲池中，且空闲列表有空闲元素（即空描述符）。<br>此时，缓冲区管理器执行以下步骤：</p><p>(1) 查找缓冲表（我们假设未找到）。</p><ol><li>创建所需页面的buffer_tag（在此例中为’Tag_E’）并计算相应的哈希桶槽位。  </li><li>以共享模式获取BufMappingLock分区。  </li><li>查找缓冲表。（根据假设，未找到。）  </li><li>释放BufMappingLock。</li></ol><p>(2) 从空闲列表中获取一个空的缓冲描述符并将其固定。在此例中，获取的描述符的buffer_id为4。</p><p>(3) 以排他模式获取BufMappingLock分区。（此锁将在步骤(6)中释放。）</p><p>(4) 创建一个新的数据条目，该条目包含buffer_tag ‘Tag_E’和buffer_id 4，并将创建的条目插入到缓冲表中。</p><p>(5) 如下所示，从存储加载所需页面数据到buffer_id为4的缓冲池槽位：</p><ol><li><strong>在9.5或更早版本中</strong>，获取相应描述符的排他io_in_progress_lock。  </li><li>将相应描述符的io_in_progress位设置为1，以防止其他进程访问。  </li><li>从存储加载所需页面数据到缓冲池槽位。  </li><li>更改相应描述符的状态：将io_in_progress位设置为0，并将有效位设置为1。  </li><li><strong>在9.5或更早版本中</strong>，释放io_in_progress_lock。</li></ol><p>(6) 释放BufMappingLock。</p><p>(7) 访问buffer_id为4的缓冲池槽位。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_10.png" alt="img_10.png"></p><h4 id="8-4-3-Loading-a-Page-from-Storage-to-a-Victim-Buffer-Pool-Slot"><a href="#8-4-3-Loading-a-Page-from-Storage-to-a-Victim-Buffer-Pool-Slot" class="headerlink" title="8.4.3. Loading a Page from Storage to a Victim Buffer Pool Slot"></a>8.4.3. Loading a Page from Storage to a Victim Buffer Pool Slot</h4><p><strong>从存储加载页面到牺牲缓冲池槽位</strong></p><p>在这种情况下，假设所有缓冲池槽位都被页面占用，但所需的页面并未存储在其中。缓冲区管理器执行以下步骤：</p><p>(1) 创建所需页面的buffer_tag并查找缓冲表。在此例中，我们假设buffer_tag为’Tag_M’（未找到所需页面）。</p><p>(2) 使用时钟扫描算法选择一个牺牲缓冲池槽位。从缓冲表中获取旧条目，该条目包含牺牲槽位的buffer_id，<br>并在缓冲描述符层中固定牺牲槽位。在此例中，牺牲槽位的buffer_id为5，旧条目为’Tag_F, id&#x3D;5’。<br>时钟扫描算法在8.4.4节中描述。</p><p>(3) 如果牺牲页面脏，则刷新（写入和fsync）牺牲页面数据；否则进入步骤(4)。<br>在覆盖新数据前，脏页面必须写入存储。刷新脏页面的操作如下：</p><ol><li>获取buffer_id为5的描述符的共享content_lock和排他io_in_progress锁（在步骤6中释放）。  </li><li>更改相应描述符的状态：将io_in_progress位设置为1，将just_dirtied位设置为0。  </li><li>根据情况，调用XLogFlush()函数将WAL缓冲区中的WAL数据写入当前WAL段文件<br>（具体细节省略；WAL和XLogFlush()函数在第9章中描述）。  </li><li>将牺牲页面数据刷新到存储。  </li><li>更改相应描述符的状态：将io_in_progress位设置为0，将有效位设置为1。  </li><li>释放io_in_progress和content_lock锁。</li></ol><p>(4) 以排他模式获取包含旧条目的槽位的旧BufMappingLock分区。</p><p>(5) 获取新BufMappingLock分区并向缓冲表插入新条目：</p><ol><li>创建由新buffer_tag ‘Tag_M’和牺牲者的buffer_id组成的新条目。  </li><li>获取包含新条目的槽位的新BufMappingLock分区的排他锁。  </li><li>将新条目插入缓冲表中。</li></ol><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_11.png" alt="img_11.png"></p><p>(6) 从缓冲表中删除旧条目，并释放旧的BufMappingLock分区。</p><p>(7) 从存储加载所需页面数据到牺牲缓冲槽位。然后，更新buffer_id为5的描述符的标志位；<br>将脏位设为0，并初始化其他位。</p><p>(8) 释放新的BufMappingLock分区。</p><p>(9) 访问buffer_id为5的缓冲池槽位。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_12.png" alt="img_12.png"></p><h4 id="8-4-4-Page-Replacement-Algorithm-Clock-Sweep"><a href="#8-4-4-Page-Replacement-Algorithm-Clock-Sweep" class="headerlink" title="8.4.4. Page Replacement Algorithm: Clock Sweep"></a>8.4.4. Page Replacement Algorithm: Clock Sweep</h4><p><strong>页面替换算法：时钟扫描</strong></p><p>本节剩余部分将描述时钟扫描算法。此算法是低开销的NFU（不经常使用）算法变体，<br>能高效地选择使用频率较低的页面。</p><p>想象缓冲描述符组成一个环形列表（见图8.12）。一个无符号的32位整数nextVictimBuffer总是指向其中一个缓冲描述符，<br>并顺时针旋转。该算法的伪代码及描述如下：</p><blockquote><p>Pseudocode: clock-sweep</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs commandline">    WHILE true<br>(1)    Obtain the candidate buffer descriptor pointed by the nextVictimBuffer<br>(2)    IF the candidate descriptor is &#x27;unpinned&#x27; THEN<br>(3)       IF the candidate descriptor&#x27;s usage_count == 0 THEN<br>             BREAK WHILE LOOP  /* the corresponding slot of this descriptor */<br>                               /* is victim slot.                           */<br>          ELSE<br>             Decrease the candidate descriptpor&#x27;s usage_count by 1<br>          END IF<br>       END IF<br>(4)    Advance nextVictimBuffer to the next one<br>    END WHILE <br>(5) RETURN buffer_id of the victim<br></code></pre></td></tr></table></figure><p>(1) 获取由nextVictimBuffer指向的候选缓冲描述符。<br>(2) 如果候选缓冲描述符未被固定，进入步骤(3)。否则，进入步骤(4)。<br>(3) 如果候选描述符的usage_count为0，选择该描述符对应的槽位作为牺牲者，进入步骤(5)。<br>否则，将此描述符的usage_count减1，然后回到步骤(4)。<br>(4) 将nextVictimBuffer推进到下一个描述符（如果是最后一个，则回绕到开头），<br>然后返回步骤(1)。重复此过程，直到找到牺牲者。<br>(5) 返回牺牲者的buffer_id。  </p></blockquote><p>图8.12展示了一个具体示例。缓冲描述符以蓝色或青色方框表示，方框内的数字展示了每个描述符的usage_count。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch8/ch8/img_13.png" alt="img_13.png"></p><ol><li>nextVictimBuffer指向第一个描述符（buffer_id为1）。但是，由于该描述符被固定，所以跳过了它。  </li><li>nextVictimBuffer指向第二个描述符（buffer_id为2）。此描述符未被固定，但其usage_count为2。<br>因此，将usage_count减1，并将nextVictimBuffer推进到第三个候选描述符。  </li><li>nextVictimBuffer指向第三个描述符（buffer_id为3）。此描述符未被固定且其usage_count为0。<br>因此，在这一轮中，这就是牺牲者。</li></ol><p>每当nextVictimBuffer遍历到一个未固定的描述符时，都会将其usage_count减1。<br>因此，如果缓冲池中存在未固定的描述符，通过循环移动nextVictimBuffer，<br>此算法总能找到一个usage_count为0的牺牲者。</p><h3 id="8-5-Ring-Buffer"><a href="#8-5-Ring-Buffer" class="headerlink" title="8.5 Ring Buffer"></a><a name="Ring-Buffer"></a>8.5 Ring Buffer</h3><p><strong>环形缓冲区</strong></p><p>当读取或写入大型表时，PostgreSQL会使用环形缓冲区而非缓冲池。</p><p>环形缓冲区是一个小型且临时的缓冲区域。满足以下任一条件时，会在共享内存中分配一个环形缓冲区：</p><p>(1). 批量读取：<br>当扫描的表大小超过缓冲池大小的四分之一（ shared_buffers &#x2F; 4 ）时。这种情况下，环形缓冲区的大小为256 KB。</p><p>(2). 批量写入：<br>当执行下列SQL命令时。这种情况下，环形缓冲区的大小为16 MB。</p><ol><li>COPY FROM命令。  </li><li>CREATE TABLE AS命令。  </li><li>CREATE MATERIALIZED VIEW或REFRESH MATERIALIZED VIEW命令。  </li><li>ALTER TABLE命令。</li></ol><p>(3). Vacuum-processing:<br>当自动真空处理（autovacuum）执行真空处理时。这种情况下，环形缓冲区的大小也为256 KB。</p><p>分配的环形缓冲区在使用完毕后会立即释放。</p><p>环形缓冲区的好处显而易见。如果后端进程在不使用环形缓冲区的情况下读取大型表，<br>缓冲池中存储的所有页面都会被替换出去，从而降低了缓存命中率。环形缓冲区通过为大型表提供一个临时缓冲区域，<br>避免了这个问题。</p><blockquote><p>为什么批量读取和真空处理的默认环形缓冲区大小为256 KB呢？</p><p>为何是256 KB？答案在缓冲区管理器源代码目录下的README文件(src&#x2F;backend&#x2F;storage&#x2F;buffer&#x2F;README)中有解释。</p><p>对于顺序扫描，使用了256 KB大小的环。这个大小足够小，能够适应L2缓存，使得从操作系统缓存传输页面到<br>共享缓冲区缓存的过程变得高效。通常情况下，即使更小的容量也常常足够，但环形缓冲区必须足够大，<br>以容纳扫描过程中同时被固定的全部页面。（节选）</p></blockquote><h3 id="8-6-Flushing-Dirty-Pages"><a href="#8-6-Flushing-Dirty-Pages" class="headerlink" title="8.6 Flushing Dirty Pages"></a><a name="Flush-DP"></a>8.6 Flushing Dirty Pages</h3><p>除了替换牺牲页面外，检查点进程（checkpointer）和后台写入器进程（background writer）还会将脏页面刷新到存储中。<br>这两个进程具有相同的刷新脏页功能，但它们扮演的角色和行为有所不同。</p><p>检查点进程在每次检查点开始时，会向WAL段文件写入检查点记录并刷新脏页面。第9.7节描述了检查点及何时启动。</p><p>后台写入器的作用是减轻检查点密集写入的影响。后台写入器持续不断地、以最小化对数据库活动影响的方式一点点刷新脏页面。<br>默认情况下，后台写入器每隔200毫秒（由bgwriter_delay定义）唤醒一次，并最多刷新bgwriter_lru_maxpages个页面<br>（默认是100页）。</p><p>这样的设计旨在平衡性能和数据安全性，确保即使在高负载下也能定期将数据持久化，同时避免在检查点时刻产生太大<br>的I&#x2F;O压力，从而维持数据库运行的稳定性。</p><blockquote><p>为什么检查点进程要与后台写入器分开？</p><p>在9.1或更早的版本中，后台写入器进程定期执行检查点处理工作。</p><p>在9.2版本中，检查点进程从后台写入器进程中分离出来。原因在于一份名为“分离后台写入器和检查点进程”的提案中<br>有所描述，下面摘录了其中的部分内容(<a href="https://www.postgresql.org/message-id/CA%2BU5nMLv2ah-HNHaQ%3D2rxhp_hDJ9jcf-LL2kW3sE4msfnUw9gA%40mail.gmail.com)%EF%BC%9A">https://www.postgresql.org/message-id/CA%2BU5nMLv2ah-HNHaQ%3D2rxhp_hDJ9jcf-LL2kW3sE4msfnUw9gA%40mail.gmail.com)：</a></p><p>目前（2011年），后台写入器进程同时执行后台写入、检查点处理以及其他一些职责。<br>这意味着我们无法在不停止后台写入的情况下执行最后检查点的fsync操作，因此在一个进程中同时做这两件事会<br>对性能产生负面影响。<br>此外，我们在9.2版本的目标是用闩锁（latches）代替轮询循环以降低功耗。后台写入器循环的复杂性较高，<br>而且似乎不太可能提出一个使用闩锁的干净解决方案。<br>（节选）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL指南：内幕探索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch7. HOT and Index-Only Scans</title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch7/ch7/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch7/ch7/</url>
    
    <content type="html"><![CDATA[<h2 id="ch7-HOT-and-Index-Only-Scans"><a href="#ch7-HOT-and-Index-Only-Scans" class="headerlink" title="ch7. HOT and Index-Only Scans"></a>ch7. HOT and Index-Only Scans</h2><p>这一章讨论了两个与索引扫描相关的特性:堆元组扫描和仅索引扫描。</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#HOT">7.1 Heap Only Tuple (HOT)</a></td></tr><tr><td><a href="#IOS">7.2 Index-Only Scans</a></td></tr></tbody></table><h3 id="7-1-Heap-Only-Tuple-HOT"><a href="#7-1-Heap-Only-Tuple-HOT" class="headerlink" title="7.1 Heap Only Tuple (HOT)"></a><a name="HOT"></a>7.1 Heap Only Tuple (HOT)</h3><p>HOT 是在 8.3 版本中实现的,当更新的行存储在与旧行相同的表页面中时,<br>HOT 可以有效地利用索引和表的页面。HOT 还减少了 VACUUM 处理的需求。</p><p>由于 HOT 的详细信息在源代码目录的 README.HOT 文件中有描述,本章只对 HOT 做了简要介绍。</p><p>7.1.1 节首先描述了不使用 HOT 更新行的方式,以阐明 HOT 解决的问题。</p><p>7.1.2 节描述了 HOT 是如何工作的。</p><h4 id="7-1-1-Update-a-Row-Without-HOT"><a href="#7-1-1-Update-a-Row-Without-HOT" class="headerlink" title="7.1.1. Update a Row Without HOT"></a>7.1.1. Update a Row Without HOT</h4><p>假设表 ‘tbl’ 有两列: ‘id’ 和 ‘data’；’id’ 是 ‘tbl’ 的主键。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># \d tbl<br>                <span class="hljs-keyword">Table</span> &quot;public.tbl&quot;<br> <span class="hljs-keyword">Column</span> <span class="hljs-operator">|</span>  Type   <span class="hljs-operator">|</span> <span class="hljs-keyword">Collation</span> <span class="hljs-operator">|</span> Nullable <span class="hljs-operator">|</span> <span class="hljs-keyword">Default</span> <br><span class="hljs-comment">--------+---------+-----------+----------+---------</span><br> id     <span class="hljs-operator">|</span> <span class="hljs-type">integer</span> <span class="hljs-operator">|</span>           <span class="hljs-operator">|</span> <span class="hljs-keyword">not null</span> <span class="hljs-operator">|</span> <br> data   <span class="hljs-operator">|</span> text    <span class="hljs-operator">|</span>           <span class="hljs-operator">|</span>          <span class="hljs-operator">|</span> <br>Indexes:<br>    &quot;tbl_pkey&quot; <span class="hljs-keyword">PRIMARY KEY</span>, btree (id)<br></code></pre></td></tr></table></figure><p>表 ‘tbl’ 有 1000 个元组；其中 id 为 1000 的最后一个元组存储在表的第 5 页中。<br>这个最后一个元组被对应索引元组指向，<br>该索引元组的键值是 1000，tid 是 ‘(5, 1)’。如图 7.1(a) 所示。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch7/ch7/img.png" alt="img.png"></p><p>让我们考虑在不使用 HOT 的情况下更新最后一个元组。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">UPDATE</span> tbl <span class="hljs-keyword">SET</span> data <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;B&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><p>在这种情况下, PostgreSQL 不仅会插入新的表元组,还会将新的索引元组插入到索引页中。<br>如图 7.1(b) 所示。</p><p>插入索引元组会消耗索引页的空间,而且插入和清理索引元组的成本都很高。HOT 可以减轻这些问题的影响。</p><h4 id="7-1-2-How-HOT-Performs"><a href="#7-1-2-How-HOT-Performs" class="headerlink" title="7.1.2. How HOT Performs"></a>7.1.2. How HOT Performs</h4><p>当使用 HOT 更新一行时,如果更新后的行将存储在与老行相同的表页面中,PostgreSQL 不会插入相应的<br>索引元组,而是会分别将 HEAP_HOT_UPDATED 位和 HEAP_ONLY_TUPLE 位设置到老元组和新元组<br>的 t_infomask2 字段中。如图 7.2 和 7.3 所示。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch7/ch7/img_1.png" alt="img_1.png"></p><p>例如,在这种情况下,Tuple_1 和 Tuple_2 分别被设置了 HEAP_HOT_UPDATED 位和 HEAP_ONLY_TUPLE 位。</p><p>另外,无论是修剪还是碎片整理过程(下文描述)是否执行,HEAP_HOT_UPDATED 和 HEAP_ONLY_TUPLE 位都会被使用。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch7/ch7/img_2.png" alt="img_2.png"></p><p>接下来,将描述 PostgreSQL 在使用 HOT 更新元组后,如何通过索引扫描访问更新后的元组。请参见图 7.4(a)。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch7/ch7/img_3.png" alt="img_3.png"></p><p>(1) 找到指向目标元组的索引元组。<br>(2) 访问索引元组指向的行指针[1]。<br>(3) 读取 Tuple_1。<br>(4) 通过 Tuple_1 的 t_ctid 访问 Tuple_2。  </p><p>在这种情况下,PostgreSQL 读取了两个元组 Tuple_1 和 Tuple_2,并使用第 5 章描述的<br>并发控制机制来决定哪个是可见的。</p><p>但是,如果删除了表页面中的死元组,就会出现一个问题。例如,在图 7.4(a)中,如果<br>Tuple_1 被删除,因为它是一个死元组,那么 Tuple_2 就无法从索引中访问。</p><p>为了解决这个问题,在适当的时候,PostgreSQL 会将指向旧元组的行指针重定向到指向新元组的行指针。<br>在 PostgreSQL 中,这个处理过程称为修剪(pruning)。图 7.4(b)描述了修剪后如何访问更新后的元组。</p><p>(1) 找到索引元组。<br>(2) 访问索引元组指向的行指针[1]。<br>(3) 通过重定向的行指针访问指向 Tuple_2 的行指针[2]。<br>(4) 读取行指针[2]指向的 Tuple_2。  </p><p>当执行 SELECT、UPDATE、INSERT 和 DELETE 等 SQL 命令时,如果可能,就会执行修剪处理。<br>具体的执行时机在本章中没有描述,因为它非常复杂。详细信息在 README.HOT 文件中有说明。</p><p>PostgreSQL 会在适当的时候尽可能地删除死元组,就像修剪过程一样。在 PostgreSQL 的文档中,<br>这个处理过程称为碎片整理(defragmentation)。图 7.5 描述了 HOT 的碎片整理过程。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch7/ch7/img_4.png" alt="img_4.png"></p><p>需要注意的是,碎片整理的成本低于普通 VACUUM 处理的成本,因为碎片整理不涉及删除索引元组。</p><p>因此,使用 HOT 可以减少索引和表的页面消耗;这也减少了 VACUUM 处理需要处理的元组数量。因此,<br>HOT 对性能有积极影响,因为它最终减少了更新时插入索引元组的数量,以及 VACUUM 处理的必要性。</p><p><strong>无法使用 HOT 的情况</strong><br>为了更清楚地理解 HOT 的工作原理,我将描述无法使用 HOT 的情况。</p><p>当更新后的元组存储在与存储旧元组的页面不同的页面中时,<br>指向该元组的索引元组也必须插入到索引页面中。如图 7.6(a)所示。</p><p>当索引元组的键值发生更新时,必须在索引页面中插入一个新的索引元组。如图 7.6(b)所示。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch7/ch7/img_5.png" alt="img_5.png"></p><h3 id="7-2-Index-Only-Scans"><a href="#7-2-Index-Only-Scans" class="headerlink" title="7.2 Index-Only Scans"></a><a name="IOS"></a>7.2 Index-Only Scans</h3><p>为了减少 I&#x2F;O (输入&#x2F;输出) 成本,当 SELECT 语句的所有目标条目都包含在索引键中时,<br>索引扫描(通常称为索引仅访问)可以直接使用索引键而不访问相应的表页面。<br>这种技术几乎所有的商业数据库管理系统(RDBMS)都提供,如 DB2 和 Oracle。<br>PostgreSQL 从 9.2 版本开始引入了这个选项。</p><p>下面,将通过一个具体的例子描述 PostgreSQL 中索引仅扫描的工作方式。</p><p>该示例的假设条件解释如下:</p><ol><li>表定义<br>我们有一个名为 tbl 的表,其定义如下:</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># \d tbl<br>      <span class="hljs-keyword">Table</span> &quot;public.tbl&quot;<br> <span class="hljs-keyword">Column</span> <span class="hljs-operator">|</span>  Type   <span class="hljs-operator">|</span> Modifiers <br><span class="hljs-comment">--------+---------+-----------</span><br> id     <span class="hljs-operator">|</span> <span class="hljs-type">integer</span> <span class="hljs-operator">|</span> <br> name   <span class="hljs-operator">|</span> text    <span class="hljs-operator">|</span> <br> data   <span class="hljs-operator">|</span> text    <span class="hljs-operator">|</span> <br>Indexes:<br>    &quot;tbl_idx&quot; btree (id, name)<br></code></pre></td></tr></table></figure><ol start="2"><li><p>索引<br>表 tbl 有一个索引 tbl_idx，由 id 和 name 两列组成。</p></li><li><p>元组<br>表 tbl 已经插入了两个元组：<br>Tuple_18, 其 id 为 18，name 为 ‘Queen’，存储在 0th 页。<br>Tuple_19, 其 id 为 19，name 为 ‘BOSTON’，存储在 1st 页。  </p></li><li><p>可见性<br>0th 页中的所有元组都是可见的;1st 页中的元组不一定都是可见的。<br>每个页的可见性存储在相应的可见性映射(VM)中,VM 在第 6.2 节有描述。</p></li></ol><p>让我们探讨当执行以下 SELECT 命令时,PostgreSQL 如何读取元组。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> id, name <span class="hljs-keyword">FROM</span> tbl <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">18</span> <span class="hljs-keyword">and</span> <span class="hljs-number">19</span>;<br> id <span class="hljs-operator">|</span>  name   <br><span class="hljs-comment">----+--------</span><br> <span class="hljs-number">18</span> <span class="hljs-operator">|</span> Queen<br> <span class="hljs-number">19</span> <span class="hljs-operator">|</span> Boston<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>这个查询从表的’id’和’name’两个列以及’tbl_idx’索引中获取数据。<br>乍一看,使用索引扫描似乎不需要访问表页面,因为索引元组包含了所需的数据。</p><p>但实际上,PostgreSQL 原则上必须检查元组的可见性。索引元组没有任何关于事务的信息,<br>如堆元组中描述的 t_xmin 和 t_xmax,这在第 5.2 节中有介绍。</p><p>因此,PostgreSQL 必须访问表数据来检查索引元组中数据的可见性。这就像把车把放在马前面。</p><p>为了避免这个困境,PostgreSQL 使用目标表的可见性映射(visibility map)。如果存储在某个页面中<br>的所有元组都是可见的,PostgreSQL 就使用索引元组的键,而不访问从索引元组指向的表页面来检查其可见性。<br>否则,PostgreSQL 读取从索引元组指向的表元组,并检查该元组的可见性,这是普通的过程。</p><p>在这个例子中,不需要访问 Tuple_18,因为存储 Tuple_18 的 0th 页是可见的,也就是说 0th 页中的<br>所有元组都是可见的。相反,需要访问 Tuple_19,因为 1st 页的可见性不可见,需要处理并发控制。<br>参见图 7.7。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch7/ch7/img_6.png" alt="img_6.png"></p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL指南：内幕探索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch6. VACUUM Processing</title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch6/ch6/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch6/ch6/</url>
    
    <content type="html"><![CDATA[<h2 id="ch6-VACUUM-Processing"><a href="#ch6-VACUUM-Processing" class="headerlink" title="ch6. VACUUM Processing"></a>ch6. VACUUM Processing</h2><p>VACUUM处理是一个维护进程,可以确保PostgreSQL持续稳定运行。它主要有两个任务:<br>删除死元组和冻结事务ID,这两点在第5.10节中简要提到过。</p><p>为了删除死元组,VACUUM处理提供了两种模式:并发VACUUM和完全VACUUM。<br>并发VACUUM(通常直接称为VACUUM)会逐页删除表文件中的死元组,其他事务在此过程中仍然可以读取该表。<br>而完全VACUUM则会删除整个文件中的死元组并对活元组进行碎片整理,在此过程中其他事务无法访问该表。</p><p>尽管VACUUM处理对PostgreSQL至关重要,但相比其他功能其改进进度一直较慢。<br>例如在8.0版本之前,这一进程必须手动执行(使用psql工具或cron守护进程)。直到2005年才实现了自动化,<br>引入了autovacuum守护进程。</p><p>由于VACUUM处理需要扫描整个表,因此是一个耗费资源的过程。<br>在8.4版本(2009年)中引入了可见性映射(Visibility Map,VM)来提高删除死元组的效率。<br>在9.6版本(2016年)中,冻结进程通过增强VM得到了进一步改进。</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#outline-vacuum">6.1 Outline of Concurrent VACUUM</a></td></tr><tr><td><a href="#vmap">6.2 Visibility Map</a></td></tr><tr><td><a href="#freeze-process">6.3 Freeze Processing</a></td></tr><tr><td><a href="#remove-clog">6.4 Removing unnecessary clog files</a></td></tr><tr><td><a href="#autovacuum">6.5 Autovacuum Daemon</a></td></tr><tr><td><a href="#full-vacuum">6.6 Full VACUUM</a></td></tr></tbody></table><h3 id="6-1-Outline-of-Concurrent-VACUUM"><a href="#6-1-Outline-of-Concurrent-VACUUM" class="headerlink" title="6.1 Outline of Concurrent VACUUM"></a><a name="outline-vacuum"></a>6.1 Outline of Concurrent VACUUM</h3><p>VACUUM处理会对指定的表或整个数据库中的所有表执行以下任务:</p><p>1、删除死元组<br>删除每个页面中的死元组并对活元组进行碎片整理。<br>删除指向死元组的索引元组。<br>冻结旧的事务ID</p><p>2、必要时冻结元组的旧事务ID。<br>更新与冻结事务ID相关的系统目录(pg_database和pg_class)。<br>如果可能,删除日志文件(clog)的不必要部分。<br>其他</p><p>3、更新已处理表的空间管理(FSM)和可见性映射(VM)。<br>更新若干统计信息(pg_stat_all_tables等)。<br>假定读者熟悉以下术语:死元组、冻结事务ID、FSM和日志文件(clog);如果不熟悉,请参考第5章。<br>VM在第6.2节中介绍。</p><p>以下是VACUUM处理的伪代码:  </p><blockquote><p> Code Pseudocode: Concurrent VACUUM</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql">(<span class="hljs-number">1</span>)    <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">table</span><br>(<span class="hljs-number">2</span>)      Acquire a ShareUpdateExclusiveLock lock <span class="hljs-keyword">for</span> the target <span class="hljs-keyword">table</span><br><br>         <span class="hljs-comment">/* The first block */</span><br>(<span class="hljs-number">3</span>)      Scan <span class="hljs-keyword">all</span> pages <span class="hljs-keyword">to</span> <span class="hljs-keyword">get</span> <span class="hljs-keyword">all</span> dead tuples, <span class="hljs-keyword">and</span> freeze <span class="hljs-keyword">old</span> tuples if necessary<br>(<span class="hljs-number">4</span>)      Remove the index tuples that point <span class="hljs-keyword">to</span> the respective dead tuples if <span class="hljs-keyword">exists</span><br><br>         <span class="hljs-comment">/* The second block */</span><br>(<span class="hljs-number">5</span>)      <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">each</span> page <span class="hljs-keyword">of</span> the <span class="hljs-keyword">table</span><br>(<span class="hljs-number">6</span>)         Remove the dead tuples, <span class="hljs-keyword">and</span> Reallocate the live tuples <span class="hljs-keyword">in</span> the page<br>(<span class="hljs-number">7</span>)         <span class="hljs-keyword">Update</span> FSM <span class="hljs-keyword">and</span> VM<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">FOR</span><br><br>         <span class="hljs-comment">/* The third block */</span><br>(<span class="hljs-number">8</span>)      Clean up indexes<br>(<span class="hljs-number">9</span>)      <span class="hljs-keyword">Truncate</span> the <span class="hljs-keyword">last</span> page if possible<br>(<span class="hljs-number">10</span>)     <span class="hljs-keyword">Update</span> <span class="hljs-keyword">both</span> the statistics <span class="hljs-keyword">and</span> <span class="hljs-keyword">system</span> catalogs <span class="hljs-keyword">of</span> the target <span class="hljs-keyword">table</span><br><span class="hljs-keyword">Release</span> the ShareUpdateExclusiveLock lock<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">FOR</span><br><br>      <span class="hljs-comment">/* Post-processing */</span><br>(<span class="hljs-number">11</span>)  <span class="hljs-keyword">Update</span> statistics <span class="hljs-keyword">and</span> <span class="hljs-keyword">system</span> catalogs<br>(<span class="hljs-number">12</span>)  Remove <span class="hljs-keyword">both</span> unnecessary files <span class="hljs-keyword">and</span> pages <span class="hljs-keyword">of</span> the clog if possible<br></code></pre></td></tr></table></figure><p>(1) 从指定的表中获取每个表。<br>(2) 为目标表获取一个ShareUpdateExclusiveLock锁。这个锁允许其他事务进行读取操作。<br>(3) 扫描所有页面以获取所有死元组,并在必要时冻结旧的事务 ID。<br>(4) 删除指向相应死元组的索引元组(如果存在)。<br>(5) 对表的每个页面执行以下任务,第(6)和(7)步。<br>(6) 删除死元组,并重新分配页面中的活元组。<br>(7) 更新目标表的相应 FSM 和 VM。<br>(8) 通过 index_vacuum_cleanup()@indexam.c 函数清理索引。<br>(9) 如果最后一个页面没有任何元组,则截断该页面。<br>(10) 更新与目标表的vacuum处理相关的统计信息和系统目录。<br>(11) 更新与vacuum处理相关的统计信息和系统目录。<br>(12) 如果可能,删除日志文件(clog)中不必要的文件和页面。  </p></blockquote><p>这个伪代码有两个部分：一个是针对每个表的循环,另一个是后处理。内部循环可以分为三个块。<br>每个块都有各自的任务。</p><p>这三个块和后处理过程概括如下:</p><blockquote><p>PARALLEL option</p><p>自 PostgreSQL 13 版本开始,VACUUM 命令支持 PARALLEL 选项。如果设置了此选项,<br>并且创建了多个索引,则 vacuuming 索引和清理索引的阶段会并行处理。</p><p>需要注意的是,这个功能只适用于 VACUUM 命令,autovacuum 不支持此功能。</p></blockquote><h4 id="6-1-1-First-Block"><a href="#6-1-1-First-Block" class="headerlink" title="6.1.1. First Block"></a>6.1.1. First Block</h4><p>这个块执行冻结处理,并删除指向死元组的索引元组。</p><p>首先,PostgreSQL 扫描目标表以构建死元组的列表,并尽可能冻结老元组。<br>该列表存储在名为 maintenance_work_mem 的本地内存中。冻结处理在第 6.3 节中有描述。</p><p>扫描完成后,PostgreSQL 通过参考死元组列表来删除索引元组。这个过程在内部称为”清理阶段”。<br>这是一个代价高昂的过程,所以 PostgreSQL 在 11 版本中进行了改进。</p><p>在 10 版本或更早的版本中,清理阶段总是执行。在 11 版本或更新的版本中,如果目标索引是 B 树,<br>是否执行清理阶段由配置参数 vacuum_cleanup_index_scale_factor 决定。</p><p>请参阅该参数的详细描述。</p><p>如果 maintenance_work_mem 已满且扫描未完成,PostgreSQL 将进入下一个任务,<br>即步骤(4)到(7)。然后,它会回到步骤(3),继续剩余的扫描。</p><h4 id="6-1-2-Second-Block"><a href="#6-1-2-Second-Block" class="headerlink" title="6.1.2. Second Block"></a>6.1.2. Second Block</h4><p>这个块按逐页的方式删除死元组,并更新 FSM 和 VM。图 6.1 展示了一个示例:</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch6/ch6/img.png" alt="img.png"></p><p>假设这个表包含三个页面。我们关注第 0 页(即第一页)。这个页面有三个元组。<br>Tuple_2 是一个死元组(图 6.1(1))。在这种情况下,PostgreSQL<br>删除 Tuple 2 并重新排序剩余的元组以修复碎片。然后,它更新这个页面的 FSM 和 VM(图 6.1(2))。<br>PostgreSQL 继续这个过程,直到最后一页。</p><p>请注意,不必要的行指针不会被删除。它们将在将来被重复使用。这是因为,如果删除了行指针,<br>所有相关索引的索引元组都必须更新。</p><h4 id="6-1-3-Third-Block"><a href="#6-1-3-Third-Block" class="headerlink" title="6.1.3. Third Block"></a>6.1.3. Third Block</h4><p>第三个块执行索引删除后的清理操作,并更新与 vacuum 处理相关的统计信息和系统目录,针对每个目标表。</p><p>此外,如果最后一页没有元组,它将从表文件中截断。</p><h4 id="6-1-4-Post-processing"><a href="#6-1-4-Post-processing" class="headerlink" title="6.1.4. Post-processing"></a>6.1.4. Post-processing</h4><p>当 vacuum 处理完成后,PostgreSQL 会更新所有与 vacuum 处理相关的统计信息和系统目录。<br>如果可能的话,它还会删除 clog 中不必要的部分(第 6.4 节)。</p><blockquote><p>Ring Buffer</p><p>Vacuum 处理使用了一个环形缓冲区,这在第 8.5 节有描述。<br>因此,已经处理的页面不会被缓存在共享缓冲区中。</p></blockquote><h3 id="6-2-Visibility-Map"><a href="#6-2-Visibility-Map" class="headerlink" title="6.2 Visibility Map"></a><a name="vmap"></a>6.2 Visibility Map</h3><p>Vacuum 处理是一个代价高昂的操作。因此,在 8.4 版本中引入了 VM(可见性映射)来降低这种成本。</p><p>VM 的基本概念很简单。每个表都有一个独立的可见性映射,用于保存表文件中每个页面的可见性状态。<br>页面的可见性决定了该页面是否包含死元组。Vacuum 处理可以通过使用相应的可见性映射(VM)<br>跳过没有死元组的页面。</p><p>图 6.2 展示了 VM 的使用方式。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch6/ch6/img_1.png" alt="img_1.png"></p><p>假设这个表由三个页面组成,其中第 0 页和第 2 页包含死元组,而第 1 页不包含。这个表<br>的 VM 保存了哪些页面包含死元组的信息。在这种情况下, Vacuum 处理可以通过查看 VM 的信息,<br>跳过第 1 页。</p><p>每个 VM 由一个或多个 8 KB 的页面组成,并以 ‘vm’ 后缀存储在文件系统中。<br>例如,一个 relfilenode 为 18751 的表文件,其对应的 FSM (18751_fsm) 和 VM (18751_vm) 文件<br>如下所示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$PGDATA</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -la base/16384/18751*</span><br>-rw------- 1 postgres postgres  8192 Apr 21 10:21 base/16384/18751<br>-rw------- 1 postgres postgres 24576 Apr 21 10:18 base/16384/18751_fsm<br>-rw------- 1 postgres postgres  8192 Apr 21 10:18 base/16384/18751_vm<br></code></pre></td></tr></table></figure><h4 id="6-2-1-Enhancement-of-VM"><a href="#6-2-1-Enhancement-of-VM" class="headerlink" title="6.2.1. Enhancement of VM"></a>6.2.1. Enhancement of VM</h4><p>在 9.6 版本中,VM 进行了增强,以提高冻结处理的效率。<br>新的 VM 不仅显示页面的可见性,还包含每个页面中元组是否冻结的信息(第 6.3.3 节)。</p><h3 id="6-3-Freeze-Processing"><a href="#6-3-Freeze-Processing" class="headerlink" title="6.3 Freeze Processing"></a><a name="freeze-process"></a>6.3 Freeze Processing</h3><p>冻结处理有两种模式。为了方便区分,它们被称为lazy mode和eager mode。<br>根据特定条件，它可以以任一模式执行。</p><blockquote><p>Note</p><p>并发 VACUUM 在内部通常被称为”懒惰 vacuum”。<br>但是,本文中定义的懒惰模式是冻结处理的一种模式。</p></blockquote><p>冻结处理通常以惰性模式运行，但当满足特定条件时就会运行急切模式。</p><p>在懒惰模式下,冻结处理只扫描包含死元组的页面,使用目标表的相应 VM。</p><p>相反,在积极模式下,它会扫描所有页面,而不管每个页面是否包含死元组。<br>它还会更新与冻结处理相关的系统目录,并在可能的情况下删除 clog 中不必要的部分。</p><p>第 6.3.1 节和第 6.3.2 节分别描述了这两种模式。<br>第 6.3.3 节描述了如何在积极模式下改进冻结过程。</p><h4 id="6-3-1-Lazy-Mode"><a href="#6-3-1-Lazy-Mode" class="headerlink" title="6.3.1. Lazy Mode"></a>6.3.1. Lazy Mode</h4><p>在开始冻结处理时,PostgreSQL 会计算 [Math Processing Error]，并冻结 t_xmin 小于<br>freezeLimit_txid 的元组。</p><p>freezeLimit_txid 的定义如下:</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch6/ch6/img_2.png" alt="img_2.png"></p><p>其中 OldestXmin 是当前正在运行的事务中最老的 txid。</p><p>例如,当执行 VACUUM 命令时,有三个事务(txid 为 100、101 和 102)正在运行,<br>那么 OldestXmin 就是 100。如果没有其他事务存在,OldestXmin 就是执行这个 VACUUM 命令的 txid。<br>这里,vacuum_freeze_min_age 是一个配置参数,默认值为 50,000,000。</p><p>图 6.3 展示了一个具体的例子。Table_1 由三个页面组成,每个页面有三个元组。<br>当执行 VACUUM 命令时,当前的 txid 是 50,002,500,且没有其他事务。在这种情况下,<br>OldestXmin 是 50,002,500,因此 freezeLimit_txid 为 2500。冻结处理执行如下:</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch6/ch6/img_3.png" alt="img_3.png"></p><p>在完成 Vacuum 过程之前,与 Vacuum 相关的统计信息会被更新,<br>例如 pg_stat_all_tables 中的 n_live_tup、n_dead_tup、last_vacuum、vacuum_count 等。</p><p>如上面的例子所示,懒惰模式可能无法完全冻结元组,因为它可以跳过某些页面。</p><h4 id="6-3-2-Eager-Mode"><a href="#6-3-2-Eager-Mode" class="headerlink" title="6.3.2. Eager Mode"></a>6.3.2. Eager Mode</h4><p>积极模式弥补了懒惰模式的缺陷。它会扫描所有页面来检查表中的所有元组,<br>更新相关的系统目录,并在可能的情况下删除 clog 中不必要的文件和页面。</p><p>当满足以下条件时,会执行积极模式:</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch6/ch6/img_4.png" alt="img_4.png"></p><p>在上述条件中, [Math Processing Error] 代表 pg_database 系统目录的列,<br>保存了每个数据库最旧的冻结 txid。详细信息将在稍后描述;因此,我们假设所有<br>pg_database.datfrozenxid 的值都是 1821(这是在 9.5 版本中新安装的数据库集群的初始值)。<br>vacuum_freeze_table_age 是一个配置参数,默认值为 150,000,000。</p><p>图 6.4 显示了一个具体的例子。在 Table_1 中,Tuple_1 和 Tuple_7 已被删除。<br>Tuple_10 和 Tuple_11 已插入到第 2 页。当执行 VACUUM 命令时,当前的 txid 是 150,002,000,<br>没有其他事务。因此,OldestXmin 是 150,002,000,freezeLimit_txid 是 100,002,000。<br>在这种情况下,上述条件得到满足,因为 [Math Processing Error]。因此,冻结处理以积极模式执行,<br>如下所示。</p><p><strong>(请注意,这是 9.5 或更早版本的行为;最新的行为描述在第 6.3.3 节中。)</strong></p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch6/ch6/img_5.png" alt="img_5.png"></p><p>在冻结每个表之后,目标表的 pg_class.relfrozenxid 会被更新。pg_class 是一个系统目录,<br>每个 pg_class.relfrozenxid 列都保存了相应表的最新冻结 xid。在这个例子中,<br>Table_1 的 pg_class.relfrozenxid 被更新为当前的 freezeLimit_txid(即 100,002,000),<br>这意味着 Table_1 中 t_xmin 小于 100,002,000 的所有元组都被冻结了。</p><p>在完成vacuum过程之前,如果必要的话会更新 pg_database.datfrozenxid。<br>每个 pg_database.datfrozenxid 列都保存了对应数据库中最小的 pg_class.relfrozenxid。<br>例如,如果只有 Table_1 在eager模式下被冻结,则该数据库的 pg_database.datfrozenxid 不会被更新,<br>因为其他关系(包括其他表和当前数据库可见的系统目录)的 pg_class.relfrozenxid 都没有变化<br>(图 6.5(1))。如果当前数据库中的所有关系都在eager模式下被冻结,那么该数据库的<br>pg_database.datfrozenxid 会被更新,因为该数据库所有关系的 pg_class.relfrozenxid<br>都被更新为当前的 freezeLimit_txid (图 6.5(2))。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch6/ch6/img_6.png" alt="img_6.png"></p><blockquote><p>How to show pg_class.relfrozenxid and pg_database.datfrozenxid.</p><p>下面的第一个查询显示了 ‘testdb’ 数据库中所有可见关系的 relfrozenxid,<br>第二个查询显示了 ‘testdb’ 数据库的 pg_database.datfrozenxld。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># VACUUM table_1;<br>VACUUM<br>testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> n.nspname <span class="hljs-keyword">as</span> &quot;Schema&quot;, c.relname <span class="hljs-keyword">as</span> &quot;Name&quot;, c.relfrozenxid<br><span class="hljs-keyword">FROM</span> pg_catalog.pg_class c<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> pg_catalog.pg_namespace n <span class="hljs-keyword">ON</span> n.oid <span class="hljs-operator">=</span> c.relnamespace<br><span class="hljs-keyword">WHERE</span> c.relkind <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-keyword">AND</span> n.nspname <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;information_schema&#x27;</span> <span class="hljs-keyword">AND</span> n.nspname <span class="hljs-operator">!</span><span class="hljs-operator">~</span> <span class="hljs-string">&#x27;^pg_toast&#x27;</span><br><span class="hljs-keyword">AND</span> pg_catalog.pg_table_is_visible(c.oid)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> c.relfrozenxid::text::<span class="hljs-type">bigint</span> <span class="hljs-keyword">DESC</span>;<br>Schema   <span class="hljs-operator">|</span>            Name         <span class="hljs-operator">|</span> relfrozenxid<br><span class="hljs-comment">------------+-------------------------+--------------</span><br>public     <span class="hljs-operator">|</span> table_1                 <span class="hljs-operator">|</span>    <span class="hljs-number">100002000</span><br>public     <span class="hljs-operator">|</span> table_2                 <span class="hljs-operator">|</span>         <span class="hljs-number">1846</span><br>pg_catalog <span class="hljs-operator">|</span> pg_database             <span class="hljs-operator">|</span>         <span class="hljs-number">1827</span><br>pg_catalog <span class="hljs-operator">|</span> pg_user_mapping         <span class="hljs-operator">|</span>         <span class="hljs-number">1821</span><br>pg_catalog <span class="hljs-operator">|</span> pg_largeobject          <span class="hljs-operator">|</span>         <span class="hljs-number">1821</span><br><br>...<br><br>pg_catalog <span class="hljs-operator">|</span> pg_transform            <span class="hljs-operator">|</span>         <span class="hljs-number">1821</span><br>(<span class="hljs-number">57</span> <span class="hljs-keyword">rows</span>)<br><br>testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> datname, datfrozenxid <span class="hljs-keyword">FROM</span> pg_database <span class="hljs-keyword">WHERE</span> datname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;testdb&#x27;</span>;<br>datname <span class="hljs-operator">|</span> datfrozenxid<br><span class="hljs-comment">---------+--------------</span><br>testdb  <span class="hljs-operator">|</span>         <span class="hljs-number">1821</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>FREEZE option</p><p>带有 FREEZE 选项的 VACUUM 命令会强制冻结指定表中的所有 txid。<br>这是在积极模式下执行的,但是 freezeLimit 被设置为 OldestXmin<br>(而不是 ‘OldestXmin - vacuum_freeze_min_age’)。例如,<br>当 VACUUM FULL 命令由 txid 5000 执行且没有其他正在运行的事务时,OldestXmin<br>被设置为 5000,小于 5000 的 txid 都会被冻结。</p></blockquote><h4 id="6-3-3-Improving-Freeze-Processing-in-Eager-Mode"><a href="#6-3-3-Improving-Freeze-Processing-in-Eager-Mode" class="headerlink" title="6.3.3. Improving Freeze Processing in Eager Mode"></a>6.3.3. Improving Freeze Processing in Eager Mode</h4><p>在9.5或更早版本中的eager模式并不高效,因为它总是扫描所有页面。<br>比如在6.3.2节的例子中,即使0号页面中的所有元组都已经被冻结,也还是会被扫描。</p><p>为了解决这个问题,在9.6版本中对VM和冻结过程进行了改进。<br>如6.2.1节所述,新的VM包含了每个页面中是否所有元组都已冻结的信息。<br>在eager模式下执行冻结处理时,仅包含已冻结元组的页面可以被跳过。</p><p>图6.6展示了一个例子。在冻结这个表时,通过参考VM的信息,0号页面被跳过了。在冻结完1号页面之后,<br>相关的VM信息也被更新,因为该页面的所有元组都已被冻结。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch6/ch6/img_7.png" alt="img_7.png"></p><h3 id="6-4-Removing-unnecessary-clog-files"><a href="#6-4-Removing-unnecessary-clog-files" class="headerlink" title="6.4 Removing unnecessary clog files"></a><a name="remove-clog"></a>6.4 Removing unnecessary clog files</h3><p>第5.4节描述了事务状态存储的Clog。当pg_database.datfrozenxid更新时,<br>PostgreSQL会尝试删除不必要的Clog文件。需要注意的是,相应的Clog页面也会被删除。</p><p>图6.7展示了一个例子。如果最小的pg_database.datfrozenxid包含在Clog文件’0002’中,<br>那么较旧的文件(‘0000’和’0001’)就可以被删除,因为这些文件中存储的所有事务都可以被视为<br>整个数据库集群中已冻结的txid。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch6/ch6/img_8.png" alt="img_8.png"></p><blockquote><p>pg_database.datfrozenxid and the clog file</p><p>下面展示了pg_database.datfrozenxid和Clog文件的实际输出:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">$ psql testdb <span class="hljs-operator">-</span>c &quot;SELECT datname, datfrozenxid FROM pg_database&quot;<br>datname  <span class="hljs-operator">|</span> datfrozenxid<br><span class="hljs-comment">-----------+--------------</span><br>template1 <span class="hljs-operator">|</span>      <span class="hljs-number">7308883</span><br>template0 <span class="hljs-operator">|</span>      <span class="hljs-number">7556347</span><br>postgres  <span class="hljs-operator">|</span>      <span class="hljs-number">7339732</span><br>testdb    <span class="hljs-operator">|</span>      <span class="hljs-number">7506298</span><br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br><br>$ ls <span class="hljs-operator">-</span>la <span class="hljs-operator">-</span>h data<span class="hljs-operator">/</span>pg_xact<span class="hljs-operator">/</span># <span class="hljs-keyword">In</span> versions <span class="hljs-number">9.6</span> <span class="hljs-keyword">or</span> earlier, &quot;ls -la -h data/pg_clog/&quot;<br>total <span class="hljs-number">316</span>K<br>drwx<span class="hljs-comment">------  2 postgres postgres   28 Dec 29 17:15 .</span><br>drwx<span class="hljs-comment">------ 20 postgres postgres 4.0K Dec 29 17:13 ..</span><br><span class="hljs-operator">-</span>rw<span class="hljs-comment">-------  1 postgres postgres 256K Dec 29 17:15 0006</span><br><span class="hljs-operator">-</span>rw<span class="hljs-comment">-------  1 postgres postgres  56K Dec 29 17:15 0007</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="6-5-Autovacuum-Daemon"><a href="#6-5-Autovacuum-Daemon" class="headerlink" title="6.5 Autovacuum Daemon"></a><a name="autovacuum"></a>6.5 Autovacuum Daemon</h3><p>在 PostgreSQL 中,Vacuum 处理已经通过自动 vacuum 后台进程自动化了,<br>使得 PostgreSQL 的操作变得非常简单。</p><p>自动 vacuum 后台进程会定期启动多个自动 vacuum 工作进程。默认情况下,<br>它每 1 分钟(由 autovacuum_naptime 定义)唤醒一次,并启动三个工作进程<br>(由 autovacuum_max_works 定义)。</p><p>由自动 vacuum 后台进程启动的自动 vacuum 工作进程会并发地为<br>各自的表执行 vacuum 处理,逐步并且对数据库活动的影响很小。</p><h4 id="6-5-1-Conditions-for-autovacuum-to-run"><a href="#6-5-1-Conditions-for-autovacuum-to-run" class="headerlink" title="6.5.1. Conditions for autovacuum to run"></a>6.5.1. Conditions for autovacuum to run</h4><p>自动 vacuum 进程会在以下任意条件满足时为目标表运行:</p><p>1、当前 txid 先于以下表达式:  </p><p>relfrozenxid + autovacuum_freeze_max_age</p><p>其中 relfrozenxid 是定义在 pg_class 中的目标表的 relfrozenxid 值,<br>autovacuum_freeze_max_age 是一个配置参数(默认为 200,000,000)。<br>如果满足这个条件,则自动 vacuum 进程会对目标表执行冻结处理。</p><p>2、死元组数量大于以下表达式:  </p><p>autovacuum_vacuum_threshold + autovacuum_vacuum_scale_factor × reltuples</p><p>其中 autovacuum_vacuum_threshold(默认为 50)和 autovacuum_vacuum_scale_factor(默认为 0.2)是配置参数,<br>reltuples 是目标表的元组数。<br>例如,如果目标表有 10,000 个元组和 2,100 个死元组,则自动<br>vacuum 进程会运行,因为 </p><p>2,100 &gt; 50 + 0.2 × 10,000。</p><p>3、插入的元组数量大于以下表达式:  </p><p>autovacuum_vacuum_insert_threshold + autovacuum_vacuum_insert_scale_factor × reltuples</p><p>其中 autovacuum_vacuum_insert_threshold(默认为 1000)和 autovacuum_vacuum_insert_scale_factor(默认为 0.2)<br>是配置参数, reltuples 是目标表的元组数。<br>例如,如果目标表有 10,000 个元组和 3,010 个插入元组,<br>则自动 vacuum 进程会运行,因为 </p><p>3,010 &gt; 1000 + 0.2 × 10,000。</p><p>这个条件是从 13 版本开始添加的。</p><p>此外,如果以下条件对目标表满足,自动 vacuum 进程还将执行analyze处理:</p><p>mod_since_analyze &gt; autovacuum_analyze_threshold + autovacuum_analyze_scale_factor × reltuples</p><p>其中 mod_since_analyze 是上次分析处理后对表执行的修改次数(INSERT、DELETE 或 UPDATE)。<br>autovacuum_analyze_threshold(默认为 50)和 autovacuum_analyze_scale_factor(默认为 0.1)<br>是配置参数, reltuples 是目标表的元组数。</p><p>例如,如果目标表有 10,000 个元组,且自上次分析处理后修改了 1,100 个元组,<br>则自动 vacuum 进程会运行,因为 </p><p>1,100 &gt; 50 + 0.1 × 10,000。</p><blockquote><p>Info</p><p>relation_needs_vacanalyze()函数负责确定目标表是否需要执行 vacuum 或分析操作。</p></blockquote><h4 id="6-5-2-Maintenance-tips"><a href="#6-5-2-Maintenance-tips" class="headerlink" title="6.5.2. Maintenance tips"></a>6.5.2. Maintenance tips</h4><p>经常提到的表膨胀是管理 PostgreSQL 最恼人的问题之一。造成这个问题的原因有几种,<br>其中自动 vacuum 就是其中之一。</p><p>当死元组数量大于以下值时,自动 vacuum 就会运行:<br>对于 1,000 个关系,是 250 个; 对于 100,000 个关系,是 20,050 个;<br>对于 100,000,000 个关系,是 20,000,050 个。<br>从这些例子可以看出,一个表拥有的元组越多,自动 vacuum 运行的频率就越低。</p><p>一个很好的建议是降低 autovacuum_vacuum_scale_factor 的值。<br>实际上,它的默认值(0.2)对于大型表来说太大了。</p><p>PostgreSQL 可以使用 ALTER TABLE 命令为每个表设置合适的 autovacuum_vacuum_scale_factor 值。<br>例如,我将展示如何为 pgbench_accounts 表设置新的 autovacuum_vacuum_scale_factor 值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">ALTER TABLE</span> pgbench_accounts <span class="hljs-keyword">SET</span> (autovacuum_vacuum_scale_factor <span class="hljs-operator">=</span> <span class="hljs-number">0.05</span>);<br><span class="hljs-keyword">ALTER TABLE</span><br></code></pre></td></tr></table></figure><p>如果你希望自动 vacuum 对目标表进行处理,而不依赖于它们的元组数量,也是可以做到的。</p><p>例如,假设你需要在死元组数量达到 10,000 时执行自动 vacuum 处理。在这种情况下,<br>通过为表设置以下存储参数,每当死元组数量达到 10,000 时,自动 vacuum 进程就会执行 vacuum 处理:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">ALTER TABLE</span> pgbench_accounts <span class="hljs-keyword">SET</span> (autovacuum_vacuum_threshold <span class="hljs-operator">=</span> <span class="hljs-number">10000</span>);<br><span class="hljs-keyword">ALTER TABLE</span><br>postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">ALTER TABLE</span> pgbench_accounts <span class="hljs-keyword">SET</span> (autovacuum_vacuum_scale_factor <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>);<br><span class="hljs-keyword">ALTER TABLE</span><br></code></pre></td></tr></table></figure><h3 id="6-6-Full-VACUUM"><a href="#6-6-Full-VACUUM" class="headerlink" title="6.6 Full VACUUM"></a><a name="full-vacuum"></a>6.6 Full VACUUM</h3><p>尽管并发 VACUUM 对于操作至关重要,但它并不够充分。例如,即使删除了许多死元组,<br>它也无法减小表的大小。</p><p>图 6.8 展示了一个极端的例子。假设一个表由三个页面组成,每个页面包含六个元组。执<br>行以下 DELETE 命令删除元组,并执行 VACUUM 命令删除死元组:</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch6/ch6/img_9.png" alt="img_9.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> tbl <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">%</span> <span class="hljs-number">6</span> <span class="hljs-operator">!=</span> <span class="hljs-number">0</span>;<br>testdb<span class="hljs-operator">=</span># VACUUM tbl;<br></code></pre></td></tr></table></figure><p>虽然死元组被移除了,但表的大小并没有减小。这不仅浪费了磁盘空间,还对数据库性能产生负面影响。<br>比如在上述示例中,当读取表中的三个元组时,必须从磁盘加载三个页面。</p><p>为了处理这种情况,PostgreSQL 提供了完全 VACUUM 模式。图 6.9 概括了这种模式的工作原理。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch6/ch6/img_10.png" alt="img_10.png"></p><p>[1] 创建新的表文件: 图 6.9(1)<br>当对一个表执行 VACUUM FULL 命令时,PostgreSQL 首先为该表获取 AccessExclusiveLock 锁,<br>并创建一个大小为 8 KB 的新表文件。AccessExclusiveLock 锁阻止其他用户访问该表。</p><p>[2] 将活元组复制到新表: 图 6.9(2)<br>PostgreSQL 只将旧表文件中的活元组复制到新表。</p><p>[3] 删除旧文件,重建索引,并更新统计信息、FSM 和 VM: 图 6.9(3)<br>在复制所有活元组后,PostgreSQL 删除旧文件,重建所有相关的表索引,<br>更新该表的 FSM 和 VM,并更新相关的统计信息和系统目录。</p><p>完全 VACUUM 的伪代码如下所示:</p><blockquote><p>Pseudocode: Full VACUUM</p><p>(1)  FOR each table<br>(2)     Acquire AccessExclusiveLock lock for the table<br>(3)     Create a new table file<br>(4)     FOR each live tuple in the old table<br>(5)        Copy the live tuple to the new table file<br>(6)        Freeze the tuple IF necessary<br>END FOR<br>(7)     Remove the old table file<br>(8)     Rebuild all indexes<br>(9)     Update FSM and VM<br>(10)    Update statistics<br>Release AccessExclusiveLock lock<br>END FOR<br>(11) Remove unnecessary clog files and pages if possible</p></blockquote><p>在使用 VACUUM FULL 命令时,需要考虑以下两点:</p><ol><li>当完全 VACUUM 正在处理时,没有人可以访问(读取&#x2F;写入)该表。  </li><li>最多使用该表两倍的磁盘空间临时存储;因此,在处理大型表时,需要检查剩余的磁盘容量。</li></ol><blockquote><p>When should I do VACUUM FULL?</p><p>对于什么时候执行 VACUUM FULL 这个问题,不幸没有一种通用的答案。不过,扩展 pg_freespacemap 可以给出一些好的建议。</p><p>下面的查询可以显示您想要了解的表的平均空闲空间比例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">CREATE</span> EXTENSION pg_freespacemap;<br><span class="hljs-keyword">CREATE</span> EXTENSION<br><br>testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> &quot;number of pages&quot;,<br>pg_size_pretty(<span class="hljs-built_in">cast</span>(<span class="hljs-built_in">avg</span>(avail) <span class="hljs-keyword">as</span> <span class="hljs-type">bigint</span>)) <span class="hljs-keyword">as</span> &quot;Av. freespace size&quot;,<br>round(<span class="hljs-number">100</span> <span class="hljs-operator">*</span> <span class="hljs-built_in">avg</span>(avail)<span class="hljs-operator">/</span><span class="hljs-number">8192</span> ,<span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> &quot;Av. freespace ratio&quot;<br><span class="hljs-keyword">FROM</span> pg_freespace(<span class="hljs-string">&#x27;accounts&#x27;</span>);<br>number <span class="hljs-keyword">of</span> pages <span class="hljs-operator">|</span> Av. freespace size <span class="hljs-operator">|</span> Av. freespace ratio<br><span class="hljs-comment">----------------+--------------------+---------------------</span><br>           <span class="hljs-number">1640</span> <span class="hljs-operator">|</span> <span class="hljs-number">99</span> bytes           <span class="hljs-operator">|</span>                <span class="hljs-number">1.21</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>根据上述结果,您可以发现该表的空闲空间很少(1.21% 的空闲空间)。</p><p>如果您删除了大部分元组并执行 VACUUM 命令,您会发现几乎所有页面都是空的(86.97% 的空闲空间),<br>但页面数量仍然保持不变。换句话说,表文件并没有被压缩。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> aid <span class="hljs-operator">%</span><span class="hljs-number">10</span> <span class="hljs-operator">!=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">OR</span> aid <span class="hljs-operator">&lt;</span> <span class="hljs-number">100</span>;<br><span class="hljs-keyword">DELETE</span> <span class="hljs-number">90009</span><br><br>testdb<span class="hljs-operator">=</span># VACUUM accounts;<br>VACUUM<br><br>testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> &quot;number of pages&quot;,<br>pg_size_pretty(<span class="hljs-built_in">cast</span>(<span class="hljs-built_in">avg</span>(avail) <span class="hljs-keyword">as</span> <span class="hljs-type">bigint</span>)) <span class="hljs-keyword">as</span> &quot;Av. freespace size&quot;,<br>round(<span class="hljs-number">100</span> <span class="hljs-operator">*</span> <span class="hljs-built_in">avg</span>(avail)<span class="hljs-operator">/</span><span class="hljs-number">8192</span> ,<span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> &quot;Av. freespace ratio&quot;<br><span class="hljs-keyword">FROM</span> pg_freespace(<span class="hljs-string">&#x27;accounts&#x27;</span>);<br>number <span class="hljs-keyword">of</span> pages <span class="hljs-operator">|</span> Av. freespace size <span class="hljs-operator">|</span> Av. freespace ratio<br><span class="hljs-comment">----------------+--------------------+---------------------</span><br>           <span class="hljs-number">1640</span> <span class="hljs-operator">|</span> <span class="hljs-number">7124</span> bytes         <span class="hljs-operator">|</span>               <span class="hljs-number">86.97</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>下面的查询可以检查指定表的每个页面的空闲空间比例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>, round(<span class="hljs-number">100</span> <span class="hljs-operator">*</span> avail<span class="hljs-operator">/</span><span class="hljs-number">8192</span> ,<span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> &quot;freespace ratio&quot;<br><span class="hljs-keyword">FROM</span> pg_freespace(<span class="hljs-string">&#x27;accounts&#x27;</span>);<br>blkno <span class="hljs-operator">|</span> avail <span class="hljs-operator">|</span> freespace ratio<br><span class="hljs-comment">------+-------+-----------------</span><br>    <span class="hljs-number">0</span> <span class="hljs-operator">|</span>  <span class="hljs-number">7904</span> <span class="hljs-operator">|</span>           <span class="hljs-number">96.00</span><br>    <span class="hljs-number">1</span> <span class="hljs-operator">|</span>  <span class="hljs-number">7520</span> <span class="hljs-operator">|</span>           <span class="hljs-number">91.00</span><br>    <span class="hljs-number">2</span> <span class="hljs-operator">|</span>  <span class="hljs-number">7136</span> <span class="hljs-operator">|</span>           <span class="hljs-number">87.00</span><br>    <span class="hljs-number">3</span> <span class="hljs-operator">|</span>  <span class="hljs-number">7136</span> <span class="hljs-operator">|</span>           <span class="hljs-number">87.00</span><br>    <span class="hljs-number">4</span> <span class="hljs-operator">|</span>  <span class="hljs-number">7136</span> <span class="hljs-operator">|</span>           <span class="hljs-number">87.00</span><br>    <span class="hljs-number">5</span> <span class="hljs-operator">|</span>  <span class="hljs-number">7136</span> <span class="hljs-operator">|</span>           <span class="hljs-number">87.00</span><br>....<br></code></pre></td></tr></table></figure><p>如果在这种情况下执行 VACUUM FULL，您将看到表文件已经被压缩。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># VACUUM <span class="hljs-keyword">FULL</span> accounts;<br>VACUUM<br>testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> &quot;number of blocks&quot;,<br>pg_size_pretty(<span class="hljs-built_in">cast</span>(<span class="hljs-built_in">avg</span>(avail) <span class="hljs-keyword">as</span> <span class="hljs-type">bigint</span>)) <span class="hljs-keyword">as</span> &quot;Av. freespace size&quot;,<br>round(<span class="hljs-number">100</span> <span class="hljs-operator">*</span> <span class="hljs-built_in">avg</span>(avail)<span class="hljs-operator">/</span><span class="hljs-number">8192</span> ,<span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> &quot;Av. freespace ratio&quot;<br><span class="hljs-keyword">FROM</span> pg_freespace(<span class="hljs-string">&#x27;accounts&#x27;</span>);<br>number <span class="hljs-keyword">of</span> pages <span class="hljs-operator">|</span> Av. freespace size <span class="hljs-operator">|</span> Av. freespace ratio<br><span class="hljs-comment">----------------+--------------------+---------------------</span><br>            <span class="hljs-number">164</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> bytes            <span class="hljs-operator">|</span>                <span class="hljs-number">0.00</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL指南：内幕探索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch5. 并发控制</title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/</url>
    
    <content type="html"><![CDATA[<h2 id="ch5-并发控制"><a href="#ch5-并发控制" class="headerlink" title="ch5. 并发控制"></a>ch5. 并发控制</h2><p>CONCURRENCY CONTROL</p><p>并发控制是在数据库中多个事务并发运行时，维护ACID属性中原子性和隔离性的一种机制。</p><p>并发控制主要有三种广泛的技术：多版本并发控制（MVCC）、<br>严格两阶段锁定（S2PL）和乐观并发控制（OCC）。每种技术都有多种变体。</p><p>在MVCC中，每次写操作都会创建数据项的新版本，同时保留旧版本。当事务读取数据项时，系统会选择一个版本以确保<br>单个事务的隔离性。MVCC的主要优点在于“读者不会阻塞写者，写者也不会阻塞读者”，<br>相比之下，例如基于S2PL的系统在写入数据项时必须阻塞读者，因为写者会为此数据项获取排他锁。<br>PostgreSQL和一些关系型数据库管理系统使用了MVCC的一个变体，称为快照隔离（SI）。</p><p>为了实现SI，一些数据库系统如Oracle使用回滚段。在写入新数据项时，数据项的旧版本会被写入回滚段，<br>随后新项会覆盖到数据区域。PostgreSQL采用了更简单的方法。新数据项直接插入到相关的表页中。<br>在读取项时，PostgreSQL通过应用可见性检查规则，为每个事务选择数据项的适当版本。</p><p>SI不允许出现ANSI SQL-92标准中定义的三种异常：脏读、不可重复读和幻读。然而，SI不能达到真正的可串行化，<br>因为它允许如写偏斜和只读事务偏斜等串行化异常。需要注意的是，基于经典可串行化定义<br>的ANSI SQL-92标准与现代理论中的定义并不等价。</p><p>为了解决这个问题，从9.1版开始引入了可串行化快照隔离（SSI）。SSI可以检测串行化异常并解决由此引起的冲突 ，<br>因此PostgreSQL 9.1或更高版本提供了真正的SERIALIZABLE隔离级别。<br>（另外，SQL Server也使用SSI；Oracle仍然仅使用SI。）</p><p>本章包含以下四个部分：</p><p>第一部分：第5.1节至第5.3节。<br>这部分提供了理解后续内容所需的基础信息。<br>第5.1节和第5.2节分别介绍了事务ID和元组结构。第5.3节展示了元组是如何被插入、删除和更新的。</p><p>第二部分：第5.4节至第5.6节。<br>这部分阐述了实现并发控制机制所需的关键特性。<br>第5.4节、第5.5节和第5.6节分别描述了保存所有事务状态的提交日志（clog）、事务快照以及可见性检查规则。</p><p>第三部分：第5.7节至第5.9节。<br>这部分通过具体实例说明了PostgreSQL中的并发控制。<br>第5.7节描述了可见性检查，同时也展示了如何防止ANSI SQL标准中定义的三种异常。第5.8节说明了如何防止丢失更新，第5.9节简要介绍了SSI（Serializable Snapshot Isolation）。</p><p>第四部分：第5.10节。<br>这部分描述了永久运行并发控制机制所需的若干维护过程。这些维护过程由真空处理（vacuum处理）执行，该处理在第6章中详细介绍。</p><p>本章侧重于PostgreSQL特有的主题，尽管与并发控制相关的主题很多。<br>请注意，有关死锁预防和锁模式的描述已被省略。（更多信息请参考官方文档, <a href="https://www.postgresql.org/docs/current/explicit-locking.html%EF%BC%89">https://www.postgresql.org/docs/current/explicit-locking.html）</a></p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#txid">5.1 事务ID</a></td></tr><tr><td><a href="#tuple">5.2 元组结构</a></td></tr><tr><td><a href="#tuple-operate">5.3 元组的插入、删除与更新</a></td></tr><tr><td><a href="#clog">5.4 提交日志（clog）</a></td></tr><tr><td><a href="#snapshot">5.5 事务快照</a></td></tr><tr><td><a href="#v-rules">5.6 可见性检查规则</a></td></tr><tr><td><a href="#v-do">5.7 可见性检查</a></td></tr><tr><td><a href="#prevent-update">5.8 防止丢失更新</a></td></tr><tr><td><a href="#SSI"><em>unfinish</em> 5.9 可串行化快照隔离（SSI）</a></td></tr><tr><td><a href="#5-process">5.10 必要的维护过程</a></td></tr></tbody></table><blockquote><p> Transaction Isolation Level in PostgreSQL</p><p>PostgreSQL-implemented transaction isolation levels are described in the following table:<br><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img.png" alt="img.png"></p><p>*1 : 在9.0及更早版本中，此隔离级别被用作“SERIALIZABLE”，因为它不允许出现ANSI SQL-92标准中定义的三种异常。<br>然而，随着9.1版本中SSI（Serializable Snapshot Isolation）的实现，此级别变更为“REPEATABLE READ”，<br>并且引入了真正的SERIALIZABLE隔离级别。</p></blockquote><blockquote><p>note<br>PostgreSQL在处理DML（数据操作语言，如SELECT, UPDATE, INSERT, DELETE等）时采用SSI<br>（Serializable Snapshot Isolation），<br>而在处理DDL（数据定义语言，如CREATE TABLE等）时则采用2PL（Two-Phase Locking，两阶段锁定）。<br><a href="https://wiki.postgresql.org/wiki/SSI">https://wiki.postgresql.org/wiki/SSI</a></p></blockquote><h3 id="5-1-事务ID"><a href="#5-1-事务ID" class="headerlink" title="5.1 事务ID"></a><a name="txid"></a>5.1 事务ID</h3><p>每当一个事务开始时，事务管理器会为其分配一个唯一的标识符，称为事务ID（txid）。<br>PostgreSQL中的txid是一个32位无符号整数，大约为42亿（即数十亿）。如果你在一个事务开始后执行内置<br>的txid_current()函数，该函数会返回当前的txid，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">BEGIN</span><br>testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> txid_current();<br> txid_current <br><span class="hljs-comment">--------------</span><br>          <span class="hljs-number">100</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>PostgreSQL保留了以下三个特殊的txid：</p><p>0 表示无效的txid。</p><p>1 表示引导txid，仅在数据库集群初始化时使用。</p><p>2 表示冻结txid，这个概念在5.10.1节中有描述。</p><p>txid之间可以相互比较。例如，从txid 100的角度来看，大于100的txid处于“未来”，<br>对于txid 100是不可见的；小于100的txid处于“过去”，对于txid 100来说是可见的（图5.1a）。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_1.png" alt="img_1.png"></p><p>由于在实际系统中txid空间可能不够用，PostgreSQL将txid空间视为一个循环。前21亿个txid被视为“过去”，接下来的21亿个txid被视为“未来”（图5.1b）。</p><p>请注意，所谓的txid环绕问题在5.10.1节中有描述。</p><blockquote><p>note</p><p>请注意，BEGIN命令本身并不会被分配一个txid。</p><p>在PostgreSQL中，当执行完BEGIN命令后，首次执行命令时，事务管理器才会分配一个txid，随后事务才真正开始。</p></blockquote><h3 id="5-2-元组结构"><a href="#5-2-元组结构" class="headerlink" title="5.2 元组结构"></a><a name="tuple"></a>5.2 元组结构</h3><p>表页面中的堆元组分为两种类型：常规数据元组和TOAST元组。本节仅描述常规元组。</p><p>一个堆元组由三部分组成：HeapTupleHeaderData结构、NULL位图以及用户数据（图5.2）。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_2.png" alt="img_2.png"><br>The HeapTupleHeaderData structure is defined in src&#x2F;include&#x2F;access&#x2F;htup_details.h.</p><p>HeapTupleHeaderData结构包含七个字段，但在后续章节中只需要其中的四个：</p><p>t_xmin 存储插入此元组的事务的txid。</p><p>t_xmax 存储删除或更新此元组的事务的txid。<br>如果这个元组未被删除或更新，t_xmax 则被设置为0，表示无效（INVALID）。</p><p>t_cid 持有命令ID（cid），它是当前事务中在此之前执行的SQL命令数量，从0开始计数。<br>例如，假设我们在一个事务中执行三条INSERT命令：BEGIN; INSERT; INSERT; INSERT; COMMIT;。<br>如果第一条命令插入了这个元组，t_cid就被设置为0。如果是第二条命令插入，则t_cid设为1，以此类推。</p><p>t_ctid 持有指向自身或新元组的元组标识符（tid）。<br>tid（在1.3节中描述）用于在表内唯一标识一个元组。<br>当这个元组被更新时，此元组的t_ctid会指向新元组；否则，t_ctid指向自己。</p><h3 id="5-3-元组的插入、删除与更新"><a href="#5-3-元组的插入、删除与更新" class="headerlink" title="5.3 元组的插入、删除与更新"></a><a name="tuple-operate"></a>5.3 元组的插入、删除与更新</h3><p>本节介绍元组如何被插入、删除和更新。接着，简要描述用于插入和更新元组的空闲空间映射<br>（Free Space Map, FSM）。</p><p>为了集中讨论元组，以下内容将不展示页头和行指针。图5.3展示了一个元组表示方式的示例。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_3.png" alt="img_3.png"></p><h4 id="5-3-1-Insertion"><a href="#5-3-1-Insertion" class="headerlink" title="5.3.1. Insertion"></a>5.3.1. Insertion</h4><p>在插入操作中，新元组会直接被插入到目标表的一个页面中（如图5.4所示）。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_4.png" alt="img_4.png"></p><p>假设有一个事务，其txid为99，该事务在一个页面中插入了一个元组。<br>在这种情况下，插入元组的头字段被设置如下：</p><p>Tuple_1:</p><p>t_xmin 设置为99，因为这个元组是由txid 99插入的。<br>t_xmax 设置为0，因为这个元组尚未被删除或更新。<br>t_cid 设置为0，因为这是txid 99插入的第一个元组。<br>t_ctid 设置为(0,1)，它指向自己，因为这是最新的元组。  </p><p>PostgreSQL 提供了一个名为 ‘pageinspect’ 的扩展模块,它是一个贡献模块,可以用来查看数据库页面的内容。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">CREATE</span> EXTENSION pageinspect;<br><span class="hljs-keyword">CREATE</span> EXTENSION<br>testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">CREATE TABLE</span> tbl (data text);<br><span class="hljs-keyword">CREATE TABLE</span><br>testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">INSERT INTO</span> tbl <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br>testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> lp <span class="hljs-keyword">as</span> tuple, t_xmin, t_xmax, t_field3 <span class="hljs-keyword">as</span> t_cid, t_ctid <br>                <span class="hljs-keyword">FROM</span> heap_page_items(get_raw_page(<span class="hljs-string">&#x27;tbl&#x27;</span>, <span class="hljs-number">0</span>));<br> tuple <span class="hljs-operator">|</span> t_xmin <span class="hljs-operator">|</span> t_xmax <span class="hljs-operator">|</span> t_cid <span class="hljs-operator">|</span> t_ctid <br><span class="hljs-comment">-------+--------+--------+-------+--------</span><br>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span>     <span class="hljs-number">99</span> <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span>     <span class="hljs-number">0</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><h4 id="5-3-2-Deletion"><a href="#5-3-2-Deletion" class="headerlink" title="5.3.2. Deletion"></a>5.3.2. Deletion</h4><p>在删除操作中,目标元组是逻辑删除的。执行 DELETE 命令的 txid 值被设置为元组的 t_xmax 字段(如图 5.5 所示)。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_5.png" alt="img_5.png"></p><p>假设 Tuple_1 被 txid 111 删除。在这种情况下, Tuple_1 的头部字段会被设置如下:</p><p>Tuple_1:<br>t_xmax 被设置为 111。</p><p>如果 txid 111 已提交,那么 Tuple_1 就不再需要了。通常在 PostgreSQL 中,这种不需要的元组被称为”死元组”。</p><p>这些死元组最终应该从页面中删除。清理死元组的过程称为 VACUUM 处理,将在第 6 章中介绍。</p><h4 id="5-3-3-Update"><a href="#5-3-3-Update" class="headerlink" title="5.3.3. Update"></a>5.3.3. Update</h4><p>在更新操作中,PostgreSQL 会逻辑地删除最新的元组,并插入一个新的元组(如图 5.6 所示)。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_6.png" alt="img_6.png"></p><p>假设一个记录被 txid 99 插入,然后被 txid 100 更新了两次。</p><p>当第一个 UPDATE 命令执行时,Tuple_1 会被逻辑删除,通过将 t_xmax 设置为 100。然后会插入一个新的 Tuple_2。Tuple_1 和 Tuple_2 的头部字段如下:</p><p>Tuple_1:<br>t_xmax 被设置为 100<br>t_ctid 被重写为 (0,2)  </p><p>Tuple_2:<br>t_xmin 被设置为 100<br>t_xmax 被设置为 0<br>t_cid 被设置为 0<br>t_ctid 被设置为 (0,2)  </p><p>当第二个 UPDATE 命令执行时,Tuple_2 会被逻辑删除,并插入一个新的 Tuple_3。Tuple_2 和 Tuple_3 的头部字段如下:</p><p>Tuple_2:<br>t_xmax 被设置为 100<br>t_ctid 被重写为 (0,3)  </p><p>Tuple_3:<br>t_xmin 被设置为 100<br>t_xmax 被设置为 0<br>t_cid 被设置为 1<br>t_ctid 被设置为 (0,3)  </p><p>如果 txid 100 被提交,Tuple_1 和 Tuple_2 将成为死元组。如果 txid 100 被中止,Tuple_2 和 Tuple_3 将成为死元组。</p><h4 id="5-3-4-Free-Space-Map"><a href="#5-3-4-Free-Space-Map" class="headerlink" title="5.3.4. Free Space Map"></a>5.3.4. Free Space Map</h4><p>当插入 heap 或索引元组时,PostgreSQL 会使用相应表或索引的 FSM (Free Space Map) 来选择可以插入的页面。</p><p>如前文 1.2.3 节所提到的,所有表和索引都有各自的 FSM。每个 FSM 存储了相应表或索引文件中每个页面的空闲空间容量信息。</p><p>所有的 FSM 都以 ‘fsm’ 为后缀存储,并且在需要时会被加载到共享内存中。</p><p>pg_freespacemap 扩展提供了指定表或索引的空闲空间信息。下面的查询显示了指定表中每个页面的空闲空间比例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">CREATE</span> EXTENSION pg_freespacemap;<br><span class="hljs-keyword">CREATE</span> EXTENSION<br><br>testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>, round(<span class="hljs-number">100</span> <span class="hljs-operator">*</span> avail<span class="hljs-operator">/</span><span class="hljs-number">8192</span> ,<span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> &quot;freespace ratio&quot;<br>                <span class="hljs-keyword">FROM</span> pg_freespace(<span class="hljs-string">&#x27;accounts&#x27;</span>);<br> blkno <span class="hljs-operator">|</span> avail <span class="hljs-operator">|</span> freespace ratio <br><span class="hljs-comment">-------+-------+-----------------</span><br>     <span class="hljs-number">0</span> <span class="hljs-operator">|</span>  <span class="hljs-number">7904</span> <span class="hljs-operator">|</span>           <span class="hljs-number">96.00</span><br>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span>  <span class="hljs-number">7520</span> <span class="hljs-operator">|</span>           <span class="hljs-number">91.00</span><br>     <span class="hljs-number">2</span> <span class="hljs-operator">|</span>  <span class="hljs-number">7136</span> <span class="hljs-operator">|</span>           <span class="hljs-number">87.00</span><br>     <span class="hljs-number">3</span> <span class="hljs-operator">|</span>  <span class="hljs-number">7136</span> <span class="hljs-operator">|</span>           <span class="hljs-number">87.00</span><br>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span>  <span class="hljs-number">7136</span> <span class="hljs-operator">|</span>           <span class="hljs-number">87.00</span><br>     <span class="hljs-number">5</span> <span class="hljs-operator">|</span>  <span class="hljs-number">7136</span> <span class="hljs-operator">|</span>           <span class="hljs-number">87.00</span><br>....<br></code></pre></td></tr></table></figure><h3 id="5-4-提交日志（clog）"><a href="#5-4-提交日志（clog）" class="headerlink" title="5.4 提交日志（clog）"></a><a name="clog"></a>5.4 提交日志（clog）</h3><p>PostgreSQL 将事务的状态存储在提交日志(Commit Log)中。提交日志,通常称为 clog,分配在共享内存中,并在整个事务处理过程中使用。</p><p>本节介绍了 PostgreSQL 中事务的状态、clog 的操作以及 clog 的维护。</p><h4 id="5-4-1-Transaction-Status"><a href="#5-4-1-Transaction-Status" class="headerlink" title="5.4.1.  Transaction Status"></a>5.4.1.  Transaction Status</h4><p>PostgreSQL 定义了四种事务状态: IN_PROGRESS、COMMITTED、ABORTED 和 SUB_COMMITTED。</p><p>前三种状态是不言自明的。例如,当一个事务正在进行时,其状态为 IN_PROGRESS。</p><p>SUB_COMMITTED 是针对子事务的状态,在本文中没有对其作进一步描述。</p><h4 id="5-4-2-How-Clog-Performs"><a href="#5-4-2-How-Clog-Performs" class="headerlink" title="5.4.2. How Clog Performs"></a>5.4.2. How Clog Performs</h4><p>clog 由一个或多个 8 KB 的页面组成,存放在共享内存中。它在逻辑上形成一个数组,<br>数组的索引对应于相应的事务 ID,数组中的每一项都保存着对应事务 ID 的状态。图 5.7 展示了 clog 的结构及其工作原理。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_7.png" alt="img_7.png"></p><p>当当前的事务 ID 增加到 clog 无法再存储时,就会追加一个新的页面。</p><p>当需要获取事务的状态时,会调用内部函数。这些函数会读取 clog,并返回所请求事务的状态。<br>(也可参考第 5.7.1 节中的”提示位”部分)</p><h4 id="5-4-3-Maintenance-of-the-Clog"><a href="#5-4-3-Maintenance-of-the-Clog" class="headerlink" title="5.4.3. Maintenance of the Clog"></a>5.4.3. Maintenance of the Clog</h4><p>当 PostgreSQL 关闭或者检查点进程运行时,clog 的数据会被写入存储在 pg_xact 子目录下的文件中。<br>(需要注意,在 9.6 或更早版本中,pg_xact 被称为 pg_clog。)这些文件被命名为 ‘0000’、’0001’ 等。</p><p>每个文件的最大尺寸为 256 KB。例如,如果 clog 使用了 8 个页面(从第一个页面到第八个页面,总大小为 64 KB),它的数据就会被写入<br>‘0000’(64 KB)。如果 clog 使用了 37 个页面(296 KB),它的数据就会被写入 ‘0000’ 和 ‘0001’，分别为 256 KB 和 40 KB。</p><p>当 PostgreSQL 启动时,存储在 pg_xact 文件中的数据会被加载以初始化 clog。</p><p>clog 的大小会持续增加,因为每当 clog 被填满时都会追加一个新的页面。但并非 clog 中的所有数据都是必需的。<br>在第 6 章中描述的 Vacuum 处理会定期删除这些旧数据(包括 clog 页面和文件)。</p><p>有关删除 clog 数据的详细信息,请参阅第 6.4 节。</p><h3 id="5-5-事务快照"><a href="#5-5-事务快照" class="headerlink" title="5.5 事务快照"></a><a name="snapshot"></a>5.5 事务快照</h3><p>事务快照是一个数据集,它存储了某一特定时间点所有事务是否处于活动状态的信息。这里,所谓”活动事务”是指正在进行或尚未开始的事务。</p><p>PostgreSQL 内部将事务快照的文本表示格式定义为 ‘100:100:’。例如, ‘100:100:’ 表示”小于 99 的事务 ID 不是活动的,大于或等于 100 的事务 ID 是活动的”。</p><p>在下面的描述中,将使用这种方便的表示形式。如果你不熟悉这种表示法,请参见下面的说明。</p><p>PostgreSQL 提供了一个内置函数 pg_current_snapshot,它可以返回当前会话的事务快照,并以文本表示形式输出。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> pg_current_snapshot();<br> pg_current_snapshot <br><span class="hljs-comment">---------------------</span><br> <span class="hljs-number">100</span>:<span class="hljs-number">104</span>:<span class="hljs-number">100</span>,<span class="hljs-number">102</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>事务快照的文本表示形式是’xmin:xmax:xip_list’，各个组成部分说明如下:</p><p>xmin<br>(仍在活动的最早事务 ID)：所有早于这个 ID 的事务要么已提交并可见, 要么已回滚并死掉。</p><p>xmax<br>(尚未分配的第一个事务 ID)：所有大于或等于这个 ID 的事务在快照时刻还未开始, 因此对当前快照是不可见的。</p><p>xip_list<br>(快照时刻正在活动的事务 ID列表)：列表只包含 xmin 和 xmax 之间的活动事务 ID。</p><p>例如, 在快照 ‘100:104:100,102’ 中, xmin 是 ‘100’, xmax 是 ‘104’, xip_list 是 ‘100,102’。</p><p>Here are two specific examples:</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_8.png" alt="img_8.png"></p><p>第一个示例 ‘100:100:’ 意味着以下情况(图 5.8(a)):<br>小于或等于 99 的事务 ID 都不是活动的,因为 xmin 是 100。<br>大于或等于 100 的事务 ID 都是活动的,因为 xmax 是 100。  </p><p>第二个示例 ‘100:104:100,102’ 意味着以下情况(图 5.8(b)):<br>小于或等于 99 的事务 ID 都不是活动的。<br>大于或等于 104 的事务 ID 都是活动的。<br>事务 ID 100 和 102 是活动的,因为它们在 xip 列表中,而事务 ID 101 和 103 是不活动的。  </p><p>事务快照由事务管理器提供。在 READ COMMITTED 隔离级别下, 每执行一条 SQL 命令时都会获取一个快照; 否则(REPEATABLE READ 或 SERIALIZABLE),<br>事务只在第一条 SQL 命令执行时获取一个快照。获取的事务快照用于对元组进行可见性检查,在第 5.7 节中有描述。</p><p>在使用获取的快照进行可见性检查时, 快照中的活动事务必须被视为正在进行中,即使它们实际上已经提交或回滚。这一规则很重要,<br>因为它造成了 READ COMMITTED 和 REPEATABLE READ (或 SERIALIZABLE) 之间行为的差异。我们将在后续章节中多次提到这一规则。</p><p>在本节的其余部分, 我们将使用特定的场景图 5.9 来描述事务管理器和事务。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_9.png" alt="img_9.png"></p><p>事务管理器总是持有当前正在运行的事务的信息。假设有三个事务依次启动,其中 Transaction_A 和 Transaction_B 的隔离级别是<br>READ COMMITTED, Transaction_C 的隔离级别是 REPEATABLE READ。</p><p>T1:<br>Transaction_A 启动并执行第一条 SELECT 命令。在执行第一条命令时, Transaction_A 请求了当前时刻的事务 ID 和快照。<br>在这个场景中, 事务管理器分配了事务 ID 200, 并返回了事务快照 ‘200:200:’。</p><p>T2:<br>Transaction_B 启动并执行第一条 SELECT 命令。事务管理器分配了事务 ID 201, 并返回了事务快照 ‘200:200:’ ,<br>因为 Transaction_A (事务 ID 200) 正在进行中。因此, Transaction_A 对 Transaction_B 是不可见的。</p><p>T3:<br>Transaction_C 启动并执行第一条 SELECT 命令。事务管理器分配了事务 ID 202, 并返回了事务快照 ‘200:200:’,<br>因此 Transaction_A 和 Transaction_B 对 Transaction_C 是不可见的。</p><p>T4:<br>Transaction_A 已经提交。事务管理器删除了关于这个事务的信息。</p><p>T5:<br>Transaction_B 和 Transaction_C 执行各自的 SELECT 命令。<br>Transaction_B 需要一个事务快照,因为它处于 READ COMMITTED 级别。在这个场景中, Transaction_B 获得了一个新的快照 ‘201:201:’,<br>因为 Transaction_A (事务 ID 200) 已经提交。因此, Transaction_A 对 Transaction_B 不再是不可见的。Transaction_C 不需要事务快照,<br>因为它处于 REPEATABLE READ 级别, 使用之前获得的快照 ‘200:200:’。因此, Transaction_A 对 Transaction_C 仍然是不可见的。</p><h3 id="5-6-可见性检查规则"><a href="#5-6-可见性检查规则" class="headerlink" title="5.6 可见性检查规则"></a><a name="v-rules"></a>5.6 可见性检查规则</h3><p>可见性检查规则是一系列规则，用于根据元组的t_xmin和t_xmax、clog（提交日志）以及获取的事务快照来判断每<br>个元组是否可见。</p><p>这些规则过于复杂，无法详细解释。因此，本文档仅展示后续描述所需的最简规则。在以下内容中，<br>我们将忽略与子事务相关的规则，并且不讨论t_ctid，即不考虑在单个事务中被更新超过两次的元组。</p><p>选定的规则共有十条，它们可以分为三种情况。</p><h4 id="5-6-1-Status-of-t-xmin-is-ABORTED"><a href="#5-6-1-Status-of-t-xmin-is-ABORTED" class="headerlink" title="5.6.1. Status of t_xmin is ABORTED"></a>5.6.1. Status of t_xmin is ABORTED</h4><p>当元组的t_xmin状态为ABORTED时，该元组总是不可见的（规则1），因为插入这个元组的事务已经被中止了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/* t_xmin status == ABORTED */</span><br>Rule <span class="hljs-number">1</span>:  IF t_xmin status <span class="hljs-keyword">is</span> <span class="hljs-string">&#x27;ABORTED&#x27;</span> <span class="hljs-keyword">THEN</span><br>                 <span class="hljs-keyword">RETURN</span> <span class="hljs-string">&#x27;Invisible&#x27;</span><br>          <span class="hljs-keyword">END</span> IF<br></code></pre></td></tr></table></figure><p>这条规则具体地表达为以下数学表达式。</p><blockquote><p>Rule 1: If Status(t_xmin) &#x3D; ABORTED ⇒ Invisible</p></blockquote><h4 id="5-6-2-Status-of-t-xmin-is-IN-PROGRESS"><a href="#5-6-2-Status-of-t-xmin-is-IN-PROGRESS" class="headerlink" title="5.6.2. Status of t_xmin is IN_PROGRESS"></a>5.6.2. Status of t_xmin is IN_PROGRESS</h4><p>一个元组，若其t_xmin状态为IN_PROGRESS，基本上是不可见的（规则3和4），除非满足一种特殊情况。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"> <span class="hljs-comment">/* t_xmin status == IN_PROGRESS */</span><br>       IF t_xmin status <span class="hljs-keyword">is</span> <span class="hljs-string">&#x27;IN_PROGRESS&#x27;</span> <span class="hljs-keyword">THEN</span><br>              IF t_xmin <span class="hljs-operator">=</span> current_txid <span class="hljs-keyword">THEN</span><br>Rule <span class="hljs-number">2</span>:              IF t_xmax <span class="hljs-operator">=</span> INVALID <span class="hljs-keyword">THEN</span><br>                           <span class="hljs-keyword">RETURN</span> <span class="hljs-string">&#x27;Visible&#x27;</span><br>Rule <span class="hljs-number">3</span>:              <span class="hljs-keyword">ELSE</span>  <span class="hljs-comment">/* this tuple has been deleted or updated  */</span><br>                           <span class="hljs-comment">/* by the current transaction itself.      */</span><br>                            <span class="hljs-keyword">RETURN</span> <span class="hljs-string">&#x27;Invisible&#x27;</span><br>                     <span class="hljs-keyword">END</span> IF<br>Rule <span class="hljs-number">4</span>:       <span class="hljs-keyword">ELSE</span>   <span class="hljs-comment">/* t_xmin &amp;ne; current_txid */</span><br>                     <span class="hljs-keyword">RETURN</span> <span class="hljs-string">&#x27;Invisible&#x27;</span><br>              <span class="hljs-keyword">END</span> IF<br>       <span class="hljs-keyword">END</span> IF<br></code></pre></td></tr></table></figure><p>如果此元组是由其他事务插入的，并且t_xmin的状态为IN_PROGRESS，那么这个元组显然是不可见的（规则4）。</p><p>如果t_xmin等于当前事务的txid（即，此元组是由当前事务插入的）并且t_xmax不是INVALID，那么这个元组<br>是不可见的，因为它已经被当前事务更新或删除了（规则3）。</p><p>例外情况是当此元组是由当前事务插入并且t_xmax为INVALID时。在这种情况下，从当前事务的角度看，<br>此元组必须是可见的（规则2），因为这个元组是当前事务自身插入的元组。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_10.png" alt="img_10.png"></p><h4 id="5-6-3-Status-of-t-xmin-is-COMMITTED"><a href="#5-6-3-Status-of-t-xmin-is-COMMITTED" class="headerlink" title="5.6.3. Status of t_xmin is COMMITTED"></a>5.6.3. Status of t_xmin is COMMITTED</h4><p>当元组的t_xmin状态为COMMITTED时，该元组通常是可见的（规则6、8和9），除非满足以下三个条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"> <span class="hljs-comment">/* t_xmin status == COMMITTED */</span><br>        IF t_xmin status <span class="hljs-keyword">is</span> <span class="hljs-string">&#x27;COMMITTED&#x27;</span> <span class="hljs-keyword">THEN</span><br>Rule <span class="hljs-number">5</span>:        IF t_xmin <span class="hljs-keyword">is</span> <span class="hljs-string">&#x27;active&#x27;</span> <span class="hljs-keyword">in</span> the obtained transaction snapshot <span class="hljs-keyword">THEN</span><br>                      <span class="hljs-keyword">RETURN</span> <span class="hljs-string">&#x27;Invisible&#x27;</span><br>Rule <span class="hljs-number">6</span>:        <span class="hljs-keyword">ELSE</span> IF t_xmax <span class="hljs-operator">=</span> INVALID <span class="hljs-keyword">OR</span> status <span class="hljs-keyword">of</span> t_xmax <span class="hljs-keyword">is</span> <span class="hljs-string">&#x27;ABORTED&#x27;</span> <span class="hljs-keyword">THEN</span><br>                      <span class="hljs-keyword">RETURN</span> <span class="hljs-string">&#x27;Visible&#x27;</span><br>               <span class="hljs-keyword">ELSE</span> IF t_xmax status <span class="hljs-keyword">is</span> <span class="hljs-string">&#x27;IN_PROGRESS&#x27;</span> <span class="hljs-keyword">THEN</span><br>Rule <span class="hljs-number">7</span>:               IF t_xmax <span class="hljs-operator">=</span>  current_txid <span class="hljs-keyword">THEN</span><br>                             <span class="hljs-keyword">RETURN</span> <span class="hljs-string">&#x27;Invisible&#x27;</span><br>Rule <span class="hljs-number">8</span>:               <span class="hljs-keyword">ELSE</span>  <span class="hljs-comment">/* t_xmax != current_txid */</span><br>                             <span class="hljs-keyword">RETURN</span> <span class="hljs-string">&#x27;Visible&#x27;</span><br>                      <span class="hljs-keyword">END</span> IF<br>               <span class="hljs-keyword">ELSE</span> IF t_xmax status <span class="hljs-keyword">is</span> <span class="hljs-string">&#x27;COMMITTED&#x27;</span> <span class="hljs-keyword">THEN</span><br>Rule <span class="hljs-number">9</span>:               IF t_xmax <span class="hljs-keyword">is</span> <span class="hljs-string">&#x27;active&#x27;</span> <span class="hljs-keyword">in</span> the obtained transaction snapshot <span class="hljs-keyword">THEN</span><br>                             <span class="hljs-keyword">RETURN</span> <span class="hljs-string">&#x27;Visible&#x27;</span><br>Rule <span class="hljs-number">10</span>:              <span class="hljs-keyword">ELSE</span><br>                             <span class="hljs-keyword">RETURN</span> <span class="hljs-string">&#x27;Invisible&#x27;</span><br>                      <span class="hljs-keyword">END</span> IF<br>               <span class="hljs-keyword">END</span> IF<br>        <span class="hljs-keyword">END</span> IF<br></code></pre></td></tr></table></figure><p>规则6很明显，因为t_xmax是INVALID或ABORTED。接下来描述三个例外条件以及规则8和9：</p><p>第一个例外条件是t_xmin在获取的事务快照中是活动的（规则5）。在这种情况下，该元组是不可见的，<br>因为应将t_xmin视为仍在进行中。</p><p>第二个例外条件是t_xmax等于当前txid（规则7）。在这种情况下，如同规则3，该元组是不可见的，<br>因为它已经被当前事务自身更新或删除。</p><p>相比之下，如果t_xmax的状态是IN_PROGRESS且t_xmax不是当前txid（规则8），那么该元组是可见的，<br>因为它尚未被删除。</p><p>第三个例外条件是t_xmax的状态为COMMITTED且在获取的事务快照中t_xmax不活跃（规则10）。<br>在这种情况下，该元组是不可见的，因为它已被另一个事务更新或删除。</p><p>相反，如果t_xmax的状态为COMMITTED，但在获取的事务快照中t_xmax是活动的（规则9），那么该元组是可见的，<br>因为应将t_xmax视为仍在进行中。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_11.png" alt="img_11.png"></p><h3 id="5-7-可见性检查"><a href="#5-7-可见性检查" class="headerlink" title="5.7 可见性检查"></a><a name="v-do"></a>5.7 可见性检查</h3><p>本节说明了PostgreSQL如何执行可见性检查，这是在给定事务中选取适当版本的堆元组的过程。此外，本节还介绍了PostgreSQL<br>如何防止ANSI SQL-92标准中定义的几种异常情况：脏读（Dirty Reads）、<br>可重复读（Repeatable Reads）和幻读（Phantom Reads）。</p><h4 id="5-7-1-Visibility-Check"><a href="#5-7-1-Visibility-Check" class="headerlink" title="5.7.1. Visibility Check"></a>5.7.1. Visibility Check</h4><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_12.png" alt="img_12.png"></p><p>在图5.10所示的场景中，SQL命令按照以下时间序列执行：</p><p>T1: 开始事务（txid 200）<br>T2: 开始事务（txid 201）<br>T3: 执行txid 200和201的SELECT命令<br>T4: 执行txid 200的UPDATE命令<br>T5: 再次执行txid 200和201的SELECT命令<br>T6: 提交txid 200<br>T7: 执行txid 201的SELECT命令  </p><p>为简化描述，假设仅有两个事务，即txid 200和txid 201。txid 200的隔离级别为READ COMMITTED，<br>而txid 201的隔离级别为READ COMMITTED或REPEATABLE READ。</p><p>接下来，我们探究SELECT命令是如何对每个元组执行可见性检查的。</p><p>我们来探讨T3时刻的SELECT命令是如何对每个元组进行可见性检查的。</p><p>在T3时刻，表’tbl’中仅有Tuple_1这一条元组，并且根据规则6，Tuple_1对所有事务都是可见的。<br>因此，txid 200和txid 201的SELECT命令都会返回’Jekyll’。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_13.png" alt="img_13.png"></p><p>T5时刻的SELECT命令执行情况如下：</p><p>首先，考察txid 200执行的SELECT命令。根据规则7，Tuple_1对txid 200是不可见的，<br>因为Tuple_1已被同一事务内的UPDATE操作所修改；而Tuple_2根据规则2是可见的，因为它是txid 200自己的<br>插入操作产生的。因此，txid 200的这次SELECT命令会返回’Hyde’。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_14.png" alt="img_14.png"></p><p>另一方面，在txid 201执行的SELECT命令中，Tuple_1根据规则8是可见的，<br>因为它虽然被其他事务（txid 200）更新，但更新事务并未提交；而Tuple_2根据规则4是不可见的，<br>因为txid 201在其事务快照中认为txid 200的修改尚未发生。因此，txid 201的这次SELECT命令<br>会返回’Jekyll’。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_15.png" alt="img_15.png"></p><p>如果在事务提交之前，其他事务能够看到被更新的元组，这种情况被称为脏读（Dirty Reads），<br>也称为写-读冲突（wr-conflicts）。然而，如上所示，在PostgreSQL的任何隔离级别中都不会发生脏读。</p><p>T7时刻的SELECT命令：</p><p>接下来，描述T7时刻的SELECT命令在两种隔离级别下的行为。</p><p>当txid 201处于READ COMMITTED隔离级别时，由于事务快照为‘201:201:’，所以txid 200被视为已提交。<br>因此，根据规则10，Tuple_1对txid 201不可见；而根据规则6，Tuple_2对txid 201是可见的。这次SELECT命令的<br>结果是返回’Hyde’。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_16.png" alt="img_16.png"></p><p>需要注意的是，在txid 200提交前后执行的SELECT命令得到的结果不同。<br>这通常被称为不可重复读（Non-Repeatable Reads）现象。</p><p>相反，当txid 201处于REPEATABLE READ隔离级别时，因为其事务快照为‘200:200:’，<br>所以必须将txid 200视为仍在进行中。因此，根据规则9，Tuple_1对txid 201是可见的；<br>而根据规则5，Tuple_2对txid 201是不可见的。这次SELECT命令的结果是返回’Jekyll’。</p><p>请注意，在REPEATABLE READ（以及SERIALIZABLE）隔离级别下，不会发生不可重复读现象。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_17.png" alt="img_17.png"></p><blockquote><p>Hint Bits</p><p>为了获取事务的状态，PostgreSQL内部提供了三个函数：TransactionIdIsInProgress、<br>TransactionIdDidCommit和TransactionIdDidAbort。这些函数设计来减少对事务状态日志（clog）频繁的访问，<br>可能会利用缓存等机制来优化。但是，如果每次检查元组时都要执行这些函数，仍然可能会成为瓶颈。</p><p>为了解决这个问题，PostgreSQL采用了提示位（hint bits）机制，具体如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">#<span class="hljs-keyword">define</span> HEAP_XMIN_COMMITTED       <span class="hljs-number">0x0100</span>   <span class="hljs-comment">/* t_xmin committed */</span><br>#<span class="hljs-keyword">define</span> HEAP_XMIN_INVALID         <span class="hljs-number">0x0200</span>   <span class="hljs-comment">/* t_xmin invalid/aborted */</span><br>#<span class="hljs-keyword">define</span> HEAP_XMAX_COMMITTED       <span class="hljs-number">0x0400</span>   <span class="hljs-comment">/* t_xmax committed */</span><br>#<span class="hljs-keyword">define</span> HEAP_XMAX_INVALID         <span class="hljs-number">0x0800</span>   <span class="hljs-comment">/* t_xmax invalid/aborted */</span><br></code></pre></td></tr></table></figure><p>在读取或写入元组时，如果可能，PostgreSQL会在元组的t_infomask中设置提示位。例如，<br>假设PostgreSQL检查了一个元组的t_xmin状态，并发现其为COMMITTED。此时，PostgreSQL就会在该元组的<br>t_infomask中设置HEAP_XMIN_COMMITTED提示位。一旦设置了提示位，之后对于该元组的t_xmin来说，<br>就不再需要调用TransactionIdDidCommit和TransactionIdDidAbort函数了。因此，PostgreSQL能够高效地<br>检查每个元组的t_xmin和t_xmax状态。</p><p>提示位机制显著提高了处理事务状态验证的效率，减少了对clog的直接访问需求，从而提升了数据库的整体性能。</p></blockquote><h3 id="5-8-防止丢失更新"><a href="#5-8-防止丢失更新" class="headerlink" title="5.8 防止丢失更新"></a><a name="prevent-update"></a>5.8 防止丢失更新</h3><p>丢失更新（又称写-写冲突）是指并发事务同时更新同一行数据时出现的一种异常情况，<br>必须在可重复读（REPEATABLE READ）和可串行化（SERIALIZABLE）隔离级别中防止此类问题的发生。<br>（需要注意的是，读已提交（READ COMMITTED）隔离级别并不需要防止丢失更新。）<br>本节将阐述PostgreSQL如何防止丢失更新现象，并给出相应示例。</p><h4 id="5-8-1-Behavior-of-Concurrent-UPDATE-Commands"><a href="#5-8-1-Behavior-of-Concurrent-UPDATE-Commands" class="headerlink" title="5.8.1. Behavior of Concurrent UPDATE Commands"></a>5.8.1. Behavior of Concurrent UPDATE Commands</h4><p>当执行UPDATE命令时，内部会调用函数ExecUpdate。以下是ExecUpdate的伪代码表示：</p><p>Pseudocode: ExecUpdate:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sql">(<span class="hljs-number">1</span>)   <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span> that will be updated <span class="hljs-keyword">by</span> this <span class="hljs-keyword">UPDATE</span> command<br>(<span class="hljs-number">2</span>)        WHILE <span class="hljs-literal">true</span><br><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * The First Block</span><br><span class="hljs-comment">                 */</span><br>(<span class="hljs-number">3</span>)             IF the target <span class="hljs-type">row</span> <span class="hljs-keyword">is</span> <span class="hljs-string">&#x27;being updated&#x27;</span> <span class="hljs-keyword">THEN</span><br>(<span class="hljs-number">4</span>)             WAIT <span class="hljs-keyword">for</span> the termination <span class="hljs-keyword">of</span> the transaction that updated the target <span class="hljs-type">row</span><br><br>(<span class="hljs-number">5</span>)                  IF (the status <span class="hljs-keyword">of</span> the terminated transaction <span class="hljs-keyword">is</span> COMMITTED)<br>                  <span class="hljs-keyword">AND</span> (the isolation level <span class="hljs-keyword">of</span> this transaction <span class="hljs-keyword">is</span> REPEATABLE READ <span class="hljs-keyword">or</span> SERIALIZABLE) <span class="hljs-keyword">THEN</span><br>(<span class="hljs-number">6</span>)                  ABORT this transaction  <span class="hljs-comment">/* First-Updater-Win */</span><br>                     <span class="hljs-keyword">ELSE</span> <br>(<span class="hljs-number">7</span>)                       GOTO step (<span class="hljs-number">2</span>)<br>                     <span class="hljs-keyword">END</span> IF<br><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * The Second Block</span><br><span class="hljs-comment">                 */</span><br>(<span class="hljs-number">8</span>)             <span class="hljs-keyword">ELSE</span> IF the target <span class="hljs-type">row</span> has been updated <span class="hljs-keyword">by</span> another concurrent transaction <span class="hljs-keyword">THEN</span><br>(<span class="hljs-number">9</span>)                  IF (the isolation level <span class="hljs-keyword">of</span> this transaction <span class="hljs-keyword">is</span> READ COMMITTED <span class="hljs-keyword">THEN</span><br>(<span class="hljs-number">10</span>)                      <span class="hljs-keyword">UPDATE</span> the target <span class="hljs-type">row</span><br>                     <span class="hljs-keyword">ELSE</span><br>(<span class="hljs-number">11</span>)                      ABORT this transaction  <span class="hljs-comment">/* First-Updater-Win */</span><br>                     <span class="hljs-keyword">END</span> IF<br><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * The Third Block</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">ELSE</span>  <span class="hljs-comment">/* The target row is not yet modified               */</span><br>                      <span class="hljs-comment">/* or has been updated by a terminated transaction. */</span><br>(<span class="hljs-number">12</span>)                  <span class="hljs-keyword">UPDATE</span> the target <span class="hljs-type">row</span><br>                <span class="hljs-keyword">END</span> IF<br>           <span class="hljs-keyword">END</span> WHILE <br>      <span class="hljs-keyword">END</span> <span class="hljs-keyword">FOR</span> <br></code></pre></td></tr></table></figure><p>(1) 获取此UPDATE命令将要更新的每一行。</p><p>(2) 重复以下过程，直到目标行被更新（或当前事务被中止）。</p><p>(3) 如果目标行正在被其他事务更新，则转到步骤(3)；否则，转到步骤(8)。</p><p>(4) 等待更新目标行的事务终止，因为在SI（Serializable Isolation）中，<br>PostgreSQL采用先更新者获胜的策略。</p><p>(5) 如果更新目标行的事务状态为COMMITTED，并且当前事务的隔离级别为<br>REPEATABLE READ（或SERIALIZABLE），则转到步骤(6)；否则，转到步骤(7)。</p><p>(6) 中止当前事务以防止丢失更新。</p><p>(7) 转到步骤(2)，并在下一轮尝试再次更新目标行。</p><p>(8) 如果目标行已被其他并发事务更新，则转到步骤(9)；否则，转到步骤(12)。</p><p>(9) 如果当前事务的隔离级别为READ COMMITTED，则转到步骤(10)；否则，转到步骤(11)。</p><p>(10) 更新目标行，然后转到步骤(1)。</p><p>(11) 中止当前事务以防止丢失更新。</p><p>(12) 更新目标行，然后转到步骤(1)，因为目标行尚未被修改或已被终止的事务更新，<br>即存在写-写冲突（ww-conflict）。</p><p>此函数依次为每个待更新的目标行执行更新操作。它有一个外层循环来更新每一行，<br>而内部while循环则包含了三个分支，分支条件如图5.11所示。<br><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_18.png" alt="img_18.png"></p><p>[1] 目标行正在被更新（图5.11[1]）<br>“正在被更新”意味着该行正被另一个并发事务更新，且该事务还未终止。<br>在这种情况下，当前事务必须等待更新目标行的事务终止，因为PostgreSQL的SI（Serializable Isolation）<br>采用先更新者获胜的策略。<br>例如，假设事务Tx_A和Tx_B并发运行，Tx_B尝试更新一行，但Tx_A已经更新了它且还在进行中。<br>在这种情况下，Tx_B会等待Tx_A终止。在更新目标行的事务提交后，当前事务的更新操作将继续进行。<br>如果当前事务处于READ COMMITTED隔离级别，目标行将被更新；<br>否则（在REPEATABLE READ或SERIALIZABLE级别），当前事务会立即中止以防止丢失更新。</p><p>[2] 目标行已被并发事务更新（图5.11[2]）<br>当前事务尝试更新目标元组，但另一个并发事务已经更新了目标行并已提交。<br>在这种情况下，如果当前事务处于READ COMMITTED隔离级别，目标行将被更新；<br>否则，当前事务会立即中止以防止丢失更新。</p><p>[3] 无冲突（图5.11[3]）<br>当没有冲突时，当前事务可以直接更新目标行。</p><blockquote><p> First-updater-win &#x2F; First-commiter-win<br>如本节所述，PostgreSQL基于SI（Serializable Isolation）的并发控制采用了“先更新者获胜”的策略来避免丢失更新异常。<br>相比之下，正如下一节所解释的，<br>PostgreSQL的SSI（Serializable Snapshot Isolation）采用的是“先提交者获胜”的策略来避免序列化异常。</p></blockquote><h4 id="5-8-2-Examples"><a href="#5-8-2-Examples" class="headerlink" title="5.8.2. Examples"></a>5.8.2. Examples</h4><p>下面将通过三个例子进行说明。前两个例子展示了目标行正在被更新时的行为，<br>第三个例子展示了目标行已被更新时的行为。</p><h5 id="5-8-2-1-Example-1"><a href="#5-8-2-1-Example-1" class="headerlink" title="5.8.2.1. Example 1"></a>5.8.2.1. Example 1</h5><p>Transactions Tx_A and Tx_B update the same row in the same table,<br>and their isolation level is READ COMMITTED.</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_19.png" alt="img_19.png"></p><p>Tx_B的执行过程如下：</p><p>执行UPDATE命令后，Tx_B应当等待Tx_A终止，因为目标元组正被Tx_A更新（遵循ExecUpdate中的步骤(4)）。<br>Tx_A提交后，Tx_B尝试更新目标行（遵循ExecUpdate中的步骤(7)）。<br>在ExecUpdate的下一轮循环中，目标行被Tx_B再次更新（遵循ExecUpdate中的步骤(2),(8),(9),(10)）。  </p><h5 id="5-8-2-2-Example-2"><a href="#5-8-2-2-Example-2" class="headerlink" title="5.8.2.2. Example 2"></a>5.8.2.2. Example 2</h5><p>Tx_A and Tx_B update the same row in the same table, and their isolation levels<br>are READ COMMITTED and REPEATABLE READ, respectively.</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_20.png" alt="img_20.png"></p><p>Tx_B的行为描述如下：</p><p>执行UPDATE命令后，Tx_B需要等待Tx_A终止（遵循ExecUpdate中的步骤(4)）。<br>在Tx_A提交后，由于目标行已被更新，并且当前事务Tx_B的隔离级别为REPEATABLE READ，<br>因此Tx_B会被中止以解决冲突（遵循ExecUpdate中的步骤(5)和(6)）。</p><h5 id="5-8-2-3-Example-3"><a href="#5-8-2-3-Example-3" class="headerlink" title="5.8.2.3. Example 3"></a>5.8.2.3. Example 3</h5><p>Tx_B（处于REPEATABLE READ隔离级别）尝试更新已被提交的Tx_A更新过的目标行。<br>在这种情况下，Tx_B将会被中止（遵循ExecUpdate中的步骤(2),(8),(9)和(11)）。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_21.png" alt="img_21.png"></p><h3 id="5-9-可串行化快照隔离（SSI）"><a href="#5-9-可串行化快照隔离（SSI）" class="headerlink" title="5.9 可串行化快照隔离（SSI）"></a><a name="SSI"></a>5.9 可串行化快照隔离（SSI）</h3><p>可串行化快照隔离(Serializable Snapshot Isolation, SSI)自 9.1 版本开始就嵌入在<br>SI(Snapshot Isolation)中,以实现真正的可串行化隔离级别。由于对 SSI 的解释并不简单,<br>这里只给出概要。详细内容请参考原论文:”Serializable Snapshot Isolation in PostgreSQL”。</p><p>在下面的介绍中,将使用以下技术术语,但不作定义解释。如果您不熟悉这些术语,请参考相关参考资料:</p><p>优先级图(也称为依赖图和串行化图)<br>串行化异常(如写偏斜)</p><blockquote><p> References<br>Abraham Silberschatz, Henry F. Korth, and S. Sudarshan, “Database System Concepts”, McGraw-Hill Education, ISBN-13: 978-0073523323<br>Thomas M. Connolly, and Carolyn E. Begg, “Database Systems”, Pearson, ISBN-13: 978-0321523068</p></blockquote><h4 id="5-9-1-Basic-Strategy-for-SSI-Implementation"><a href="#5-9-1-Basic-Strategy-for-SSI-Implementation" class="headerlink" title="5.9.1. Basic Strategy for SSI Implementation"></a>5.9.1. Basic Strategy for SSI Implementation</h4><h3 id="5-10-必要的维护过程"><a href="#5-10-必要的维护过程" class="headerlink" title="5.10 必要的维护过程"></a><a name="5-process"></a>5.10 必要的维护过程</h3><p>PostgreSQL的并发控制机制需要以下维护进程:</p><p>删除死元组和指向相应死元组的索引元组。<br>删除日志文件(clog)中不必要的部分。<br>冻结旧的事务ID(txid)。<br>更新文件段映射(FSM)、可见性映射(VM)和统计信息。  </p><p>前两个过程的需求已分别在第5.3.2节和第5.4.3节中进行了解释。<br>第三个过程与事务ID环绕问题有关,将在以下小节中简要描述。</p><p>在PostgreSQL中,VACUUM处理负责这些过程,并在第6章中进行了描述。</p><h4 id="5-10-1-FREEZE-Processing"><a href="#5-10-1-FREEZE-Processing" class="headerlink" title="5.10.1. FREEZE Processing"></a>5.10.1. FREEZE Processing</h4><p>这里我描述了事务ID(txid)环绕问题。</p><p>假设元组Tuple_1以txid 100插入,即Tuple_1的t_xmin为100。</p><p>服务器已运行很长时间,Tuple_1未被修改。当前txid为21亿+100,执行一条SELECT命令。<br>此时,Tuple_1可见,因为txid 100在过去。然后再次执行相同的SELECT命令,此时当前txid为21亿+101。<br>但是,Tuple_1不再可见,因为txid 100在未来(图5.20)。</p><p>这就是PostgreSQL中所谓的事务ID环绕问题。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_22.png" alt="img_22.png"></p><p>为了解决这个问题,PostgreSQL引入了一个称为<br>“冻结事务ID(frozen txid)”的概念,并实现了一个称为”FREEZE”的进程。</p><p>在PostgreSQL中,冻结事务ID是一个特殊的保留事务ID 2,它始终比所有其他事务ID更旧。换句话说,<br>冻结事务ID始终处于非活动状态并可见。</p><p>FREEZE进程由VACUUM进程调用。FREEZE进程扫描所有表文件,如果t_xmin值比当前事务ID减去<br>vacuum_freeze_min_age(默认为5000万)更旧,就将元组的t_xmin值重写为冻结事务ID(2)。<br>这在第6章中有更详细的解释。</p><p>例如,如图5.21a所示,当前事务ID为5000万,并由VACUUM命令调用FREEZE进程。<br>在这种情况下,Tuple_1和Tuple_2的t_xmin都被重写为2。</p><p>在9.4或更高版本中,XMIN_FROZEN位被设置在元组的t_infomask字段中,<br>而不是将t_xmin重写为冻结事务ID(图5.21b)。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch5/ch5/img_23.png" alt="img_23.png"></p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL指南：内幕探索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch3. 外部数据包装器</title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch4/ch4/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch4/ch4/</url>
    
    <content type="html"><![CDATA[<h2 id="ch4-外部数据包装器"><a href="#ch4-外部数据包装器" class="headerlink" title="ch4. 外部数据包装器"></a>ch4. 外部数据包装器</h2><p>2003年，SQL标准增加了一项访问远程数据的规范，称为SQL外部数据管理（SQL&#x2F;MED, <a href="https://wiki.postgresql.org/wiki/SQL/MED%EF%BC%89%E3%80%82PostgreSQL%E4%BB%8E9.1%E7%89%88%E6%9C%AC">https://wiki.postgresql.org/wiki/SQL/MED）。PostgreSQL从9.1版本</a><br>开始就一直在开发这项功能，以实现SQL&#x2F;MED的部分功能。</p><p>在SQL&#x2F;MED中，位于远程服务器上的表被称为外部表。PostgreSQL的<br>外部数据包装器（Foreign Data Wrappers, FDW）利用SQL&#x2F;MED来管理这些外部表，这些外部表在使用上与本地表相似。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch4/ch4/img.png" alt="img.png"></p><p>在安装了必需的扩展并进行了恰当的设置后，你就能访问远程服务器上的外部表了。举个例子，假设存在两个远程服务器，<br>一个是运行PostgreSQL的，包含表foreign_pg_tbl；另一个是运行MySQL的，包含表foreign_my_tbl。在这种情况下，<br>你可以通过在本地服务器上执行以下SELECT查询来访问这些远程表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">localdb<span class="hljs-operator">=</span># <span class="hljs-comment">-- foreign_pg_tbl is on the remote postgresql server. </span><br>localdb<span class="hljs-operator">-</span># <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> foreign_pg_tbl;<br> count <br><span class="hljs-comment">-------</span><br> <span class="hljs-number">20000</span><br><br>localdb<span class="hljs-operator">=</span># <span class="hljs-comment">-- foreign_my_tbl is on the remote mysql server. </span><br>localdb<span class="hljs-operator">-</span># <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> foreign_my_tbl;<br> count <br><span class="hljs-comment">-------</span><br> <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><p>你也可以像操作本地表那样，对存储在不同服务器上的外部表执行联接操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">localdb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> foreign_pg_tbl <span class="hljs-keyword">AS</span> p, foreign_my_tbl <span class="hljs-keyword">AS</span> m <span class="hljs-keyword">WHERE</span> p.id <span class="hljs-operator">=</span> m.id;<br> count <br><span class="hljs-comment">-------</span><br> <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><p>已经开发了许多外部数据包装器（FDW, <a href="https://wiki.postgresql.org/wiki/Foreign_data_wrappers%EF%BC%89%E6%89%A9%E5%B1%95%EF%BC%8C">https://wiki.postgresql.org/wiki/Foreign_data_wrappers）扩展，</a><br>并在Postgres维基(<a href="https://www.postgresql.org/docs/current/postgres-fdw.html)%E4%B8%8A%E5%88%97%E5%87%BA%E3%80%82%E7%84%B6%E8%80%8C%EF%BC%8C%E5%87%A0%E4%B9%8E%E6%89%80%E6%9C%89%E7%9A%84%E6%89%A9%E5%B1%95%E9%83%BD%E6%9C%AA%E8%83%BD%E5%BE%97%E5%88%B0%E5%A6%A5%E5%96%84%E7%BB%B4%E6%8A%A4%EF%BC%8C">https://www.postgresql.org/docs/current/postgres-fdw.html)上列出。然而，几乎所有的扩展都未能得到妥善维护，</a><br>例外的是postgres_fdw，它是由PostgreSQL全球开发集团官方开发和维护的扩展，用于访问远程的PostgreSQL服务器。</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#4-Overview">4.1 概述</a></td></tr><tr><td><a href="#postgres_fdw">4.2 postgres_fdw</a></td></tr></tbody></table><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a><a name="4-Overview"></a>4.1 概述</h3><p>为了使用FDW特性，你需要安装合适的扩展并执行一些设置命令，<br>如CREATE FOREIGN TABLE、CREATE SERVER和CREATE USER MAPPING。<br>（具体操作详情，请参考官方文档。<a href="https://www.postgresql.org/docs/current/postgres-fdw.html#AEN180314%EF%BC%89">https://www.postgresql.org/docs/current/postgres-fdw.html#AEN180314）</a></p><p>在进行了适当的配置后，在查询处理期间，扩展中定义的函数会被调用来访问外部表。</p><p>图4.2简要说明了FDW在PostgreSQL中是如何运作的。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch4/ch4/img_1.png" alt="img_1.png"></p><p>(1) 分析器&#x2F;分析程序根据输入的SQL创建查询树。<br>(2) 规划器（或执行器）连接到远程服务器。<br>(3) 如果use_remote_estimate选项设置为‘on’（默认为‘off’），规划器会执行EXPLAIN命令以估算每个计划路径的成本。<br>(4) 规划器根据计划树生成一个纯文本的SQL语句，这一过程内部称为反解析（deparse）。<br>(5) 执行器将纯文本的SQL语句发送到远程服务器并接收结果。  </p><p>然后，执行器根据需要处理接收到的数据。例如，如果执行的是多表查询，<br>执行器会对接收到的数据与其他表进行连接处理。</p><p>各项处理的具体细节将在后续章节中进行描述。</p><h4 id="4-1-1-Creating-a-Query-Tree"><a href="#4-1-1-Creating-a-Query-Tree" class="headerlink" title="4.1.1. Creating a Query Tree"></a>4.1.1. Creating a Query Tree</h4><p>分析器&#x2F;分析程序利用存储在pg_catalog.pg_class和pg_catalog.pg_foreign_table目录中的外部表定义<br>来创建输入SQL的查询树。<br>这些外部表是通过CREATE FOREIGN TABLE或IMPORT FOREIGN SCHEMA命令创建并存储的。</p><h4 id="4-1-2-Connecting-to-the-Remote-Server"><a href="#4-1-2-Connecting-to-the-Remote-Server" class="headerlink" title="4.1.2. Connecting to the Remote Server"></a>4.1.2. Connecting to the Remote Server</h4><p>为了连接到远程服务器，规划器（或执行器）会使用适当的库来建立与远程数据库服务器的连接。<br>例如，若要连接到远程的PostgreSQL服务器，postgres_fdw扩展就会使用libpq库。而对于连接MySQL服务器，<br>由EnterpriseDB开发的mysql_fdw扩展则会采用libmysqlclient库。</p><p>连接参数，诸如用户名、服务器IP地址和端口号等，是通过CREATE USER MAPPING和CREATE SERVER命令存储在<br>pg_catalog.pg_user_mapping和pg_catalog.pg_foreign_server目录中的。</p><h4 id="4-1-3-Creating-a-Plan-Tree-Using-EXPLAIN-Commands-Optional"><a href="#4-1-3-Creating-a-Plan-Tree-Using-EXPLAIN-Commands-Optional" class="headerlink" title="4.1.3. Creating a Plan Tree Using EXPLAIN Commands (Optional)"></a>4.1.3. Creating a Plan Tree Using EXPLAIN Commands (Optional)</h4><p>PostgreSQL的FDW支持获取外部表的统计信息，以便估计查询的计划树。一些FDW扩展，<br>如postgres_fdw、mysql_fdw、tds_fdw和jdbc2_fdw，都会利用这些统计信息。</p><p>如果通过ALTER SERVER命令将use_remote_estimate选项设置为‘on’，规划器将通过执行EXPLAIN命令向远程服务器<br>查询计划的成本。否则，默认情况下会使用嵌入的常量值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">localdb<span class="hljs-operator">=</span># <span class="hljs-keyword">ALTER</span> SERVER remote_server_name OPTIONS (use_remote_estimate <span class="hljs-string">&#x27;on&#x27;</span>);<br></code></pre></td></tr></table></figure><p>虽然一些扩展利用了EXPLAIN命令的值，但只有postgres_fdw能够反映EXPLAIN命令的结果，<br>因为PostgreSQL的EXPLAIN命令会返回启动成本和总成本。</p><p>EXPLAIN命令的执行结果并不能被其他数据库管理系统（DBMS）的FDW扩展用于规划目的。<br>例如，MySQL的EXPLAIN命令仅返回行的估计数量。<br>然而，PostgreSQL的查询优化器需要更多如第3章所述的信息来估算成本。</p><h4 id="4-1-4-Deparesing"><a href="#4-1-4-Deparesing" class="headerlink" title="4.1.4. Deparesing"></a>4.1.4. Deparesing</h4><p>为了生成计划树，规划器会根据外部表在计划树中的扫描路径生成一段纯文本的SQL语句。<br>例如，图4.3展示了一个SELECT语句的计划树结构。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">localdb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tbl_a <span class="hljs-keyword">AS</span> a <span class="hljs-keyword">WHERE</span> a.id <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>图4.3展示的是，在源自PlannedStmt的计划树中，ForeignScan节点存储了一段纯文本的SELECT语句。在这里，postgres_fdw<br>从已经过解析和分析而创建的查询树中重新生成这段纯文本的SELECT语句，<br>这一过程在PostgreSQL中被称为反解析(deparsing)。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch4/ch4/img_2.png" alt="img_2.png"></p><p>mysql_fdw 的使用会根据查询树重新创建一个针对MySQL的SELECT文本。<br>而redis_fdw或rw_redis_fdw的使用，则用于生成一个SELECT命令。</p><h4 id="4-1-5-Sending-SQL-Statements-and-Receiving-Result"><a href="#4-1-5-Sending-SQL-Statements-and-Receiving-Result" class="headerlink" title="4.1.5. Sending SQL Statements and Receiving Result"></a>4.1.5. Sending SQL Statements and Receiving Result</h4><p>在解析之后，执行器会将解析后的SQL语句发送到远程服务器并接收结果。</p><p>向远程服务器发送SQL语句的方法取决于每个扩展的开发者。例如，mysql_fdw发送SQL语句时不使用事务。<br>在mysql_fdw中执行SELECT查询的典型SQL语句序列如下所示（图4.4）。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch4/ch4/img_3.png" alt="img_3.png"></p><p>(5-1) 将SQL_MODE设置为‘ANSI_QUOTES’。<br>(5-2) 向远程服务器发送SELECT语句。<br>(5-3) 从远程服务器接收结果。<br>在此过程中，mysql_fdw会将结果转换为PostgreSQL可读的数据格式。  </p><p>所有FDW扩展都实现了将结果转换为PostgreSQL可读数据的功能。  </p><p>Actual log of the remote server: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> command_type,argument <span class="hljs-keyword">FROM</span> mysql.general_log;<br><span class="hljs-operator">+</span><span class="hljs-comment">--------------+-----------------------------------------------------------------------+</span><br><span class="hljs-operator">|</span> command_type <span class="hljs-operator">|</span> argument                                                              <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------+-----------------------------------------------------------------------+</span><br>... snip ...<br><br><span class="hljs-operator">|</span> Query        <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> sql_mode<span class="hljs-operator">=</span><span class="hljs-string">&#x27;ANSI_QUOTES&#x27;</span>                                            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">Prepare</span>      <span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> `id`, `data` <span class="hljs-keyword">FROM</span> `localdb`.`tbl_a` <span class="hljs-keyword">WHERE</span> ((`id` <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span>))        <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">Close</span> stmt   <span class="hljs-operator">|</span>                                                                       <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">--------------+-----------------------------------------------------------------------+</span><br></code></pre></td></tr></table></figure><p>在postgres_fdw中，SQL命令的序列更为复杂。执行SELECT查询时，<br>postgres_fdw中典型的SQL语句序列如下所示（图4.5）。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch4/ch4/img_4.png" alt="img_4.png"></p><p>(5-1) 开启远程事务。<br>远程事务的默认隔离级别是REPEATABLE READ；如果本地事务的隔离级别设置为SERIALIZABLE，<br>那么远程事务也会被设置为SERIALIZABLE。<br>(5-2)至(5-4) 声明游标。<br>SQL语句基本上作为游标来执行。<br>(5-5) 执行FETCH命令以获取结果。<br>默认情况下，FETCH命令每次获取100行数据。<br>(5-6) 从远程服务器接收结果。<br>(5-7) 关闭游标。<br>(5-8) 提交远程事务。  </p><p> Actual log of the remote server</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">LOG:  statement: START TRANSACTION ISOLATION LEVEL REPEATABLE READ<br>LOG:  parse &lt;unnamed&gt;: DECLARE c1 CURSOR FOR SELECT id, data FROM public.tbl_a WHERE ((id &lt; 10))<br>LOG:  bind &lt;unnamed&gt;: DECLARE c1 CURSOR FOR SELECT id, data FROM public.tbl_a WHERE ((id &lt; 10))<br>LOG:  execute &lt;unnamed&gt;: DECLARE c1 CURSOR FOR SELECT id, data FROM public.tbl_a WHERE ((id &lt; 10))<br>LOG:  statement: FETCH 100 FROM c1<br>LOG:  statement: CLOSE c1<br>LOG:  statement: COMMIT TRANSACTION<br></code></pre></td></tr></table></figure><blockquote><p>The default remote transaction isolation level in postgres_fdw.</p><p>关于为什么默认的远程事务隔离级别设置为REPEATABLE READ的原因，在官方文档中有详细解释。(<a href="https://www.postgresql.org/docs/current/postgres-fdw.html#id-1.11.7.43.12">https://www.postgresql.org/docs/current/postgres-fdw.html#id-1.11.7.43.12</a>)</p><p>当本地事务采用SERIALIZABLE隔离级别时，远程事务也将使用SERIALIZABLE隔离级别；<br>否则，它将使用REPEATABLE READ隔离级别。这样的选择确保了如果查询在远程服务器上对多个表进行扫描，<br>所有扫描都将获得快照一致性的结果。其后果是，在同一事务中的连续查询将看到来自远程服务器的相同数据，<br>即便由于其他活动导致远程服务器上有并发更新发生也是如此。</p></blockquote><h3 id="4-2-HOW-THE-POSTGRES-FDW-EXTENSION-PERFORMS"><a href="#4-2-HOW-THE-POSTGRES-FDW-EXTENSION-PERFORMS" class="headerlink" title="4.2 HOW THE POSTGRES_FDW EXTENSION PERFORMS"></a><a name="postgres_fdw"></a>4.2 HOW THE POSTGRES_FDW EXTENSION PERFORMS</h3><p>postgres_fdw扩展是一个特别的模块，由PostgreSQL全球开发集团官方维护，其源代码包含在PostgreSQL的源代码树中。</p><p>postgres_fdw随着时间逐步得到改进。表4.1展示了从官方文档中摘录的与postgres_fdw相关的发行说明。</p><table><thead><tr><th>Version</th><th>Description</th></tr></thead><tbody><tr><td>9.3</td><td>postgres_fdw模块发布。</td></tr><tr><td>9.6</td><td>考虑在远程服务器上执行排序。 <br> 考虑在远程服务器上执行连接操作。 <br> 当可行时，完全在远程服务器上执行UPDATE或DELETE。 <br> 允许设置抓取大小作为服务器或表选项。</td></tr><tr><td>10</td><td>尽可能将聚合函数推送到远程服务器。</td></tr><tr><td>11</td><td>支持将聚合操作推送到作为分区的外部表。<br> 支持使用JOIN在远程服务器上执行UPDATE和DELETE。</td></tr><tr><td>12</td><td>在更多情况下允许ORDER BY排序和LIMIT子句下推。</td></tr><tr><td>14</td><td>允许TRUNCATE操作应用于外部表。<br> 允许TRUNCATE操作应用于外部表。<br> 添加函数postgres_fdw_get_connections()以报告打开的外部服务器连接。</td></tr></tbody></table><p>上一节介绍了postgres_fdw如何处理单表查询，<br>接下来的子节将阐述其如何处理多表查询、排序操作及聚合函数。</p><p>本小节主要关注于SELECT语句的处理，但需注意，postgres_fdw同样能够处理其它数据操作语言<br>（DML，包括INSERT、UPDATE和DELETE）语句。</p><blockquote><p>Note: PostgreSQL’s FDW does not detect deadlock</p></blockquote><p>postgres_fdw扩展及FDW特性并不支持分布式锁管理器和分布式死锁检测功能。因此，死锁情况很容易产生。</p><p>例如，如果客户端A正在更新本地表tbl_local和外部表tbl_remote，同时客户端B正在更新tbl_remote和tbl_local，<br>那么这两个事务就形成了死锁状态，但PostgreSQL无法检测到这一死锁。因此，这些事务无法提交成功。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">localdb<span class="hljs-operator">=</span># <span class="hljs-comment">-- Client A</span><br>localdb<span class="hljs-operator">=</span># <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">BEGIN</span><br>localdb<span class="hljs-operator">=</span># <span class="hljs-keyword">UPDATE</span> tbl_local <span class="hljs-keyword">SET</span> data <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-number">1</span><br>localdb<span class="hljs-operator">=</span># <span class="hljs-keyword">UPDATE</span> tbl_remote <span class="hljs-keyword">SET</span> data <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">localdb<span class="hljs-operator">=</span># <span class="hljs-comment">-- Client B</span><br>localdb<span class="hljs-operator">=</span># <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">BEGIN</span><br>localdb<span class="hljs-operator">=</span># <span class="hljs-keyword">UPDATE</span> tbl_remote <span class="hljs-keyword">SET</span> data <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-number">1</span><br>localdb<span class="hljs-operator">=</span># <span class="hljs-keyword">UPDATE</span> tbl_local <span class="hljs-keyword">SET</span> data <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="4-2-1-Multi-Table-Query"><a href="#4-2-1-Multi-Table-Query" class="headerlink" title="4.2.1. Multi-Table Query"></a>4.2.1. Multi-Table Query</h4>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL指南：内幕探索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch3. 查询处理</title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch3/ch3/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch3/ch3/</url>
    
    <content type="html"><![CDATA[<h2 id="ch3-查询处理"><a href="#ch3-查询处理" class="headerlink" title="ch3. 查询处理"></a>ch3. 查询处理</h2><p>按照官方文件的描述,PostgreSQL 支持 2011 年 SQL 标准所需的大量功能。查询处理是 PostgreSQL 中最复杂的子系统,它有效地处理了支持的 SQL。本章概述了这种查询处理,特别关注查询优化。</p><p>本章包含以下三个部分:</p><p>第 1 部分: 第 3.1 节</p><p>本节概述了 PostgreSQL 中的查询处理。</p><p>第 2 部分: 第 3.2 - 3.4 节</p><p>这一部分解释了为单表查询获得最优计划所采取的步骤。第 3.2 和 3.3 节分别解释了估算成本和创建计划树的过程,第 3.4 节简要介绍了执行器的操作。</p><p>第 3 部分: 第 3.5 - 3.6 节</p><p>这一部分解释了为多表查询获得最优计划的过程。第 3.5 节描述了三种连接方法: 嵌套循环、合并和哈希连接。第 3.6 节解释了为多表查询创建计划树的过程。</p><p>PostgreSQL 支持三个技术上有趣且实用的特性: 外部数据包装器 (Foreign Data Wrappers, FDW)、并行查询和 JIT 编译。前者将在第 4 章中介绍,后两者超出了本文的范围。</p><blockquote><p>Warning!!</p><p>only 3.1 because of me!</p></blockquote><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#three-Overview">3.1 概述</a></td></tr><tr><td><a href="#cost-single-table">3.2 单表查询的成本估算</a></td></tr><tr><td><a href="#plan-single-table">3.3 单表查询计划树的创建</a></td></tr><tr><td><a href="#Executor-Performs">3.4 执行器的工作原理</a></td></tr><tr><td><a href="#Join-Operations">3.5 连接操作</a></td></tr><tr><td><a href="#plan-multi-table">3.6 多表查询计划树的创建</a></td></tr></tbody></table><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a><a name="three-Overview"></a>3.1 概述</h3><p>在PostgreSQL中，尽管从9.6版本开始实现的并行查询使用了多个后台工作者进程，<br>但基本的后台进程负责处理与之相连客户端发出的所有查询。这个后台进程包含五个子系统：</p><ol><li>解析器（Parser）</li></ol><p>解析器将文本形式的SQL语句转换为解析树。</p><ol start="2"><li>分析器&#x2F;解析器（Analyzer&#x2F;Analyser）</li></ol><p>分析器&#x2F;解析器对解析树进行语义分析，并生成查询树。</p><ol start="3"><li>重写器（Rewriter）</li></ol><p>如果存在这样的规则，重写器会使用规则系统中存储的规则来转换查询树。</p><ol start="4"><li>规划器（Planner）</li></ol><p>规划器根据查询树生成执行效率最高的计划树。</p><ol start="5"><li>执行器（Executor）</li></ol><p>执行器按照计划树创建的顺序访问表和索引来执行查询。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch3/ch3/img.png" alt="img.png"></p><p>本节将对这些子系统进行概览介绍。鉴于规划器（Planner）和执行器（Executor）的复杂性，它们的具体功能将在后续章节中进行详细阐述。</p><blockquote><p>PostgreSQL的查询处理过程在官方文档中有详细说明。<br><a href="https://www.postgresql.org/docs/current/overview.html">https://www.postgresql.org/docs/current/overview.html</a></p></blockquote><h4 id="3-1-1-Parser"><a href="#3-1-1-Parser" class="headerlink" title="3.1.1. Parser"></a>3.1.1. Parser</h4><p>解析器根据纯文本形式的SQL语句生成解析树，以便后续子系统解读。请看下面的示例查询，不做进一步描述。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> id, data <span class="hljs-keyword">FROM</span> tbl_a <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">300</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> data;<br></code></pre></td></tr></table></figure><p>解析树是一种树形结构，其根节点是由parsenodes.h中定义的SelectStmt结构。<br>图3.2(b)展示了图3.2(a)中所示查询的解析树。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch3/ch3/img_1.png" alt="img_1.png"></p><p>SELECT查询中的各元素及其在解析树中对应的元素编号相同。例如，(1) 是目标列表中的第一项，代表表中的 ‘id’ 列；<br>(4) 是WHERE子句；以此类推。</p><p>解析器在生成解析树时仅检查输入的语法。因此，只有当查询中存在语法错误时，它才会返回错误。</p><p>解析器不检查输入查询的语义。例如，即使查询中包含一个不存在的表名，<br>解析器也不会返回错误。语义检查由分析器&#x2F;解析器完成。</p><h4 id="3-1-2-Analyzer-Analyser"><a href="#3-1-2-Analyzer-Analyser" class="headerlink" title="3.1.2. Analyzer&#x2F;Analyser"></a>3.1.2. Analyzer&#x2F;Analyser</h4><p>分析器&#x2F;分析程序会对解析器生成的解析树执行语义分析，并生成查询树。</p><p>查询树的根节点是由 parsenodes.h  (src&#x2F;include&#x2F;nodes&#x2F;parsenodes.h) 文件定义的 Query 结构体。<br>该结构体包含了与其对应的查询相关元数据，如命令类型（SELECT、INSERT 等），以及多个子节点。<br>每一个子节点组成一个列表或树形结构，用于存储各个具体子句的信息。</p><p>图 3.3 描述了前一小节中图 3.2(a) 所示查询的查询树结构。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch3/ch3/img_2.png" alt="img_2.png"></p><p>上述查询树简要说明如下：</p><p>目标列表（targetlist）：是查询结果中的列列表。在此例中，列表包含两列：’id’ 和 ‘data’。<br>如果输入的查询树使用了 ‘*’（星号），分析器&#x2F;分析程序会将其显式替换为所有列。</p><p>范围表（range table）：是查询中使用到的关系列表。在此例中，列表包含了表 ‘tbl_a’ 的信息，<br>如表的OID（对象标识符）和表名。</p><p>连接树（join tree）：存储了FROM子句及WHERE子句的相关信息。</p><p>排序子句（sort clause）：是一个 SortGroupClause 列表，用于定义排序条件。</p><p>查询树的具体细节在官方文档中有详细描述。</p><blockquote><p>查询树<br><a href="https://www.postgresql.org/docs/current/querytree.html">https://www.postgresql.org/docs/current/querytree.html</a></p></blockquote><h4 id="3-1-3-Rewriter"><a href="#3-1-3-Rewriter" class="headerlink" title="3.1.3. Rewriter"></a>3.1.3. Rewriter</h4><p>重写器是实现规则系统的一个组件。如有必要，它会根据存储在pg_rules系统目录中的规则来转换查询树。<br>规则系统本身是一个非常有趣的机制，但由于篇幅限制，本章将不对规则系统和重写器做详细说明，以避免内容过于冗长。</p><p>PostgreSQL中的视图(view, <a href="https://www.postgresql.org/docs/current/rules-views.html)%E6%98%AF%E9%80%9A%E8%BF%87%E8%A7%84%E5%88%99%E7%B3%BB%E7%BB%9F%E6%9D%A5">https://www.postgresql.org/docs/current/rules-views.html)是通过规则系统来</a><br>实现的。当使用CREATE VIEW命令定义视图时，相应的规则会自动生成并存储在系统目录中。</p><p>假设已有如下视图定义，并且相应的规则已被存储在pg_rules系统目录中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">sampledb<span class="hljs-operator">=</span># <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> employees_list<br>sampledb<span class="hljs-operator">-</span>#      <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> e.id, e.name, d.name <span class="hljs-keyword">AS</span> department<br>sampledb<span class="hljs-operator">-</span>#            <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">AS</span> e, departments <span class="hljs-keyword">AS</span> d <span class="hljs-keyword">WHERE</span> e.department_id <span class="hljs-operator">=</span> d.id;<br></code></pre></td></tr></table></figure><p>当发出包含如下视图的查询时，解析器会创建如图3.4(a)所示的解析树。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sampledb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees_list;<br></code></pre></td></tr></table></figure><p>此时，重写器会处理范围表节点，将其转换为存储在pg_rules中的对应视图子查询的解析树。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch3/ch3/img_3.png" alt="img_3.png"></p><p>由于PostgreSQL采用这种机制实现视图，因此在9.2版本之前视图是不可更新的。但从9.3版本开始，视图可以被更新了；<br>尽管如此，在更新视图时仍存在许多限制。这些具体细节在官方文档中有描述。</p><h4 id="3-1-4-Planner-and-Executor"><a href="#3-1-4-Planner-and-Executor" class="headerlink" title="3.1.4. Planner and Executor"></a>3.1.4. Planner and Executor</h4><p>规划器接收来自重写器的查询树，并生成一个能被执行器最高效处理的（查询）计划树。</p><p>PostgreSQL中的规划器基于纯粹的成本估算优化，不支持基于规则的优化或提示。<br>此规划器是PostgreSQL中最复杂的子系统。因此，本章后续部分将提供对规划器的概述。</p><blockquote><p>pg_hint_plan</p><p>PostgreSQL 在 SQL 中不支持查询优化器提示，并且预计未来也不会支持。如果你希望在查询中使用提示，<br>可以考虑使用名为 pg_hint_plan 的扩展。关于如何使用 pg_hint_plan，请详细参考官方网站。</p></blockquote><p>和其他关系型数据库管理系统（RDBMS）一样，PostgreSQL中的EXPLAIN命令会展示查询的计划树。下面是一个具体的示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tbl_a <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">300</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> data;<br>                          QUERY PLAN<br><span class="hljs-comment">---------------------------------------------------------------</span><br> Sort  (cost<span class="hljs-operator">=</span><span class="hljs-number">182.34</span>.<span class="hljs-number">.183</span><span class="hljs-number">.09</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">300</span> width<span class="hljs-operator">=</span><span class="hljs-number">8</span>)<br>   Sort Key: data<br>   <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>  Seq Scan <span class="hljs-keyword">on</span> tbl_a  (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.170</span><span class="hljs-number">.00</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">300</span> width<span class="hljs-operator">=</span><span class="hljs-number">8</span>)<br>         <span class="hljs-keyword">Filter</span>: (id <span class="hljs-operator">&lt;</span> <span class="hljs-number">300</span>)<br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>This result shows the plan tree shown in Fig. 3.5.</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch3/ch3/img_4.png" alt="img_4.png"></p><p>计划树由称为计划节点的元素组成，这些元素连接到PlannedStmt结构的plantree列表上，<br>这些元素在plannodes.h中定义。具体细节将在第3.3.3节（及第3.5.4.2节）中进行解释。</p><p>每个计划节点都包含了执行器处理所需的必要信息。对于单表查询而言，执行器会从计划树的末端开始，向根部进行处理。</p><p>例如，图3.5所示的计划树是一个排序节点和顺序扫描节点的列表。因此，执行器首先通过顺序扫描的方式读取表tbl_a，<br>然后对获取的结果进行排序。</p><p>执行器通过第8章所述的缓冲区管理器来读写数据库集群中的表和索引。在处理查询时，<br>执行器会使用预先分配的一些内存区域，如temp_buffers和work_mem，并在必要时创建临时文件。</p><p>此外，在访问元组时，PostgreSQL利用并发控制机制来维护运行事务的一致性和隔离性。<br>并发控制机制在第5章中进行描述。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch3/ch3/img_5.png" alt="img_5.png"></p><p>图3.6展示了执行器、缓冲区管理器和临时文件之间的关系。</p><h3 id="3-2-单表查询的成本估算"><a href="#3-2-单表查询的成本估算" class="headerlink" title="3.2 单表查询的成本估算"></a><a name="cost-single-table"></a>3.2 单表查询的成本估算</h3><h3 id="3-3-单表查询计划树的创建"><a href="#3-3-单表查询计划树的创建" class="headerlink" title="3.3 单表查询计划树的创建"></a><a name="plan-single-table"></a>3.3 单表查询计划树的创建</h3><h3 id="3-4-执行器的工作原理"><a href="#3-4-执行器的工作原理" class="headerlink" title="3.4 执行器的工作原理"></a><a name="Executor-Performs"></a>3.4 执行器的工作原理</h3><h3 id="3-5-连接操作"><a href="#3-5-连接操作" class="headerlink" title="3.5 连接操作"></a><a name="Join-Operations"></a>3.5 连接操作</h3><h3 id="3-6-多表查询计划树的创建"><a href="#3-6-多表查询计划树的创建" class="headerlink" title="3.6 多表查询计划树的创建"></a><a name="plan-multi-table"></a>3.6 多表查询计划树的创建</h3>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL指南：内幕探索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch2. 进程和内存架构</title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch2/ch2/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch2/ch2/</url>
    
    <content type="html"><![CDATA[<h2 id="ch2-进程和内存架构"><a href="#ch2-进程和内存架构" class="headerlink" title="ch2. 进程和内存架构"></a>ch2. 进程和内存架构</h2><p>本章总结了PostgreSQL的进程架构和内存架构，以便于理解后续章节。如果您已经熟悉这些内容，可以跳过本章。</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#process-structure">2.1 进程架构</a></td></tr><tr><td><a href="#memory-structure">2.2 内存架构</a></td></tr></tbody></table><h3 id="2-1-进程架构"><a href="#2-1-进程架构" class="headerlink" title="2.1 进程架构"></a><a name="process-structure"></a>2.1 进程架构</h3><p>PostgreSQL是一个运行在单一主机上的、具有多进程架构的客户端&#x2F;服务器型关系数据库管理系统。</p><p>共同管理数据库集群的一组多个进程通常被称为“PostgreSQL服务器”。</p><p>它包含以下类型的进程：</p><p>postgres服务器进程：是所有与数据库集群管理相关的进程的父进程。</p><p>后台进程（Backend Process）：每个后台进程负责处理与其相连客户端发出的所有查询和语句。</p><p>各种后台进程：执行数据库管理任务，如VACUUM清理和CHECKPOINT处理。</p><p>复制相关进程：执行流式复制。更多详细信息在第11章中描述。</p><p>后台工作者进程（Background Worker Processes）：从9.3版本开始支持，可以执行用户实现的任何处理。</p><p>更多信息，请参考官方文档。以下小节将详细介绍前三种类型的进程。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch2/ch2/img.png" alt="img.png"><br>此图展示了PostgreSQL服务器的进程结构：一个postgres服务器进程、两个后台进程、七个后台辅助进程以及两个客户端进程。同时，图中也描绘了数据库集群、共享内存区域及两个客户端进程。</p><h4 id="2-1-1-postgres服务器进程"><a href="#2-1-1-postgres服务器进程" class="headerlink" title="2.1.1 postgres服务器进程"></a>2.1.1 postgres服务器进程</h4><p>如前所述，postgres服务器进程是PostgreSQL服务器中所有进程的父进程。在早期版本中，它被称为’postmaster’。</p><p>当你使用带有’start’选项的pg_ctl实用程序时，postgres服务器进程将启动。<br>随后，它会在内存中分配一个共享内存区域，<br>启动多种后台进程，并根据需要启动与复制相关的进程和后台工作者进程，然后等待来自客户端的连接请求。<br>每当收到客户端的连接请求时，它就会启动一个后台进程。（启动的后台进程将处理连接客户端发出的所有查询。）</p><p>postgres服务器进程监听一个网络端口，默认端口是5432。虽然可以在同一主机上运行多个PostgreSQL服务器，<br>但每个服务器必须设置为监听不同的端口号，例如5432、5433等。</p><h4 id="2-1-2-后台进程（Backend-Process）"><a href="#2-1-2-后台进程（Backend-Process）" class="headerlink" title="2.1.2 后台进程（Backend Process）"></a>2.1.2 后台进程（Backend Process）</h4><p>后台进程，也称为’postgres’进程，由postgres服务器进程启动，处理来自单个已连接客户端的所有查询。<br>它通过单一的TCP连接与客户端通信，并在客户端断开连接时终止。</p><p>由于后台进程只能操作一个数据库，所以在连接PostgreSQL服务器时必须明确指定要使用的数据库。</p><p>PostgreSQL允许多个客户端同时连接，配置参数max_connections用于控制最大客户端连接数（默认为100）。</p><p>如果许多客户端，如Web应用程序，频繁地与PostgreSQL服务器建立和断开连接，将会增加建立连接和创建后台进程的成本，<br>因为PostgreSQL本身不具备原生的连接池特性。</p><p>这种情况会对数据库服务器的性能产生负面影响。</p><p>为了解决这类问题，通常会使用如pgbouncer或pgpool-II这样的连接池中间件。</p><h4 id="2-1-3-后台工作者进程（Background-Worker-Processes）"><a href="#2-1-3-后台工作者进程（Background-Worker-Processes）" class="headerlink" title="2.1.3 后台工作者进程（Background Worker Processes）"></a>2.1.3 后台工作者进程（Background Worker Processes）</h4><p>表2.1展示了一张后台进程列表。</p><p>与postgres服务器进程和后台进程相比，简单地解释每个功能是不可能的。<br>这是因为这些功能依赖于各个特定特性和PostgreSQL的内部机制。</p><p>因此，在本章中仅做简单介绍。详细内容将在后续章节中进行描述。</p><table><thead><tr><th>process</th><th>description</th><th>reference</th></tr></thead><tbody><tr><td>background writer</td><td>此进程负责定期且逐步地将共享缓冲区池中的脏页写入持久性存储设备（如HDD、SSD）。在9.1及更早版本中，它同时还承担了检查点处理的任务。</td><td>Section 8.6</td></tr><tr><td>checkpointer</td><td>此进程在9.2或以后的版本中执行检查点处理过程。</td><td>Section 8.6, Section 9.7</td></tr><tr><td>autovacuum launcher</td><td>此进程定期触发自动清理工作进程以进行清理进程。（更准确地说，它请求postgres服务器创建自动清理工作进程。）</td><td>Section 6.5</td></tr><tr><td>WAL writer</td><td>此进程负责定期将WAL缓冲区中的WAL数据写入并刷新到持久化存储中。</td><td>Section 9.9</td></tr><tr><td>statistics collector</td><td>此进程收集诸如pg_stat_activity和pg_stat_database等统计信息。</td><td></td></tr><tr><td>logging collector (logger)</td><td>此进程将错误消息写入日志文件。</td><td></td></tr><tr><td>archiver</td><td>此进程执行归档日志记录。</td><td>Section 9.10</td></tr></tbody></table><blockquote><p>Info<br>以下是PostgreSQL服务器的实际进程示例。<br>在以下示例中，存在一个postgres服务器进程（PID为9687），两个后台进程（PID分别为9697和9717），<br>以及表2.1中列出的几个后台进程。同时参见图2.1。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres&gt; </span><span class="language-bash">pstree -p 9687</span><br>-+= 00001 root /sbin/launchd<br> \-+- 09687 postgres /usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data<br>   |--= 09688 postgres postgres: logger process<br>   |--= 09690 postgres postgres: checkpointer process<br>   |--= 09691 postgres postgres: writer process<br>   |--= 09692 postgres postgres: wal writer process<br>   |--= 09693 postgres postgres: autovacuum launcher process<br>   |--= 09694 postgres postgres: archiver process<br>   |--= 09695 postgres postgres: stats collector process<br>   |--= 09697 postgres postgres: postgres sampledb 192.168.1.100(54924) idle<br>   \--= 09717 postgres postgres: postgres sampledb 192.168.1.100(54964) idle in transaction<br></code></pre></td></tr></table></figure><h3 id="2-2-内存架构"><a href="#2-2-内存架构" class="headerlink" title="2.2 内存架构"></a><a name="memory-structure"></a>2.2 内存架构</h3><p>PostgreSQL 中的内存架构可以分为两大类:</p><p>本地内存区域 - 由每个后端进程为自己的使用而分配。<br>共享内存区域 - 由 PostgreSQL 服务器的所有进程共同使用。</p><p>以下小节将简要介绍这些内存区域。<br><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch2/ch2/img_1.png" alt="img_1.png"></p><h4 id="2-2-1-Local-Memory-Area"><a href="#2-2-1-Local-Memory-Area" class="headerlink" title="2.2.1 Local Memory Area"></a>2.2.1 Local Memory Area</h4><p>每个后端进程都会分配一个本地内存区域用于查询处理。这个区域被划分为几个子区域,<br>其大小要么是固定的,要么是可变的。</p><p>表 2.2 列出了主要的子区域。各子区域的详细信息将在后续章节中介绍。</p><table><thead><tr><th>sub-area</th><th>description</th><th>reference</th></tr></thead><tbody><tr><td>work_mem</td><td>执行器使用这个区域对 ORDER BY 和 DISTINCT 操作进行元组排序,以及使用合并连接和哈希连接操作连接表。</td><td>Chapter 3</td></tr><tr><td>maintenance_work_mem</td><td>一些维护操作(如 VACUUM、REINDEX)会使用这个区域。</td><td>Section 6.1</td></tr><tr><td>temp_buffers</td><td>执行器使用这个区域存储临时表。</td><td></td></tr></tbody></table><h4 id="2-2-2-Shared-Memory-Area"><a href="#2-2-2-Shared-Memory-Area" class="headerlink" title="2.2.2 Shared Memory Area"></a>2.2.2 Shared Memory Area</h4><p>在 PostgreSQL 服务器启动时,会分配一个共享内存区域。这个区域也被划分为几个固定大小的子区域。<br>表 2.3 列出了主要的子区域。详细信息将在后续章节中介绍。</p><table><thead><tr><th>子区域</th><th>描述</th><th>引用</th></tr></thead><tbody><tr><td>shared buffer pool</td><td>PostgreSQL 将页面从持久性存储加载到此区域,并直接在此区域进行操作。</td><td>第 3 章</td></tr><tr><td>WAL buffer</td><td>为了确保服务器故障时不会丢失数据,PostgreSQL 支持 WAL 机制。WAL 缓冲区是 WAL 数据在写入持久性存储之前的缓冲区。</td><td>第 9 章</td></tr><tr><td>commit log</td><td>提交日志(CLOG)记录了所有事务(如正在进行、提交、中止)的状态,用于并发控制(CC)机制。</td><td>第 5.4 节</td></tr></tbody></table><p>除了共享缓冲池、WAL 缓冲区和提交日志外,PostgreSQL 还分配了几个其他区域,如下所示:</p><p>1、用于各种访问控制机制(如信号量、轻量级锁、共享和独占锁等)的子区域。</p><p>2、用于各种后台进程(如检查点和自动清空)的子区域。</p><p>3、用于事务处理(如保存点和二阶段提交)的子区域。</p><p>其他一些区域。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL指南：内幕探索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch11. Streaming Replication</title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch11/ch11/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch11/ch11/</url>
    
    <content type="html"><![CDATA[<h2 id="ch11-Streaming-Replication"><a href="#ch11-Streaming-Replication" class="headerlink" title="ch11. Streaming Replication"></a>ch11. Streaming Replication</h2><p>同步流复制功能在9.1版本中得以实现。这是一种单一主多从类型的复制，其中“主”和“从”通常分别称为主服务器和备用服务器。</p><p>这一本土复制特性基于日志传送，这是一种通用的复制技术，主服务器会持续将WAL（预写日志）数据发送到备用服务器，<br>备用服务器随后立即重放接收到的数据。</p><p>本章节专注于流复制的工作原理，并涵盖以下内容：</p><p>流复制是如何启动的。<br>数据是如何在主服务器和备用服务器之间传输的。<br>主服务器是如何管理多个备用服务器的。<br>主服务器是如何检测备用服务器故障的。  </p><p>通过这一章节的探讨，您可以深入理解PostgreSQL中流复制的核心机制及其在高可用性和数据保护策略中的应用。</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#stream-rep">11.1. Starting the Streaming Replication</a></td></tr><tr><td><a href="#conduct-strp">11.2. How to Conduct Streaming Replication</a></td></tr><tr><td><a href="#multi-standy">11.3. Managing Multiple-Standby Servers</a></td></tr><tr><td><a href="#fail-standy-server">11.4. Detecting Failures of Standby Servers</a></td></tr></tbody></table><blockquote><p>info </p><p>虽然最初的复制特性，仅支持异步复制，是在9.0版本中引入的，但在9.1版本中，<br>这一实现被替换为一个新的实现方式，用以支持同步复制，这一新实现至今仍在使用中。</p></blockquote><h3 id="11-1-Starting-the-Streaming-Replication"><a href="#11-1-Starting-the-Streaming-Replication" class="headerlink" title="11.1. Starting the Streaming Replication"></a><a name="stream-rep"></a>11.1. Starting the Streaming Replication</h3><p>在流复制中，三种类型的进程协同工作：</p><ol><li>在主服务器上的walsender进程负责将WAL（预写日志）数据发送到备用服务器。  </li><li>在备用服务器上的walreceiver进程负责接收并重放这些WAL数据。  </li><li>同样在备用服务器上，一个startup进程负责启动walreceiver进程。</li></ol><p>walsender和walreceiver通过单个TCP连接进行通信。</p><p>流复制的启动顺序如图11.1所示：</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch11/ch11/img.png" alt="img.png"></p><pre><code class="hljs">(1) 启动主服务器和备用服务器。(2) 备用服务器启动startup进程。(3) 备用服务器启动walreceiver进程。(4) walreceiver向主服务器发送连接请求。如果主服务器没有运行，walreceiver会周期性地发送这些请求。(5) 当主服务器接收到连接请求时，它启动一个walsender进程，并在walsender和walreceiver之间建立TCP连接。(6) walreceiver发送备用服务器数据库集群的最新LSN（日志序列号）。在信息技术领域，这一过程被称为握手。(7) 如果备用服务器的最新LSN小于主服务器的最新LSN（即，备用LSN &lt; 主LSN），则walsender会从备用的LSN开始向前发送WAL数据，直到主服务器的LSN。这些WAL数据来源于主服务器pg_wal子目录中存储的日志段（在9.6或更早版本中为pg_xlog）。接着，备用服务器重放接收到的WAL数据。在这个阶段，备用服务器逐渐与主服务器同步，因此称为追赶（catch-up）阶段。(8) 流复制开始正常工作。</code></pre><p>每个walsender进程会维护一个状态，该状态适合与之相连的walreceiver或应用程序的工作阶段。<br>以下是walsender进程可能处于的几种状态：</p><ol><li>启动阶段（start-up）：从启动walsender进程到握手结束。参见图11.1的步骤(5)至(6)。  </li><li>追赶阶段（catch-up）：在追赶主服务器数据的过程中。参见图11.1的步骤(7)。  </li><li>流送阶段（streaming）：当流复制正在正常工作时。参见图11.1的步骤(8)。  </li><li>备份阶段（backup）：在为备份工具（如pg_basebackup实用程序）发送整个数据库集群文件期间。</li></ol><p>视图pg_stat_replication显示所有正在运行的walsender的状态。下面是一个示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> application_name,state <span class="hljs-keyword">FROM</span> pg_stat_replication;<br> application_name <span class="hljs-operator">|</span>   state<br><span class="hljs-comment">------------------+-----------</span><br> standby1         <span class="hljs-operator">|</span> streaming<br> standby2         <span class="hljs-operator">|</span> streaming<br> pg_basebackup    <span class="hljs-operator">|</span> backup<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>如上结果所示，有两个walsender进程正在运行，用于向连接的备用服务器发送WAL数据，<br>还有一个walsender进程正在运行，用于为pg_basebackup实用工具发送数据库集群的所有文件。</p><blockquote><p>如果备用服务器在长时间停止后重新启动，会发生什么情况呢？</p><p>在9.3或更早的版本中，如果备用服务器所需的主服务器WAL段已经被回收，那么备用服务器就无法赶上主服务器了。<br>针对这个问题，没有十分可靠的解决方案，只能通过设置较大的wal_keep_segments配置参数值来减少这种情况发生的可能性，<br>但这只是一个权宜之计。</p><p>而在9.4或之后的版本中，可以通过使用“复制槽（replication slot）”来预防这个问题。复制槽是一项扩展WAL数据发送<br>灵活性的功能，主要服务于逻辑复制，同时也为解决这个问题提供了方案——通过暂停回收过程，可以在复制槽中保留含有<br>未发送数据的WAL段文件，从而避免了因WAL段被删除而导致备用服务器无法追赶上主服务器的问题。详细信息请参考官方文档。<br><a href="https://www.postgresql.org/docs/current/warm-standby.html#STREAMING-REPLICATION-SLOTS">https://www.postgresql.org/docs/current/warm-standby.html#STREAMING-REPLICATION-SLOTS</a></p></blockquote><h3 id="11-2-How-to-Conduct-Streaming-Replication"><a href="#11-2-How-to-Conduct-Streaming-Replication" class="headerlink" title="11.2. How to Conduct Streaming Replication"></a><a name="conduct-strp"></a>11.2. How to Conduct Streaming Replication</h3><p>流复制有两个方面：日志传送和数据库同步。日志传送是流复制的主要方面，因为主服务器会在写入WAL（预写日志）数据的同时，<br>将其发送给所有连接的备用服务器。数据库同步则是同步复制所必需的，此时主服务器需与每个备用服务器通信，<br>以确保它们的数据库集群保持同步。</p><p>为了准确理解流复制的工作原理，我们需要了解一个主服务器是如何管理多个备用服务器的。<br>本节将从简单情况（即，单一主服务器单一备用服务器系统）开始讨论，随后在下节中探讨一般情况<br>（单一主服务器多备用服务器系统）。</p><h4 id="11-2-1-Communication-Between-a-Primary-and-a-Synchronous-Standby"><a href="#11-2-1-Communication-Between-a-Primary-and-a-Synchronous-Standby" class="headerlink" title="11.2.1. Communication Between a Primary and a Synchronous Standby"></a>11.2.1. Communication Between a Primary and a Synchronous Standby</h4><p><strong>主服务器与同步备用服务器间的通信</strong>  </p><p>假设备用服务器处于同步复制模式中，但配置参数hot_standby被禁用，<br>并且wal_level设置为‘replica’。主服务器的主要参数如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">synchronous_standby_names = &#x27;standby1&#x27;<br>hot_standby = off<br>wal_level = replica<br></code></pre></td></tr></table></figure><p>此外，在第9.5节中提到的写入WAL（Write-Ahead Log）数据的三个触发器中，我们这里重点关注事务提交。</p><p>假设主服务器上的一个后端进程以自动提交模式发出一个简单的INSERT语句。该后端开始一个事务，发出INSERT语句，<br>然后立即提交事务。让我们进一步探讨这个提交操作将如何完成。请参见图11.2中的以下序列图：</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch11/ch11/img_1.png" alt="img_1.png"></p><pre><code class="hljs">(1) 后端进程通过执行XLogInsert()和XLogFlush()函数，将WAL数据写入并刷新到WAL段文件中。(2) walsender进程将写入WAL段的WAL数据发送给walreceiver进程。(3) 发送WAL数据后，后端进程继续等待来自备用服务器的ACK响应。更准确地说，后端进程通过执行内部函数SyncRepWaitForLSN()获取一个闩锁，并等待其释放。(4) 备用服务器上的walreceiver使用write()系统调用将接收到的WAL数据写入备用服务器的WAL段，并向walsender返回一个ACK响应。(5) walreceiver使用如fsync()的系统调用将WAL数据刷新到WAL段，再向walsender返回另一个ACK响应，并通知启动进程有关WAL数据已更新的信息。(6) 启动进程重放已写入WAL段的WAL数据。(7) 当walsender从walreceiver接收到ACK响应时，它会释放后端进程的闩锁，随后后端进程的提交或回滚动作将完成。闩锁释放的时间取决于synchronous_commit参数的设定。如果synchronous_commit设置为&#39;on&#39;（默认值），则在收到步骤(5)的ACK时释放闩锁；如果设置为&#39;remote_write&#39;，则在收到步骤(4)的ACK时释放闩锁。</code></pre><p>每个ACK响应都会向主服务器传达备用服务器的内部状态信息，它包含以下四项内容：</p><ol><li>最新WAL数据已被写入的位置（LSN）。  </li><li>最新WAL数据已被刷新到磁盘的位置（LSN）。  </li><li>在启动进程中最新WAL数据已被重放的位置（LSN）。  </li><li>发送此响应的时间戳。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">XLogWalRcvSendReply(<span class="hljs-type">void</span>)@src/backend/replication/walreceiver.c<br><span class="hljs-comment">/* Construct a new message */</span><br>writePtr = LogstreamResult.Write;<br>flushPtr = LogstreamResult.Flush;<br>applyPtr = GetXLogReplayRecPtr(<span class="hljs-literal">NULL</span>);<br><br>resetStringInfo(&amp;reply_message);<br>pq_sendbyte(&amp;reply_message, <span class="hljs-string">&#x27;r&#x27;</span>);<br>pq_sendint64(&amp;reply_message, writePtr);<br>pq_sendint64(&amp;reply_message, flushPtr);<br>pq_sendint64(&amp;reply_message, applyPtr);<br>pq_sendint64(&amp;reply_message, GetCurrentTimestamp());<br>pq_sendbyte(&amp;reply_message, requestReply ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>walreceiver不仅在WAL数据被写入和刷新后返回ACK响应，还会定期作为备用服务器的心跳信号返回ACK。<br>因此，主服务器始终能准确掌握所有连接的备用服务器的状态。</p><p>可以通过执行以下查询来显示连接的备用服务器的LSN相关信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> application_name <span class="hljs-keyword">AS</span> host,<br>        write_location <span class="hljs-keyword">AS</span> write_LSN, flush_location <span class="hljs-keyword">AS</span> flush_LSN, <br>        replay_location <span class="hljs-keyword">AS</span> replay_LSN <span class="hljs-keyword">FROM</span> pg_stat_replication;<br><br>   host   <span class="hljs-operator">|</span> write_lsn <span class="hljs-operator">|</span> flush_lsn <span class="hljs-operator">|</span> replay_lsn <br><span class="hljs-comment">----------+-----------+-----------+------------</span><br> standby1 <span class="hljs-operator">|</span> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">5000280</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">5000280</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">5000280</span><br> standby2 <span class="hljs-operator">|</span> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">5000280</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">5000280</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">5000280</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><blockquote><p>info</p><p>心跳间隔由参数wal_receiver_status_interval设置，默认为10秒。</p></blockquote><h4 id="11-2-2-Behavior-When-a-Failure-Occurs"><a href="#11-2-2-Behavior-When-a-Failure-Occurs" class="headerlink" title="11.2.2. Behavior When a Failure Occurs"></a>11.2.2. Behavior When a Failure Occurs</h4><p><strong>故障发生时的行为</strong></p><p>在本小节中，我将描述当同步备用服务器发生故障时主服务器的行为，以及如何处理这种情况。</p><p>即使同步备用服务器发生故障，无法再返回ACK响应，主服务器也将无限期地等待响应。这意味着正在运行的事务无法提交，<br>后续的查询处理也无法开始。换句话说，主服务器的所有操作实际上都停止了。<br>（流复制不支持在超时后自动恢复为异步模式的功能。）</p><p>避免这种情况有两种方法。一种是使用多个备用服务器来提高系统可用性。<br>另一种是手动将同步模式切换为异步模式，执行以下步骤：</p><p>(1) 将参数synchronous_standby_names设置为空字符串。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">synchronous_standby_names = &#x27;&#x27;<br></code></pre></td></tr></table></figure><p>(2) 使用reload选项执行pg_ctl命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres&gt; </span><span class="language-bash">pg_ctl -D <span class="hljs-variable">$PGDATA</span> reload</span><br></code></pre></td></tr></table></figure><p>此过程不影响已连接的客户端。主服务器将继续处理事务，客户端与其各自后端进程之间的所有会话都将保持不变。</p><h3 id="11-3-Managing-Multiple-Standby-Servers"><a href="#11-3-Managing-Multiple-Standby-Servers" class="headerlink" title="11.3. Managing Multiple-Standby Servers"></a><a name="multi-standy"></a>11.3. Managing Multiple-Standby Servers</h3><p>在这一部分，我将描述在多备用服务器环境下流复制的工作方式。</p><h4 id="11-3-1-sync-priority-and-sync-state"><a href="#11-3-1-sync-priority-and-sync-state" class="headerlink" title="11.3.1. sync_priority and sync_state"></a>11.3.1. sync_priority and sync_state</h4><p>主服务器为所有受管的备用服务器分配sync_priority和sync_state属性，并根据各自的值对待每个备用服务器。<br>（即使主服务器仅管理一个备用服务器，也会分配这些值；这在前一节中未提及。）</p><p>sync_priority属性表示备用服务器在同步模式下的优先级。值越低，优先级越高。特殊值0表示备用服务器处于“异步模式”。<br>备用服务器的优先级按照在主服务器配置参数synchronous_standby_names中列出的顺序分配。<br>例如，在以下配置中，standby1和standby2的优先级分别是1和2。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">synchronous_standby_names <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;standby1, standby2&#x27;</span><br></code></pre></td></tr></table></figure><p>（未在此参数中列出的备用服务器处于异步模式，并且优先级为0。）</p><p>sync_state是备用服务器的状态。此属性指示备用服务器的状态，可以是以下值之一：</p><ol><li>sync：备用服务器处于同步模式，并且是当前正在工作的最高优先级备用服务器。  </li><li>potential：备用服务器处于同步模式，但属于较低优先级，当前正在工作。如果当前的同步备用服务器发生故障，<br>该备用服务器将被提升为sync状态。  </li><li>async：备用服务器处于异步模式。（它永远不会处于sync或potential状态。）</li></ol><p>可以通过执行以下查询来显示备用服务器的优先级和状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">testdb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> application_name <span class="hljs-keyword">AS</span> host, <br>         sync_priority, sync_state <span class="hljs-keyword">FROM</span> pg_stat_replication;<br>   host   <span class="hljs-operator">|</span> sync_priority <span class="hljs-operator">|</span> sync_state<br><span class="hljs-comment">----------+---------------+------------</span><br> standby1 <span class="hljs-operator">|</span>             <span class="hljs-number">1</span> <span class="hljs-operator">|</span> sync<br> standby2 <span class="hljs-operator">|</span>             <span class="hljs-number">2</span> <span class="hljs-operator">|</span> potential<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><h4 id="11-3-2-How-the-Primary-Manages-Multiple-standbys"><a href="#11-3-2-How-the-Primary-Manages-Multiple-standbys" class="headerlink" title="11.3.2. How the Primary Manages Multiple-standbys"></a>11.3.2. How the Primary Manages Multiple-standbys</h4><p>主服务器仅等待来自同步备用服务器的ACK响应。换句话说，主服务器仅确认同步备用服务器对WAL数据的写入和刷新。<br>因此，流复制确保只有同步备用服务器与主服务器保持一致和同步的状态。</p><p>图11.3展示了一个场景，其中潜在备用服务器的ACK响应比主备用服务器的响应更早返回。在这种情况下，主服务器不会完成<br>当前事务的提交操作，而是继续等待主备用服务器的ACK响应。一旦收到主备用服务器的响应，后端进程就会释放闩锁并完成<br>当前事务的处理。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch11/ch11/img_2.png" alt="img_2.png"></p><pre><code class="hljs">备用服务器standby1和standby2的sync_state分别是sync和potential。(1) 即使已经收到了潜在备用服务器的ACK响应，主服务器的后端进程仍会继续等待来自同步备用服务器的ACK响应。  (2) 收到来自同步备用服务器的ACK响应后，主服务器的后端进程释放闩锁并完成当前事务的处理。  </code></pre><p>相反的情况是（即，主备用服务器的ACK响应比潜在备用服务器的响应更早返回），<br>主服务器会立即完成当前事务的提交操作，而不确保潜在备用服务器是否已经写入并刷新了WAL数据。</p><h4 id="11-3-3-Behavior-When-a-Failure-Occurs"><a href="#11-3-3-Behavior-When-a-Failure-Occurs" class="headerlink" title="11.3.3. Behavior When a Failure Occurs"></a>11.3.3. Behavior When a Failure Occurs</h4><p>再次来看，当备用服务器发生故障时，主服务器是如何表现的。</p><p>如果潜在备用服务器或异步备用服务器发生故障，主服务器将终止与该故障备用服务器相连的walsender进程，<br>并继续所有处理。换句话说，主服务器上的事务处理不会受到这两种类型备用服务器故障的影响。</p><p>如果同步备用服务器发生故障，主服务器同样会终止与该故障备用服务器相连的walsender进程，并用优先级最高的潜在<br>备用服务器替换掉故障的同步备用服务器。见图11.4。与上述故障情况不同的是，从故障发生到同步备用服务器被替换期间，<br>主服务器上的查询处理将会暂停。（因此，备用服务器的故障检测是提高复制系统可用性的非常重要的功能。<br>故障检测将在下一节中描述。）</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch11/ch11/img_3.png" alt="img_3.png"></p><p>无论如何，如果有一个或多个备用服务器以同步模式运行，<br>主服务器始终只会保持一个同步备用服务器，并且这个同步备用服务器始终与主服务器保持一致和同步的状态。</p><h3 id="11-4-Detecting-Failures-of-Standby-Servers"><a href="#11-4-Detecting-Failures-of-Standby-Servers" class="headerlink" title="11.4. Detecting Failures of Standby Servers"></a><a name="fail-standy-server"></a>11.4. Detecting Failures of Standby Servers</h3><p><strong>备用服务器故障检测</strong></p><p>流复制使用两种常见的故障检测程序，这些程序不需要任何特殊硬件。</p><p>(1) 备用服务器进程故障检测：</p><p>当检测到walsender与walreceiver之间的连接断开时，主服务器会立即判定备用服务器或walreceiver进程存在故障。<br>当底层网络功能因无法写入或读取walreceiver的套接字接口而返回错误时，主服务器也会立即判断其发生故障。  </p><p>(2) 硬件及网络故障检测：</p><p>如果在参数wal_sender_timeout（默认为60秒）设定的时间内walreceiver没有返回任何信息，<br>主服务器将判定备用服务器存在故障。<br>与上述故障不同，即使备用服务器由于某些故障（例如，备用服务器硬件故障、网络故障等）无法发送任何响应，<br>主服务器确认备用服务器故障也需要一定时间，最长可达wal_sender_timeout秒。  </p><p>根据故障类型，通常故障发生后可以立即被检测到。然而，故障发生与其被检测到之间可能存在时间延迟。<br>特别是，如果同步备用服务器发生后一种类型的故障，即使可能存在多个工作正常的潜在备用服务器，<br>主服务器上的所有事务处理也会在检测到备用服务器故障之前暂停。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL指南：内幕探索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch10. Base Backup and Point-In-Time Recovery (PITR)</title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch10/ch10/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch10/ch10/</url>
    
    <content type="html"><![CDATA[<h2 id="ch10-Base-Backup-and-Point-In-Time-Recovery-PITR"><a href="#ch10-Base-Backup-and-Point-In-Time-Recovery-PITR" class="headerlink" title="ch10. Base Backup and Point-In-Time Recovery (PITR)"></a>ch10. Base Backup and Point-In-Time Recovery (PITR)</h2><p>在线数据库备份大致可以分为两类：逻辑备份和物理备份。虽然两者都有优缺点，但逻辑备份的一个缺点是可能非常耗时。<br>特别是，对大型数据库进行备份可能需要很长时间，而从备份数据中恢复数据库所需的时间甚至更长。<br>相比之下，物理备份的创建和恢复速度要快得多，这使得它们在实际系统中成为一个非常重要且有用的特性。</p><p>在PostgreSQL中，从8.0版本开始就支持在线物理全备份。对运行中的整个数据库集群（即物理备份数据）的快照称为<br>基础备份（base backup）。</p><p>时间点恢复（Point-in-Time Recovery，简称PITR）也是从8.0版本开始提供的功能，它<br>利用基础备份和连续归档功能创建的归档日志，可以将数据库集群恢复到任意时间点。<br>例如，如果您犯了一个重大错误（比如截断了所有表），可以使用此功能将数据库恢复到错误发生前的状态。</p><p>本章将涵盖以下主题：</p><p>什么是基础备份？<br>PITR是如何工作的？<br>什么是时间线ID（timelineId）？<br>什么是时间线历史文件（timeline history file）？  </p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#10-Overview">10.1. Base Backup</a></td></tr><tr><td><a href="#pitr">10.2. How Point-in-Time Recovery Works</a></td></tr><tr><td><a href="#timeline">10.3. timelineId and Timeline History File</a></td></tr><tr><td><a href="#pitr-timeline">10.4. Point-in-Time Recovery with Timeline History File</a></td></tr></tbody></table><blockquote><p>info</p><p>在7.4或更早的版本中，PostgreSQL仅支持逻辑备份（包括逻辑完全备份、逻辑部分备份以及数据导出）。</p></blockquote><h3 id="10-1-Base-Backup"><a href="#10-1-Base-Backup" class="headerlink" title="10.1. Base Backup"></a><a name="10-Overview"></a>10.1. Base Backup</h3><p>首先，使用低级命令制作基础备份的标准流程如下：</p><ol><li>执行pg_backup_start命令（在14或更早版本中为pg_start_backup）。  </li><li>使用您选择的归档命令对数据库集群进行快照。  </li><li>执行pg_backup_stop命令（在14或更早版本中为pg_stop_backup）。</li></ol><p>这个简单的流程对于数据库管理员来说很容易使用，因为它除了像cp命令或类似归档工具这样的通用工具外，<br>不需要其他特殊工具。此外，此流程不需要表锁，因此所有用户都可以继续发出查询，而不受备份操作的影响。<br>这相比于其他主要的开源关系型数据库管理系统是一个显著的优势。</p><p>制作基础备份的一个更简单的方法是使用pg_basebackup实用程序，它内部会发出上述的低级命令。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch10/ch10/img.png" alt="img.png"></p><blockquote><p>info</p><p>The pg_backup_start and pg_backup_stop commands are defined<br>here: src&#x2F;backend&#x2F;access&#x2F;transam&#x2F;xlogfuncs.c.</p></blockquote><p>由于pg_backup_start和pg_backup_stop命令对于理解PITR至关重要，我们将在接下来的小节中更详细地探讨它们。</p><h4 id="10-1-1-pg-backup-start-Ver-14-or-earlier-pg-start-backup"><a href="#10-1-1-pg-backup-start-Ver-14-or-earlier-pg-start-backup" class="headerlink" title="10.1.1. pg_backup_start (Ver.14 or earlier, pg_start_backup)"></a>10.1.1. pg_backup_start (Ver.14 or earlier, pg_start_backup)</h4><p>pg_backup_start命令用于准备制作基础备份。</p><p>如第9.8节所述，恢复过程从一个REDO点开始，因此pg_backup_start命令在开始制作基础备份时必须执行检查点以显式<br>创建一个REDO点。此外，其检查点的位置必须保存在一个不同于pg_control的文件中，因为在备份过程中可能会多次执行<br>常规检查点。因此，pg_backup_start执行以下四个操作：</p><ol><li>强制数据库进入全页写入模式。  </li><li>切换到当前WAL段文件（8.4或更高版本）。  </li><li>执行检查点。  </li><li>创建backup_label文件 – 此文件在基础目录的顶层创建，包含有关基础备份本身的基本信息，如该检查点的检查点位置。</li></ol><p>第三和第四项操作是该命令的核心。第一和第二项操作是为了更可靠地恢复数据库集群而执行的。</p><p>backup_label文件包含以下六项内容（在11或更高版本中为七项）：</p><ol><li>CHECKPOINT LOCATION – 这是记录由该命令创建的检查点的LSN位置。  </li><li>START WAL LOCATION – 这在PITR中不使用，但用于第11章中描述的流复制。<br>之所以命名为‘START WAL LOCATION’，是因为复制模式下的备用服务器仅在初始启动时读取此值一次。  </li><li>BACKUP METHOD – 这是制作此基础备份所使用的方法。  </li><li>BACKUP FROM – 这表明备份是从主服务器还是备用服务器上获取的。  </li><li>START TIME – 这是执行pg_backup_start命令时的时间戳。  </li><li>LABEL – 这是在pg_backup_start命令中指定的标签。  </li><li>START TIMELINE – 这是备份开始时的时间线。这是为了进行健康检查，并在11版本中引入。</li></ol><blockquote><p>backup_label</p><p>下面是使用 pg_basebackup 制作的第 16 版 backup_label 文件的实际示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres&gt; </span><span class="language-bash"><span class="hljs-built_in">cat</span> /usr/local/pgsql/data/backup_label</span><br>START WAL LOCATION: 0/1B000028 (file 00000001000000000000001B)<br>CHECKPOINT LOCATION: 0/1B000060<br>BACKUP METHOD: streamed<br>BACKUP FROM: primary<br>START TIME: 2024-1-1 11:45:19 GMT<br>LABEL: pg_basebackup base backup<br>START TIMELINE: 1<br></code></pre></td></tr></table></figure></blockquote><p>正如您可能想象的那样，当您使用此基础备份恢复数据库时，PostgreSQL会从backup_label文件中获取“CHECKPOINT LOCATION”，<br>以便从相应的归档日志中读取检查点记录。然后，它从记录中获取REDO点并开始恢复过程。（具体细节将在下一部分描述。）</p><h4 id="10-1-2-pg-backup-stop-Ver-14-or-earlier-pg-stop-backup"><a href="#10-1-2-pg-backup-stop-Ver-14-or-earlier-pg-stop-backup" class="headerlink" title="10.1.2. pg_backup_stop (Ver.14 or earlier, pg_stop_backup)"></a>10.1.2. pg_backup_stop (Ver.14 or earlier, pg_stop_backup)</h4><p>pg_backup_stop命令执行以下五项操作来完成备份：</p><ol><li>如果pg_backup_start命令已强制更改，则重置为非全页写入模式。  </li><li>写入备份结束的XLOG记录。  </li><li>切换WAL段文件。  </li><li>创建备份历史文件。此文件包含backup_label文件的内容以及执行pg_backup_stop命令的时间戳。  </li><li>删除backup_label文件。从基础备份恢复时需要backup_label文件，但在复制后，原始数据库集群中就不需要了。</li></ol><blockquote><p>info</p><p>备份历史文件的命名方法如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;WAL segment&#125;.&#123;offset value at the time the base backup was started&#125;.backup<br></code></pre></td></tr></table></figure></blockquote><h3 id="10-2-How-Point-in-Time-Recovery-Works"><a href="#10-2-How-Point-in-Time-Recovery-Works" class="headerlink" title="10.2. How Point-in-Time Recovery Works"></a><a name="pitr"></a>10.2. How Point-in-Time Recovery Works</h3><p>图10.2展示了PITR（Point-in-Time Recovery）的基本概念。在PITR模式下，PostgreSQL会将归档日志中<br>的WAL（Write-Ahead Log）数据重放到底层备份上，从pg_backup_start创建的REDO点开始，一直重放到您希望恢复的<br>那个时间点。在PostgreSQL中，需要恢复到的时间点被称为恢复目标（recovery target）。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch10/ch10/img_1.png" alt="img_1.png"></p><p>以下是PITR工作原理的描述。</p><p>假设你在2024年1月1日格林威治标准时间12:05时犯了一个错误。你需要删除数据库集群，并使用在此之前制作的<br>基础备份来恢复一个新的。</p><p>首先，你需要设置restore_command参数的命令，同时在postgresql.conf文件中<br>（对于版本11或更早的，则是在recovery.conf文件中）设置recovery_target_time参数的时间为<br>你犯错的那个时间点（本例中为12:05 GMT）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Place archive logs under /mnt/server/archivedir directory.</span><br>restore_command = &#x27;cp /mnt/server/archivedir/%f %p&#x27;<br>recovery_target_time = &quot;2024-1-1 12:05 GMT&quot;<br></code></pre></td></tr></table></figure><p>当PostgreSQL启动时，如果在数据库集群中检测到backup_label文件和recovery.signal文件<br>（对于版本11或更早的，则是检测recovery.conf文件），它就会进入PITR（Point-in-Time Recovery）模式。</p><blockquote><p>recovery.conf &#x2F; recovery.signal</p><p>从版本12开始，recovery.conf文件已被废弃，所有与恢复相关的参数都应该写入postgresql.conf中。<br>详细情况请参阅官方文档。</p><p>在版本12或之后，当您使用basebackup恢复服务器时，需要在数据库集群目录下创建一个空文件<br>名为recovery.signal。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">touch</span> /usr/local/pgsql/data/recovery.signal</span><br></code></pre></td></tr></table></figure></blockquote><p>PITR（时间点恢复）过程几乎与第9.8节中描述的正常恢复过程相同。唯一不同之处在于：</p><ol><li><p>WAL段&#x2F;归档日志从何处读取？</p><p> 正常恢复模式 - 从基本目录下的pg_wal子目录（在9.6或更早版本中为pg_xlog子目录）读取。<br> PITR模式 - 从’archive_command’参数设置的归档目录中读取。  </p></li><li><p>检查点位置从何处读取？</p><p> 正常恢复模式 - 从pg_control文件中读取。<br> PITR模式 - 从backup_label文件中读取。</p></li></ol><p>PITR过程的大致步骤如下：</p><ol><li>PostgreSQL使用内部函数read_backup_label()<br>从backup_label文件中读取“CHECKPOINT LOCATION”的值，以找到重做点（REDO点）。  </li><li>PostgreSQL从postgresql.conf文件中读取一些参数的值（在11或更早版本中，是从recovery.conf文件），<br>比如’restore_command’和’recovery_target_time’。  </li><li>PostgreSQL开始从REDO点重放WAL数据，这个点可以通过“CHECKPOINT LOCATION”的值轻松获得。<br>WAL数据通过执行’restore_command’参数中所写的命令，从归档区复制到临时区域的日志文件中读取。<br>（临时区域中的复制日志文件在使用后会被删除。）<br>在这个例子中，因为’recovery_target_time’参数被设置为时间戳‘2024-1-1 12:05:00’，<br>所以PostgreSQL会从REDO点开始读取并重放WAL数据，直到该时间戳前的位置。<br>如果没有在postgresql.conf（11或更早版本中为recovery.conf）中设置恢复目标，<br>PostgreSQL将一直重放到归档日志的末尾。</li><li>当恢复过程完成后，在pg_wal子目录下（在9.6或更早版本中为pg_xlog子目录）会创建一个时间线历史文件，<br>如‘00000002.history’。 如果启用了归档日志功能，同名文件也会在归档目录中创建。<br>该文件的内容和作用将在后续部分进行说明。</li></ol><p>提交和中止操作的记录都包含了各自操作完成的<br>时间戳（这两种操作的XLOG数据部分分别在xl_xact_commit和xl_xact_abort中有定义）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xl_xact_commit</span></span><br><span class="hljs-class">&#123;</span><br>        TimestampTzxact_time;          <span class="hljs-comment">/* time of commit */</span><br>        uint32          xinfo;              <span class="hljs-comment">/* info flags */</span><br>        <span class="hljs-type">int</span>            nrels;              <span class="hljs-comment">/* number of RelFileNodes */</span><br>        <span class="hljs-type">int</span>            nsubxacts;          <span class="hljs-comment">/* number of subtransaction XIDs */</span><br>        <span class="hljs-type">int</span>            nmsgs;              <span class="hljs-comment">/* number of shared inval msgs */</span><br>        Oid            dbId;               <span class="hljs-comment">/* MyDatabaseId */</span><br>        Oid            tsId;               <span class="hljs-comment">/* MyDatabaseTableSpace */</span><br>        <span class="hljs-comment">/* Array of RelFileNode(s) to drop at commit */</span><br>        RelFileNode     xnodes[<span class="hljs-number">1</span>];          <span class="hljs-comment">/* VARIABLE LENGTH ARRAY */</span><br>        <span class="hljs-comment">/* ARRAY OF COMMITTED SUBTRANSACTION XIDs FOLLOWS */</span><br>        <span class="hljs-comment">/* ARRAY OF SHARED INVALIDATION MESSAGES FOLLOWS */</span><br>&#125; xl_xact_commit;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xl_xact_abort</span></span><br><span class="hljs-class">&#123;</span><br>        TimestampTz     xact_time;          <span class="hljs-comment">/* time of abort */</span><br>        <span class="hljs-type">int</span>            nrels;              <span class="hljs-comment">/* number of RelFileNodes */</span><br>        <span class="hljs-type">int</span>             nsubxacts;          <span class="hljs-comment">/* number of subtransaction XIDs */</span><br>        <span class="hljs-comment">/* Array of RelFileNode(s) to drop at abort */</span><br>        RelFileNode     xnodes[<span class="hljs-number">1</span>];          <span class="hljs-comment">/* VARIABLE LENGTH ARRAY */</span><br>        <span class="hljs-comment">/* ARRAY OF ABORTED SUBTRANSACTION XIDs FOLLOWS */</span><br>&#125; xl_xact_abort;<br></code></pre></td></tr></table></figure><p>因此，如果在’recovery_target_time’参数中设置了目标时间，PostgreSQL每当重放提交或中止操作的XLOG记录时，<br>就可以选择是否继续恢复。当重放每种操作的XLOG记录时，PostgreSQL会比较目标时间和记录中写入的每个时间戳，<br>如果时间戳超过了目标时间，PITR过程就会结束。</p><blockquote><p>info<br>The function read_backup_label() is defined in src&#x2F;backend&#x2F;access&#x2F;transam&#x2F;xlog.c.</p><p>The structure xl_xact_commit and xl_xact_abort are defined in src&#x2F;include&#x2F;access&#x2F;xact.h.</p></blockquote><blockquote><p>为什么我们可以使用普通的归档工具制作基础备份呢？</p><p>恢复过程是一个将数据库集群恢复到一致状态的过程，即使该集群本身不一致。PITR正是基于恢复过程的，<br>因此即便基础备份是一组不一致的文件，它也能够恢复数据库集群。这就是为什么我们能够使用普通的归档工具<br>而无需文件系统快照功能或特殊工具的原因。</p></blockquote><h3 id="10-3-timelineId-and-Timeline-History-File"><a href="#10-3-timelineId-and-Timeline-History-File" class="headerlink" title="10.3. timelineId and Timeline History File"></a><a name="timeline"></a>10.3. timelineId and Timeline History File</h3><p>在PostgreSQL中，时间线（timeline）用于区分原始数据库集群和恢复的集群，是PITR（Point-in-Time Recovery）<br>中的一个核心概念。<br>本节将描述与时间线相关的两个要素：timelineId和时间线历史文件。</p><h4 id="10-3-1-timelineId"><a href="#10-3-1-timelineId" class="headerlink" title="10.3.1. timelineId"></a>10.3.1. timelineId</h4><p>每个时间线都有一个相应的时间线ID（timelineId），这是一个从1开始的4字节无符号整数。</p><p>每个数据库集群都会被分配一个独立的时间线ID。由initdb工具创建的原始数据库集群的时间线ID为1。<br>每当数据库集群进行恢复时，时间线ID就会增加1。例如，在前一节的例子中，从原始集群恢复出的集群的时间线ID就是2。</p><p>图10.3从时间线ID的角度展示了PITR过程。</p><p>首先，我们移除当前的数据库集群，并恢复之前制作的基础备份，以便回到恢复的起始点。这种情况在图中以红色箭头曲线表示。</p><p>接下来，我们启动PostgreSQL服务器，它会重放归档日志中的WAL数据，从pg_backup_start创建的REDO点开始，<br>沿着初始时间线（时间线ID 1）直至恢复目标。这种情况在图中以蓝色箭头直线表示。<br>然后，为恢复后的数据库集群分配一个新的时间线ID 2，PostgreSQL在此新时间线上运行。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch10/ch10/img_2.png" alt="img_2.png"></p><p>正如第9章中简要提到的，WAL段文件名的前8位数字等于创建该段的数据库集群的时间线ID。<br>当时间线ID发生变化时，WAL段文件名也会相应改变。</p><p>聚焦于WAL段文件，恢复过程可以这样描述：假设我们使用两个归档日志<br>‘000000010000000000000009’和‘00000001000000000000000A’来恢复数据库集群。<br>新恢复的数据库集群会被分配时间线ID 2，PostgreSQL将从‘00000002000000000000000A’开始创建新的WAL段文件。</p><p>图10.4展示了这种情况。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch10/ch10/img_3.png" alt="img_3.png"></p><h4 id="10-3-2-Timeline-History-File"><a href="#10-3-2-Timeline-History-File" class="headerlink" title="10.3.2. Timeline History File"></a>10.3.2. Timeline History File</h4><p>当PITR过程完成后，会在归档目录下以及pg_xlog子目录（在版本10或之后为pg_wal子目录）<br>中创建一个名为类似‘00000002.history’的时间线历史文件。这个文件记录了它从哪个时间线分支出来以及分支发生的时间。</p><p>The naming rule of this file is shown below:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&quot;8-digit new timelineId&quot;.history<br></code></pre></td></tr></table></figure><p>时间线历史文件至少包含一行，每行由以下三项组成：</p><ol><li>timelineId：用于恢复的归档日志的时间线ID。  </li><li>LSN：WAL段切换发生的LSN（日志序列号）位置。  </li><li>reason：关于为什么时间线发生变更的人可读解释。</li></ol><p>A specific example is shown below:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres&gt; </span><span class="language-bash"><span class="hljs-built_in">cat</span> /home/postgres/archivelogs/00000002.<span class="hljs-built_in">history</span></span><br>1  0/A000198before 2024-1-1 12:05:00.861324+00<br></code></pre></td></tr></table></figure><p>Meaning as follows:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">该数据库集群（时间线ID = 2）是基于时间线ID为1的基础备份构建的，<br>并且通过重放归档日志直到位置‘0/A000198’，恢复到了‘2024-1-1 12:05:00.861324+00’这一时刻之前的状态。<br></code></pre></td></tr></table></figure><p>这样一来，每个时间线历史文件都向我们完整叙述了单个恢复数据库集群的历史。此外，它也在PITR过程本身中发挥作用。<br>具体细节将在下一节中解释。</p><blockquote><p>info</p><p>版本9.3对时间线历史文件格式进行了更改。以下是9.3版本或之后以及更早版本的格式示例，但未详细展开。</p><p>Later version 9.3:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">timelineIdLSN&quot;reason&quot;<br></code></pre></td></tr></table></figure><p>Until version 9.2:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">timelineIdWAL_segment&quot;reason&quot;<br></code></pre></td></tr></table></figure></blockquote><h3 id="10-4-Point-in-Time-Recovery-with-Timeline-History-File"><a href="#10-4-Point-in-Time-Recovery-with-Timeline-History-File" class="headerlink" title="10.4. Point-in-Time Recovery with Timeline History File"></a><a name="pitr-timeline"></a>10.4. Point-in-Time Recovery with Timeline History File</h3><p>时间线历史文件在第二次及以后的PITR过程中扮演着重要角色。通过尝试再次恢复，我们将探讨它是如何被使用的。</p><p>再次假设，在时间线ID为2的已恢复数据库集群中，您在‘12:15:00’时犯了一个错误。在这种情况下，为了恢复数据库集群，<br>您应该创建一个如下所示的新recovery.conf文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">restore_command = &#x27;cp /mnt/server/archivedir/%f %p&#x27;<br>recovery_target_time = &quot;2024-1-1 12:15:00 GMT&quot;<br>recovery_target_timeline = 2<br></code></pre></td></tr></table></figure><p>参数recovery_target_time设置的是您犯新错误的时间点，而参数recovery_target_timeline设置为2，<br>目的是沿着时间线ID 2进行恢复。</p><p>重启PostgreSQL服务器并进入PITR模式，以便沿着时间线ID 2恢复目标时间点的数据库。参见图10.5。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch10/ch10/img_4.png" alt="img_4.png"></p><ol><li><p>PostgreSQL 从 backup_label 文件中读取 CHECKPOINT LOCATION 的值。  </p></li><li><p>从 recovery.conf 文件中读取某些参数的值；在这个例子中，<br>包括 restore_command、recovery_target_time 和 recovery_target_timeline。  </p></li><li><p>根据 recovery_target_timeline 参数的值，PostgreSQL 读取对应的时间线历史文件 ‘00000002.history’。  </p></li><li><p>PostgreSQL 按照以下步骤重放WAL数据：</p><p> 从 REDO 点到 0&#x2F;A000198 LSN（该LSN记录在‘00000002.history’文件中），PostgreSQL读取<br>并重放时间线ID为1的适当归档日志中的WAL数据。<br> 从 0&#x2F;A000198 LSN之后到时间戳 2024-1-1 12:15:00 之前，PostgreSQL读取并<br>重放时间线ID为2的适当归档日志中的WAL数据。     </p></li><li><p>当恢复过程完成时，当前的时间线ID将进阶到3，并在 pg_wal 子目录（如果是9.6或更早版本则是 pg_xlog 目录）<br>以及归档目录中创建一个新的命名为 ‘00000003.history’ 的时间线历史文件。</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres&gt; </span><span class="language-bash"><span class="hljs-built_in">cat</span> /home/postgres/archivelogs/00000003.<span class="hljs-built_in">history</span></span><br>1         0/A000198     before 2024-1-1 12:05:00.861324+00<br><br>2         0/B000078     before 2024-1-1 12:15:00.927133+00<br></code></pre></td></tr></table></figure><p>当您进行多次PITR操作时，应该明确设置时间线ID以使用相应的时间线历史文件。</p><p>这样一来，时间线历史文件不仅是数据库集群的历史记录日志，也是PITR过程中恢复指令的重要参考文档。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL指南：内幕探索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch1. 数据库集簇、数据库和数据表</title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch1/ch1/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch1/ch1/</url>
    
    <content type="html"><![CDATA[<h2 id="ch1-数据库集簇、数据库和数据表"><a href="#ch1-数据库集簇、数据库和数据表" class="headerlink" title="ch1. 数据库集簇、数据库和数据表"></a>ch1. 数据库集簇、数据库和数据表</h2><p>本章及下一章概括了PostgreSQL的基本知识，以帮助阅读后续章节。本章涵盖了以下主题：  </p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#logical-structure">1.1 数据库集簇的逻辑结构</a></td></tr><tr><td><a href="#physical-structure">1.2 数据库集簇的物理结构</a></td></tr><tr><td><a href="#heap-table-layout">1.3 堆表文件的内部布局</a></td></tr><tr><td><a href="#read-write-methods">1.4 向表中读写元组的方式</a></td></tr></tbody></table><p>如果您已经熟悉这些主题，您可以跳过本章。</p><h3 id="1-1-数据库集簇的逻辑结构"><a href="#1-1-数据库集簇的逻辑结构" class="headerlink" title="1.1 数据库集簇的逻辑结构"></a><a name="logical-structure"></a>1.1 数据库集簇的逻辑结构</h3><p>数据库集群是由PostgreSQL服务器管理的一系列数据库的集合。如果您是首次听到这个定义，<br>可能对此概念感到好奇。在PostgreSQL中，“数据库集群”这个词并不意味着“一组数据库服务器”。<br>一个PostgreSQL服务器运行在一个单一主机上并管理着一个单独的数据库集群。</p><p>图1.1展示了数据库集群的逻辑结构。一个数据库是数据库对象的集合。在关系型数据库理论中，<br>数据库对象是一种用于存储或引用数据的数据结构。堆表是一个典型的例子，还有许多其他类型，<br>比如索引、序列、视图、函数等。在PostgreSQL中，数据库自身也是数据库对象，并且在逻辑上相互独立。<br>所有其他的数据库对象（如表、索引等）都归属于各自的数据库。<br><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch1/ch1/img.png" alt="img.png"></p><p>PostgreSQL中的所有数据库对象都通过各自的对象标识符（OID）进行内部管理，这些标识符是无符号<br>的4字节整数。数据库对象及其相应OID之间的关联关系会根据对象的类型存储在相应的系统目录中。<br>例如，数据库的OID存储在pg_database表中，而堆表（普通表）的OID则存储在pg_class表中。<br>您可以通过执行如下类似的查询来找出您想要了解的OID：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">sampledb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> datname, oid <span class="hljs-keyword">FROM</span> pg_database <span class="hljs-keyword">WHERE</span> datname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;sampledb&#x27;</span>;<br> datname  <span class="hljs-operator">|</span>  oid<br><span class="hljs-comment">----------+-------</span><br> sampledb <span class="hljs-operator">|</span> <span class="hljs-number">16384</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><br>sampledb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> relname, oid <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;sampletbl&#x27;</span>;<br>  relname  <span class="hljs-operator">|</span>  oid<br><span class="hljs-comment">-----------+-------</span><br> sampletbl <span class="hljs-operator">|</span> <span class="hljs-number">18740</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><h3 id="1-2-数据库集簇的物理结构"><a href="#1-2-数据库集簇的物理结构" class="headerlink" title="1.2 数据库集簇的物理结构"></a><a name="logical-structure"></a>1.2 数据库集簇的物理结构</h3><p>数据库集群基本上就是一个单一的目录，称为基本目录（base directory）。它包含一些子目录和<br>众多文件。当你执行initdb工具初始化一个新的数据库集群时，会在指定的目录下创建一个基本目录。<br>基本目录的路径通常被设置为环境变量 <em>PGDATA</em> 的值。</p><p>图1.2展示了PostgreSQL中数据库集群的一个示例。一个数据库是基本子目录下的一个子目录，<br>而每个表和索引至少是存储在其所属数据库子目录下的一个文件。还有几个包含特定数据和配置文件的子目录。</p><p>虽然PostgreSQL支持表空间（tablespaces），但这一术语的含义与其他关系型数据库管理系统（RDBMS）有所不同。在PostgreSQL中，表空间是一个包含基本目录之外某些数据的单一目录。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch1/ch1/img_1.png" alt="img_1.png"></p><p>在接下来的各个小节中，将详细描述PostgreSQL中数据库集群的结构布局、数据库、与表和索引相关的文件，以及表空间的安排。</p><h4 id="1-2-1-数据库集簇的布局"><a href="#1-2-1-数据库集簇的布局" class="headerlink" title="1.2.1 数据库集簇的布局"></a>1.2.1 数据库集簇的布局</h4><p>数据库集群的布局已在官方文档中进行了描述。文档的一部分列出了主要文件和子目录，如表1.1所示：</p><p>表1.1：基础目录下文件与子目录的布局（出自官方文档）</p><table><thead><tr><th>Files</th><th>Description</th></tr></thead><tbody><tr><td>PG_VERSION</td><td>包含PostgreSQL的主要版本号的一个文件。</td></tr><tr><td>pg_hba.conf</td><td>控制PostgreSQL客户端认证的一个文件。</td></tr><tr><td>pg_ident.conf</td><td>控制PostgreSQL用户名映射的一个文件。</td></tr><tr><td>postgresql.conf</td><td>设置配置参数的一个文件。</td></tr><tr><td>postgresql.auto.conf (versions 9.4 or later)</td><td>存储在ALTER SYSTEM设置的配置参数的一个文件。</td></tr><tr><td>postmaster.opts</td><td>记录服务器上次启动时使用的命令行选项的一个文件。</td></tr></tbody></table><table><thead><tr><th>Subdirectories</th><th>Description</th></tr></thead><tbody><tr><td>base&#x2F;</td><td>包含每个数据库子目录的子目录。</td></tr><tr><td>global&#x2F;</td><td>包含全局表（如pg_database和pg_control）的子目录。</td></tr><tr><td>pg_commit_ts (versions 9.5 or later)</td><td>包含事务提交时间戳数据的子目录。</td></tr><tr><td>pg_clog (versions 9.6 or earlier)</td><td>包含事务提交状态数据的子目录。在版本10中重命名为pg_xact。CLOG将在第5.4节中描述。</td></tr><tr><td>pg_dynshmem&#x2F;</td><td>包含动态共享内存子系统的文件（从版本9.4开始）。</td></tr><tr><td>pg_logical</td><td>包含逻辑解码的状态数据（从版本9.4开始）。</td></tr><tr><td>pg_multixact</td><td>包含多事务状态数据（用于共享行锁）。</td></tr><tr><td>pg_notify</td><td>包含LISTEN&#x2F;NOTIFY状态数据。</td></tr><tr><td>pg_repslot</td><td>包含复制槽数据（从版本9.4开始）。</td></tr><tr><td>pg_serial</td><td>包含已提交可串行化事务的信息（从版本9.1开始）。</td></tr><tr><td>pg_snapshots</td><td>包含导出快照。PostgreSQL的功能pg_export_snapshot在这个子目录中创建快照信息文件（从版本9.2开始）。</td></tr><tr><td>pg_stat</td><td>包含统计子系统的永久性文件。</td></tr><tr><td>pg_stat_tmp</td><td>包含统计子系统的临时文件。</td></tr><tr><td>pg_subtrans</td><td>包含子事务状态数据。</td></tr><tr><td>pg_tblspc</td><td>包含指向表空间的符号链接。</td></tr><tr><td>pg_twophase</td><td>包含预提交事务的状态文件。</td></tr><tr><td>pg_wal（从版本10开始）</td><td>包含WAL（Write Ahead Logging）段文件。自版本10起，它被重命名为pg_xlog。</td></tr><tr><td>pg_xact（从版本10开始）</td><td>包含事务提交状态数据。自版本10起，它被重命名为pg_clog。CLOG将在第5.4节中描述。</td></tr><tr><td>pg_xlog（从版本9.6或更早版本）</td><td>包含WAL（Write Ahead Logging）段文件。自版本10起，它被重命名为pg_wal。</td></tr></tbody></table><h4 id="1-2-2-数据库的布局"><a href="#1-2-2-数据库的布局" class="headerlink" title="1.2.2 数据库的布局"></a>1.2.2 数据库的布局</h4><p>数据库是基础子目录下的一个子目录。数据库目录的名称与其相应的OID（对象标识符）相同。<br>例如，如果数据库’sampledb’的OID是16384，那么其子目录的名称就是16384。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">$ cd $PGDATA<br>$ ls <span class="hljs-operator">-</span>ld base<span class="hljs-operator">/</span><span class="hljs-number">16384</span><br>drwx<span class="hljs-comment">------  213 postgres postgres  7242  8 26 16:33 16384</span><br></code></pre></td></tr></table></figure><h4 id="1-2-3-表和索引关联文件的布局"><a href="#1-2-3-表和索引关联文件的布局" class="headerlink" title="1.2.3 表和索引关联文件的布局"></a>1.2.3 表和索引关联文件的布局</h4><p>20:50每个大小小于1GB的表或索引都存储在其所属数据库目录下的单个文件中。表和索引在内部通过各自的OID进行管理，<br>而它们的数据文件则通过变量relfilenode进行管理。表和索引的relfilenode值基本上但<strong>不总是</strong>与各自的OID相匹配，<br>具体细节如下所述。</p><p>例如，展示表’sampletbl’的OID和relfilenode如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">sampledb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> relname, oid, relfilenode <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;sampletbl&#x27;</span>;<br>  relname  <span class="hljs-operator">|</span>  oid  <span class="hljs-operator">|</span> relfilenode<br><span class="hljs-comment">-----------+-------+-------------</span><br> sampletbl <span class="hljs-operator">|</span> <span class="hljs-number">18740</span> <span class="hljs-operator">|</span>       <span class="hljs-number">18740</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>请看，oid与relfilenode的值在此情况下相等。此外，表“sampletbl”的数据文件路径为“base&#x2F;16384&#x2F;18740”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">$ cd $PGDATA<br>$ ls <span class="hljs-operator">-</span>la base<span class="hljs-operator">/</span><span class="hljs-number">16384</span><span class="hljs-operator">/</span><span class="hljs-number">18740</span><br><span class="hljs-operator">-</span>rw<span class="hljs-comment">------- 1 postgres postgres 8192 Apr 21 10:21 base/16384/18740</span><br></code></pre></td></tr></table></figure><p>表和索引的relfilenode值可以通过某些命令改变，比如TRUNCATE、REINDEX、CLUSTER。例如，如果我们截断表’sampletbl’，PostgreSQL会为该表分配一个新的relfilenode（18812），移除旧的数据文件（18740），并创建一个新的（18812）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">sampledb<span class="hljs-operator">=</span># <span class="hljs-keyword">TRUNCATE</span> sampletbl;<br><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span><br><br>sampledb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> relname, oid, relfilenode <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;sampletbl&#x27;</span>;<br>  relname  <span class="hljs-operator">|</span>  oid  <span class="hljs-operator">|</span> relfilenode<br><span class="hljs-comment">-----------+-------+-------------</span><br> sampletbl <span class="hljs-operator">|</span> <span class="hljs-number">18740</span> <span class="hljs-operator">|</span>       <span class="hljs-number">18812</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><blockquote><p>提示</p><p>在9.0或之后的版本中，内置函数pg_relation_filepath非常有用，因为它可以根据指定的OID或名称返回关系的文件路径名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">sampledb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> pg_relation_filepath(<span class="hljs-string">&#x27;sampletbl&#x27;</span>);<br>pg_relation_filepath<br><span class="hljs-comment">----------------------</span><br>base<span class="hljs-operator">/</span><span class="hljs-number">16384</span><span class="hljs-operator">/</span><span class="hljs-number">18812</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure></blockquote><p>当表和索引的文件大小超过1GB时，PostgreSQL会创建一个名为relfilenode.1的新文件并使用它。如果这个新文件也被填满，PostgreSQL将继续创建名为relfilenode.2的另一个新文件，以此类推。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">$ cd $PGDATA<br>$ ls <span class="hljs-operator">-</span>la <span class="hljs-operator">-</span>h base<span class="hljs-operator">/</span><span class="hljs-number">16384</span><span class="hljs-operator">/</span><span class="hljs-number">19427</span><span class="hljs-operator">*</span><br><span class="hljs-operator">-</span>rw<span class="hljs-comment">------- 1 postgres postgres 1.0G  Apr  21 11:16 data/base/16384/19427</span><br><span class="hljs-operator">-</span>rw<span class="hljs-comment">------- 1 postgres postgres  45M  Apr  21 11:20 data/base/16384/19427.1</span><br></code></pre></td></tr></table></figure><blockquote><p>提示</p><p>表和索引的最大文件大小可以通过构建PostgreSQL时使用的配置选项“–with-segsize”来更改。</p></blockquote><p>在数据库的子目录下，你会注意到每个表都有两个相关联的文件，扩展名为‘_fsm’和‘_vm’，它们分别是空闲空间映射和<br>可见性映射。</p><p>空闲空间映射用来记录表文件内每一页的空闲空间情况，而可见性映射则记录表文件内各页数据的可见性状态。<br>（更多详细内容可参考第5.3.4节和第6.2节。）</p><p>索引仅有空闲空间映射文件，没有可见性映射文件。</p><p>具体示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$PGDATA</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -la base/16384/18751*</span><br>-rw------- 1 postgres postgres  8192 Apr 21 10:21 base/16384/18751<br>-rw------- 1 postgres postgres 24576 Apr 21 10:18 base/16384/18751_fsm<br>-rw------- 1 postgres postgres  8192 Apr 21 10:18 base/16384/18751_vm<br></code></pre></td></tr></table></figure><p>空闲空间映射和可见性映射在内部也可能被称为每个关系的数据文件的分叉。其中，空闲空间映射是表或索引数据文件的第一个分叉（分叉编号为1），<br>可见性映射则是表数据文件的第二个分叉（分叉编号为2）。数据文件本身的分叉编号为0。</p><h4 id="1-2-4-表空间"><a href="#1-2-4-表空间" class="headerlink" title="1.2.4 表空间"></a>1.2.4 表空间</h4><p>PostgreSQL中的表空间是一个位于基本目录之外的额外数据区域。此功能在8.0版本中实现。</p><p>图1.3展示了表空间的内部结构及其与主数据区域的关系:<br><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch1/ch1/img_2.png" alt="img_2.png"><br>Fig. 1.3. A Tablespace in the Database Cluster.</p><p>表空间在执行CREATE TABLESPACE语句时指定的目录下创建。在该目录下，会创建一个版本特定的子目录<br>（例如，PG_14_202011044）。版本特定子目录的命名规则如下所示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">PG _ &#x27;Major version&#x27; _ &#x27;Catalogue version number&#x27;<br></code></pre></td></tr></table></figure><p>例如，如果在目录‘&#x2F;home&#x2F;postgres&#x2F;tblspc’下创建了一个名为’new_tblspc’的表空间，其OID为16386，则在该表空间下会创建一个名为‘PG_14_202011044’的子目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l /home/postgres/tblspc/</span><br>total 4<br>drwx------ 2 postgres postgres 4096 Apr 21 10:08 PG_14_202011044<br></code></pre></td></tr></table></figure><p>表空间目录通过从pg_tblspc子目录下的符号链接进行寻址。该链接名称与表空间的OID值相同。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l <span class="hljs-variable">$PGDATA</span>/pg_tblspc/</span><br>total 0<br>lrwxrwxrwx 1 postgres postgres 21 Apr 21 10:08 16386 -&gt; /home/postgres/tblspc<br></code></pre></td></tr></table></figure><p>如果在该表空间下创建一个新数据库（OID 16387），则其目录将在版本特定的子目录下创建。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l /home/postgres/tblspc/PG_14_202011044/</span><br>total 4<br>drwx------ 2 postgres postgres 4096 Apr 21 10:10 16387<br></code></pre></td></tr></table></figure><p>如果在基础目录下创建的数据库中创建一个新表，首先会在版本特定的子目录下创建一个新的目录。<br>新目录的名称与现有数据库的OID相同。接着，新表文件将被放置在所创建的目录下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">sampledb<span class="hljs-operator">=</span># <span class="hljs-keyword">CREATE TABLE</span> newtbl (.....) TABLESPACE new_tblspc;<br><br>sampledb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> pg_relation_filepath(<span class="hljs-string">&#x27;newtbl&#x27;</span>);<br>             pg_relation_filepath<br><span class="hljs-comment">---------------------------------------------</span><br> pg_tblspc<span class="hljs-operator">/</span><span class="hljs-number">16386</span><span class="hljs-operator">/</span>PG_14_202011044<span class="hljs-operator">/</span><span class="hljs-number">16384</span><span class="hljs-operator">/</span><span class="hljs-number">18894</span><br></code></pre></td></tr></table></figure><h3 id="1-3-堆表文件的内部布局"><a href="#1-3-堆表文件的内部布局" class="headerlink" title="1.3 堆表文件的内部布局"></a><a name="heap-table-layout"></a>1.3 堆表文件的内部布局</h3><p>在数据文件（堆表、索引、自由空间映射和可见性映射）内部，它被划分为固定长度的页（或块），<br>默认长度为8192字节（8 KB）。每个文件内的页从0开始顺序编号，这些编号称为块号。如果文件已满，<br>PostgreSQL会在文件末尾添加一个新的空白页以增大文件尺寸。</p><p>页的内部布局取决于数据文件类型。本节将描述表的布局，因为这些信息在后续章节中将会用到。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch1/ch1/img_3.png" alt="img_3.png"></p><p>表内的一页包含三种数据：</p><ol><li><p>堆元组（heap tuple） - 堆元组是记录数据本身。<br>堆元组按照从页底部开始的顺序堆叠。 堆元组的内部结构在第5.2节和第9章中有描述，<br>因为这需要了解PostgreSQL中的并发控制（CC）和预写日志（WAL）知识。</p></li><li><p>行指针（line pointer） - 行指针长4字节，持有指向每个堆元组的指针。也被称为项目指针。<br>行指针形成一个简单的数组，起到对元组的索引作用。每个索引从1开始编号，称为偏移量编号。<br>当新元组添加到页上时，也会在数组中新增一个行指针指向新元组。</p></li><li><p>页头数据（header data） - 由PageHeaderData结构定义的页头数据位于页的开头，占24字节，<br>包含了关于该页的一般信息。 结构的主要变量描述如下：</p></li></ol><p>PageHeaderData</p><p>pd_lsn     - 此变量存储最后一次更改此页时所写的XLOG记录的LSN（日志序列号）。<br>它是一个8字节的无符号整数，与WAL（预写日志）机制有关。详情在第9.1.2节描述。</p><p>pd_checksum - 此变量存储该页的校验和值。（请注意，此变量在9.3版本或之后支持；在<br>早期版本中，这部分存储的是页的时间线ID。）</p><p>pd_lower, pd_upper - pd_lower指向行指针的结束位置，pd_upper指向最新堆元组的起始位置。</p><p>pd_special  - 此变量用于索引。在表的页中，它指向页的末尾。（在索引的页中，它指向特殊空间的起始，<br>特殊空间是仅由索引持有的数据区域，根据索引类型（如B树、GiST、GiN等）包含特定数据。）</p><p>页内行指针结束与最新元组起始之间的空隙被称为自由空间或空洞。</p><p>为了在表内唯一标识一个元组，内部使用了元组标识符（TID）。TID由一对值组成：包含该元组的页的块号，<br>以及指向该元组的行指针的偏移量编号。其典型应用场景之一是索引。更多细节请见第1.4.2节。</p><blockquote><p>提示</p><p>The structure PageHeaderData is defined in src&#x2F;include&#x2F;storage&#x2F;bufpage.h.</p><p>在计算机科学领域，这种类型的页被称为槽页（slotted page），行指针则对应于一个槽数组（slot array）。</p></blockquote><p>此外，大小超过约2KB（8KB的大约1&#x2F;4）的堆元组将使用一种称为TOAST（The Oversized-Attribute Storage Technique，大属性存储技术）<br>的方法进行存储和管理。详细信息请参考PostgreSQL文档。</p><h3 id="1-4-向表中读写元组的方式"><a href="#1-4-向表中读写元组的方式" class="headerlink" title="1.4 向表中读写元组的方式"></a><a name="read-write-methods"></a>1.4 向表中读写元组的方式</h3><p>在本章的最后，将描述写入和读取堆元组的方法。</p><h4 id="1-4-1-写入堆元组的过程"><a href="#1-4-1-写入堆元组的过程" class="headerlink" title="1.4.1 写入堆元组的过程"></a>1.4.1 写入堆元组的过程</h4><p>假设一个表由仅包含一个堆元组的一页构成。该页的pd_lower指向第一个行指针，行指针和pd_upper都指向第一个堆元组。<br>参见图1.5(a)。</p><p>当插入第二个元组时，它被放置在第一个元组之后。第二个行指针追加在第一个之后，并指向第二个元组。<br>pd_lower更新为指向第二个行指针，pd_upper则指向第二个堆元组。参见图1.5(b)。<br>此页内的其他头部数据（如pd_lsn、pd_checksum、pd_flags等）也会被更新为合适的值；<br>更多细节在第5.3节和第9.4节中有描述。<br><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch1/ch1/img_4.png" alt="img_4.png"></p><h4 id="1-4-2-读取堆元组的过程"><a href="#1-4-2-读取堆元组的过程" class="headerlink" title="1.4.2 读取堆元组的过程"></a>1.4.2 读取堆元组的过程</h4><p>这里概述两种典型的访问方法：顺序扫描和B-树索引扫描：</p><p>顺序扫描 – 通过遍历每个页中的所有行指针，顺序读取所有页中的所有元组。参见图1.6(a)。</p><p>B-树索引扫描 – 读取包含索引元组的索引文件，每个索引元组由索引键和指向目标堆元组的TID组成。<br>如果找到了具有所需键的索引元组，PostgreSQL将使用获得的TID值读取目标堆元组。(这里未解释如何在B-树索引中查找索引元组的具体方法，<br>因其过程较为常见且篇幅有限。详情请参阅相关资料。) 例如，在图1.6(b)中，<br>获取的索引元组的TID值为‘(块 &#x3D; 7, 偏移 &#x3D; 2)’。这意味着目标堆元组位于表中第7页的第2个元组，<br>因此PostgreSQL可以直接读取所需的堆元组，无需在其他页中进行不必要的扫描。</p><p><img src="/2025/05/05/DB/PostgreSQL%E6%8C%87%E5%8D%97/%E5%86%85%E5%B9%95%E6%8E%A2%E7%B4%A2_new_release/ch1/ch1/img_5.png" alt="img_5.png"></p><p>This document does not explain indexes in details.<br>To understand them, I recommend to read the valuable posts shown below:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">https://postgrespro.com/blog/pgsql<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">sampledb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> ctid, data <span class="hljs-keyword">FROM</span> sampletbl <span class="hljs-keyword">WHERE</span> ctid <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;(0,1)&#x27;</span>;<br> ctid  <span class="hljs-operator">|</span>   data<br><span class="hljs-comment">-------+-----------</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> AAAAAAAAA<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><blockquote><p>Info</p><p>PostgreSQL还支持TID扫描、位图扫描和仅索引扫描。TID扫描是一种直接利用目标元组的TID访问元组的方法。例如，要查找表中第0页的第一个元组，可以执行如下查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">sampledb<span class="hljs-operator">=</span># <span class="hljs-keyword">SELECT</span> ctid, data <span class="hljs-keyword">FROM</span> sampletbl <span class="hljs-keyword">WHERE</span> ctid <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;(0,1)&#x27;</span>;<br>ctid  <span class="hljs-operator">|</span>   data<br><span class="hljs-comment">-------+-----------</span><br>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> AAAAAAAAA<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>Index-Only-Scan will be described in details in Section 7.2.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL指南：内幕探索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/flB/flB/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/flB/flB/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/flA/flA/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/flA/flA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch8/ch8/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch8/ch8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch9/ch9/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch9/ch9/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ch6. 逻辑解码与逻辑复制</title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch6/ch6/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch6/ch6/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>PostgreSQL技术内幕<br>事务处理深度探索<br>ch6. 逻辑解码与逻辑复制</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>PG的物理复制即流复制，它主要复制的是数据库中的WAL日志，并按照顺序在备机上回放，<br>从而获得和主机一致的数据。<br>逻辑复制放松很多限制。<br>PG的物理日志的内容是二进制的，是对页面写操作的一种描述；<br>PG的逻辑日志则是对当前事务操作的描述。是对物理日志进行解码得到，按照顺序。  </p><h5 id="6-1-复制槽"><a href="#6-1-复制槽" class="headerlink" title="6.1 复制槽"></a>6.1 复制槽</h5><p>复制槽 – 解决逻辑复制过程中的状态保存问题，PG分为物理复制槽和逻辑复制槽。  </p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL技术内幕-事务处理深度探索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch7/ch7/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch7/ch7/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ch5. 物理复制</title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch5/ch5/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch5/ch5/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>PostgreSQL技术内幕<br>事务处理深度探索<br>ch5. 物理复制</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>从日志复制时机上看(区别：事务提交时是否需要等待备机的日志持久性消息)：<br>异步复制<br>同步复制<br>从日志的形态看：<br>逻辑复制<br>物理复制  </p><h5 id="5-1-环境搭建"><a href="#5-1-环境搭建" class="headerlink" title="5.1 环境搭建"></a>5.1 环境搭建</h5><h5 id="5-2-物理复制"><a href="#5-2-物理复制" class="headerlink" title="5.2 物理复制"></a>5.2 物理复制</h5><h5 id="5-3-同步复制"><a href="#5-3-同步复制" class="headerlink" title="5.3 同步复制"></a>5.3 同步复制</h5><p>物理复制可以分为同步复制和异步复制。<br>同步复制 – 在主机的事务提交时，必须保证该事物产生的WAL日志已经在备机中刷入或回放，否则主机的事务不能提交。<br>异步复制 – 不必关心事务日志在备机中是否已经写入。  </p><h5 id="5-4-HotStandby"><a href="#5-4-HotStandby" class="headerlink" title="5.4 HotStandby"></a>5.4 HotStandby</h5><p>hot_standby &#x3D; on，则代表当前的主备集群是Hot Standby集群。<br>Hot指当前的备机可以支持读操作，即常见的一些多读集群。  </p><h5 id="5-5-物理复制槽"><a href="#5-5-物理复制槽" class="headerlink" title="5.5 物理复制槽"></a>5.5 物理复制槽</h5><p>PG 9.4引入，主要用来记录复制的状态：<br>一方面，可以防止在物理复制(流复制)的过程中，主机清理掉备机所需的WAL日志<br>另一方面，为了逻辑复制做准备<br>wal_keep_segments – 指定WAL日志回收时，需要保持的余量。<br>创建物理复制槽目前有两种方法：<br>1、在备机上指定GUC参数 primary_slot_name, 这样在创建复制连接时，他会在主机上查找<br>同名的复制槽然后使用。<br>2、设置GUC参数，wal_receiver_create_temp_slot 为true，这样就会给每个没有指定 primary_slot_name<br>的复制连接都创建一个临时复制槽，在WalSender退出时，临时复制槽会被清理掉。<br>物理复制槽<br>逻辑复制槽  </p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL技术内幕-事务处理深度探索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch3. 故障恢复</title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch4/ch4/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch4/ch4/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>PostgreSQL技术内幕<br>事务处理深度探索<br>ch4. 故障恢复</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="4-1-故障的分类"><a href="#4-1-故障的分类" class="headerlink" title="4.1 故障的分类"></a>4.1 故障的分类</h5><p>1、事务级故障<br>2、系统级故障<br>3、硬件故障和灾难性故障  </p><h5 id="4-2-事务日志"><a href="#4-2-事务日志" class="headerlink" title="4.2 事务日志"></a>4.2 事务日志</h5><p>WAL日志记录以 Append 方式不断追加到日志文件中，即对磁盘做顺序写入，这样可以避免数据页面直接写入的<br>随机IO问题，在性能上有一定优势。<br>PostgreSQL 的故障恢复主要基于 ARIES方法 实现。  </p><h5 id="4-3-日志文件"><a href="#4-3-日志文件" class="headerlink" title="4.3 日志文件"></a>4.3 日志文件</h5><p>目前，PostgreSQL 中只有Redo 日志，没有Undo 日志。<br>日志序列号(LSN)  </p><h5 id="4-4-查看日志内容"><a href="#4-4-查看日志内容" class="headerlink" title="4.4 查看日志内容"></a>4.4 查看日志内容</h5><p>资源管理器<br>RmgrData<br><img src="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch4/ch4/img.png" alt="img.png">  </p><h5 id="4-5-日志格式"><a href="#4-5-日志格式" class="headerlink" title="4.5 日志格式"></a>4.5 日志格式</h5><p>XLogRecord – 每个日志记录固定的头部信息<br>book 123p</p><h5 id="4-6-XLog-初始化"><a href="#4-6-XLog-初始化" class="headerlink" title="4.6 XLog 初始化"></a>4.6 XLog 初始化</h5><p>XLogCtlData – 记录了当前 WAL的写入状态、刷盘状态及Buffer页面的状态等<br>XLogCtlInsert – 向WAL日志中写入新的日志记录所需的各种变量</p><h5 id="4-7-日志的注册"><a href="#4-7-日志的注册" class="headerlink" title="4.7 日志的注册"></a>4.7 日志的注册</h5><p>日志中间状态的变量 src\backend\access\transam\xloginsert.c：100<br>PostgreSQL 提供了写入日志的标准接口，包括注册数据、组装数据及写入数据等。<br>128p<br>事务日志不直接写入 WAL Buffer，而是先组成 XLogRecData 链表，然后将这个链表转化为一条事务日志。<br>src\backend\access\transam\xloginsert.c<br>XLogBeginInsert<br>XLogRegisterData<br>XLogRegisterDBuffer<br>XLogRegisterDBufData  </p><h5 id="4-8-日志的组成"><a href="#4-8-日志的组成" class="headerlink" title="4.8 日志的组成"></a>4.8 日志的组成</h5><p>XLogRecordAssemble src\backend\access\transam\xloginsert.c：509<br>此函数很重要  </p><h5 id="4-9-日志的写入"><a href="#4-9-日志的写入" class="headerlink" title="4.9 日志的写入"></a>4.9 日志的写入</h5><p>XLogRecordAssemble 函数能够将所有注册的日志转换为二进制的形式，本节介绍把这些日志<br>写入WAL Buffer的过程，PG将此过程分为预留空间和数据复制两个步骤。<br>预留空间<br>数据复制  </p><h5 id="4-10-控制文件"><a href="#4-10-控制文件" class="headerlink" title="4.10 控制文件"></a>4.10 控制文件</h5><p>保存着数据库运行过程中的控制信息</p><h5 id="4-11-Full-Page-Write"><a href="#4-11-Full-Page-Write" class="headerlink" title="4.11 Full Page Write"></a>4.11 Full Page Write</h5><p>由于PostgreSQL默认的页面大小为8KB，而磁盘缓存的页面大小为4KB，磁盘扇区为512B，因此一个<br>数据库页面写入磁盘的过程并非原子操作。那么，刷入4KB后发生故障，则数据库中就会出现<br>坏页，前半部分、后半部分数据不一致，PG可以检测出坏页(数据一致性校验的方法)，但是无法避免出现坏页。<br>MySQL – Double Write机制，基于整页备份的思想，当出现半页写时，用备份页面覆盖坏页。<br>PG – FPW，将数据页保存于WAL日志中，以Checkpoint 为界，当一个页面在最近一次Checkpoint后第一次<br>被修改时，需要考虑FPW。  </p><h5 id="4-12-检查点"><a href="#4-12-检查点" class="headerlink" title="4.12 检查点"></a>4.12 检查点</h5><p>book 142-162p</p><h6 id="4-12-1-检查点的触发"><a href="#4-12-1-检查点的触发" class="headerlink" title="4.12.1 检查点的触发"></a>4.12.1 检查点的触发</h6><p>自动触发checkpoint的衡量指标：<br>1、时间 checkpoint_timeout<br>2、日志数量，达到一定数量自动触发<br>CheckPointSegments – 表示上一次Checkpoint之后新增多少日志才需要触发一个新的CHECKPOINT。<br>CalculateCheckpointSegments – 计算</p><h6 id="4-12-2-BgWriter-刷入脏页"><a href="#4-12-2-BgWriter-刷入脏页" class="headerlink" title="4.12.2 BgWriter 刷入脏页"></a>4.12.2 BgWriter 刷入脏页</h6><p>148 - 151p<br>循环将可能被重复利用的缓存页面刷入磁盘。它需要领先于页面淘汰算法的循环过程，这样它才能<br>提前刷入脏页，避免用户后台进程去独自利用页面淘汰算法交换页面。<br>领先 – BgWriter领先页面淘汰算法一轮  </p><h6 id="4-12-3-回写机制"><a href="#4-12-3-回写机制" class="headerlink" title="4.12.3 回写机制"></a>4.12.3 回写机制</h6><p>UPS保护 – 是一种含有储能装置的不间断电源。主要用于给部分对电源稳定性要求较高的设备，提供不间断的电源。<br>回写 – 磁盘缓存写入磁盘存储介质</p><h6 id="4-12-4-Sync-请求"><a href="#4-12-4-Sync-请求" class="headerlink" title="4.12.4 Sync 请求"></a>4.12.4 Sync 请求</h6><p>检查点进程被唤醒时，会马上处理CheckpointerShmemStruct中的requests，这些request是不同的后台进程在对<br>数据文件进行操作时记录下来的。<br>RememberSyncRequest<br>例如：<br>mdwrite-&gt;register_dirty_segment-&gt;RegisterSyncRequest-&gt;RememberSyncRequest …  </p><h6 id="4-12-5-检查点的创建"><a href="#4-12-5-检查点的创建" class="headerlink" title="4.12.5 检查点的创建"></a>4.12.5 检查点的创建</h6><h6 id="4-12-6-检查点中脏页的刷入"><a href="#4-12-6-检查点中脏页的刷入" class="headerlink" title="4.12.6 检查点中脏页的刷入"></a>4.12.6 检查点中脏页的刷入</h6><h6 id="4-12-7-检查点中的XLog清理"><a href="#4-12-7-检查点中的XLog清理" class="headerlink" title="4.12.7 检查点中的XLog清理"></a>4.12.7 检查点中的XLog清理</h6><h5 id="4-13-日志归档"><a href="#4-13-日志归档" class="headerlink" title="4.13 日志归档"></a>4.13 日志归档</h5><p>archive_mode – 三种模式：<br>ON – 归档打开，不允许机器处于RECOVERy模式下时进行归档<br>OFF – 不对日志进行归档<br>ALWAYS – 如果长时间没有归档，则尝试在做日志切换后，强制归档<br>日志归档的目的是能够通过归档日志对数据库进行恢复，只设置archive_mode和archive_command还不能<br>完全满足故障恢复的要求，还需要保证wal_level不能是MINIMAL状态，因为此时PG会省略一些WAL日志，在数据库<br>启动时会进行检查。<br>归档命令：<br>%p – 源文件的路径<br>%f – 源文件的名字<br>致命缺点：归档命令必须有效，否则，待归档的日志由于没有被真正的归档，就需要一直保留，这样日志清理时就无法清理成功，导致日志堆积。<br>见 RemoveOldXlogFiles<br><img src="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch4/ch4/img_1.png" alt="img_1.png"><br>每当WAL日志中的一个日志段(日志文件)已满，需要切换到下一个日志段时，就可以通知日志归档进程将这个日志归档，<br>触发日志段切换的进程会向PostMaster进程发出通知，然后PostMaster进程会检查日志归档进程是否启动，如果存在，<br>则PostMaster会将这个通知再转发给日志归档进程。<br>产生日志切换的进程会在通知PostMaster之前先在pg_wal&#x2F;archive_status下生成一个 .ready 文件，这个文件<br>和待归档的日志同名。日志归档进程只关心是否存在此文件，不关心内容。<br>XLogWrite 发送通知<br>XLogArchiveNotify 发送日志归档的通知信息<br>由于只有在日志段切换时才能进行归档，那么可能会数据丢失。<br>archive_timeout – 指向了日志归档的最大时间间隔，如果超过这个设定的时间而没有进行日志归档<br>那么需要做一次日志切换，这样就会强制归档。<br>CheckArchiveTimeout  </p><h5 id="4-14-基础备份"><a href="#4-14-基础备份" class="headerlink" title="4.14 基础备份"></a>4.14 基础备份</h5><p>逻辑备份 – pg_dump<br>物理备份：<br>冷备：停止数据库的备份<br>热备：不需要停机的备份<br>命令： pg_start_backup&#x2F;pg_stop_backup 函数  </p><p>pg_start_backup：<br>3个参数。<br>1、用户给本次操作定义的名字<br>2、fast参数。如果为true，则为CHECKPOINT_IMMEDIATE类型的检查点，影响性能。<br>3、是否是排他模式。是否可以多个pg_start_backup。<br>当使用排他模式时，会在数据目录下创建一个新的backup_labal文件，这个文件中保存的是Backup开始时数据库实例的状态。<br>backup_label – 记录了检查点的位置信息，检查点即执行pg_start_backup创建的。从这个检查点开始，强制进入FPW模式，<br>这就避免了直接复制数据的一致性问题。  </p><h5 id="4-15-PITR"><a href="#4-15-PITR" class="headerlink" title="4.15 PITR"></a>4.15 PITR</h5><p>1、时间线<br>recovery_target_action:<br>shutdown – PITR恢复之后，数据库服务停止<br>promote – PITR恢复之后，数据库开始提供服务<br>pause – PITR之后暂停，用户可以连接数据库进行只读操作，需要<br>执行 pg_wal_replay_resume 函数继续  </p><p>pg_wal_replay_pause: 暂停日志回放，此时可以进行只读操作，提供了数据检查的机会。<br>时间线历史文件 – 记录了从哪个时间线的哪个日志跳转的  </p><h5 id="4-16-故障恢复"><a href="#4-16-故障恢复" class="headerlink" title="4.16 故障恢复"></a>4.16 故障恢复</h5><p>startup进程、StartupXLOG函数<br>通过不同的函数，startup进程能够分为：<br>故障恢复 – 不存在下述文件，则为普通故障恢复<br>备机回放 – standby.signal, 则为备机<br>PITR – recovery.signal, 则为PITR<br>等功能提供服务  </p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL技术内幕-事务处理深度探索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch3. MVCC</title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch3/ch3/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch3/ch3/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>PostgreSQL技术内幕<br>事务处理深度探索<br>ch3. MVCC</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>MVCC – 通过记录数据副本的方式，实现读写操作互不阻塞<br>MySQL、Oracle – 回滚段、undo<br>MySQL – 记录最新元组和历史元组的联系，根据时间判断可见<br>Oracle – 基于页面回滚的方式<br>PostgreSQL – 历史元组和最新元组存于Heap表  </p><h5 id="3-1-元组上的版本信息"><a href="#3-1-元组上的版本信息" class="headerlink" title="3.1 元组上的版本信息"></a>3.1 元组上的版本信息</h5><p>每条元组 – 在头部记录版本信息，xmin、xmax、CommandID及一些Hints信息。<br>src\include\access\htup_details.h：121<br><img src="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch3/ch3/img.png" alt="img.png">  </p><h5 id="3-2-快照"><a href="#3-2-快照" class="headerlink" title="3.2 快照"></a>3.2 快照</h5><p>PostgreSQL 数据库的快照要保存当前的所有活跃事务的最小xid，最大xid，当前的活跃事务列表，当前事务的CommandID。<br>快照可以分为多种类型，每种快照类型都对应了一种判断元组可见性的方法。<br>快照中最重要的信息 xmin、xmax、xid(含 subxip)， 它们可以用来表示当前系统中所有事务所处的状态。<br>Snapshot-&gt;xmin – 代表的是当前所有活跃事务中的最小 xid，若 xid &lt; Snapshot-&gt;xmin ，则证明此事务提交或终止。<br>Snapshot-&gt;xmax – 借助 latestCompletedXid 获得的，xmax &#x3D; latestCompletedXid + 1 ，没当事务提交时，如果这个xid<br>比系统记录的 latestCompletedXid 更大，则需要 latestCompletedXid 的值为正在提交的 xid<br>latestCompletedXid – 记录的是所有已提交事务中最大的那个 xid<br>那么，一个 xid 大于 xmax，就代表这个事务还是活跃事务(或 尚未启动)。需要注意，此处的活跃指的是获得快照的<br>瞬时是活跃的，在快照存续期间，即使已经提交，快照的内容也不会变化。<br><strong>可见性判断</strong><br>快照类型<br>SnapshotType</p><h5 id="3-3-获得快照"><a href="#3-3-获得快照" class="headerlink" title="3.3 获得快照"></a>3.3 获得快照</h5><p>生成一个快照要遍历 PGPROC 和 PGXACT 结构体<br>src\backend\utils\time\snapmgr.c<br>在PG14 之前，获取快照的同时会获得4个 xmin 变量：<br>TransactionXmin – 它的值和PGPROC 中的xmin保持一致，是当前事务第一次获得快照时的快照xmin<br>RecentXmin – 每次获得快照时的快照xmin<br>RecentGlobalXmin – 首先遍历PGPROC数组获得最小的 PGPROC-&gt;xmin(代表当前事务开始时最小的活跃事务ID)，<br>比它小的事务都已经提交或回滚；然后，减去为vacuum预留的空间；最后，结合复制槽中的xmin 和 Catalog xmin，<br>找到全局最小的xmin<br>RecentGlobalDataXmin – 不考虑事务槽中的 Catalog xmin<br>PG 14 修改以及 openguass csn！  </p><h5 id="3-4-可见性判断"><a href="#3-4-可见性判断" class="headerlink" title="3.4 可见性判断"></a>3.4 可见性判断</h5><p>src\backend\access\heap\heapam_visibility.c：968<br>基于MVCC的可见性判断方法要结合快照，可参考《内幕指南》<br><strong>CSN</strong><br>B站 吕海波视频</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL技术内幕-事务处理深度探索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch2/hangsuo/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch2/hangsuo/</url>
    
    <content type="html"><![CDATA[<h1 id="dayStudy"><a href="#dayStudy" class="headerlink" title="dayStudy"></a>dayStudy</h1><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>PostgreSQL 行锁</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p><img src="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch2/hangsuo/img_8.png" alt="img_8.png"><br><img src="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch2/hangsuo/img_9.png" alt="img_9.png"><br>在表上加 RowShareLock，还会加元组级常规锁<br><img src="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch2/hangsuo/img_10.png" alt="img_10.png">  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ch2. 锁</title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch2/ch2/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch2/ch2/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>PostgreSQL技术内幕<br>事务处理深度探索<br>ch2. 锁</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>并发控制机制：<br>1、基于封锁的并发控制<br>2、基于时间戳的并发控制<br>PostgreSQL数据库采用两阶段锁和MVCC相结合的方法。</p><h5 id="2-1-并发的异常现象"><a href="#2-1-并发的异常现象" class="headerlink" title="2.1 并发的异常现象"></a>2.1 并发的异常现象</h5><h5 id="2-2-调度"><a href="#2-2-调度" class="headerlink" title="2.2 调度"></a>2.2 调度</h5><h5 id="2-3-并发控制"><a href="#2-3-并发控制" class="headerlink" title="2.3 并发控制"></a>2.3 并发控制</h5><p>1、乐观<br>2、悲观<br>区别：何时检测冲突<br>乐观并发控制 – 事后检测冲突，一般三个阶段：<br>读阶段 – 事务维护一个读集合和写集合，并且将对对象的写操作存放到私有空间中<br>有效性确认阶段 – 事务提交时检查两个集合，如果发现违反了可串行化原则，要终止事务<br>写阶段 – 有效性确认之后，对事务在私有空间中的数据进行应用，事务提交成功  </p><p><strong>悲观并发控制</strong> – 事先检测冲突 两阶段锁技术  </p><h5 id="2-4-两阶段锁"><a href="#2-4-两阶段锁" class="headerlink" title="2.4 两阶段锁"></a>2.4 两阶段锁</h5><p>增长阶段 – 尝试申请锁，不允许放锁<br>收缩阶段 – 可以放锁，但是禁止再申请新的锁  </p><p>PostgreSQL中的封锁协议在2PL基础上增强，为S2PL，区别在于S2PL在<strong>事务提交统一放锁</strong>。  </p><h5 id="2-5-PostgreSQL中的锁"><a href="#2-5-PostgreSQL中的锁" class="headerlink" title="2.5 PostgreSQL中的锁"></a>2.5 PostgreSQL中的锁</h5><p>数据库内核通过自己控制、调度锁，来解放应用程序的生产力。<br>在PostgreSQL中，锁分为3个层次。<br>1、自旋锁<br>2、轻量锁 – 借助原子操作的原语进行“无锁”保护，这样会降低“锁”的粒度，提高并发的性能<br>3、常规锁 – 两阶段锁即借助常规锁实现。可分为不同粒度。借助轻量锁、自旋锁实现<br>在数据库对象中，又可以分为三种类型：<br>表锁 – 对表加锁，会依照操作的不同加不同等级的锁<br>页面锁 – PostgreSQL的存储是基于页面的，因此操作页面要加锁<br>行锁 – 元组锁，利用常规锁和xmax相结合方式加锁<br>用户可以利用LOCK命令加锁，再如可以利用咨询锁(Advisory Lock)对数据库对象加锁，咨询锁的<br>持锁时间不受事务的影响，即可以跨事务。  </p><h6 id="2-5-1-自旋锁"><a href="#2-5-1-自旋锁" class="headerlink" title="2.5.1 自旋锁"></a>2.5.1 自旋锁</h6><p>自旋锁的自旋等待虽然浪费CPU资源，但是它比释放CPU资源带来的切换上下文的消耗要小，这时自旋是值得的。<br>自旋锁：<br>1、不想释放CPU资源<br>2、保护的临界区“小”<br>book 45-49p<br>TAS CAS<br>在X86下，提供了XCHG和CMPXCHG命令实现TAS、CAS<br>PostgreSQL采用基于XCHG的TAS来实现的自旋锁<br>TTAS存在误判<br>PostgreSQL在原地自旋做了优化：<br>1、适当的偷懒<br><img src="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch2/ch2/img.png" alt="img.png"><br>目的是不放弃CPU，但也没必要不停的旋。<br>2、在哪里旋转，就在哪里“休息一下”。<br>尝试多次TAS后仍然无法获得锁资源，那么就进入sleep，即交出CPU资源，sleep时间随机但是不能超过上下界。<br><img src="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch2/ch2/img_1.png" alt="img_1.png"><br>3、如果旋转了很长时间，仍然没有办法获得锁资源，那么进入自杀模式。<br><img src="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch2/ch2/img_2.png" alt="img_2.png"><br>放锁过程：<br>采用内存屏障保证锁释放的有序性。  </p><h6 id="2-5-2-轻量锁"><a href="#2-5-2-轻量锁" class="headerlink" title="2.5.2 轻量锁"></a>2.5.2 轻量锁</h6><p>自旋锁是一种互斥锁。<br>共享内存保护 – 轻量锁<br>模式：共享、排他<br>轻量锁有两种使用方法：<br>1、统一保存的 Individual LWLocks<br>2、BuiltinTranches 方式<br>两种方式即形式不同，本质上没有区别。  </p><p>一、Individual LWLocks<br>目前45种，src\backend\storage\lmgr\lwlocknames.txt中<br>保存于MainLWLockArray中，每种都有自己固定要保护的对象，使用方式如下：<br>LWLockAcquire(ShmemIndexLock, LW_EXCLUSIVE);<br>xxx<br>LWLockRelease(ShmemIndexLock);<br>MainLWLockArray中前 (NUM_INDIVIDUAL_LWLOCKS -1)个都是 Individual LWLocks  </p><p>二、BuiltinTranches<br>每个 Builtin Tranche 可能对应多个LWLock，它代表的是一组LWLocks，虽然各自封锁各自的内容，但是功能相同。<br>BuiltinTrancheIds<br>src\include\storage\lwlock.h<br>book 52-55p<br>存在两种拓展方法。<br>1、RequestNamedLWLockTranche与GetNamedLWLockTranche<br><img src="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch2/ch2/img_3.png" alt="img_3.png"><br><img src="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch2/ch2/img_4.png" alt="img_4.png"><br>2、LWLockNewTrancheId LWLockRegisterTranche LWLockInitialize<br><img src="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch2/ch2/img_5.png" alt="img_5.png"><br><img src="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch2/ch2/img_6.png" alt="img_6.png"><br><img src="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch2/ch2/img_7.png" alt="img_7.png"><br>下面介绍LWLock庐山真面目！<br>src\include\storage\lwlock.h<br>src\backend\storage\lmgr\lwlock.c  </p><h6 id="2-5-3-常规锁"><a href="#2-5-3-常规锁" class="headerlink" title="2.5.3 常规锁"></a>2.5.3 常规锁</h6><h5 id="2-6-常规锁的内存结构"><a href="#2-6-常规锁的内存结构" class="headerlink" title="2.6 常规锁的内存结构"></a>2.6 常规锁的内存结构</h5><p>InitLocks 初始话保存锁对象的共享内存空间。<br>LockMethodLockHash、LockMethodProcLockHash  </p><h5 id="2-7-常规锁的加锁"><a href="#2-7-常规锁的加锁" class="headerlink" title="2.7 常规锁的加锁"></a>2.7 常规锁的加锁</h5><h5 id="2-8-行锁"><a href="#2-8-行锁" class="headerlink" title="2.8 行锁"></a>2.8 行锁</h5><p>book 73-84p<br>虽然用常规所来对元组加锁也能防止多个事务同时修改一个元组，但是常规锁保存在锁表中，<br>锁表在共享内存中的大小是有限的。如果一个事务修改了大量的元组，那么就需要在事务中申请<br>大量的行级常规锁，则锁表规模增大，性能劣化，这是难以接受的。<br>PostgreSQL采用常规锁(元组级常规锁)和行锁(xmax)结合的方式来实现行锁。<br>在PostgreSQL中，通常有两种方式对元组加锁：<br>1、UPDATE、DELETE操作<br>2、通过显式的指定行锁<br>FOR UPDATE…<br>src\include\nodes\lockoptions.h<br>相容性矩阵：<br>左三角<br>FOR UPDATE<br>FOR NO KEY UPDATE<br>FOR SHARE<br>FOR KEY SHARE  </p><p>UPDATE、DELETE操作加锁：<br>DELETE – 行级排他锁，FOR UPDATE<br>UPDATE – 不修改键值 - FOR NO KEY UPDATE<br>            修改键值 - FOR UPDATE<br>src\backend\access\heap\heapam.c:119<br>MultiXact中的锁模式也保存，如果只有一个事务加行锁，直接xmax设置xid，并在infomask中设置对应的所类型。<br>但是可以加行级共享锁，多个事务对统一元组加锁，因此需要MultiXactId，使用时会加HEAP_XMAX_IS_MULTI标记。<br>src\include\access\htup_details.h：189<br>行锁和标记位的反向对应关系：<br>FOR UPDATE – HEAP_KEYS_UPDATED 和 HEAP_XMAX_EXCL_LOCK|HEAP_XMAX_LOCK_ONLY<br>FOR NO KEY UPDATE – HEAP_XMAX_EXCL_LOCK|HEAP_XMAX_LOCK_ONLY<br>FOR SHARE – HEAP_XMAX_SHR_LOCK|HEAP_XMAX_LOCK_ONLY<br>FOR KEY SHARE – HEAP_XMAX_KEYSHR_LOCK|HEAP_XMAX_LOCK_ONLY<br>UPDATE – HEAP_KEYS_UPDATED 和 HEAP_XMAX_EXCL_LOCK<br>DELETE – HEAP_KEYS_UPDATED 和 HEAP_XMAX_EXCL_LOCK<br>MultiXactId的锁模式<br>src\include\access\multixact.h:40<br>以更新操作为例：<br>src\include\access\tableam.h：68 – 元组的状态类型<br>src\backend\access\heap\heapam.c heap_update - replace a tuple  </p><h5 id="2-9-死锁检测"><a href="#2-9-死锁检测" class="headerlink" title="2.9 死锁检测"></a>2.9 死锁检测</h5><p>实边虚边<br>死锁检测需要保护锁表，但是从本地锁表或FastPath 就能获得，则它不会受死锁检测的限制。<br>如何寻找链表中的环？<br>1、快慢指针<br>2、PostgreSQL 通过 visitedProcs 数组方法来找环<br>当它要检查一个 PGPROC 时，将这个会话和 visitedProcs 中的 PGPROC 逐个对比， 查看是否存在于其中。<br>如果没有，那么现在还没有环，此时将当前检查的 PGPROC 加入其中，然后开始检查下一个。<br>环的检查是有目标的，只关心当前会话，如果检测到了其他会话的环，不报死锁。<br>EDGE src\backend\storage\lmgr\deadlock.c：37<br>DeadLockCheckRecurse 会不断地递归调用，如果遇到实边则停止并报死锁错误，<br>如果有虚边构成的环，就会尝试在 curConstraints 中推进探测的 Configuration<br>TestConfiguration 函数：<br>1、根据当前的 Configuration (即curConstraints)产生新的等待队列，TopoSort 函数根据输入的锁及虚边数组信息，<br>通过拓扑排序的方法获得一个新的等待队列<br>2、使用新的等待队列检测是否存在环，优先查找实边，找到报错；否则查找虚边，找到则加入 possibleConstraints 中  </p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL技术内幕-事务处理深度探索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch1. 事务概述</title>
    <link href="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch1/ch1/"/>
    <url>/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch1/ch1/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>PostgreSQL技术内幕<br>    事务处理深度探索<br>ch1. 事务概述    </p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>把由一组语句构成的一个逻辑单元叫作一个事务<br>事务的基本性质：<br>A(Atomicity) 原子性： 一个事务要么全做，要么全不做<br>C(Consistency) 一致性： 在应用层面，通过完整性约束保持数据一致<br>I(Isolation) 隔离性： 不同事物之间不会相互影响<br>D(Durability) 持久性： 事务在提交之后，它对数据库的改变不会消失  </p><h5 id="1-1-事务的作用"><a href="#1-1-事务的作用" class="headerlink" title="1.1 事务的作用"></a>1.1 事务的作用</h5><h5 id="1-2-事物的性质"><a href="#1-2-事物的性质" class="headerlink" title="1.2 事物的性质"></a>1.2 事物的性质</h5><p>1、数据库需要通过并发控制(Concurrency Control)机制和故障恢复技术来支持事务的ACID性质，如下图。<br>原子性 – 并发控制、故障恢复<br>一致性 – SQL的完整性约束(主键约束、外键约束等)<br>隔离性 – 并发控制<br>持久性 – 故障恢复  </p><p>2、 常用的并发控制技术<br>基于锁的并发控制<br>基于时间戳的并发控制<br>PostgreSQL针对DDL采用两阶段锁技术、针对DML语句采用多版本控制技术(MVCC)<br>PostgreSQL数据库的故障恢复采用WAL日志的方式，redo日志<br>通过redo日志和MVCC可以保证事务读写的一致性<br><img src="/2025/05/05/DB/PostgreSQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/ch1/ch1/img.png" alt="img.png"><br>3、Zheap – Undo日志</p><h5 id="1-3-事务的隔离级别"><a href="#1-3-事务的隔离级别" class="headerlink" title="1.3 事务的隔离级别"></a>1.3 事务的隔离级别</h5><p>事务的原子性、一致性、持久性被破坏是不可容忍的(PostgreSQL的事务异步提交属于对事务持久性的放松)，<br>考虑在隔离性上妥协。  </p><h5 id="1-4-PostgreSQL中的事务"><a href="#1-4-PostgreSQL中的事务" class="headerlink" title="1.4 PostgreSQL中的事务"></a>1.4 PostgreSQL中的事务</h5><p>从事务形态上划分，隐式事务和显示事务。隐式事务是一个独立的SQL语句，执行结束之后自动提交。<br>显示事务需要明确指定事务所需要的“标记”， 这些“标记”将一组SQL语句组合到一起，形成一个事务块(Transaction Block)。<br>一个事务块的开始使用BGEIN，结束使用COMMIT、END、ABORT、ROLLBACK等。<br>如果在事务块中发生了错误，由于事务需要满足原子性，那么事务块中后续的SQL语句就无法正常执行，但是仍然需要明确指定结束标记才可以彻底结束事务。<br>事务块是借助有限状态机实现的，包含很多状态，见 src\backend\access\transam\xact.c</p><h6 id="1-4-1-PostgreSQL的事务处理过程分成3个层次"><a href="#1-4-1-PostgreSQL的事务处理过程分成3个层次" class="headerlink" title="1.4.1 PostgreSQL的事务处理过程分成3个层次"></a>1.4.1 PostgreSQL的事务处理过程分成3个层次</h6><p>1、上层：处理显示的事务块命令<br>BeginTransactionBlock<br>EndTransactionBlock<br>UserAbortTransactionBlock<br>DefineSavepoint<br>RollbackToSavepoint<br>ReleaseSavepoint<br>等<br>2、中层：无论是事务块命令，还是事务块中间的DML、DDL命令，对于事务来说，每一条都是一个查询，每个查询的执行<br>都会借助中层的事务处理机制来完成<br>StartTransactionCommand<br>CommitTransactionCommand<br>AbortCurrentTransaction<br>(*Command)<br>3、底层：真正的事务处理机制<br>StartTransaction<br>CommitTransaction<br>AbortTransaction<br>CleanupTransaction<br>StartSubTransaction<br>CommitSubTransaction<br>AbortSubTransaction<br>CleanupSubTransaction  </p><p><strong>事务块</strong>的状态是通过上层函数和中层函数控制的，而底层函数主要控制<strong>事务状态</strong>(区别于事务块状态)。<br>事务的状态是底层事务真正的状态。<br>src\backend\access\transam\xact.c  </p><h6 id="1-4-2-PostgreSQL-事务状态切换过程"><a href="#1-4-2-PostgreSQL-事务状态切换过程" class="headerlink" title="1.4.2 PostgreSQL 事务状态切换过程"></a>1.4.2 PostgreSQL 事务状态切换过程</h6><p>book 10-14p</p><h6 id="1-4-3-PostgreSQL的子事务-savepoint"><a href="#1-4-3-PostgreSQL的子事务-savepoint" class="headerlink" title="1.4.3 PostgreSQL的子事务(savepoint)"></a>1.4.3 PostgreSQL的子事务(savepoint)</h6><p>每个SAVEPOINT都是一个单独的子事务块，用栈保存状态，则存在先后(父子)关系子事务对应的事务块状态：<br>src\backend\access\transam\xact.c<br>当执行ROLLBACK TO SAVEPOINT时，栈顶到这个目标SAVEPOINT之间的SAVEPOINT都会被丢弃。<br>SAVEPOINT使用的上层函数和中层函数与主事务相同，但是有自己的底层函数：<br>PushTransaction<br>PopTransaction<br>ReleaseSavepoint<br>RollbackToSavepoint<br>状态转换：<br>book 16-19p  </p><h6 id="1-4-4-隐式事务"><a href="#1-4-4-隐式事务" class="headerlink" title="1.4.4 隐式事务"></a>1.4.4 隐式事务</h6><p>隐式事务和显示事务的区别，就是它没有TBLOCK_INPROGRESS状态，全程处于TBLOCK_STARTED状态<br>隐式事务通常涉及中层及底层函数，并且可以用事务块状态来区分SQL是隐式事务还是显示事务<br>IsTransactionBlock  </p><h5 id="1-5-事务处理流程"><a href="#1-5-事务处理流程" class="headerlink" title="1.5 事务处理流程"></a>1.5 事务处理流程</h5><p>TransactionStateData结构体<br>src\backend\access\transam\xact.c  </p><h6 id="1-5-1-事务ID"><a href="#1-5-1-事务ID" class="headerlink" title="1.5.1 事务ID"></a>1.5.1 事务ID</h6><p>StartTransaction会执行：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c">s-&gt;state = TRANS_START;<br>s-&gt;fullTransactionId = InvalidFullTransactionId;<br>```  <br>其中不会申请事务ID，通常只读事务不会申请事务ID，只有涉及写操作时，才会分配事务ID，这是因为  <br>读操作只需要通过Snapshot就能判断元组可见性，不需要为只读事务产生事务日志。  <br>![img_1.png](ch1/img_1.png)  <br>同一个事务可能包含顶层的父事务和下层的子事务，因此在第一次分配事务ID时，不仅要给当前层的事务分配，还要给上层的事务分配。  <br>**顶层事务ID一定小于子事务ID**    <br>每个事务还有一个子事务编号(subTransactionId)，这个编号从TopSubTransactionId (值为<span class="hljs-number">1</span>)开始计数，事务存活期间唯一标识一个子事务。  <br>AssignTransactionId(src\backend\access\transam\xact.c)  <br>分配事务ID的工作在GetNewTransactionId函数中完成，事务ID的计数器保存在VariableCacheData结构体中，每次获取事务ID之后，  <br>都要对计数器+<span class="hljs-number">1</span>  <br>分配事务ID(生产者-消费者环形队列)存在回卷问题，因此分配时会检查如下Limit变量：  <br>VariableCacheData(src\include\access\transam.h)  <br>**<span class="hljs-number">64</span>位事务ID！**<br><br>###### <span class="hljs-number">1.5</span>.<span class="hljs-number">2</span> pg_subtrans 日志<br>借助SLRU记录事务ID的父子关系  <br>src\backend\access\transam\subtrans.c    <br>pg_subtrans对SLRU的操作不记录WAL，因为它只在事务活跃期间有效，数据库重启，内容会被彻底清除。  <br>StartupSUBTRANS  <br>**CSN**<br>###### <span class="hljs-number">1.5</span>.<span class="hljs-number">3</span> 启动事务<br>如果没有IUD操作，就不分配事务ID，但是用一个虚拟ID来代表自己  <br>src\include\storage\lock.h  <br>虚拟事务ID两部分：  <br><span class="hljs-number">1</span>、Backend ID -- 会话独有的ID  <br><span class="hljs-number">2</span>、每个会话自己维护的本地事务ID计数器  <br>可保证唯一性。  <br>StartTransaction() src\backend\access\transam\xact.c  <br><br>###### <span class="hljs-number">1.5</span>.<span class="hljs-number">4</span> 事务结束<br>两种情况：提交 or 回滚  <br>触发事务结束的行为如下：<br><span class="hljs-number">1</span>、手动终止，COMMIT END ROLLBACK ABORT  <br><span class="hljs-number">2</span>、执行过程中出现错误，导致不得不终止  <br><span class="hljs-number">3</span>、数据库故障导致的终止(机房断电)  <br><br>CLOG 记录事务提交状态：  <br>建立于SLRU之上。  <br>```c<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRANSACTION_STATUS_IN_PROGRESS0x00 <span class="hljs-comment">//运行在</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRANSACTION_STATUS_COMMITTED0x01 <span class="hljs-comment">//已经提交</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRANSACTION_STATUS_ABORTED0x02 <span class="hljs-comment">//事务已经异常终止</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRANSACTION_STATUS_SUB_COMMITTED0x03 <span class="hljs-comment">//子事务处于提交状态</span></span><br></code></pre></td></tr></table></figure><p>每个事务都需要用2位来记录状态，SLRU中每个页面的大小为 8192字节，则每页能存放32768个事务状态。<br>src\backend\access\transam\clog.c<br>CommitTransaction 中会对clog进行设置。<br>顶层事务和子事务在设置clog状态时，需要按照顺序：<br>1、所有事务ID都在同一页面，则获取一次锁即可<br>2、跨页面设置。(1)设置子事务状态为TRANSACTION_STATUS_SUB_COMMITTED，这个状态不是最终状态。<br>如果要判断子事务是否提交，当处于TRANSACTION_STATUS_SUB_COMMITTED时还要判断父事务是否COMMITED。<br>book 31-32p  </p><h5 id="1-6-异步提交"><a href="#1-6-异步提交" class="headerlink" title="1.6 异步提交"></a>1.6 异步提交</h5><p>事务提交时需要保证事务的WAL已经刷盘，WAL按照各种操作的顺序产生 – 将事务的随机读写转换成Append形式顺序读写。<br>XLogFlush – 刷盘<br>异步提交 – 放宽事务持久性要求，提高提交性能<br>WalWriter进程 – 事务在提交时，将lsn终点之前的WAL刷盘，才能保证事务真正提交  </p><h5 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7 小结"></a>1.7 小结</h5><p>…</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL技术内幕-事务处理深度探索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Conclusion</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/Conclusion/Conclusion/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/Conclusion/Conclusion/</url>
    
    <content type="html"><![CDATA[<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs text">Well, now our journey is coming to an end. I hope that you have found the book<br>useful—or at least interesting—and have learned something new from it (I myself<br>did learn a lot while I was writing it).<br>Most of the covered information is likely to remain up-to-date for quite a long time,<br>but some details will inevitably change very fast. I believe that the biggest value<br>of this book is not a set of particular facts but rather the approach to exploring<br>the system that I show. Neither this book nor the documentation should be taken<br>for granted. Contemplate, experiment, verify all the facts yourself: PostgreSQL<br>provides all the tools that you need for it, and I tried to show how to use them. It<br>is usually almost as easy as asking a question on a forum or googling the answer,<br>but is definitely much more reliable and useful.<br>For the same reason, I wanted to encourage you to look into the code. Do not get<br>intimidated by its complexity: simply try it out. Open source is a great advantage,<br>so take this opportunity.<br>I will be happy to get your feedback; you can send your comments and ideas to<br>edu@postgrespro.ru. I am going to update the book regularly, so your comments<br>can help me improve future editions. The latest online version of the book is avail-<br>able for free at postgrespro.com/community/books/internals.<br>Good luck!<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">好了，现在我们的旅程即将结束。希望你能觉得这本书有用 — 或至少有趣 — 并且从中学到了一些新东西(我自己在写作过程中也学到了很多)。<br><br>尽管大部分内容可能在很长一段时间内仍然是最新的，但一些细节将不可避免地发生变化。我相信这本书的最大价值不是一套具体的事实标准，而是我展示的探索系统的方式。你不应该认为这本书或相关文档中的信息是理所当然的。思考、实验、自行验证所有事实：PostgreSQL 为此提供了所有你需要的工具，我试图展示如何使用它们。这通常几乎和在论坛上提问或谷歌搜索答案一样简单，但绝对更可靠、更有用。<br><br>出于同样的原因，我还鼓励你查看代码。不要被其复杂性吓倒：只需尝试使用。开源是一个巨大的优势，所以抓住这个机会。很高兴收到你的反馈；你可以将你的评论和想法发送到 edu@postgrespro.ru。我打算定期更新这本书，所以你的评论可以帮助我改进未来的版本。最新的在线版本可在 postgrespro.com/community/books/internals 免费获取。<br><br>祝你好运！<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch9. Buffer Cache</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch9/ch9/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch9/ch9/</url>
    
    <content type="html"><![CDATA[<h2 id="ch9-Buffer-Cache"><a href="#ch9-Buffer-Cache" class="headerlink" title="ch9. Buffer Cache"></a>ch9. Buffer Cache</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">9.1 Caching</a></td></tr><tr><td><a href="#cp2">9.2 Buffer Cache Design</a></td></tr><tr><td><a href="#cp3">9.3 Cache Hits</a></td></tr><tr><td><a href="#cp4">9.4 Cache Misses</a></td></tr><tr><td><a href="#cp5">9.5 Bulk Eviction</a></td></tr><tr><td><a href="#cp6">9.6 Choosing the Buffer Cache Size</a></td></tr><tr><td><a href="#cp7">9.7 Cache Warming</a></td></tr><tr><td><a href="#cp8">9.8 Local Cache</a></td></tr></tbody></table><h3 id="9-1-Caching"><a href="#9-1-Caching" class="headerlink" title="9.1 Caching"></a><a name="cp1"></a>9.1 Caching</h3><p>在现代计算机系统中，缓存无处不在 — 不管是在硬件层面还是在软件层面。仅处理器自身就可能有多达三到四层缓存。RAID 控制器和磁盘也有它们自己的缓存。</p><p>缓存用于平衡高速与低速内存之间的性能差异。高速内存昂贵且容量更小，而低速内存更大且更便宜。因此，高速内存无法容纳所有存储在低速内存中的数据。但在大多数情况下，每个特定时刻只有一小部分数据被频繁使用，因此为缓存分配一些高速内存以保持热数据，可以显著减少低速内存访问所带来的开销。</p><p>在 PostgreSQL 中，缓冲区缓存 1 中保存着关系页面，以平衡对磁盘 (毫秒级) 和 RAM (纳秒级) 的访问时间。</p><p>出于同样目的，操作系统也有其自己的缓存。基于此，数据库系统通常被设计为要避免双缓存：通常直接查询存储在磁盘上的数据，绕过 OS 缓存。但是 PostgreSQL 使用了不同的方式：它通过缓冲区文件操作来读取和写入所有的数据。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">如果使用 Direct I/O ，那么便可以避免双缓存的问题。这将减少开销，因为 PostgreSQL 将使用直接内存访问 (DMA) 而不是将缓冲区页面复制到操作系统地址空间中；此外，你将直接控制磁盘上的物理写入。然而，Direct I/O 不支持数据预取 (Buffered I/O 支持预取)，因此你必须通过异步 I/O 单独实现它，这需要在 PostgreSQL 内核代码中进行大量的修改，以及处理操作系统在 Direct I/O 和异步 I/O 支持方面的不兼容问题。但一旦建立了异步通信，你便可以享受到无等待磁盘访问的额外好处。<br><br>PostgreSQL 社区已经开始了这项重大工程 2，但实际结果仍需要很长时间才能出现。<br><br>www.postgresql.org/message-id/flat/20210223100344.llw5an2aklengrmn%40alap3.anarazel.de<br></code></pre></td></tr></table></figure><h3 id="9-2-Buffer-Cache-Design"><a href="#9-2-Buffer-Cache-Design" class="headerlink" title="9.2 Buffer Cache Design"></a><a name="cp2"></a>9.2 Buffer Cache Design</h3><p>缓冲区缓存位于服务器的共享内存中，所有进程都可以访问。它占据了大部分的共享内存，并且无疑是 PostgreSQL 中最重要和最复杂的数据结构之一。理解缓存的工作原理本身就很重要，但更重要的是，许多其他结构 (例如子事务、CLOG 事务状态和 WAL 条目) 使用类似的缓存机制，尽管这些结构更简单一些。</p><p>这个缓存的名称受其内部结构的启发，因为它由一系列缓冲区组成。每个缓冲区保留了一个内存块，可以容纳单个数据页及其页头 3。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch9/ch9/img.png" alt="img.png"></p><p>页头包含了一些关于缓冲区和其中页面的信息，比如：</p><pre><code class="hljs">页面的物理位置 (文件 ID、分支和分支中的块号)用于显示页面中的数据已被修改，并且需要回写到磁盘的属性 (这样的页面被称为脏页)缓冲区使用计数锁定计数 (或者引用计数)</code></pre><p>要访问表的数据页，进程会向缓冲区管理器 4 请求它，并接收包含该页的缓冲区 ID。然后，读取缓存数据并在需要时直接在缓存中修改它。当页面正在使用时，其缓冲区被锁定。锁定过程会禁止逐出缓存页面，并且可以与其他锁一起使用。每次锁定也会增加使用计数。</p><p>只要页面被缓存，它的使用就不会产生任何文件操作。</p><p>我们可以使用 pg_buffercache 扩展来窥探缓冲区缓存：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> EXTENSION pg_buffercache;<br></code></pre></td></tr></table></figure><p>让我们创建一个表并插入一行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE TABLE</span> cacheme(<br>  id <span class="hljs-type">integer</span><br>) <span class="hljs-keyword">WITH</span> (autovacuum_enabled <span class="hljs-operator">=</span> off);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> cacheme <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>现在缓冲区缓存包含一个带有新插入行的堆页面。你可以通过选择与特定表相关的所有缓冲区进行查看。由于需要多次执行这样的查询，所以让我们将其封装至一个函数中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> buffercache(rel regclass)<br><span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">TABLE</span>(<br>  bufferid <span class="hljs-type">integer</span>, relfork text, relblk <span class="hljs-type">bigint</span>,<br>  isdirty <span class="hljs-type">boolean</span>, usagecount <span class="hljs-type">smallint</span>, pins <span class="hljs-type">integer</span><br>) <span class="hljs-keyword">AS</span> $$<br><span class="hljs-keyword">SELECT</span> bufferid,<br>  <span class="hljs-keyword">CASE</span> relforknumber<br>    <span class="hljs-keyword">WHEN</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;main&#x27;</span><br>    <span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;fsm&#x27;</span><br>    <span class="hljs-keyword">WHEN</span> <span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;vm&#x27;</span><br>  <span class="hljs-keyword">END</span>,<br>  relblocknumber,<br>  isdirty,<br>  usagecount,<br>  pinning_backends<br><span class="hljs-keyword">FROM</span> pg_buffercache<br><span class="hljs-keyword">WHERE</span> relfilenode <span class="hljs-operator">=</span> pg_relation_filenode(rel)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> relforknumber, relblocknumber;<br>$$ <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">sql</span>;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> buffercache(<span class="hljs-string">&#x27;cacheme&#x27;</span>);<br> bufferid <span class="hljs-operator">|</span> relfork <span class="hljs-operator">|</span> relblk <span class="hljs-operator">|</span> isdirty <span class="hljs-operator">|</span> usagecount <span class="hljs-operator">|</span> pins<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>      <span class="hljs-number">268</span> <span class="hljs-operator">|</span> main    <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span> t       <span class="hljs-operator">|</span>          <span class="hljs-number">1</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>页面是脏的：它已经被修改，但尚未写入磁盘。它的使用计数设置为 1。</p><h3 id="9-3-Cache-Hits"><a href="#9-3-Cache-Hits" class="headerlink" title="9.3 Cache Hits"></a><a name="cp3"></a>9.3 Cache Hits</h3><p>当缓冲区管理器需要读取一个页面时 5，它首先会检查缓冲区缓存。</p><p>所有缓冲区 ID 都存储在一个哈希表中 6，用于加速它们的搜索。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">许多现代编程语言将哈希表作为基础数据类型之一。哈希表通常被称为关联数组，实际上，从用户的角度来看，它们确实看起来像一个数组。但是，它们的索引 (哈希键) 可以是任何数据类型，例如一个文本字符串，而不是一个整数。<br><br>虽然可能的键值范围会非常大，但哈希表一次性永远不会包含那么多不同的值。哈希的思想是使用哈希函数将键值转换为一个整数。这个数字 (或这个数字的某些位) 被用作常规数组的索引。这个数组的元素被称为哈希表桶。<br><br>一个好的哈希函数在桶之间或多或少均匀地分配哈希键，但它仍然可能为不同的键分配相同的数字，从而将它们放入到同一个桶中；这种情况被称为哈希碰撞。因此，值与哈希键一起存储在桶中；要通过其键访问哈希值，PostgreSQL 必须检查所有存储在桶中的键。<br></code></pre></td></tr></table></figure><p>哈希表有多种实现方式；在所有可能的选项中，缓冲区缓存使用的是可扩展哈希表，通过链解决哈希碰撞 7。</p><p>哈希键由表文件的 ID、分支类型和此分支文件中的页面 ID 组成。因此，知道页面后，PostgreSQL 便可以快速找到包含该页面的缓冲区，或确认该页面当前没有被缓存。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch9/ch9/img_1.png" alt="img_1.png"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">长期以来，缓冲区缓存的实现因依赖于哈希表而饱受批评：当需要查找某个特定关系的页面所占用的所有缓冲区时，这种结构是没有用的，因为在运行 DROP 和 TRUNCATE 命令，或在清理期间截断一个表时 8，需要从缓存中移除页面。然而，到目前为止还没有人提出适当的替代方案。<br></code></pre></td></tr></table></figure><p>如果哈希表包含所需的缓冲区 ID，缓冲区管理器会锁定此缓冲区并将其 ID 返回给进程。然后这个进程便可以开始使用缓存页面，而不会产生任何 I&#x2F;O 流量。</p><p>为了锁定一个缓冲区，PostgreSQL 必须在其头部增加锁定计数；一个缓冲区可以同时被多个进程锁定。当其锁定计数大于零时，表明该缓冲区正在使用，不允许对其内容进行根本性的更改。例如，可以出现一条新的元组 (按照可见性规则，它将是不可见的)，但页面本身不能被替换。</p><p>当使用 analyze 和 buffers 选项运行时，EXPLAIN 命令会执行所展示的执行计划，并显示使用的缓冲区数量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, buffers, costs off, timing off, summary off)<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> cacheme;<br>                 QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> cacheme (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   Buffers: shared hit<span class="hljs-operator">=</span><span class="hljs-number">1</span><br> Planning:<br>   Buffers: shared hit<span class="hljs-operator">=</span><span class="hljs-number">12</span> read<span class="hljs-operator">=</span><span class="hljs-number">7</span><br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>此处 hit &#x3D; 1 意味着在缓存中找到了唯一需要读取的页面。</p><p>锁定缓冲区操作使得使用计数增加了 1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> buffercache(<span class="hljs-string">&#x27;cacheme&#x27;</span>);<br> bufferid <span class="hljs-operator">|</span> relfork <span class="hljs-operator">|</span> relblk <span class="hljs-operator">|</span> isdirty <span class="hljs-operator">|</span> usagecount <span class="hljs-operator">|</span> pins<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>      <span class="hljs-number">268</span> <span class="hljs-operator">|</span> main    <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span> t       <span class="hljs-operator">|</span>          <span class="hljs-number">2</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>为了在查询执行期间观察锁定行为，让我们打开一个游标 — 它将保持缓冲区锁定，因为它需要提供对结果集中下一行的快速访问：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DECLARE</span> c <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> cacheme;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FETCH</span> c;<br> id<br>−−−−<br>  <span class="hljs-number">1</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> buffercache(<span class="hljs-string">&#x27;cacheme&#x27;</span>);<br> bufferid <span class="hljs-operator">|</span> relfork <span class="hljs-operator">|</span> relblk <span class="hljs-operator">|</span> isdirty <span class="hljs-operator">|</span> usagecount <span class="hljs-operator">|</span> pins<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>      <span class="hljs-number">268</span> <span class="hljs-operator">|</span> main    <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span> t       <span class="hljs-operator">|</span>          <span class="hljs-number">3</span> <span class="hljs-operator">|</span>    <span class="hljs-number">1</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>如果某个进程无法使用被锁定的缓冲区，该进程通常会跳过它，并简单地选择另外一个缓冲区。我们可以在表清理期间看到这一点：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> VACUUM VERBOSE cacheme;<br>INFO: vacuuming &quot;public.cacheme&quot;<br>INFO: <span class="hljs-keyword">table</span> &quot;cacheme&quot;: found <span class="hljs-number">0</span> removable, <span class="hljs-number">0</span> nonremovable <span class="hljs-type">row</span><br>versions <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> <span class="hljs-keyword">out</span> <span class="hljs-keyword">of</span> <span class="hljs-number">1</span> pages<br>DETAIL: <span class="hljs-number">0</span> dead <span class="hljs-type">row</span> versions cannot be removed yet, oldest xmin:<br><span class="hljs-number">877</span><br>Skipped <span class="hljs-number">1</span> page due <span class="hljs-keyword">to</span> buffer pins, <span class="hljs-number">0</span> frozen pages.<br>CPU: <span class="hljs-keyword">user</span>: <span class="hljs-number">0.00</span> s, <span class="hljs-keyword">system</span>: <span class="hljs-number">0.00</span> s, elapsed: <span class="hljs-number">0.00</span> s.<br>VACUUM<br></code></pre></td></tr></table></figure><p>因为无法从被锁定的缓冲区中物理移除元组，所以页面被跳过了。</p><p>但如果的确需要这个缓冲区，那么进程将加入到队列中，并等待对这个缓冲区的独占访问。此操作的一个示例是带有 freeze 的清理操作 9。</p><p>一旦游标关闭或移动到另一个页面，缓冲区就会被取消锁定。在此示例中，这发生在事务结束时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> buffercache(<span class="hljs-string">&#x27;cacheme&#x27;</span>);<br> bufferid <span class="hljs-operator">|</span> relfork <span class="hljs-operator">|</span> relblk <span class="hljs-operator">|</span> isdirty <span class="hljs-operator">|</span> usagecount <span class="hljs-operator">|</span> pins<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>      <span class="hljs-number">268</span> <span class="hljs-operator">|</span> main    <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span> t       <span class="hljs-operator">|</span>          <span class="hljs-number">3</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0</span><br>      <span class="hljs-number">310</span> <span class="hljs-operator">|</span> vm      <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span> f       <span class="hljs-operator">|</span>          <span class="hljs-number">2</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>页面修改也受相同的锁定机制保护。例如，让我们再向表中插入另一行 (它会进入同一页面)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> cacheme <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> buffercache(<span class="hljs-string">&#x27;cacheme&#x27;</span>);<br> bufferid <span class="hljs-operator">|</span> relfork <span class="hljs-operator">|</span> relblk <span class="hljs-operator">|</span> isdirty <span class="hljs-operator">|</span> usagecount <span class="hljs-operator">|</span> pins<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>      <span class="hljs-number">268</span> <span class="hljs-operator">|</span> main    <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span> t       <span class="hljs-operator">|</span>          <span class="hljs-number">4</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0</span><br>      <span class="hljs-number">310</span> <span class="hljs-operator">|</span> vm      <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span> f       <span class="hljs-operator">|</span>          <span class="hljs-number">2</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>PostgreSQL 不会立即执行任何磁盘写入操作：页面会在缓冲区缓存中保持脏的状态一段时间，这为读取和写入操作带来了一些性能提升。</p><h3 id="9-4-Cache-Misses"><a href="#9-4-Cache-Misses" class="headerlink" title="9.4 Cache Misses"></a><a name="cp4"></a>9.4 Cache Misses</h3><p>如果哈希表中没有与查询页面相关的条目，那意味着这个页面没有被缓存。在此情况下，将分配一个新的缓冲区 (并立即锁定)，随后页面被读入此缓冲区中，哈希表引用也相应地被修改。</p><p>让我们重启实例以清除缓冲区缓存：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">pg_ctl restart -l /home/postgres/logfile</span><br></code></pre></td></tr></table></figure><p>尝试读取页面会导致缓存未命中，页面将被加载到一个新的缓冲区中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, buffers, costs off, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> cacheme;<br>QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> cacheme (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">2</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   Buffers: shared read<span class="hljs-operator">=</span><span class="hljs-number">1</span> dirtied<span class="hljs-operator">=</span><span class="hljs-number">1</span><br> Planning:<br>   Buffers: shared hit<span class="hljs-operator">=</span><span class="hljs-number">15</span> read<span class="hljs-operator">=</span><span class="hljs-number">7</span><br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>现在计划显示的是 read 状态，而不是 hit，这表明缓存未命中。此外，由于查询修改了一些提示位，这个页面已经变成了脏页。</p><p>缓冲区缓存查询显示，新添加页面的使用计数被设置为 1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> buffercache(<span class="hljs-string">&#x27;cacheme&#x27;</span>);<br> bufferid <span class="hljs-operator">|</span> relfork <span class="hljs-operator">|</span> relblk <span class="hljs-operator">|</span> isdirty <span class="hljs-operator">|</span> usagecount <span class="hljs-operator">|</span> pins<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>       <span class="hljs-number">98</span> <span class="hljs-operator">|</span> main    <span class="hljs-operator">|</span>      <span class="hljs-number">0</span> <span class="hljs-operator">|</span> t       <span class="hljs-operator">|</span>          <span class="hljs-number">1</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>pg_statio_all_tables 视图包含表的缓冲区缓存使用情况的完整统计数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> heap_blks_read, heap_blks_hit<br><span class="hljs-keyword">FROM</span> pg_statio_all_tables<br><span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;cacheme&#x27;</span>;<br> heap_blks_read <span class="hljs-operator">|</span> heap_blks_hit<br>−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<br>              <span class="hljs-number">2</span> <span class="hljs-operator">|</span>             <span class="hljs-number">5</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>PostgreSQL 为索引和序列提供了类似的视图。它们还可以显示有关 I&#x2F;O 操作的统计数据，但前提是需要打开 track_io_timing 参数。</p><h4 id="9-4-1-缓冲区查找与逐出"><a href="#9-4-1-缓冲区查找与逐出" class="headerlink" title="9.4.1 缓冲区查找与逐出"></a>9.4.1 缓冲区查找与逐出</h4><p>为页面选择缓冲区并非易事 10。有两种可能的情况：</p><ol><li><p>服务器启动后，所有缓冲区都是空的，并被绑定到一个列表中。当一些缓冲区仍然空闲时，从磁盘读取的下一个页面将占用第一个缓冲区，并将其从列表中移除。缓冲区只有在其页面消失时才能返回到列表中 11，而不是被另一个页面替换。如果调用 DROP 或 TRUNCATE 命令，或者表在清理期间被截断，则可能会发生这种情况。</p></li><li><p>最终，所有空闲的缓冲区都将被用完 (因为数据库的大小通常大于为缓存分配的内存块)。那个时候，缓冲区管理器将不得不选择一个已经在使用的缓冲区，并从这个缓冲区中逐出缓存页面。逐出操作使用的是时钟扫描算法，时钟隐喻很好地说明了这一点。时钟指针指向一个缓冲区，开始绕着缓冲区缓存转动，并且在经过时将每个缓存页面的使用计数减一。时钟指针找到的第一个计数为零，并且未被锁定的缓冲区将被清除。因此，每次访问缓冲区 (即锁定) 时，使用计数都会增加，而当缓冲区管理器搜索要逐出的页面时，使用计数会减少。最终，最近最少使用的页面首先被逐出，而那些经常访问的页面将在缓存中保留更长时间。可以猜到，如果所有缓冲区的使用计数均不等于零，在它们中的任何一个计数变为零之前，时钟指针必须完成一次以上的完整循环。为了避免多次循环，PostgreSQL 将使用计数限制为 5 次。一旦找到了要逐出的缓冲区，便需要从哈希表中删除仍在该缓冲区中的页面引用。但是如果这个缓冲区是脏的，也就是说，它包含了一些修改过的数据，那么旧页面将不能被简单地丢弃 — 缓冲区管理器必须先将其写入到磁盘。</p></li></ol><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch9/ch9/img_2.png" alt="img_2.png"></p><p>然后缓冲区管理器将一个新页面读入所找到的缓冲区中 — 无论它是否需要被逐出或仍然是空闲的。此操作使用的是 Buffered I&#x2F;O，所以只有当操作系统无法在其自己的缓存中找到该页面时，才会从磁盘读取该页面。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">那些使用 Direct I/O 并且不依赖操作系统缓存的数据库系统区分逻辑读 (来自 RAM，即来自缓冲区缓存) 和物理读 (来自磁盘)。从 PostgreSQL 的角度来看，页面既可以从缓冲区缓存中读取，也可以从操作系统请求，但是在后一种情况下，无法判断页面是在 RAM 中找到的，还是从磁盘读取的。<br></code></pre></td></tr></table></figure><p>哈希表被更新以引用新页面，并且缓冲区被锁定。其使用次数增加，此刻设置为 1，这允许在时钟扫描算法遍历缓冲区缓存期间，页面至少能保留一整轮。</p><h3 id="9-5-Bulk-Eviction"><a href="#9-5-Bulk-Eviction" class="headerlink" title="9.5 Bulk Eviction"></a><a name="cp5"></a>9.5 Bulk Eviction</h3><p>如果执行批量读取或写入操作，存在一次性的数据从缓冲区缓存中挤出有用页面的风险。</p><p>作为预防措施，批量操作使用的是相对较小的环形缓冲区，并且驱逐操作在其边界内执行，不会影响其他缓冲区。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">除了 “buffer ring” 这个术语之外，代码中还使用了术语 “ring buffer”。 然而，这个同义词相当模糊，因为环形缓冲区本身由若干个缓冲区 (也属于缓冲区缓存) 组成。在这方面，术语 “buffer ring” 更为准确。<br></code></pre></td></tr></table></figure><p>特定大小的环形缓冲区由依次使用的一组缓冲区组成。起初，环形缓冲区是空的，各个缓冲区在以常规方式被从缓冲区缓存中选择后，逐个加入到环形缓冲区中。然后驱逐策略开始发挥作用，但是仅限于环内 12。</p><p>添加到环中的缓冲区不会从缓冲区缓存中排除，仍然可以被其他操作使用。因此，如果要重用的缓冲区被锁定了，或者它的使用计数高于 1，它将简单地被从环中剥离，并被另一个缓冲区替换。</p><p>PostgreSQL 支持三种逐出策略。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">**批量读取策略**用于对大表的顺序扫描，当大表的大小超过了缓冲区缓存的 1/4 时便会使用。环形缓冲区占用 256 kB (32 个标准页面)。<br><br>此策略不允许将脏页写入磁盘以释放缓冲区；相反，缓冲区从环中排除，并被另一个取代。因此，读取不必等待写入完成，因此执行得更快。<br><br>如果发现表已在扫描中，那么开始另一次扫描的进程会加入现有的环形缓冲区，并访问当前可用的数据，而不会产生额外的 I/O 操作 13。当第一个进程完成扫描后，第二个进程返回到表跳过的部分。<br><br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">**批量写入策略** 由 COPY FROM、CREATE TABLE AS SELECT 和 CREATE MATERIALIZED VIEW 命令，以及那些导致表重写的 ALTER TABLE 变体应用。所分配的环形缓冲区很大，默认大小是 16 MB (2048 个标准页面)，但它永远不会超过缓冲区缓存总大小的 1/8。<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">**清理策略** 由清理进程在执行全表扫描而不考虑可见性映射时使用。环形缓冲区分配了 256 kB 的内存 (32 个标准页面)。<br></code></pre></td></tr></table></figure><p>环形缓冲区并不总是能防止不希望的驱逐。如果 UPDATE 或 DELETE 命令影响了大量行，执行的表扫描会应用批量读取策略，但由于页面不断被修改，环形缓冲区环实际上变得毫无用处。</p><p>另外一个值得一提的例子是在 TOAST 表中存储超大数据。尽管可能需要读取大量数据，但 TOAST 值始终通过索引访问，因此它们会绕过环形缓冲区。</p><p>让我们仔细看看批量读取策略。为方便起见，我们将创建一个表，使插入的行占据整个页面。 默认情况下，缓冲区缓存大小为 16384 个页面，每个 8 kB。 因此，表必须占用超过 4096 个页面，才能在扫描时使用环形缓冲区。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE TABLE</span> big(<br>  id <span class="hljs-type">integer</span> <span class="hljs-keyword">PRIMARY KEY</span> GENERATED ALWAYS <span class="hljs-keyword">AS</span> <span class="hljs-keyword">IDENTITY</span>,<br>  s <span class="hljs-type">char</span>(<span class="hljs-number">1000</span>)<br>) <span class="hljs-keyword">WITH</span> (fillfactor <span class="hljs-operator">=</span> <span class="hljs-number">10</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> big(s)<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;FOO&#x27;</span> <span class="hljs-keyword">FROM</span> generate_series(<span class="hljs-number">1</span>,<span class="hljs-number">4096</span><span class="hljs-operator">+</span><span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>让我们分析一下表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> ANALYZE big;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> relname, relfilenode, relpages<br><span class="hljs-keyword">FROM</span> pg_class<br><span class="hljs-keyword">WHERE</span> relname <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;big&#x27;</span>, <span class="hljs-string">&#x27;big_pkey&#x27;</span>);<br> relname  <span class="hljs-operator">|</span> relfilenode <span class="hljs-operator">|</span> relpages<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<br> big      <span class="hljs-operator">|</span>       <span class="hljs-number">16546</span> <span class="hljs-operator">|</span>     <span class="hljs-number">4097</span><br> big_pkey <span class="hljs-operator">|</span>       <span class="hljs-number">16551</span> <span class="hljs-operator">|</span>       <span class="hljs-number">14</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>重启服务器以清除缓存，因为现在它包含了在分析过程中读取的一些堆页面。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">pg_ctl restart -l /home/postgres/logfile</span><br></code></pre></td></tr></table></figure><p>重启服务器之后，让我们读取整个表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, costs off, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> big;<br>                 QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> big (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">4097</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>堆页面只占用 32 个缓冲区，这些缓冲区构成了此操作的环形缓冲区：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">FROM</span> pg_buffercache<br><span class="hljs-keyword">WHERE</span> relfilenode <span class="hljs-operator">=</span> pg_relation_filenode(<span class="hljs-string">&#x27;big&#x27;</span>::regclass);<br> count<br>−−−−−−−<br>    <span class="hljs-number">32</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>但在索引扫描的情况下，并不使用环形缓冲区：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, costs off, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> big <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id;<br>                         QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> big_pkey <span class="hljs-keyword">on</span> big (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">4097</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>缓冲区缓存最终包含了整个表和整个索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> relfilenode, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">FROM</span> pg_buffercache<br><span class="hljs-keyword">WHERE</span> relfilenode <span class="hljs-keyword">IN</span> (<br>  pg_relation_filenode(<span class="hljs-string">&#x27;big&#x27;</span>),<br>  pg_relation_filenode(<span class="hljs-string">&#x27;big_pkey&#x27;</span>)<br>)<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> relfilenode;<br> relfilenode <span class="hljs-operator">|</span> count<br>−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br>       <span class="hljs-number">16546</span> <span class="hljs-operator">|</span>  <span class="hljs-number">4097</span><br>       <span class="hljs-number">16551</span> <span class="hljs-operator">|</span>    <span class="hljs-number">14</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><h3 id="9-6-Choosing-the-Buffer-Cache-Size"><a href="#9-6-Choosing-the-Buffer-Cache-Size" class="headerlink" title="9.6 Choosing the Buffer Cache Size"></a><a name="cp6"></a>9.6 Choosing the Buffer Cache Size</h3><p>缓冲区缓存的大小由 shared_buffers 参数定义。众所周知，其默认值很低，因此在安装 PostgreSQL 后增加这个值是有必要的。在此情况下，你需要重新加载服务器，因为在服务器启动时便为缓存分配了共享内存。</p><p>但我们如何确定一个合适的值呢？</p><p>即使是一个非常大的数据库，也有一组同时使用的有限热数据。在理想情况下，这个数据集必须适合缓冲区缓存 (为一次性的数据预留一些空间)。如果缓存大小太小，那么频繁使用的页面将一直相互驱逐，从而导致过多的 I&#x2F;O 操作。但是无脑增加缓存大小也不是一个好主意：RAM 是稀缺资源，此外，更大的缓存会带来更高的维护成本。</p><p>最佳的缓冲区缓存大小因系统而异：它取决于可用内存的总大小、数据概况和工作负载类型等因素。不幸的是，没有一个万能的值或公式能同等适合所有场景。</p><p>你还应该记住， PostgreSQL 中的缓存未命中不一定会触发物理 I&#x2F;O。如果缓冲区缓存非常小，操作系统缓存会使用剩余的空闲内存，并且可以在一定程度上有所缓解。但与数据库不同的是，操作系统对读取的数据一无所知，因此它采用了一种不同的驱逐策略。</p><p>一个典型的建议是从 1&#x2F;4 RAM 开始，然后根据需要调整这个设置。</p><p>最好的方式是不断试验：你可以增加或减少缓存大小，并比较系统性能。当然，这需要一个完全类似于生产系统的测试系统，并且能够重现典型的工作负载。</p><p>你还可以使用 pg_buffercache 扩展进行一些分析。例如，基于使用情况分析缓冲区的分布状况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> usagecount, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">FROM</span> pg_buffercache<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> usagecount<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> usagecount;<br> usagecount <span class="hljs-operator">|</span> count<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br>          <span class="hljs-number">1</span> <span class="hljs-operator">|</span>  <span class="hljs-number">4128</span><br>          <span class="hljs-number">2</span> <span class="hljs-operator">|</span>    <span class="hljs-number">50</span><br>          <span class="hljs-number">3</span> <span class="hljs-operator">|</span>     <span class="hljs-number">4</span><br>          <span class="hljs-number">4</span> <span class="hljs-operator">|</span>     <span class="hljs-number">4</span><br>          <span class="hljs-number">5</span> <span class="hljs-operator">|</span>    <span class="hljs-number">73</span><br>            <span class="hljs-operator">|</span> <span class="hljs-number">12125</span><br>(<span class="hljs-number">6</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>空的使用计数对应于空闲的缓冲区。在这种情况下，是完全可以预料的，因为服务器已重新启动，并且大部分时间都保持空闲状态。大多数使用的缓冲区包含后端进程读取的系统表页面，用于填充其系统表缓存并执行查询。</p><p>我们可以检查每个表的哪一部分被缓存，以及这些数据是否是热的 (如果一个页面的使用计数大于 1，那么此处便认为它是热的)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> c.relname,<br>  <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) blocks,<br>  round( <span class="hljs-number">100.0</span> <span class="hljs-operator">*</span> <span class="hljs-number">8192</span> <span class="hljs-operator">*</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">/</span><br>    pg_table_size(c.oid) ) <span class="hljs-keyword">AS</span> &quot;% of rel&quot;,<br>  round( <span class="hljs-number">100.0</span> <span class="hljs-operator">*</span> <span class="hljs-number">8192</span> <span class="hljs-operator">*</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FILTER</span> (<span class="hljs-keyword">WHERE</span> b.usagecount <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>) <span class="hljs-operator">/</span><br>    pg_table_size(c.oid) ) <span class="hljs-keyword">AS</span> &quot;% hot&quot;<br>  <span class="hljs-keyword">FROM</span> pg_buffercache b<br>    <span class="hljs-keyword">JOIN</span> pg_class c <span class="hljs-keyword">ON</span> pg_relation_filenode(c.oid) <span class="hljs-operator">=</span> b.relfilenode<br>  <span class="hljs-keyword">WHERE</span> b.reldatabase <span class="hljs-keyword">IN</span> (<br>    <span class="hljs-number">0</span>, <span class="hljs-comment">-- cluster-wide objects</span><br>    (<span class="hljs-keyword">SELECT</span> oid <span class="hljs-keyword">FROM</span> pg_database <span class="hljs-keyword">WHERE</span> datname <span class="hljs-operator">=</span> current_database())<br>)<br><span class="hljs-keyword">AND</span> b.usagecount <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT NULL</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> c.relname, c.oid<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-number">2</span> <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">10</span>;<br>             relname             <span class="hljs-operator">|</span> blocks <span class="hljs-operator">|</span> <span class="hljs-operator">%</span> <span class="hljs-keyword">of</span> rel <span class="hljs-operator">|</span> <span class="hljs-operator">%</span> hot<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br> big                             <span class="hljs-operator">|</span>  <span class="hljs-number">4097</span> <span class="hljs-operator">|</span>      <span class="hljs-number">100</span> <span class="hljs-operator">|</span>     <span class="hljs-number">1</span><br> pg_attribute                    <span class="hljs-operator">|</span>     <span class="hljs-number">30</span> <span class="hljs-operator">|</span>       <span class="hljs-number">48</span> <span class="hljs-operator">|</span>    <span class="hljs-number">47</span><br> big_pkey                        <span class="hljs-operator">|</span>     <span class="hljs-number">14</span> <span class="hljs-operator">|</span>      <span class="hljs-number">100</span> <span class="hljs-operator">|</span>     <span class="hljs-number">0</span><br> pg_proc                         <span class="hljs-operator">|</span>     <span class="hljs-number">13</span> <span class="hljs-operator">|</span>       <span class="hljs-number">12</span> <span class="hljs-operator">|</span>     <span class="hljs-number">6</span><br> pg_operator                     <span class="hljs-operator">|</span>     <span class="hljs-number">11</span> <span class="hljs-operator">|</span>       <span class="hljs-number">61</span> <span class="hljs-operator">|</span>    <span class="hljs-number">50</span><br> pg_class                        <span class="hljs-operator">|</span>     <span class="hljs-number">10</span> <span class="hljs-operator">|</span>       <span class="hljs-number">59</span> <span class="hljs-operator">|</span>    <span class="hljs-number">59</span><br> pg_proc_oid_index               <span class="hljs-operator">|</span>      <span class="hljs-number">9</span> <span class="hljs-operator">|</span>       <span class="hljs-number">82</span> <span class="hljs-operator">|</span>    <span class="hljs-number">45</span><br> pg_attribute_relid_attnum_index <span class="hljs-operator">|</span>      <span class="hljs-number">8</span> <span class="hljs-operator">|</span>       <span class="hljs-number">73</span> <span class="hljs-operator">|</span>    <span class="hljs-number">64</span><br> pg_proc_proname_args_nsp_index  <span class="hljs-operator">|</span>      <span class="hljs-number">6</span> <span class="hljs-operator">|</span>       <span class="hljs-number">18</span> <span class="hljs-operator">|</span>     <span class="hljs-number">6</span><br> pg_amproc                       <span class="hljs-operator">|</span>      <span class="hljs-number">5</span> <span class="hljs-operator">|</span>       <span class="hljs-number">56</span> <span class="hljs-operator">|</span>    <span class="hljs-number">56</span><br>(<span class="hljs-number">10</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>这个例子表明大表及其索引已被完全缓存，但它们的页面并未被频繁使用。</p><p>从不同角度分析数据，你可以获得一些有用的见解。但是，在运行 pg_buffercache 查询时，请确保遵循以下简单规则：</p><pre><code class="hljs">多次重复这样的查询，因为返回的数据在一定程度上会有所不同。不要连续不断地运行这样的查询，因为 pg_buffercache 扩展会锁定查看的缓冲区，即使只是短暂的。</code></pre><h3 id="9-7-Cache-Warming"><a href="#9-7-Cache-Warming" class="headerlink" title="9.7 Cache Warming"></a><a name="cp7"></a>9.7 Cache Warming</h3><p>服务器重启后，缓存需要一段时间来预热，也就是积累频繁使用的数据。立即缓存某些表可能会有所帮助， pg_prewarm 扩展正是用于此目的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> EXTENSION pg_prewarm;<br></code></pre></td></tr></table></figure><p>除了将表加载到缓冲区缓存 (或仅加载到操作系统缓存) 之外，此扩展还可以将当前缓存状态写入磁盘，然后在服务器重新启动后恢复。要启用此功能，你需要将此扩展的库添加到 shared_preload_libraries 并重启服务器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">SET</span> shared_preload_libraries <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;pg_prewarm&#x27;</span>;<br><br>postgres$ pg_ctl restart <span class="hljs-operator">-</span>l <span class="hljs-operator">/</span>home<span class="hljs-operator">/</span>postgres<span class="hljs-operator">/</span>logfile<br></code></pre></td></tr></table></figure><p>如果 pg_prewarm.autoprewarm 设置没有改变，服务器重新加载后会自动启动一个名为 autoprewarm leader 的进程；一旦达到 pg_prewarm.autoprewarm_interval 秒，这个进程便会将缓存页面的列表刷新到磁盘 (会使用一个 max_parallel_processes 槽)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">ps -o pid,<span class="hljs-built_in">command</span> \</span><br><span class="language-bash">--ppid `<span class="hljs-built_in">head</span> -n 1 /usr/local/pgsql/data/postmaster.pid` | \</span><br><span class="language-bash">grep prewarm</span><br>  23124 postgres: autoprewarm leader<br></code></pre></td></tr></table></figure><p>现在服务器已经重启，大表没有被缓存：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">FROM</span> pg_buffercache<br><span class="hljs-keyword">WHERE</span> relfilenode <span class="hljs-operator">=</span> pg_relation_filenode(<span class="hljs-string">&#x27;big&#x27;</span>::regclass);<br> count<br>−−−−−−−<br>     <span class="hljs-number">0</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>如果你有充分的理由认为整个表将被频繁使用，并且磁盘访问使响应时间变得无法接受，那么你可以提前将这个表加载到缓冲区缓存中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_prewarm(<span class="hljs-string">&#x27;big&#x27;</span>);<br> pg_prewarm<br>−−−−−−−−−−−−<br>       <span class="hljs-number">4097</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">FROM</span> pg_buffercache<br><span class="hljs-keyword">WHERE</span> relfilenode <span class="hljs-operator">=</span> pg_relation_filenode(<span class="hljs-string">&#x27;big&#x27;</span>::regclass);<br> count<br>−−−−−−−<br>  <span class="hljs-number">4097</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>页面列表将转储到 PGDATA&#x2F;autoprewarm.blocks 文件中。你可以等到 autoprewarm leader 首次完成，但此处我们手动执行转储：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> autoprewarm_dump_now();<br> autoprewarm_dump_now<br>−−−−−−−−−−−−−−−−−−−−−−<br>                 <span class="hljs-number">4224</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>刷盘的页面数量大于 4097，因为考虑了所有正在使用的缓冲区。此文件以文本格式编写，它包含数据库、表空间和文件 ID，以及分支和段号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash"><span class="hljs-built_in">head</span> -n 10 /usr/local/pgsql/data/autoprewarm.blocks</span><br>&lt;&lt;4224&gt;&gt;<br>0,1664,1262,0,0<br>0,1664,1260,0,0<br>16391,1663,1259,0,0<br>16391,1663,1259,0,1<br>16391,1663,1259,0,2<br>16391,1663,1259,0,3<br>16391,1663,1249,0,0<br>16391,1663,1249,0,1<br>16391,1663,1249,0,2<br></code></pre></td></tr></table></figure><p>让我们再次重启服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">pg_ctl restart -l /home/postgres/logfile</span><br></code></pre></td></tr></table></figure><p>此时，表立刻出现在了缓存中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">FROM</span> pg_buffercache<br><span class="hljs-keyword">WHERE</span> relfilenode <span class="hljs-operator">=</span> pg_relation_filenode(<span class="hljs-string">&#x27;big&#x27;</span>::regclass);<br> count<br>−−−−−−−<br>  <span class="hljs-number">4097</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>autoprewarm leader 也会完成所有初始工作：它读取文件，根据数据库对页面进行排序，重新排列它们 (以便磁盘读取尽可能顺序执行)，然后将它们传递给 autoprewarm worker 进行处理。</p><h3 id="9-8-Local-Cache"><a href="#9-8-Local-Cache" class="headerlink" title="9.8 Local Cache"></a><a name="cp8"></a>9.8 Local Cache</h3><p>临时表不遵循上述工作流程。由于临时数据仅对单个进程可见，因此没有必要将其加载到共享缓冲区缓存中。因此，临时数据使用的是拥有该表的进程的本地缓存 14。</p><p>一般来说，本地缓冲区缓存的工作方式类似于共享缓存：</p><pre><code class="hljs">通过哈希表进行页面搜索。驱逐遵循标准算法 (除了不使用环形缓冲区)。页面可以被锁定以避免被驱逐。</code></pre><p>但是，本地缓存实现要简单得多，因为它既不需要处理内存结构上的锁 (缓冲区只能由单个进程访问)，也不需要容错机制 (临时数据最多存在至会话结束)。</p><p>由于通常只有少数会话使用临时表，因此本地缓存内存是按需分配的。会话可用的本地缓存的最大大小受到 temp_buffers 参数的限制。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">尽管名称相似，但 temp_file_limit 参数与临时表无关；它与可能在查询执行期间创建的文件有关，用于临时存储中间数据。<br></code></pre></td></tr></table></figure><p>在 EXPLAIN 命令的输出中，所有对本地缓冲区缓存的调用都标记为 local 而不是 shared：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> TEMPORARY <span class="hljs-keyword">TABLE</span> tmp <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, buffers, costs off, timing off, summary off)<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tmp;<br>               QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> tmp (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   Buffers: <span class="hljs-keyword">local</span> hit<span class="hljs-operator">=</span><span class="hljs-number">1</span><br> Planning:<br>   Buffers: shared hit<span class="hljs-operator">=</span><span class="hljs-number">12</span> read<span class="hljs-operator">=</span><span class="hljs-number">7</span><br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch8. Rebuilding Tables and Indexes</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch8/ch8/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch8/ch8/</url>
    
    <content type="html"><![CDATA[<h2 id="ch8-Rebuilding-Tables-and-Indexes"><a href="#ch8-Rebuilding-Tables-and-Indexes" class="headerlink" title="ch8. Rebuilding Tables and Indexes"></a>ch8. Rebuilding Tables and Indexes</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">8.1 Full Vacuuming</a></td></tr><tr><td><a href="#cp2">8.2 Other Rebuilding Methods</a></td></tr><tr><td><a href="#cp3">8.3 Precautions</a></td></tr></tbody></table><h3 id="8-1-Full-Vacuuming"><a href="#8-1-Full-Vacuuming" class="headerlink" title="8.1 Full Vacuuming"></a><a name="cp1"></a>8.1 Full Vacuuming</h3><h4 id="8-1-1-为什么例行清理不够？"><a href="#8-1-1-为什么例行清理不够？" class="headerlink" title="8.1.1 为什么例行清理不够？"></a>8.1.1 为什么例行清理不够？</h4><p>与页剪枝相比，例行清理可以释放更多空间，但有时这可能仍然不够。</p><p>如果表或索引文件的大小增加了，VACUUM 可以清理一些页内空间，但很少能减少页面的数量。只有当文件末尾出现若干空页面时，回收的空间才能返还给操作系统，但这种情况并不常见。</p><p>大小过大会导致诸多不良影响：</p><pre><code class="hljs">全表 (或索引) 扫描将花费更长时间。可能需要更大的缓冲区缓存 (页面作为一个整体被缓存，因此数据密度降低)。B 树会有额外的层级，这会减慢索引访问的速度。文件在磁盘上和备份中占用额外空间。</code></pre><p>如果文件中有用数据的比例下降至某个合理水平以下，管理员可以通过运行 VACUUM FULL 命令 1 来执行完全清理。在此情况下，表和其所有索引都将从头重建，并且数据会被尽可能密集地组织在一起 (同时考虑到 fillfactor 参数)。</p><p>当执行完全清理时，PostgreSQL 首先会完全重建表，然后重建它的每一个索引。在重建期间，新旧文件都需要存储在磁盘上 2，因此该过程可能需要大量的空闲空间。</p><p>你还应该记住，此操作会完全阻塞对表的访问，包括读取和写入。</p><h4 id="8-1-2-评估数据密度"><a href="#8-1-2-评估数据密度" class="headerlink" title="8.1.2 评估数据密度"></a>8.1.2 评估数据密度</h4><p>为了举例说明，让我们在表中插入一些行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">TRUNCATE</span> vac;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> vac(id,s)<br><span class="hljs-keyword">SELECT</span> id, id::text <span class="hljs-keyword">FROM</span> generate_series(<span class="hljs-number">1</span>,<span class="hljs-number">500000</span>) id;<br></code></pre></td></tr></table></figure><p>存储密度可以使用 pgstattuple 扩展来评估：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> EXTENSION pgstattuple;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pgstattuple(<span class="hljs-string">&#x27;vac&#x27;</span>) \gx<br>−[ RECORD <span class="hljs-number">1</span> ]−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<br>table_len          <span class="hljs-operator">|</span> <span class="hljs-number">70623232</span><br>tuple_count        <span class="hljs-operator">|</span> <span class="hljs-number">500000</span><br>tuple_len          <span class="hljs-operator">|</span> <span class="hljs-number">64500000</span><br>tuple_percent      <span class="hljs-operator">|</span> <span class="hljs-number">91.33</span><br>dead_tuple_count   <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br>dead_tuple_len     <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br>dead_tuple_percent <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br>free_space         <span class="hljs-operator">|</span> <span class="hljs-number">381844</span><br>free_percent       <span class="hljs-operator">|</span> <span class="hljs-number">0.54</span><br></code></pre></td></tr></table></figure><p>此函数读取整个表并显示其文件中空间分布的统计数据。tuple_percent 字段显示了有用数据 (堆元组) 占用空间的百分比。由于页面内有各种元数据，这个值不可避免地会小于 100%，但在这个例子中仍然相当高。</p><p>对于索引，显示的信息略有不同，但 avg_leaf_density 字段含义相同：它显示了有用数据的百分比 (在 B 树叶子页面中)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pgstatindex(<span class="hljs-string">&#x27;vac_s&#x27;</span>) \gx<br>−[ RECORD <span class="hljs-number">1</span> ]−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<br>version            <span class="hljs-operator">|</span> <span class="hljs-number">4</span><br>tree_level         <span class="hljs-operator">|</span> <span class="hljs-number">3</span><br>index_size         <span class="hljs-operator">|</span> <span class="hljs-number">114302976</span><br>root_block_no      <span class="hljs-operator">|</span> <span class="hljs-number">2825</span><br>internal_pages     <span class="hljs-operator">|</span> <span class="hljs-number">376</span><br>leaf_pages         <span class="hljs-operator">|</span> <span class="hljs-number">13576</span><br>empty_pages        <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br>deleted_pages      <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br>avg_leaf_density   <span class="hljs-operator">|</span> <span class="hljs-number">53.88</span><br>leaf_fragmentation <span class="hljs-operator">|</span> <span class="hljs-number">10.59</span><br></code></pre></td></tr></table></figure><p>之前使用的 pgstattuple 函数会完整读取表或索引以获得精确的统计数据。对于大型对象，这可能会耗费太多资源，因此该扩展还提供了另一个名为 pgstattuple_approx 的函数，该函数会跳过可见性映射中跟踪的页面，以显示近似数据。</p><p>一种更快但精度更低的方式是使用系统表粗略估算数据量与文件大小之间的比例 3。</p><p>以下是表及其索引的当前大小：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_size_pretty(pg_table_size(<span class="hljs-string">&#x27;vac&#x27;</span>)) <span class="hljs-keyword">AS</span> table_size,<br>        pg_size_pretty(pg_indexes_size(<span class="hljs-string">&#x27;vac&#x27;</span>)) <span class="hljs-keyword">AS</span> index_size;<br> table_size <span class="hljs-operator">|</span> index_size<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br> <span class="hljs-number">67</span> MB      <span class="hljs-operator">|</span> <span class="hljs-number">109</span> MB<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>现在让我们删除 90% 的行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> vac <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">%</span> <span class="hljs-number">10</span> <span class="hljs-operator">!=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">DELETE</span> <span class="hljs-number">450000</span><br></code></pre></td></tr></table></figure><p>例行清理不会缩减文件大小，因为文件末尾没有空页面：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> VACUUM vac;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_size_pretty(pg_table_size(<span class="hljs-string">&#x27;vac&#x27;</span>)) <span class="hljs-keyword">AS</span> table_size,<br>pg_size_pretty(pg_indexes_size(<span class="hljs-string">&#x27;vac&#x27;</span>)) <span class="hljs-keyword">AS</span> index_size;<br> table_size <span class="hljs-operator">|</span> index_size<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br> <span class="hljs-number">67</span> MB      <span class="hljs-operator">|</span> <span class="hljs-number">109</span> MB<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>但是，数据密度下降了大约 10 倍：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> vac.tuple_percent, vac_s.avg_leaf_density<br><span class="hljs-keyword">FROM</span> pgstattuple(<span class="hljs-string">&#x27;vac&#x27;</span>) vac, pgstatindex(<span class="hljs-string">&#x27;vac_s&#x27;</span>) vac_s;<br> tuple_percent <span class="hljs-operator">|</span> avg_leaf_density<br>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−<br>          <span class="hljs-number">9.13</span> <span class="hljs-operator">|</span>             <span class="hljs-number">6.71</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>表和索引当前位于以下文件中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_relation_filepath(<span class="hljs-string">&#x27;vac&#x27;</span>) <span class="hljs-keyword">AS</span> vac_filepath,<br>        pg_relation_filepath(<span class="hljs-string">&#x27;vac_s&#x27;</span>) <span class="hljs-keyword">AS</span> vac_s_filepath \gx<br>−[ RECORD <span class="hljs-number">1</span> ]−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−<br>vac_filepath   <span class="hljs-operator">|</span> base<span class="hljs-operator">/</span><span class="hljs-number">16391</span><span class="hljs-operator">/</span><span class="hljs-number">16514</span><br>vac_s_filepath <span class="hljs-operator">|</span> base<span class="hljs-operator">/</span><span class="hljs-number">16391</span><span class="hljs-operator">/</span><span class="hljs-number">16515</span><br></code></pre></td></tr></table></figure><p>让我们检查一下在 VACUUM FULL 之后会发生什么。当该命令运行时，可以在 pg_stat_progress_cluster 视图中跟踪其进度 (与为 VACUUM 提供的 pg_stat_progress_vacuum 视图类似)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> VACUUM <span class="hljs-keyword">FULL</span> vac;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pg_stat_progress_cluster \gx<br>                     −[ RECORD <span class="hljs-number">1</span> ]−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−<br>pid                 <span class="hljs-operator">|</span> <span class="hljs-number">19488</span><br>datid               <span class="hljs-operator">|</span> <span class="hljs-number">16391</span><br>datname             <span class="hljs-operator">|</span> internals<br>relid               <span class="hljs-operator">|</span> <span class="hljs-number">16479</span><br>command             <span class="hljs-operator">|</span> VACUUM <span class="hljs-keyword">FULL</span><br>phase               <span class="hljs-operator">|</span> rebuilding index<br>cluster_index_relid <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br>heap_tuples_scanned <span class="hljs-operator">|</span> <span class="hljs-number">50000</span><br>heap_tuples_written <span class="hljs-operator">|</span> <span class="hljs-number">50000</span><br>heap_blks_total     <span class="hljs-operator">|</span> <span class="hljs-number">8621</span><br>heap_blks_scanned <span class="hljs-operator">|</span> <span class="hljs-number">8621</span><br>index_rebuild_count <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>如预期那样， VACUUM FULL 的各个阶段 4 与常规清理有所不同。</p><p>完全清理已用新文件替换了旧文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_relation_filepath(<span class="hljs-string">&#x27;vac&#x27;</span>) <span class="hljs-keyword">AS</span> vac_filepath,<br>        pg_relation_filepath(<span class="hljs-string">&#x27;vac_s&#x27;</span>) <span class="hljs-keyword">AS</span> vac_s_filepath \gx<br>−[ RECORD <span class="hljs-number">1</span> ]−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−<br>vac_filepath   <span class="hljs-operator">|</span> base<span class="hljs-operator">/</span><span class="hljs-number">16391</span><span class="hljs-operator">/</span><span class="hljs-number">16526</span><br>vac_s_filepath <span class="hljs-operator">|</span> base<span class="hljs-operator">/</span><span class="hljs-number">16391</span><span class="hljs-operator">/</span><span class="hljs-number">16529</span><br></code></pre></td></tr></table></figure><p>现在索引和表的大小都小多了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_size_pretty(pg_table_size(<span class="hljs-string">&#x27;vac&#x27;</span>)) <span class="hljs-keyword">AS</span> table_size,<br>        pg_size_pretty(pg_indexes_size(<span class="hljs-string">&#x27;vac&#x27;</span>)) <span class="hljs-keyword">AS</span> index_size;<br> table_size <span class="hljs-operator">|</span> index_size<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br> <span class="hljs-number">6904</span> kB    <span class="hljs-operator">|</span> <span class="hljs-number">6504</span> kB<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>结果，数据密度也增加了。对于索引，数据密度甚至比原来的还要高：基于现有数据从头开始创建一棵 B 树比将条目逐行插入到已经存在的索引中更加有效：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> vac.tuple_percent,<br>          vac_s.avg_leaf_density<br><span class="hljs-keyword">FROM</span> pgstattuple(<span class="hljs-string">&#x27;vac&#x27;</span>) vac,<br>     pgstatindex(<span class="hljs-string">&#x27;vac_s&#x27;</span>) vac_s;<br> tuple_percent <span class="hljs-operator">|</span> avg_leaf_density<br>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−<br>         <span class="hljs-number">91.23</span> <span class="hljs-operator">|</span>            <span class="hljs-number">91.08</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><h4 id="8-1-3-冻结"><a href="#8-1-3-冻结" class="headerlink" title="8.1.3 冻结"></a>8.1.3 冻结</h4><p>当表被重建时，PostgreSQL 会冻结其元组，因为与剩余工作相比，这个操作的成本几乎可以忽略不计：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;vac&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) LIMIT <span class="hljs-number">5</span>;<br> ctid  <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin  <span class="hljs-operator">|</span> xmin_age <span class="hljs-operator">|</span> xmax<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">861</span> f <span class="hljs-operator">|</span>        <span class="hljs-number">5</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">861</span> f <span class="hljs-operator">|</span>        <span class="hljs-number">5</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">861</span> f <span class="hljs-operator">|</span>        <span class="hljs-number">5</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">861</span> f <span class="hljs-operator">|</span>        <span class="hljs-number">5</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">0</span>,<span class="hljs-number">5</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">861</span> f <span class="hljs-operator">|</span>        <span class="hljs-number">5</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>但是页面既没有在可见性映射中标记，也没有在冻结映射中标记，而且页头也没有可见性属性 (这在使用带有 FREEZE 选项的 COPY 命令时是会发生的)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pg_visibility_map(<span class="hljs-string">&#x27;vac&#x27;</span>,<span class="hljs-number">0</span>);<br> all_visible <span class="hljs-operator">|</span> all_frozen<br>−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br> f           <span class="hljs-operator">|</span> f<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> flags <span class="hljs-operator">&amp;</span> <span class="hljs-number">4</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> all_visible<br><span class="hljs-keyword">FROM</span> page_header(get_raw_page(<span class="hljs-string">&#x27;vac&#x27;</span>,<span class="hljs-number">0</span>));<br> all_visible<br>−−−−−−−−−−−−−<br> f<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>仅在调用 VACUUM (或触发 autovacuum) 之后，情况才有所改善：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> VACUUM vac;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pg_visibility_map(<span class="hljs-string">&#x27;vac&#x27;</span>,<span class="hljs-number">0</span>);<br> all_visible <span class="hljs-operator">|</span> all_frozen<br>−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br> t           <span class="hljs-operator">|</span> t<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> flags <span class="hljs-operator">&amp;</span> <span class="hljs-number">4</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">AS</span> all_visible<br><span class="hljs-keyword">FROM</span> page_header(get_raw_page(<span class="hljs-string">&#x27;vac&#x27;</span>,<span class="hljs-number">0</span>));<br> all_visible<br>−−−−−−−−−−−−−<br> t<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>这基本上意味着，即使页面中的所有元组都超出了数据库的视界，这样的页面仍然需要被重写。</p><h3 id="8-2-Other-Rebuilding-Methods"><a href="#8-2-Other-Rebuilding-Methods" class="headerlink" title="8.2 Other Rebuilding Methods"></a><a name="cp2"></a>8.2 Other Rebuilding Methods</h3><h4 id="8-2-1-完全清理的替代方式"><a href="#8-2-1-完全清理的替代方式" class="headerlink" title="8.2.1 完全清理的替代方式"></a>8.2.1 完全清理的替代方式</h4><p>除了 VACUUM FULL 之外，还有其他几个可以完全重建表和索引的命令。这些命令都会以排它方式锁定表，删除旧的数据文件并重建。</p><p>CLUSTER 命令与 VACUUM FULL 完全类似，但它还会根据可用索引之一对文件中的元组进行重新排序。在某些情况下，它可以帮助规划器更加有效地使用索引扫描。但是你应该记住，PostgreSQL 不支持聚簇：所有后续的表更新都会破坏元组的物理顺序。</p><p>从编程角度来看，VACUUM FULL 只是 CLUSTER 命令的一个特例，不需要对元组重新排序 5。</p><p>REINDEX 命令用于重建一个或多个索引 6。实际上，VACUUM FULL 和 CLUSTER 在重建索引时底层会使用这个命令。</p><p>TRUNCATE 命令 7 会删除表中所有的行；它与运行不带有 WHERE 子句的 DELETE 命令的逻辑等效。但是， DELETE 只是将堆元组标记为已删除 (因此它们仍然需要被清理)，而 TRUNCATE 则是创建一个新的空文件，这通常更快。</p><h4 id="8-2-2-减少重建期间的停机时间"><a href="#8-2-2-减少重建期间的停机时间" class="headerlink" title="8.2.2 减少重建期间的停机时间"></a>8.2.2 减少重建期间的停机时间</h4><p>VACUUM FULL 并不意味着要定期运行，因为它会在整个操作过程期间对表进行排它锁定 (对查询也是如此)。对于高可用系统来说，这通常不是一个选项。</p><p>有几个扩展 (例如 pg_repack 8) 可以在几乎零停机的情况下重建表和索引。排它锁仍然是必需的，但只在重建的开始与结束时刻，而且只需要很短的时间。这是通过更复杂的机制来实现的：在重建原始表时，所有对原始表所做的更改都由触发器保存，然后应用于新表。最后阶段，pg_repack 会用一个系统目录中的表替换原表。</p><p>pgcompacttable 工具 9 提供了一个非传统的解决方案。它执行多次伪行更新 (不更改任何数据)，使得当前行版本逐渐移向文件的开头。</p><p>在这些更新操作期间，清理进程会移除过期的元组，并一点一点截断文件。这种方法需要更多的时间和资源，但它不需要额外的空间来重建表并且不会导致负载高峰。在截断表时，仍然会获取短暂的排它锁，但清理操作处理起来相当平滑。</p><h3 id="8-3-Precautions"><a href="#8-3-Precautions" class="headerlink" title="8.3 Precautions"></a><a name="cp3"></a>8.3 Precautions</h3><h4 id="8-3-1-只读查询"><a href="#8-3-1-只读查询" class="headerlink" title="8.3.1 只读查询"></a>8.3.1 只读查询</h4><p>文件膨胀的原因之一是执行长时间运行的事务，这些事务在密集更新数据的同时保持着数据库视界。</p><p>长时间运行 (只读) 事务并不会导致任何问题。因此，一种常见的方式是在不同系统之间分配负载：在主库上执行快速的 OLTP 查询，并将所有 OLAP 事务转移到备库。尽管这使得解决方案变得更加昂贵和复杂，但这些措施可能是不可或缺的。</p><p>在某些情况下，长事务是应用程序或驱动 BUG 的结果，而不是必需的。如果问题无法以优雅的方式解决，管理员可以使用以下两个参数：</p><pre><code class="hljs">old_snapshot_threshold 参数定义了快照的最大生命周期。一旦到达此时间，服务器便有权移除过期的元组；如果长时间运行的事务仍然需要它们，那么便会出现 “snapshot too old” 的错误。idle_in_trasaction_session_timeout 参数限制了空闲事务的生命周期。事务一旦达到此阈值后，便会被中止。</code></pre><h4 id="8-3-2-数据更新"><a href="#8-3-2-数据更新" class="headerlink" title="8.3.2 数据更新"></a>8.3.2 数据更新</h4><p>膨胀的另一个原因是同时修改了大量元组。如果所有行都更新了，元组的数量可能会翻倍，而清理操作可能没有足够的时间进行干预。页剪枝可以减缓这个问题，但并不能完全解决它。</p><p>让我们扩展输出，增加另一列以跟踪处理过的行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER TABLE</span> vac <span class="hljs-keyword">ADD</span> processed <span class="hljs-type">boolean</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">false</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_size_pretty(pg_table_size(<span class="hljs-string">&#x27;vac&#x27;</span>));<br> pg_size_pretty<br>−−−−−−−−−−−−−−−−<br> <span class="hljs-number">6936</span> kB<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>一旦所有的行都更新了，表的大小几乎增加了一倍：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> vac <span class="hljs-keyword">SET</span> processed <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-number">50000</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_size_pretty(pg_table_size(<span class="hljs-string">&#x27;vac&#x27;</span>));<br> pg_size_pretty<br>−−−−−−−−−−−−−−−−<br> <span class="hljs-number">14</span> MB<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>为了解决这种情况，你可以减少单个事务执行的更改数量，将它们分散到不同的时间点上；然后清理操作便可以移除过期的元组，并在现有页面中为新元组腾出一些空间。假设每个行更新可以单独提交，我们可以使用以下查询作为模板，该查询选择一批指定大小的行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ID<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span><br><span class="hljs-keyword">WHERE</span> filtering the already processed <span class="hljs-keyword">rows</span><br>LIMIT batch size<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">SKIP</span> LOCKED<br></code></pre></td></tr></table></figure><p>这段代码选择并立即锁定一组不超过指定大小的行。已被其他事务锁定的行将被跳过：下次它们会进入另一个批次。这是一个相当灵活和方便的解决方案，允许你轻松更改批次大小，并在故障发生时重新开始操作。让我们恢复 processed 属性，并执行完全清理以恢复表的原始大小：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> vac <span class="hljs-keyword">SET</span> processed <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> VACUUM <span class="hljs-keyword">FULL</span> vac;<br></code></pre></td></tr></table></figure><p>第一批次更新之后，表的大小会略有增长：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WITH</span> batch <span class="hljs-keyword">AS</span> (<br>  <span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> vac <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> processed LIMIT <span class="hljs-number">1000</span><br>  <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">SKIP</span> LOCKED<br>)<br><span class="hljs-keyword">UPDATE</span> vac <span class="hljs-keyword">SET</span> processed <span class="hljs-operator">=</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> batch);<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-number">1000</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_size_pretty(pg_table_size(<span class="hljs-string">&#x27;vac&#x27;</span>));<br> pg_size_pretty<br>−−−−−−−−−−−−−−−−<br> <span class="hljs-number">7064</span> kB<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>但从现在开始，表的大小几乎保持不变，因为新的元组替换了被移除的元组：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> VACUUM vac;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WITH</span> batch <span class="hljs-keyword">AS</span> (<br><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> vac <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> processed LIMIT <span class="hljs-number">1000</span><br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">SKIP</span> LOCKED<br>)<br><span class="hljs-keyword">UPDATE</span> vac <span class="hljs-keyword">SET</span> processed <span class="hljs-operator">=</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> batch);<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-number">1000</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_size_pretty(pg_table_size(<span class="hljs-string">&#x27;vac&#x27;</span>));<br> pg_size_pretty<br>−−−−−−−−−−−−−−−−<br> <span class="hljs-number">7072</span> kB<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch7. Freezing</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch7/ch7/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch7/ch7/</url>
    
    <content type="html"><![CDATA[<h2 id="ch7-Freezing"><a href="#ch7-Freezing" class="headerlink" title="ch7. Freezing"></a>ch7. Freezing</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">7.1 Transaction ID Wraparound</a></td></tr><tr><td><a href="#cp2">7.2 Tuple Freezing and Visibility Rules</a></td></tr><tr><td><a href="#cp3">7.3 Managing Freezing</a></td></tr><tr><td><a href="#cp4">7.4 Manual Freezing</a></td></tr></tbody></table><h3 id="7-1-Transaction-ID-Wraparound"><a href="#7-1-Transaction-ID-Wraparound" class="headerlink" title="7.1 Transaction ID Wraparound"></a><a name="cp1"></a>7.1 Transaction ID Wraparound</h3><p>在 PostgreSQL 中，事务 ID 占用 32 位。四十亿似乎是一个相当大的数字，但如果系统使用频繁，那么可能很快便会耗尽。例如，对于平均每秒 1000 个事务的负载 (不包括虚拟事务)，在连续运行大约六周后就会发生这种情况。</p><p>一旦用完所有的数字，那么计数器必须重置以开始下一轮 (这种情况被称为”回卷”)。但是，只有分配的数字在始终增加的情况下，才能认为具有较小 ID 的事务比具有较大 ID 的事务更老。因此，计数器在重置后不能简单地开始重新使用相同的数字。</p><p>为事务 ID 分配 64 位本可以彻底解决这个问题，那为什么 PostgreSQL 不使用呢？问题在于，每个元组头必须存储两个事务 ID：xmin 和 xmax。元组头目前已经相当大了 (如果考虑到数据对齐，至少 24 字节)，增加更多位将会再增加 8 字节。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">PostgreSQL 确实实现了 64 位事务 ID 1，通过一个 32 位 epoch 扩展了常规 ID，但它们仅在内部使用，并且从不进入数据页。<br></code></pre></td></tr></table></figure><p>为了正确处理回卷，PostgreSQL 必须比较事务的年龄 (年龄定义为自该事务开始以来，后续出现的事务数量) 而不是事务 ID。因此，我们应该使用更老 (先于) 和更年轻 (后于) 的概念，而不是小于和大于的术语。</p><p>在代码中，这种比较方式通过使用 32 位算术实现：首先找到 32 位事务 ID 之间的差值，然后将这个结果与零进行比较 2。</p><p>为了更好地可视化这个概念，你可以将一系列事务 ID 想象成一个时钟面。对于每个事务，顺时针方向的半圆是未来，而另一半是过去。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch7/ch7/img.png" alt="img.png"></p><p>然而，这种可视化有一个令人头疼的问题。与最近的事务相比，旧事务 (T1) 处于遥远的过去。但迟早一个新的事务会在与未来有关的半圆中看到它。如果真是这样，那将产生灾难性的影响：从现在开始，所有更新的事务都将看不到事务 T1 所做的更改。</p><h3 id="7-2-Tuple-Freezing-and-Visibility-Rules"><a href="#7-2-Tuple-Freezing-and-Visibility-Rules" class="headerlink" title="7.2 Tuple Freezing and Visibility Rules"></a><a name="cp2"></a>7.2 Tuple Freezing and Visibility Rules</h3><p>为了防止这种”时间旅行”，清理进程会执行一项额外的任务 (除了页面清理 3 )：它寻找超过数据库视界的元组 (所以这些元组在所有快照中都可见) 并以一种特殊的方式标记它们，也就是，冻结它们。</p><p>对于冻结的元组，由于这些元组已知在所有快照中都是可见的，因此可见性规则不必考虑 xmin，可以安全重用此事务 ID。</p><p>你可以想象为 xmin 事务 ID 在冻结的元组中被一个假想的”负无穷大” 所替代 (如下图所示的雪花)；这表明该元组由一个过去很久的事务所创建，它的实际 ID 已经不重要了。然而，实际上 xmin 保持不变，而冻结属性由两个提示位的组合所定义：committed 和 aborted。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch7/ch7/img_1.png" alt="img_1.png"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">许多来源 (包括文档) 都提到 FrozenTransactionId = 2。这就是我所提及的&quot;负无穷大&quot; — 在 9.4 之前的版本中，这个值用于替换 xmin，但现在改为使用提示位。这样一来，原来的事务 ID 保留在元组中，这对调试和支持都很方便。即使旧系统已升级到更高版本，它们仍然可能包含已废弃的 FrozenTransactionId。<br></code></pre></td></tr></table></figure><p>xmax 事务 ID 不以任何方式参与冻结。它只存在于过期的元组中，一旦这些元组在所有快照中都不再可见 (这意味着 xmax ID 超出了数据库视界)，便会将其清理掉。</p><p>为了实验，让我们创建一个新表。将 fillfactor 参数设置为最低值，以便每个页面只能容纳两个元组 — 这样跟踪进度会更容易。我们还将禁用自动清理，以确保仅在需要的时候清理表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE TABLE</span> tfreeze(<br>  id <span class="hljs-type">integer</span>,<br>  s <span class="hljs-type">char</span>(<span class="hljs-number">300</span>)<br>)<br><span class="hljs-keyword">WITH</span> (fillfactor <span class="hljs-operator">=</span> <span class="hljs-number">10</span>, autovacuum_enabled <span class="hljs-operator">=</span> off);<br></code></pre></td></tr></table></figure><p>我们将创建另一个使用 pageinspect 显示堆页面的函数版本。在处理页面时，它将显示每个元组的冻结属性 (f) 和 xmin 事务年龄 (当然，它需要调用 age 系统函数 — 年龄本身并不存储在堆页面中)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> heap_page(<br>  relname text, pageno_from <span class="hljs-type">integer</span>, pageno_to <span class="hljs-type">integer</span><br>)<br><span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">TABLE</span>(<br>  ctid tid, state text,<br>  xmin text, xmin_age <span class="hljs-type">integer</span>, xmax text<br>) <span class="hljs-keyword">AS</span> $$<br><span class="hljs-keyword">SELECT</span> (pageno,lp)::text::tid <span class="hljs-keyword">AS</span> ctid,<br>       <span class="hljs-keyword">CASE</span> lp_flags<br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;unused&#x27;</span><br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;normal&#x27;</span><br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;redirect to &#x27;</span><span class="hljs-operator">||</span>lp_off<br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">3</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;dead&#x27;</span><br>       <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> state,<br>       t_xmin <span class="hljs-operator">||</span> <span class="hljs-keyword">CASE</span><br>         <span class="hljs-keyword">WHEN</span> (t_infomask <span class="hljs-operator">&amp;</span> <span class="hljs-number">256</span><span class="hljs-operator">+</span><span class="hljs-number">512</span>) <span class="hljs-operator">=</span> <span class="hljs-number">256</span><span class="hljs-operator">+</span><span class="hljs-number">512</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27; f&#x27;</span><br>         <span class="hljs-keyword">WHEN</span> (t_infomask <span class="hljs-operator">&amp;</span> <span class="hljs-number">256</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27; c&#x27;</span><br>         <span class="hljs-keyword">WHEN</span> (t_infomask <span class="hljs-operator">&amp;</span> <span class="hljs-number">512</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27; a&#x27;</span><br>         <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;&#x27;</span><br>       <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> xmin,<br>       age(t_xmin) <span class="hljs-keyword">AS</span> xmin_age,<br>       t_xmax <span class="hljs-operator">||</span> <span class="hljs-keyword">CASE</span><br>         <span class="hljs-keyword">WHEN</span> (t_infomask <span class="hljs-operator">&amp;</span> <span class="hljs-number">1024</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27; c&#x27;</span><br>         <span class="hljs-keyword">WHEN</span> (t_infomask <span class="hljs-operator">&amp;</span> <span class="hljs-number">2048</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27; a&#x27;</span><br>         <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;&#x27;</span><br>       <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> xmax<br><span class="hljs-keyword">FROM</span> generate_series(pageno_from, pageno_to) p(pageno),<br>     heap_page_items(get_raw_page(relname, pageno))<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> pageno, lp;<br>$$ <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">sql</span>;<br></code></pre></td></tr></table></figure><p>现在让我们在表中插入一些行，并运行 VACUUM 命令，该命令将立即创建可见性映射。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> EXTENSION IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> pg_visibility;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> tfreeze(id, s)<br>  <span class="hljs-keyword">SELECT</span> id, <span class="hljs-string">&#x27;FOO&#x27;</span><span class="hljs-operator">||</span>id <span class="hljs-keyword">FROM</span> generate_series(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>) id;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-number">0</span> <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>我们将使用 pg_visibility 扩展观察前两个堆页面。当清理完成后，这两个页面都会在可见性映射中被标记 (all_visible) ，但不在冻结映射 (all_frozen) 中，因为它们仍然包含一些未冻结的元组：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> VACUUM tfreeze;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> generate_series(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) g(blkno),<br>     pg_visibility_map(<span class="hljs-string">&#x27;tfreeze&#x27;</span>,g.blkno)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> g.blkno;<br> blkno <span class="hljs-operator">|</span> all_visible <span class="hljs-operator">|</span> all_frozen<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br>     <span class="hljs-number">0</span> <span class="hljs-operator">|</span> t           <span class="hljs-operator">|</span> f<br>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span> t           <span class="hljs-operator">|</span> f<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>插入行的事务其 xmin_age 等于 1，因为它是系统中执行的最新事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;tfreeze&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>  ctid <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin  <span class="hljs-operator">|</span> xmin_age <span class="hljs-operator">|</span> xmax<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">856</span> c <span class="hljs-operator">|</span>        <span class="hljs-number">1</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">856</span> c <span class="hljs-operator">|</span>        <span class="hljs-number">1</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">856</span> c <span class="hljs-operator">|</span>        <span class="hljs-number">1</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">856</span> c <span class="hljs-operator">|</span>        <span class="hljs-number">1</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><h3 id="7-3-Managing-Freezing"><a href="#7-3-Managing-Freezing" class="headerlink" title="7.3 Managing Freezing"></a><a name="cp3"></a>7.3 Managing Freezing</h3><p>主要有四个参数用于控制冻结。它们都代表着事务年龄，并定义以下事件何时发生：</p><pre><code class="hljs">冻结开始 (vacuum_freeze_min_age)执行急切冻结 (vacuum_freeze_table_age)强制冻结 (autovacuum_freeze_max_age)冻结优先 (vacuum_failsafe_age)</code></pre><h4 id="7-3-1-最小冻结年龄"><a href="#7-3-1-最小冻结年龄" class="headerlink" title="7.3.1 最小冻结年龄"></a>7.3.1 最小冻结年龄</h4><p>vacuum_freeze_min_age 参数定义了 xmin 事务的最小冻结年龄。它的值越低，开销就越大：如果一行是”热的”并且被频繁更改，那么冻结其所有新创建的行版本将是一种浪费。将此参数设置为相对较高的值可以允许等待一段时间。</p><p>为了观察冻结过程，我们将这个参数值减为 1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">SET</span> vacuum_freeze_min_age <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_reload_conf();<br></code></pre></td></tr></table></figure><p>现在更新第零页中的一行。因为 fillfactor 值非常小，因此新的行版本将进入到同一页中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> tfreeze <span class="hljs-keyword">SET</span> s <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;BAR&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>所有事务的年龄都增加了 1，堆页面现在如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;tfreeze&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br> ctid  <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin  <span class="hljs-operator">|</span>  xmin_age<span class="hljs-operator">|</span> xmax<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">856</span> c <span class="hljs-operator">|</span>        <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-number">857</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">856</span> c <span class="hljs-operator">|</span>        <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">857</span> <span class="hljs-operator">|</span>        <span class="hljs-number">1</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">856</span> c <span class="hljs-operator">|</span>        <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">856</span> c <span class="hljs-operator">|</span>        <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>此时，那些比 vacuum_freeze_min_age &#x3D; 1 更老的元组将被冻结。但是，vacuum 不会处理可见性映射中标记的任何页面：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> generate_series(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) g(blkno),<br>      pg_visibility_map(<span class="hljs-string">&#x27;tfreeze&#x27;</span>,g.blkno)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> g.blkno;<br> blkno <span class="hljs-operator">|</span> all_visible <span class="hljs-operator">|</span> all_frozen<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br>     <span class="hljs-number">0</span> <span class="hljs-operator">|</span> f           <span class="hljs-operator">|</span> f<br>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span> t           <span class="hljs-operator">|</span> f<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>之前的 UPDATE 命令已经移除了第零页的可见性位，所以该页面中有合适的 xmin 年龄的元组都会被冻结。但是第一页将被彻底跳过：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> VACUUM tfreeze;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;tfreeze&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br> ctid  <span class="hljs-operator">|</span>     state     <span class="hljs-operator">|</span> xmin  <span class="hljs-operator">|</span> xmin_age <span class="hljs-operator">|</span> xmax<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> redirect <span class="hljs-keyword">to</span> <span class="hljs-number">3</span> <span class="hljs-operator">|</span>       <span class="hljs-operator">|</span>          <span class="hljs-operator">|</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> normal        <span class="hljs-operator">|</span> <span class="hljs-number">856</span> f <span class="hljs-operator">|</span>        <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> normal        <span class="hljs-operator">|</span> <span class="hljs-number">857</span> c <span class="hljs-operator">|</span>        <span class="hljs-number">1</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal        <span class="hljs-operator">|</span> <span class="hljs-number">856</span> c <span class="hljs-operator">|</span>        <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> normal        <span class="hljs-operator">|</span> <span class="hljs-number">856</span> c <span class="hljs-operator">|</span>        <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>现在第零页再次出现在可见性映射中，如果第零页没有任何变化的话，那么 vacuum 将不会再返回到此页面：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> generate_series(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) g(blkno),<br>     pg_visibility_map(<span class="hljs-string">&#x27;tfreeze&#x27;</span>,g.blkno)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> g.blkno;<br> blkno <span class="hljs-operator">|</span> all_visible <span class="hljs-operator">|</span> all_frozen<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br>     <span class="hljs-number">0</span> <span class="hljs-operator">|</span> t           <span class="hljs-operator">|</span> f<br>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span> t           <span class="hljs-operator">|</span> f<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><h4 id="7-3-2-急切冻结年龄"><a href="#7-3-2-急切冻结年龄" class="headerlink" title="7.3.2 急切冻结年龄"></a>7.3.2 急切冻结年龄</h4><p>正如我们刚刚已看到的，如果一个页面仅包含在所有快照中都可见的当前版本元组，那么 vacuum 将不会冻结它们。为了克服这个限制，PostgreSQL 提供了 vacuum_freeze_table_age 参数。该参数定义了允许 vacuum 忽略可见性映射的事务年龄，因此可以冻结任何堆页面。</p><p>对于每个表，系统表都保留了一个事务 ID，可以确定所有比该事务 ID 更老的事务都已被冻结。这个值为 relfrozenid：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> relfrozenxid, age(relfrozenxid)<br><span class="hljs-keyword">FROM</span> pg_class<br><span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;tfreeze&#x27;</span>;<br> relfrozenxid <span class="hljs-operator">|</span> age<br>−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−<br>          <span class="hljs-number">854</span> <span class="hljs-operator">|</span>   <span class="hljs-number">4</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>将此事务的年龄与 vacuum_freeze_table_age 的值进行比较，以决定是否到了进行急切冻结的时候。</p><p>得益于冻结映射，在清理期间便无需进行全表扫描：只需检查那些未出现在映射中的页面就足够了。除了这个重要的优化项之外，冻结映射还带来了容错能力：如果清理操作中断，下一次运行将不必回到已处理并且在映射中标记的页面。</p><p>每当系统中的事务数量达到了 vacuum_freeze_table_age − vacuum_freeze_min_age 限制时，PostgreSQL 就会对表中的所有页面进行急切冻结 (如果使用默认值，这将在每 100 百万个事务后发生) 。因此，如果 vacuum_freeze_min_age 值太大，可能会导致过度冻结并且增加开销。</p><p>要冻结整个表，让我们将 vacuum_freeze_table_age 值减小到 4，那么就满足了急切冻结的条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">SET</span> vacuum_freeze_table_age <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_reload_conf();<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> VACUUM VERBOSE tfreeze;<br>INFO:  aggressively vacuuming &quot;public.tfreeze&quot;<br>INFO:  <span class="hljs-keyword">table</span> &quot;tfreeze&quot;: found <span class="hljs-number">0</span> removable, <span class="hljs-number">100</span> nonremovable <span class="hljs-type">row</span><br>versions <span class="hljs-keyword">in</span> <span class="hljs-number">50</span> <span class="hljs-keyword">out</span> <span class="hljs-keyword">of</span> <span class="hljs-number">50</span> pages<br>DETAIL:  <span class="hljs-number">0</span> dead <span class="hljs-type">row</span> versions cannot be removed yet, oldest xmin: <span class="hljs-number">858</span><br>Skipped <span class="hljs-number">0</span> pages due <span class="hljs-keyword">to</span> buffer pins, <span class="hljs-number">0</span> frozen pages.<br>CPU: <span class="hljs-keyword">user</span>: <span class="hljs-number">0.00</span> s, <span class="hljs-keyword">system</span>: <span class="hljs-number">0.00</span> s, elapsed: <span class="hljs-number">0.00</span> s.<br>VACUUM<br></code></pre></td></tr></table></figure><p>现在整个表已被清理，可以推进 relfrozenid 的值 — 堆页内已确保没有更老的未冻结的 xmin 事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> relfrozenxid, age(relfrozenxid)<br><span class="hljs-keyword">FROM</span> pg_class<br><span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;tfreeze&#x27;</span>;<br> relfrozenxid <span class="hljs-operator">|</span> age<br>−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−<br>          <span class="hljs-number">857</span> <span class="hljs-operator">|</span>   <span class="hljs-number">1</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>第一页现在只包含已冻结的元组：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;tfreeze&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br> ctid  <span class="hljs-operator">|</span>     state     <span class="hljs-operator">|</span> xmin  <span class="hljs-operator">|</span> xmin_age <span class="hljs-operator">|</span> xmax<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> redirect <span class="hljs-keyword">to</span> <span class="hljs-number">3</span> <span class="hljs-operator">|</span>       <span class="hljs-operator">|</span>          <span class="hljs-operator">|</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> normal        <span class="hljs-operator">|</span> <span class="hljs-number">856</span> f <span class="hljs-operator">|</span>        <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> normal        <span class="hljs-operator">|</span> <span class="hljs-number">857</span> c <span class="hljs-operator">|</span>        <span class="hljs-number">1</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal        <span class="hljs-operator">|</span> <span class="hljs-number">856</span> f <span class="hljs-operator">|</span>        <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> normal        <span class="hljs-operator">|</span> <span class="hljs-number">856</span> f <span class="hljs-operator">|</span>        <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>另外冻结映射中也已标记此页面：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> generate_series(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) g(blkno),<br>pg_visibility_map(<span class="hljs-string">&#x27;tfreeze&#x27;</span>,g.blkno)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> g.blkno;<br> blkno <span class="hljs-operator">|</span> all_visible <span class="hljs-operator">|</span> all_frozen<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br>     <span class="hljs-number">0</span> <span class="hljs-operator">|</span> t           <span class="hljs-operator">|</span> f<br>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span> t           <span class="hljs-operator">|</span> t<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><h4 id="7-3-3-强制自动清理年龄"><a href="#7-3-3-强制自动清理年龄" class="headerlink" title="7.3.3 强制自动清理年龄"></a>7.3.3 强制自动清理年龄</h4><p>有时，仅仅配置上面讨论的两个参数以及时冻结元组是不够的。自动清理进程可能会被关闭，而常规 VACUUM 根本没有被调用 (这是一个非常糟糕的主意，但从技术上来说是可能的)。另外，一些不活跃的数据库 (比如 template0) 可能不会被清理。PostgreSQL 可以通过以急切模式强制启用自动清理来处理这种情况。</p><p>当数据库中存在某些未冻结事务 ID 的年龄超过 autovacuum_freeze_max_age 值的风险时，将强制启动自动清理 4 (即使它已关闭)。这种行为基于所有表中最老的 pg_class.relfrozenxid 事务的年龄，因为所有更老的事务都确保已被冻结。此事务 ID 存储在系统表中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> datname, datfrozenxid, age(datfrozenxid) <span class="hljs-keyword">FROM</span> pg_database;<br>  datname  <span class="hljs-operator">|</span> datfrozenxid <span class="hljs-operator">|</span> age<br>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−<br> postgres  <span class="hljs-operator">|</span>          <span class="hljs-number">726</span> <span class="hljs-operator">|</span> <span class="hljs-number">132</span><br> template1 <span class="hljs-operator">|</span>          <span class="hljs-number">726</span> <span class="hljs-operator">|</span> <span class="hljs-number">132</span><br> template0 <span class="hljs-operator">|</span>          <span class="hljs-number">726</span> <span class="hljs-operator">|</span> <span class="hljs-number">132</span><br> internals <span class="hljs-operator">|</span>          <span class="hljs-number">726</span> <span class="hljs-operator">|</span> <span class="hljs-number">132</span><br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch7/ch7/img_2.png" alt="img_2.png"></p><p>autovacuum_freeze_max_age 被限制在 20 亿个事务 (略小于圆的一半)，默认值是这个值的十分之一。这样做是有充分理由的：较大的值会增加事务 ID 回卷的风险，因为 PostgreSQL 可能无法及时冻结所有需要的元组。在此情况下，服务器必须立即停止以防止可能的问题，并且必须由管理员重启。</p><p>autovacuum_freeze_max_age 的值也会影响到 CLOG 的大小。没有必要保留已冻结事务的状态，集簇中在 datfrozenxid 最老事务之前的所有事务都已经确保被冻结。那些不再需要的 CLOG 文件会被自动清理进程删除 5。</p><p>更改 autovacuum_freeze_max_age 参数需要重启服务器。但是，上面讨论的所有冻结设置也可以在表级别通过相应的存储参数进行调整。请注意，所有这些参数的名称都以”auto”开头：</p><pre><code class="hljs">autovacuum_freeze_min_age 和 toast.autovacuum_freeze_min_ageautovacuum_freeze_table_age 和 toast.autovacuum_freeze_table_ageautovacuum_freeze_max_age 和 toast.autovacuum_freeze_max_age</code></pre><h4 id="7-3-4-Failsafe-冻结年龄"><a href="#7-3-4-Failsafe-冻结年龄" class="headerlink" title="7.3.4 Failsafe 冻结年龄"></a>7.3.4 Failsafe 冻结年龄</h4><p>如果自动清理进程已经在努力防止事务 ID 回卷，并且显然在与时间赛跑，那么就会”拉动”安全开关：自动清理进程将忽略 autovacuum_vacuum_cost_delay (vacuum_cost_delay) 值，并将停止清理索引以尽快冻结堆元组。</p><p>如果数据库中存在未冻结事务的年龄有超过 vacuum_failsafe_age 值的风险时，那么就会启用 failsafe 模式 6。假定此值必须高于 autovacuum_freeze_max_age。</p><h3 id="7-4-Manual-Freezing"><a href="#7-4-Manual-Freezing" class="headerlink" title="7.4 Manual Freezing"></a><a name="cp4"></a>7.4 Manual Freezing</h3><p>有时，手动管理冻结比依靠自动清理会更加方便。</p><h4 id="7-4-1-Vacuum-时进行冻结"><a href="#7-4-1-Vacuum-时进行冻结" class="headerlink" title="7.4.1 Vacuum 时进行冻结"></a>7.4.1 Vacuum 时进行冻结</h4><p>你可以通过调用带有 FREEZE 选项的 VACUUM 命令以开启冻结操作。这将冻结所有堆元组，不管元组的事务年龄如何，就好像 vacuum_freeze_min_age 为 0 一样。</p><p>如果这样调用的目的是为了尽快冻结堆元组，那么禁用索引清理是有意义的，就像在 failsafe 模式下所做的那样。你可以通过运行 VACUUM (freeze, index_cleanup false) 命令或通过 vacuum_index_cleanup 存储参数来显式做到这一点。很明显，这不应该定期进行，因为在这种情况下，VACUUM 将无法很好地处理其主要任务 — 页面清理。</p><h4 id="7-4-2-在初始加载时冻结数据"><a href="#7-4-2-在初始加载时冻结数据" class="headerlink" title="7.4.2 在初始加载时冻结数据"></a>7.4.2 在初始加载时冻结数据</h4><p>在加载数据至数据库时，预估不会更改的数据可以立即被冻结。这是通过带有 FREEZE 选项的 COPY 命令来完成的。</p><p>结果表只有在同一事务中被创建或截断时，元组才能在初始加载期间被冻结，因为这两种操作都会对表获取排它锁。此限制是必要的，因为无论隔离级别如何，冻结的元组都应在所有快照中可见；否则，事务会在加载数据时突然看到刚刚冻结的元组。但如果获取了锁，其他事务将无法访问该表。</p><p>尽管如此，从技术上来说，打破隔离性仍然是可能的。让我们在一个单独的会话中以可重复读隔离级别开启一个新事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL REPEATABLE READ;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>; <span class="hljs-comment">-- the shapshot is built</span><br></code></pre></td></tr></table></figure><p>在同一个事务中截断 tfreeze 表并将新行插入到该表中 (如果只读事务已经访问过 tfreeze 表，TRUNCATE 命令将被阻塞。)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">TRUNCATE</span> tfreeze;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COPY</span> tfreeze <span class="hljs-keyword">FROM</span> stdin <span class="hljs-keyword">WITH</span> FREEZE;<br><span class="hljs-number">1</span> FOO<br><span class="hljs-number">2</span> BAR<br><span class="hljs-number">3</span> BAZ<br>\.<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>现在只读事务也看到了新数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> tfreeze;<br> count<br>−−−−−−−<br>   <span class="hljs-number">3</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>这确实打破了隔离性，但由于数据加载不太可能定期发生，因此在大多数情况下它不会引起任何问题。</p><p>如果在加载数据时进行冻结，那么会立即创建可见性映射，并且页头会接收到可见性属性：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pg_visibility_map(<span class="hljs-string">&#x27;tfreeze&#x27;</span>,<span class="hljs-number">0</span>);<br> all_visible <span class="hljs-operator">|</span> all_frozen<br>−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br> t           <span class="hljs-operator">|</span> t<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> flags <span class="hljs-operator">&amp;</span> <span class="hljs-number">4</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">AS</span> all_visible<br><span class="hljs-keyword">FROM</span> page_header(get_raw_page(<span class="hljs-string">&#x27;tfreeze&#x27;</span>,<span class="hljs-number">0</span>));<br> all_visible<br>−−−−−−−−−−−−−<br> t<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>因此，如果数据已经在加载时被冻结，那么表将不会被 VACUUM 处理 (只要数据保持不变)。不幸的是，TOAST 表尚不支持此功能：如果加载了过大的值，VACUUM 将不得不重写整个 TOAST 表，以设置所有页头中的可见性属性。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch6. Vacuum and Autovacuum</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch6/ch6/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch6/ch6/</url>
    
    <content type="html"><![CDATA[<h2 id="ch6-Vacuum-and-Autovacuum"><a href="#ch6-Vacuum-and-Autovacuum" class="headerlink" title="ch6. Vacuum and Autovacuum"></a>ch6. Vacuum and Autovacuum</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">6.1 Vacuum</a></td></tr><tr><td><a href="#cp2">6.2 Database Horizon Revisited</a></td></tr><tr><td><a href="#cp3">6.3 Vacuum Phases</a></td></tr><tr><td><a href="#cp4">6.4 Analysis</a></td></tr><tr><td><a href="#cp5">6.5 Automatic Vacuum and Analysis</a></td></tr><tr><td><a href="#cp5">6.6 Managing the Load</a></td></tr><tr><td><a href="#cp5">6.7 Monitoring</a></td></tr></tbody></table><h3 id="6-1-Vacuum"><a href="#6-1-Vacuum" class="headerlink" title="6.1 Vacuum"></a><a name="cp1"></a>6.1 Vacuum</h3><p>页剪枝发生得非常快，但它只释放了部分潜在可以回收的空间。页剪枝在单个堆页面内工作，并且不涉及索引 (反之亦然，清理索引页面也不会影响表)。</p><p>例行清理 (Routine vacuuming) 1 是由 VACUUM 2 命令执行的主要清理过程。它会处理整个表，并移除过期的堆元组以及相应的所有索引条目。</p><p>清理过程与数据库系统中的其他进程并行运行。当进行清理时，表和索引可以以常规方式进行读取和写入 (但不允许同时执行比如 CREATE INDEX，ALTER TABLE 等命令)。</p><p>为了避免扫描额外的页面，PostgreSQL 会使用可见性映射。在可见性映射中跟踪的页面会被跳过，因为这些页面肯定只包含当前元组，因此只有未出现在映射中的页面才会被清理。如果清理后，页面中剩余的所有元组都超出了数据库视界，便会刷新可见性映射以包含此页面。</p><p>空闲空间映射也会更新，以反馈已清理的空间。</p><p>让我们创建一个带有索引的表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE TABLE</span> vac(<br>id <span class="hljs-type">integer</span>,<br>s <span class="hljs-type">char</span>(<span class="hljs-number">100</span>)<br>)<br><span class="hljs-keyword">WITH</span> (autovacuum_enabled <span class="hljs-operator">=</span> off);<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX vac_s <span class="hljs-keyword">ON</span> vac(s);<br></code></pre></td></tr></table></figure><p>autovacuum_enabled 存储参数用于关闭自动清理；此处，我们仅出于实验的目的而关闭它，以精确控制清理的启动时间。</p><p>让我们插入一行数据并进行几次更新：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> vac(id,s) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;A&#x27;</span>);<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> vac <span class="hljs-keyword">SET</span> s <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;B&#x27;</span>;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> vac <span class="hljs-keyword">SET</span> s <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;C&#x27;</span>;<br></code></pre></td></tr></table></figure><p>现在表里含有三个元组：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;vac&#x27;</span>,<span class="hljs-number">0</span>);<br>  ctid <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin  <span class="hljs-operator">|</span> xmax  <span class="hljs-operator">|</span> hhu <span class="hljs-operator">|</span> hot <span class="hljs-operator">|</span> t_ctid<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−<span class="hljs-operator">+</span>−−−−−<span class="hljs-operator">+</span>−−−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">826</span> c <span class="hljs-operator">|</span> <span class="hljs-number">827</span> c <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)<br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">827</span> c <span class="hljs-operator">|</span> <span class="hljs-number">828</span> <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)<br> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">828</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>每个元组都被索引引用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> index_page(<span class="hljs-string">&#x27;vac_s&#x27;</span>,<span class="hljs-number">1</span>);<br> itemoffset <span class="hljs-operator">|</span> htid  <span class="hljs-operator">|</span> dead<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>          <span class="hljs-number">1</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> f<br>          <span class="hljs-number">2</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> f<br>          <span class="hljs-number">3</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> f<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>VACUUM 已删除所有死元组，仅留下了当前元组：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> VACUUM vac;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;vac&#x27;</span>,<span class="hljs-number">0</span>);<br>  ctid <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin <span class="hljs-operator">|</span> xmax <span class="hljs-operator">|</span> hhu <span class="hljs-operator">|</span> hot <span class="hljs-operator">|</span> t_ctid<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−−<span class="hljs-operator">+</span>−−−−−<span class="hljs-operator">+</span>−−−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> unused <span class="hljs-operator">|</span>       <span class="hljs-operator">|</span>      <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> unused <span class="hljs-operator">|</span>       <span class="hljs-operator">|</span>      <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">828</span> c <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a  <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>如果是页剪枝，前两个指针会被认为是 dead 的，但此处它们是 unused 的状态，因为现在没有索引条目引用它们：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> index_page(<span class="hljs-string">&#x27;vac_s&#x27;</span>,<span class="hljs-number">1</span>);<br> itemoffset <span class="hljs-operator">|</span> htid <span class="hljs-operator">|</span> dead<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>          <span class="hljs-number">1</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> f<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>具有 unused 状态的指针被视为空闲指针，可以被新的行版本复用。</p><p>现在，堆页面出现在可见性映射中；我们可以使用 pg_visibility 扩展来检查这一点：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> EXTENSION pg_visibility;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> all_visible<br><span class="hljs-keyword">FROM</span> pg_visibility_map(<span class="hljs-string">&#x27;vac&#x27;</span>,<span class="hljs-number">0</span>);<br> all_visible<br>−−−−−−−−−−−−−<br> t<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>页头中的属性也进行了更新，表明其所有元组在所有快照中都是可见的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> flags <span class="hljs-operator">&amp;</span> <span class="hljs-number">4</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">AS</span> all_visible<br><span class="hljs-keyword">FROM</span> page_header(get_raw_page(<span class="hljs-string">&#x27;vac&#x27;</span>,<span class="hljs-number">0</span>));<br> all_visible<br>−−−−−−−−−−−−−<br> t<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><h3 id="6-2-Database-Horizon-Revisited"><a href="#6-2-Database-Horizon-Revisited" class="headerlink" title="6.2 Database Horizon Revisited"></a><a name="cp2"></a>6.2 Database Horizon Revisited</h3><p>VACUUM 基于数据库视界检测死元组。这个概念很基础，因此有必要再次回顾一下。</p><p>让我们从最开始重新我们的实验：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">TRUNCATE</span> vac;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> vac(id,s) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> vac <span class="hljs-keyword">SET</span> s <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;B&#x27;</span>;<br></code></pre></td></tr></table></figure><p>但这一次，在更新行之前，我们将开启另一个事务，此事务将保持数据库视界 (几乎可以是任何事务，除了在读已提交隔离级别下执行的虚拟事务)。例如，这个事务可以修改另一个表中的一些行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> vac <span class="hljs-keyword">SET</span> s <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;C&#x27;</span>;<br></code></pre></td></tr></table></figure><p>现在表中含有三个元组，索引包含三个引用。让我们清理一下表，看看会有什么变化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> VACUUM vac;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;vac&#x27;</span>,<span class="hljs-number">0</span>);<br> ctid  <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin  <span class="hljs-operator">|</span> xmax  <span class="hljs-operator">|</span> hhu <span class="hljs-operator">|</span> hot <span class="hljs-operator">|</span> t_ctid<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−<span class="hljs-operator">+</span>−−−−−<span class="hljs-operator">+</span>−−−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> unused <span class="hljs-operator">|</span>       <span class="hljs-operator">|</span>       <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">833</span> c <span class="hljs-operator">|</span> <span class="hljs-number">835</span> c <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)<br> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">835</span> c <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> index_page(<span class="hljs-string">&#x27;vac_s&#x27;</span>,<span class="hljs-number">1</span>);<br> itemoffset <span class="hljs-operator">|</span> htid  <span class="hljs-operator">|</span> dead<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>          <span class="hljs-number">1</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> f<br>          <span class="hljs-number">2</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> f<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>虽然前一次实验只在页面中留下了一个元组，但这一次我们有两个元组：VACUUM 判断行版本 (0,2) 还不能移除。原因是数据库视界，在这个案例中，是由一个未完成的事务定义的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> backend_xmin <span class="hljs-keyword">FROM</span> pg_stat_activity<br><span class="hljs-keyword">WHERE</span> pid <span class="hljs-operator">=</span> pg_backend_pid();<br> backend_xmin<br>−−−−−−−−−−−−−−<br>          <span class="hljs-number">834</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>我们可以在调用 VACUUM 时使用 verbose 子句来观察发生了什么：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> VACUUM VERBOSE vac;<br>INFO: vacuuming &quot;public.vac&quot;<br>INFO: <span class="hljs-keyword">table</span> &quot;vac&quot;: found <span class="hljs-number">0</span> removable, <span class="hljs-number">2</span> nonremovable <span class="hljs-type">row</span> versions<br><span class="hljs-keyword">in</span> <span class="hljs-number">1</span> <span class="hljs-keyword">out</span> <span class="hljs-keyword">of</span> <span class="hljs-number">1</span> pages<br>DETAIL:  <span class="hljs-number">1</span> dead <span class="hljs-type">row</span> versions cannot be removed yet, oldest xmin: <span class="hljs-number">834</span><br>Skipped <span class="hljs-number">0</span> pages due <span class="hljs-keyword">to</span> buffer pins, <span class="hljs-number">0</span> frozen pages.<br>CPU: <span class="hljs-keyword">user</span>: <span class="hljs-number">0.00</span> s, <span class="hljs-keyword">system</span>: <span class="hljs-number">0.00</span> s, elapsed: <span class="hljs-number">0.00</span> s.<br>VACUUM<br></code></pre></td></tr></table></figure><p>VACUUM 的输出显示了以下信息：</p><pre><code class="hljs">1. VACUUM 没有检测到可以移除的元组 (0 REMOVABLE)。2. 两个元组不能被移除 (2 NONREMOVABLE)。3. 其中一个不可移除的元组状态是 dead (1 DEAD)，其他的正在使用。4. VACUUM 当前所遵循的视界 (OLDEST XMIN) 是活跃事务的视界。</code></pre><p>一旦活跃事务完成，数据库视界将向前移动，VACUUM 便可以继续：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> VACUUM VERBOSE vac;<br>INFO:  vacuuming &quot;public.vac&quot;<br>INFO:  scanned index &quot;vac_s&quot; <span class="hljs-keyword">to</span> remove <span class="hljs-number">1</span> <span class="hljs-type">row</span> versions<br>DETAIL:  CPU: <span class="hljs-keyword">user</span>: <span class="hljs-number">0.00</span> s, <span class="hljs-keyword">system</span>: <span class="hljs-number">0.00</span> s, elapsed: <span class="hljs-number">0.00</span> s<br>INFO:  <span class="hljs-keyword">table</span> &quot;vac&quot;: removed <span class="hljs-number">1</span> dead item identifiers <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> pages<br>DETAIL:  CPU: <span class="hljs-keyword">user</span>: <span class="hljs-number">0.00</span> s, <span class="hljs-keyword">system</span>: <span class="hljs-number">0.00</span> s, elapsed: <span class="hljs-number">0.00</span> s<br>INFO:  index &quot;vac_s&quot; now <span class="hljs-keyword">contains</span> <span class="hljs-number">1</span> <span class="hljs-type">row</span> versions <span class="hljs-keyword">in</span> <span class="hljs-number">2</span> pages<br>DETAIL:  <span class="hljs-number">1</span> index <span class="hljs-type">row</span> versions were removed.<br><span class="hljs-number">0</span> index pages were newly deleted.<br><span class="hljs-number">0</span> index pages <span class="hljs-keyword">are</span> currently deleted, <span class="hljs-keyword">of</span> which <span class="hljs-number">0</span> <span class="hljs-keyword">are</span> currently<br>reusable.<br>CPU: <span class="hljs-keyword">user</span>: <span class="hljs-number">0.00</span> s, <span class="hljs-keyword">system</span>: <span class="hljs-number">0.00</span> s, elapsed: <span class="hljs-number">0.00</span> s.<br>INFO:  <span class="hljs-keyword">table</span> &quot;vac&quot;:  found <span class="hljs-number">1</span> removable, <span class="hljs-number">1</span> nonremovable <span class="hljs-type">row</span> versions<br><span class="hljs-keyword">in</span> <span class="hljs-number">1</span> <span class="hljs-keyword">out</span> <span class="hljs-keyword">of</span> <span class="hljs-number">1</span> pages<br>DETAIL:  <span class="hljs-number">0</span> dead <span class="hljs-type">row</span> versions cannot be removed yet, oldest xmin: <span class="hljs-number">836</span><br>Skipped <span class="hljs-number">0</span> pages due <span class="hljs-keyword">to</span> buffer pins, <span class="hljs-number">0</span> frozen pages.<br>CPU: <span class="hljs-keyword">user</span>: <span class="hljs-number">0.00</span> s, <span class="hljs-keyword">system</span>: <span class="hljs-number">0.00</span> s, elapsed: <span class="hljs-number">0.00</span> s.<br>VACUUM<br></code></pre></td></tr></table></figure><p>VACUUM 检测并删除了超出新的数据库视界的死元组。</p><p>现在页面不包含过期的行版本，剩下的唯一行版本是当前版本：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;vac&#x27;</span>,<span class="hljs-number">0</span>);<br>  ctid <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin  <span class="hljs-operator">|</span> xmax <span class="hljs-operator">|</span> hhu <span class="hljs-operator">|</span> hot <span class="hljs-operator">|</span> t_ctid<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−−<span class="hljs-operator">+</span>−−−−−<span class="hljs-operator">+</span>−−−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> unused <span class="hljs-operator">|</span>       <span class="hljs-operator">|</span>      <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> unused <span class="hljs-operator">|</span>       <span class="hljs-operator">|</span>      <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">835</span> c <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a  <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>索引也只包含一个条目：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> index_page(<span class="hljs-string">&#x27;vac_s&#x27;</span>,<span class="hljs-number">1</span>);<br> itemoffset <span class="hljs-operator">|</span> htid  <span class="hljs-operator">|</span> dead<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>          <span class="hljs-number">1</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> f<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><h3 id="6-3-Vacuum-Phases"><a href="#6-3-Vacuum-Phases" class="headerlink" title="6.3 Vacuum Phases"></a><a name="cp3"></a>6.3 Vacuum Phases</h3><p>清理的机制似乎很简单，但这种印象具有误导性。毕竟，表和索引都必须同时处理，且不能阻塞其他进程。为了实现这样的操作，每个表的清理都分为几个阶段 3 进行。</p><p>一切都从扫描表开始，寻找死元组；如果找到，首先从索引中移除它们，然后从表自身中移除。如果一次性需要清理太多的死元组，那么会重复此过程。在最后阶段，可能会执行堆截断。</p><h5 id="6-3-1-堆扫描"><a href="#6-3-1-堆扫描" class="headerlink" title="6.3.1 堆扫描"></a>6.3.1 堆扫描</h5><p>在第一阶段，执行堆扫描 4。扫描过程会考虑可见性映射：在此映射中跟踪的所有页面都会被跳过，因为这些页面肯定不包含过期的元组。如果一个元组超出了视界且不再需要，那么其 ID 将被添加到一个特殊的 tid 数组中。这些元组还不能被移除，因为它们仍然可能被索引引用。</p><p>tid 数组位于 VACUUM 进程的本地内存中；分配的内存块大小由 maintenance_work_mem 参数定义。整个内存块是一次性分配的，而不是按需分配。但是，分配的内存永远不会超过最坏情况下所需的容量，因此如果表很小，清理操作可能使用的内存比此参数指定的要少。</p><h4 id="6-3-2-索引清理"><a href="#6-3-2-索引清理" class="headerlink" title="6.3.2 索引清理"></a>6.3.2 索引清理</h4><p>第一阶段可能有两个结果：要么表全部扫描了，要么在此操作完成之前，为 tid 数组分配的内存已满。无论哪种情况，索引清理 5 都会开始。在此阶段，表上创建的每个索引都会被完整扫描，以找到所有引用 tid 数组中记录的元组条目。这些条目将从索引页面中移除。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">索引可以通过索引键帮助你快速定位到一个堆元组，但还没有办法通过相应的元组 ID 快速找到索引条目。这个功能目前正在为 B 树实现中 6，但这项工作尚未完成。<br><br></code></pre></td></tr></table></figure><p>如果有多个大于 min_parallel_index_scan_size 的索引，那么这些索引可以被后台工作进程并行清理。除非子句 parallel N 明确指定了并行度级别，否则 VACUUM 会为每个合适的索引启动一个工作进程 (在后台工作进程数量的总体限制内) 7。一个索引不能由多个工作进程处理。</p><p>在索引清理阶段，PostgreSQL 会更新空闲空间映射并计算清理的统计信息。但是，如果仅插入行 (既不删除也不更新)，那么会跳过此阶段，因为在此情况下表中没有死元组。那么，只有在最后，作为独立的索引规整 (index cleanup) 8 阶段的一部分，才会强制进行一次索引扫描。</p><p>索引清理阶段在索引中不再保留对过期堆元组的引用，但这些元组本身仍然存在于表中。这是正常的：索引扫描无法找到任何死元组，而对表的顺序扫描依赖于可见性规则将它们过滤掉。</p><h4 id="6-3-3-堆清理"><a href="#6-3-3-堆清理" class="headerlink" title="6.3.3 堆清理"></a>6.3.3 堆清理</h4><p>然后开始堆清理阶段 9。表将被再次扫描，以移除 tid 数组中记录的元组并释放相应的指针。由于所有相关的索引引用已经被移除，这个操作现在可以安全地进行。</p><p>VACUUM 回收的空间反映在空闲空间映射中，而现在仅包含在所有快照中均可见的当前元组的页面，将在可见性映射中进行标记。</p><p>如果在堆扫描阶段没有完整读取表，那么会清空 tid 数组，并从上次停止的地方恢复，继续堆扫描。</p><h4 id="6-3-4-堆截断"><a href="#6-3-4-堆截断" class="headerlink" title="6.3.4 堆截断"></a>6.3.4 堆截断</h4><p>已清理的堆页面包含一些空闲空间；有时，你可能会幸运地清除整个页面。如果文件末尾有若干个空页面，那么清理进程可以”咬掉”这条尾巴，并将回收的空间返回给操作系统。这发生在堆截断 10 期间，即清理的最后阶段。</p><p>堆截断需要获取表上短暂的排它锁。为了避免阻塞其他进程太久，尝试获取锁的时间不超过 5 秒。</p><p>由于需要锁表，因此仅当尾部空闲空间至少占表大小的 1&#x2F;16 或达到 1000 页的长度时，才会执行截断。这些阈值是硬编码的，无法配置。</p><p>如果，尽管采取了这些预防措施，表锁仍然可能会导致问题，那么可以使用 vacuum_truncate 和 toast.vacuum_truncate 存储参数彻底禁用截断。</p><h3 id="6-4-Analysis"><a href="#6-4-Analysis" class="headerlink" title="6.4 Analysis"></a><a name="cp4"></a>6.4 Analysis</h3><p>在讨论清理时，我们必须提到另一个与之密切相关的任务，即使它们之间没有正式的联系。这便是分析 11，或者说为查询规划器收集统计信息。收集的统计信息包括表中的行数 (pg_class.reltuples) 和页数(pg_class.relpages)、列中的数据分布情况以及一些其他信息。</p><p>你可以使用 ANALYZE 12 命令手动运行分析，或通过调用 VACUUM ANALYZE 将其与 VACUUM 相结合。不过这两个任务还是顺序执行的，所以性能方面没有区别。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">历史上，VACUUM ANALYZE 首先出现在 6.1 版本中，而单独的 ANALYZE 命令直到 7.2 版本才实现。在早期版本中，统计信息是通过一个 TCL 脚本收集的。<br></code></pre></td></tr></table></figure><p>自动清理和自动分析的设置方式类似，因此有必要一起讨论它们。</p><h3 id="6-5-Automatic-Vacuum-and-Analysis"><a href="#6-5-Automatic-Vacuum-and-Analysis" class="headerlink" title="6.5 Automatic Vacuum and Analysis"></a><a name="cp5"></a>6.5 Automatic Vacuum and Analysis</h3><p>除非数据库视界被长时间保持，否则例行清理足以应付它的工作。但是我们需要多久调用一次 VACUUM 命令？</p><p>如果一个频繁更新的表很少清理，那么其大小会比预期的要大。此外，它可能会积累太多的更改，然后下一次 VACUUM 操作将不得不对索引进行多次遍历。</p><p>如果表清理得太频繁，服务器将忙于维护而不是有用的工作。</p><p>此外，典型的工作负载可能会随着时间而变化，因此就算有一个固定的清理计划也无济于事：表更新得越频繁，就越需要更频繁地进行清理。</p><p>这个问题由自动清理 13 解决，它根据表更新的强度启动清理和分析进程。</p><h4 id="6-5-1-自动清理机制"><a href="#6-5-1-自动清理机制" class="headerlink" title="6.5.1 自动清理机制"></a>6.5.1 自动清理机制</h4><p>启用自动清理时 (autovacuum 配置参数为 on) ，系统中始终运行着自动清理守护进程。该进程定义了自动清理的周期，并根据统计信息维护着”活跃”数据库的列表。如果启用了 track_counts 参数，则会收集此类统计信息。不要关闭这些参数，否则自动清理将无法工作。</p><p>每隔 autovacuum_naptime 时间，自动清理守护进程就会为列表中的每个活跃数据库启动一个自动清理工作进程 14 (这些工作进程如往常一样由 postmaster 创建) 。因此，如果集簇中有 N 个活跃数据库，那么在 autovacuum_naptime 时间间隔内将生成 N 个工作进程。但是，并行运行的自动清理工作进程总数不能超过 autovacuum_max_workers 参数定义的阈值。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">自动清理工作进程与常规的后台工作进程十分相似，但它们比这种通用的任务管理机制出现得早得多。自动清理的实现决定保持不变，因此自动清理工作进程不使用 max_worker_processes 槽。<br></code></pre></td></tr></table></figure><p>一旦启动，后台工作进程便会连接到指定的数据库，并构建两个列表：</p><pre><code class="hljs">1. 所有需要清理的表、物化视图和 TOAST 表的列表2. 所有需要分析的表和物化视图的列表 (因为 TOAST 表总是通过索引访问，所以不会进行分析)</code></pre><p>然后逐一清理或分析选定的对象 (或同时进行两种操作)，一旦工作完成，工作进程就会终止。</p><p>自动清理的工作方式类似于 VACUUM 命令发起的手动清理，但有一些细微差别：</p><pre><code class="hljs">1. 手动清理会在 maintenance_work_mem 所指定大小的内存块中累积元组 ID。但是，对自动清理使用相同的限制是不可取的，因为这会导致过多的内存消耗：可能有多个自动清理工作进程同时运行，每个工作进程都会同时获得 maintenance_work_mem 大小的内存。相反，PostgreSQL 为自动清理进程提供了单独的内存限制，该限制由 autovacuum_work_mem 参数定义。默认情况下，autovacuum_work_mem 参数回退到常规 maintenance_work_mem 参数的限制，因此如果 autovacuum_max_workers 的值较高，你可能需要相应地调整 autovacuum_work_mem 的值。2. 只能通过手动清理才能并发处理表上创建的多个索引；使用自动清理会导致大量并行进程，因此不允许这样做。</code></pre><p>如果工作进程未能在 autovacuum_naptime 时间间隔内完成所有预期任务，那么自动清理守护进程会在该数据库中生成另外一个工作进程，并行运行。第二个工作进程会创建自己的待清理和待分析的对象列表，并开始处理它们。表级别层面没有并行性；只有不同的表可以同时被处理。</p><h4 id="6-5-2-哪些表需要被清理？"><a href="#6-5-2-哪些表需要被清理？" class="headerlink" title="6.5.2 哪些表需要被清理？"></a>6.5.2 哪些表需要被清理？</h4><p>你可以在表级别禁用自动清理 — 尽管很难想象为什么需要这样做。为此，提供了两个存储参数，一个用于常规的表，另一个用于 TOAST 表：</p><pre><code class="hljs">autovacuum_enabledtoast.autovacuum_enabled</code></pre><p>通常情况下，自动清理由累积的死元组数量或新行的插入数量触发。</p><p><strong>死元组累积。</strong> 统计信息收集器会不断计算死元组数量；当前死元组的数量显示在名为 pg_stat_all_tables 的系统表中。</p><p>当死元组超过以下两个参数所定义的阈值时，则必须清除死元组：</p><pre><code class="hljs">autovacuum_vacuum_threshold，指定死元组的数量 (绝对值)autovacuum_vacuum_scale_factor，设置表中死元组的比例</code></pre><p>如果满足以下条件，则需要进行清理：pg_stat_all_tables.n_dead_tup &gt; autovacuum_vacuum_threshold + autovacuum_vacuum_scale_factor × pg_class.reltuples。</p><p>此处主要参数当然是 autovacuum_vacuum_scale_factor：它的值对于大表很重要 (而且大表可能会导致大部分问题)。默认值 20% 似乎太大，可能需要大幅减小。</p><p>对于不同的表，最佳参数值可能会有所不同：这很大程度上取决于表的大小和工作负载的类型。设置合理的初始值是有意义的，然后使用存储参数为特定的表覆盖这些值：</p><pre><code class="hljs">autovacuum_vacuum_threshold 和 toast.autovacuum_vacuum_thresholdautovacuum_vacuum_scale_factor 和 toast.autovacuum_vacuum_scale_factor</code></pre><p><strong>行插入。</strong> 如果仅插入行，而不删除或更新行，那么表中不会包含死元组。但是这样的表也应该被清理以提前冻结堆元组，并更新可见性映射 (从而允许使用仅索引扫描)。</p><p>如果自上次清理以来插入的行数超过了另一对类似参数所定义的阈值，那么表便会被清理：</p><pre><code class="hljs">autovacuum_vacuum_insert_thresholdautovacuum_vacuum_insert_scale_factor</code></pre><p>公式如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">pg_stat_all_tables.n_ins_since_vacuum &gt; autovacuum_vacuum_insert_threshold + autovacuum_vacuum_insert_scale_factor × pg_class.reltuples<br></code></pre></td></tr></table></figure><p>与前面的示例一样，你可以使用存储参数在表级别覆盖这些值：</p><pre><code class="hljs">autovacuum_vacuum_insert_threshold 和 TOAST 相对应的参数autovacuum_vacuum_insert_scale_factor 和 TOAST 相对应的参数</code></pre><h4 id="6-5-3-哪些表需要被分析？"><a href="#6-5-3-哪些表需要被分析？" class="headerlink" title="6.5.3 哪些表需要被分析？"></a>6.5.3 哪些表需要被分析？</h4><p>自动分析只需要处理修改过的行，因此计算比自动清理要简单一些。</p><p>如果自上次分析以来修改的行数超过了以下两个配置参数所定义的阈值，那么就需要对表进行分析：</p><pre><code class="hljs">autovacuum_analyze_thresholdautovacuum_analyze_scale_factor</code></pre><p>如果满足以下条件，则会触发自动分析：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">pg_stat_all_tables.n_mod_since_analyze &gt; autovacuum_analyze_threshold + autovacuum_analyze_scale_factor × pg_class.reltuples<br></code></pre></td></tr></table></figure><p>要覆盖特定表的自动分析设置，你可以使用同名存储参数：</p><pre><code class="hljs">autovacuum_analyze_thresholdautovacuum_analyze_scale_factor</code></pre><p>由于不会分析 TOAST 表，因此没有相应参数。</p><h4 id="6-5-4-自动清理实践"><a href="#6-5-4-自动清理实践" class="headerlink" title="6.5.4 自动清理实践"></a>6.5.4 自动清理实践</h4><p>为了具体描述本节所述内容，让我们创建两个视图以显示当前哪些表需要被清理和分析 15。这些视图中使用的函数返回当前传递参数的值，同时考虑到这个值可以在表级别被重新定义：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> p(param text, c pg_class) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">float</span><br><span class="hljs-keyword">AS</span> $$<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">coalesce</span>(<br>    <span class="hljs-comment">-- use storage parameter if set</span><br>    (<span class="hljs-keyword">SELECT</span> option_value<br>     <span class="hljs-keyword">FROM</span> pg_options_to_table(c.reloptions)<br>     <span class="hljs-keyword">WHERE</span> option_name <span class="hljs-operator">=</span> <span class="hljs-keyword">CASE</span><br>             <span class="hljs-comment">-- for TOAST tables the parameter name is different</span><br>             <span class="hljs-keyword">WHEN</span> c.relkind <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;t&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;toast.&#x27;</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;&#x27;</span><br>            <span class="hljs-keyword">END</span> <span class="hljs-operator">||</span> param<br>    ),<br>    <span class="hljs-comment">-- else take the configuration parameter value</span><br>    current_setting(param)<br>  )::<span class="hljs-type">float</span>;<br>$$ <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">sql</span>;<br></code></pre></td></tr></table></figure><p>这是与 VACUUM 相关的视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> need_vacuum <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">WITH</span> c <span class="hljs-keyword">AS</span> (<br>  <span class="hljs-keyword">SELECT</span> c.oid,<br>    greatest(c.reltuples, <span class="hljs-number">0</span>) reltuples,<br>    p(<span class="hljs-string">&#x27;autovacuum_vacuum_threshold&#x27;</span>, c) threshold,<br>    p(<span class="hljs-string">&#x27;autovacuum_vacuum_scale_factor&#x27;</span>, c) scale_factor,<br>    p(<span class="hljs-string">&#x27;autovacuum_vacuum_insert_threshold&#x27;</span>, c) ins_threshold,<br>    p(<span class="hljs-string">&#x27;autovacuum_vacuum_insert_scale_factor&#x27;</span>, c) ins_scale_factor<br>  <span class="hljs-keyword">FROM</span> pg_class c<br><span class="hljs-keyword">WHERE</span> c.relkind <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>)<br>)<br><span class="hljs-keyword">SELECT</span> st.schemaname <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-operator">||</span> st.relname <span class="hljs-keyword">AS</span> tablename,<br>  st.n_dead_tup <span class="hljs-keyword">AS</span> dead_tup,<br>  c.threshold <span class="hljs-operator">+</span> c.scale_factor <span class="hljs-operator">*</span> c.reltuples <span class="hljs-keyword">AS</span> max_dead_tup,<br>  st.n_ins_since_vacuum <span class="hljs-keyword">AS</span> ins_tup,<br>  c.ins_threshold <span class="hljs-operator">+</span> c.ins_scale_factor <span class="hljs-operator">*</span> c.reltuples <span class="hljs-keyword">AS</span> max_ins_tup,<br>  st.last_autovacuum<br><span class="hljs-keyword">FROM</span> pg_stat_all_tables st<br>  <span class="hljs-keyword">JOIN</span> c <span class="hljs-keyword">ON</span> c.oid <span class="hljs-operator">=</span> st.relid;<br></code></pre></td></tr></table></figure><p>max_dead_tup 列显示了触发自动清理的死元组数量，而 max_ins_tup 列则显示了与插入相关的阈值。</p><p>以下是一个类似的 analyze 视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> need_analyze <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">WITH</span> c <span class="hljs-keyword">AS</span> (<br>  <span class="hljs-keyword">SELECT</span> c.oid,<br>    greatest(c.reltuples, <span class="hljs-number">0</span>) reltuples,<br>    p(<span class="hljs-string">&#x27;autovacuum_analyze_threshold&#x27;</span>, c) threshold,<br>    p(<span class="hljs-string">&#x27;autovacuum_analyze_scale_factor&#x27;</span>, c) scale_factor<br>  <span class="hljs-keyword">FROM</span> pg_class c<br>  <span class="hljs-keyword">WHERE</span> c.relkind <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;m&#x27;</span>)<br>)<br><span class="hljs-keyword">SELECT</span> st.schemaname <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-operator">||</span> st.relname <span class="hljs-keyword">AS</span> tablename,<br>  st.n_mod_since_analyze <span class="hljs-keyword">AS</span> mod_tup,<br>  c.threshold <span class="hljs-operator">+</span> c.scale_factor <span class="hljs-operator">*</span> c.reltuples <span class="hljs-keyword">AS</span> max_mod_tup,<br>  st.last_autoanalyze<br><span class="hljs-keyword">FROM</span> pg_stat_all_tables st<br>  <span class="hljs-keyword">JOIN</span> c <span class="hljs-keyword">ON</span> c.oid <span class="hljs-operator">=</span> st.relid;<br></code></pre></td></tr></table></figure><p>max_mod_tup 列显示了触发自动分析的阈值。</p><p>为了加快实验，我们将每秒启动一次自动清理：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">SET</span> autovacuum_naptime <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1s&#x27;</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_reload_conf();<br></code></pre></td></tr></table></figure><p>让我们截断 vac 表，然后插入 1000 行。请注意，自动清理在表级别层面被关闭了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> vac;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> vac(id,s)<br><span class="hljs-keyword">SELECT</span> id, <span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-keyword">FROM</span> generate_series(<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>) id;<br></code></pre></td></tr></table></figure><p>此处是与 vacuum 相关的视图内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> need_vacuum <span class="hljs-keyword">WHERE</span> tablename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;public.vac&#x27;</span> \gx<br>−[ RECORD <span class="hljs-number">1</span> ]−−−<span class="hljs-operator">+</span>−−−−−−−−−−−<br>tablename       <span class="hljs-operator">|</span> public.vac<br>dead_tup        <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br>max_dead_tup    <span class="hljs-operator">|</span> <span class="hljs-number">50</span><br>ins_tup         <span class="hljs-operator">|</span> <span class="hljs-number">1000</span><br>max_ins_tup     <span class="hljs-operator">|</span> <span class="hljs-number">1000</span><br>last_autovacuum <span class="hljs-operator">|</span><br></code></pre></td></tr></table></figure><p>实际的阈值是 max_dead_tup &#x3D; 50，尽管上面列出的公式表明它应该是 50 + 0.2 × 1000 &#x3D; 250。问题在于，由于 INSERT 命令没有更新统计信息，所以这个表的统计信息还不可用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> reltuples <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;vac&#x27;</span>;<br> reltuples<br>−−−−−−−−−−−<br>        −<span class="hljs-number">1</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>pg_class.reltuples 值被设为 -1；这个替代零值的特殊常数用于区分没有任何统计信息的表和已经分析过的真正的空表。为了方便计算，负值被当做零值处理，因此值是 50 + 0.2 × 0 &#x3D; 50。</p><p>max_ins_tup 的值是 1000，与预期的 1200 不同，原因也是一样的。</p><p>让我们看一下 analyze 视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> need_analyze <span class="hljs-keyword">WHERE</span> tablename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;public.vac&#x27;</span> \gx<br>−[ RECORD <span class="hljs-number">1</span> ]−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−<br>tablename        <span class="hljs-operator">|</span> public.vac<br>mod_tup          <span class="hljs-operator">|</span> <span class="hljs-number">1006</span><br>max_mod_tup      <span class="hljs-operator">|</span> <span class="hljs-number">50</span><br>last_autoanalyze <span class="hljs-operator">|</span><br></code></pre></td></tr></table></figure><p>我们已经更新了 (在这个例子中是插入) 1000 行； 因此已经超过了阈值，由于表的大小未知，所以当前被设置为 50 。这意味着当我们启用自动分析时，将会立即触发自动分析：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER TABLE</span> vac <span class="hljs-keyword">SET</span> (autovacuum_enabled <span class="hljs-operator">=</span> <span class="hljs-keyword">on</span>);<br></code></pre></td></tr></table></figure><p>一旦表分析完成，阈值将被重置为合适的值：150 行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> reltuples <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;vac&#x27;</span>;<br> reltuples<br>−−−−−−−−−−−<br>      <span class="hljs-number">1000</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> need_analyze <span class="hljs-keyword">WHERE</span> tablename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;public.vac&#x27;</span> \gx<br>−[ RECORD <span class="hljs-number">1</span> ]−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br>tablename        <span class="hljs-operator">|</span> public.vac<br>mod_tup          <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br>max_mod_tup      <span class="hljs-operator">|</span> <span class="hljs-number">150</span><br>last_autoanalyze <span class="hljs-operator">|</span> <span class="hljs-number">2023</span>−<span class="hljs-number">03</span>−<span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">00</span>:<span class="hljs-number">45.533464</span><span class="hljs-operator">+</span><span class="hljs-number">03</span><br></code></pre></td></tr></table></figure><p>让我们回到自动清理：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> need_vacuum <span class="hljs-keyword">WHERE</span> tablename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;public.vac&#x27;</span> \gx<br>−[ RECORD <span class="hljs-number">1</span> ]−−−<span class="hljs-operator">+</span>−−−−−−−−−−−<br>tablename       <span class="hljs-operator">|</span> public.vac<br>dead_tup        <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br>max_dead_tup    <span class="hljs-operator">|</span> <span class="hljs-number">250</span><br>ins_tup         <span class="hljs-operator">|</span> <span class="hljs-number">1000</span><br>max_ins_tup     <span class="hljs-operator">|</span> <span class="hljs-number">1200</span><br>last_autovacuum <span class="hljs-operator">|</span><br></code></pre></td></tr></table></figure><p>基于分析统计的实际表大小，max_dead_tup 和 max_ins_tup 的值也已更新。</p><p>如果满足以下至少一个条件，将开始进行清理操作：</p><pre><code class="hljs">1. 累计超过 250 个死元组2. 插入表中的行数超过了 200</code></pre><p>让我们再次关闭自动清理 ，并更新 251 行，使阈值超过 1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER TABLE</span> vac <span class="hljs-keyword">SET</span> (autovacuum_enabled <span class="hljs-operator">=</span> off);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> vac <span class="hljs-keyword">SET</span> s <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;B&#x27;</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&lt;=</span> <span class="hljs-number">251</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> need_vacuum <span class="hljs-keyword">WHERE</span> tablename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;public.vac&#x27;</span> \gx<br>−[ RECORD <span class="hljs-number">1</span> ]−−−<span class="hljs-operator">+</span>−−−−−−−−−−−<br>tablename       <span class="hljs-operator">|</span> public.vac<br>dead_tup        <span class="hljs-operator">|</span> <span class="hljs-number">251</span><br>max_dead_tup    <span class="hljs-operator">|</span> <span class="hljs-number">250</span><br>ins_tup         <span class="hljs-operator">|</span> <span class="hljs-number">1000</span><br>max_ins_tup     <span class="hljs-operator">|</span> <span class="hljs-number">1200</span><br>last_autovacuum <span class="hljs-operator">|</span><br></code></pre></td></tr></table></figure><p>现在触发条件已满足。让我们启用自动清理，短暂过后，我们便会看到表已被处理，并且其使用统计信息已被重置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER TABLE</span> vac <span class="hljs-keyword">SET</span> (autovacuum_enabled <span class="hljs-operator">=</span> <span class="hljs-keyword">on</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> need_vacuum <span class="hljs-keyword">WHERE</span> tablename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;public.vac&#x27;</span> \gx<br>−[ RECORD <span class="hljs-number">1</span> ]−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br>tablename       <span class="hljs-operator">|</span> public.vac<br>dead_tup        <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br>max_dead_tup    <span class="hljs-operator">|</span> <span class="hljs-number">250</span><br>ins_tup         <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br>max_ins_tup     <span class="hljs-operator">|</span> <span class="hljs-number">1200</span><br>last_autovacuum <span class="hljs-operator">|</span> <span class="hljs-number">2023</span>−<span class="hljs-number">03</span>−<span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">00</span>:<span class="hljs-number">51.736815</span><span class="hljs-operator">+</span><span class="hljs-number">03</span><br></code></pre></td></tr></table></figure><h3 id="6-6-Managing-the-Load"><a href="#6-6-Managing-the-Load" class="headerlink" title="6.6 Managing the Load"></a><a name="cp6"></a>6.6 Managing the Load</h3><p>在页级别操作，清理不会阻塞其他进程；但尽管如此，它仍会增加系统负载，并且可能对性能产生明显影响。</p><h4 id="6-6-1-Vacuum-限流"><a href="#6-6-1-Vacuum-限流" class="headerlink" title="6.6.1 Vacuum 限流"></a>6.6.1 Vacuum 限流</h4><p>为了控制清理的强度，PostgreSQL 会在处理表的过程中定期暂停。在完成大约 vacuum_cost_limit 个单位工作后，进程会进入休眠状态，并在 vacuum_cost_delay 时间间隔内保持空闲。</p><p>vacuum_cost_delay 的默认值为 0，意味着例行清理实际上从不休眠，因此 vacuum_cost_limit 的确切值并没有区别。这基于如果管理员不得不手动清理，他们可能希望尽快完成的假设。</p><p>如果设置了睡眠时间，那么每当在缓冲区缓存中的页面处理上花费了 vacuum_cost_limit 个单位工作后，进程就会暂停。如果在缓冲区缓存中找到页面，那么每个页面读取的成本预估为 vacuum_cost_page_hit 个单位，否则为 vacuum_cost_page_miss 16。如果一个干净的页面被 VACUUM 弄脏了，它会增加额外的 vacuum_cost_page_dirty 单位 17。</p><p>如果保持 vacuum_cost_limit 参数的默认值，VACUUM 在最佳情况下每个周期最多可以处理 200 个页面 (如果所有页面都被缓存，并且没有页面被 VACUUM 弄脏)，在最坏的情况下只能处理 9 个页面 (如果所有页面都从磁盘读取，并且变脏了)。</p><h4 id="6-6-2-Autovacuum-限流"><a href="#6-6-2-Autovacuum-限流" class="headerlink" title="6.6.2 Autovacuum 限流"></a>6.6.2 Autovacuum 限流</h4><p>Autovacuum 限流 18 和 VACUUM 限流十分类似。但是，Autovacuum 可以以不同的强度运行，因为它有自己的一套参数：</p><pre><code class="hljs">autovacuum_vacuum_cost_limitautovacuum_vacuum_cost_delay</code></pre><p>如果这些参数中的任何一个设置为 -1，那么便会回退到常规 VACUUM 相应的参数。 因此，默认情况下，autovacuum_vacuum_cost_limit 参数依赖于 vacuum_cost_limit 的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">在 <span class="hljs-number">12</span> 版本之前，autovacuum_vacuum_cost_delay 的默认值为 <span class="hljs-number">20</span> ms，这会导致在现代硬件上的性能非常之差。<br></code></pre></td></tr></table></figure><p>每个周期内，Autovacuum 的工作单位限制在 autovacuum_vacuum_cost_limit，并且由于此限制在所有工作进程之间共享，因此对系统的总体影响大致相同，无论其数量如何。因此，如果你需要加快自动清理的速度，那么 autovacuum_max_workers 和 autovacuum_vacuum_cost_limit 的值都应该按比例增加。</p><p>如果需要，你可以通过设置以下存储参数来覆盖特定表的这些设置：</p><pre><code class="hljs">autovacuum_vacuum_cost_delay 和 toast.autovacuum_vacuum_cost_delayautovacuum_vacuum_cost_limit 和 toast.autovacuum_vacuum_cost_limit****</code></pre><h3 id="6-7-Monitoring"><a href="#6-7-Monitoring" class="headerlink" title="6.7 Monitoring"></a><a name="cp7"></a>6.7 Monitoring</h3><p>如果对清理操作进行监控，你可以检测到无法一次性移除死元组的情况，因为对这些死元组的引用不适合 maintenance_work_mem 内存块。在这种情况下，所有索引将不得不被完全扫描多次。对于大表来说，这可能需要相当长的时间，从而对系统造成显著负载。尽管查询不会被阻塞，但额外的 I&#x2F;O 操作也会严重限制系统的吞吐量。</p><p>此类问题可以通过更频繁地清理表 (以便每次只需清理较少的元组) 或分配更多的内存来改善。</p><h4 id="6-7-1-监控-Vacuum"><a href="#6-7-1-监控-Vacuum" class="headerlink" title="6.7.1 监控 Vacuum"></a>6.7.1 监控 Vacuum</h4><p>当使用 VERBOSE 子句运行时，VACUUM 命令执行清理并显示状态报告信息，pg_stat_progress_vacuum 视图显示了已启动进程的当前状态。</p><p>分析也有类似的视图 (pg_stat_progress_analyze)，尽管它通常执行得非常快并且不太可能导致问题。</p><p>让我们在表中插入更多的行，并全部更新，这样 VACUUM 就需要运行相当长的一段时间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">TRUNCATE</span> vac;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> vac(id,s)<br>  <span class="hljs-keyword">SELECT</span> id, <span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-keyword">FROM</span> generate_series(<span class="hljs-number">1</span>,<span class="hljs-number">500000</span>) id;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> vac <span class="hljs-keyword">SET</span> s <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;B&#x27;</span>;<br></code></pre></td></tr></table></figure><p>出于演示的目的，我们将分配给 tid 数组的内存限制为 1 MB：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">SET</span> maintenance_work_mem <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1MB&#x27;</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_reload_conf();<br></code></pre></td></tr></table></figure><p>然后启动 VACUUM 命令，并在 VACUUM 运行时多次查询 pg_stat_progress_vacuum 视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> VACUUM VERBOSE vac;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pg_stat_progress_vacuum \gx<br>−[ RECORD <span class="hljs-number">1</span> ]−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−<br>pid                <span class="hljs-operator">|</span> <span class="hljs-number">14531</span><br>datid              <span class="hljs-operator">|</span> <span class="hljs-number">16391</span><br>datname            <span class="hljs-operator">|</span> internals<br>relid              <span class="hljs-operator">|</span> <span class="hljs-number">16479</span><br>phase              <span class="hljs-operator">|</span> vacuuming indexes<br>heap_blks_total    <span class="hljs-operator">|</span> <span class="hljs-number">17242</span><br>heap_blks_scanned  <span class="hljs-operator">|</span> <span class="hljs-number">3009</span><br>heap_blks_vacuumed <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br>index_vacuum_count <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br>max_dead_tuples    <span class="hljs-operator">|</span> <span class="hljs-number">174761</span><br>num_dead_tuples    <span class="hljs-operator">|</span> <span class="hljs-number">174522</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pg_stat_progress_vacuum \gx<br>−[ RECORD <span class="hljs-number">1</span> ]−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−<br>pid                <span class="hljs-operator">|</span> <span class="hljs-number">14531</span><br>datid              <span class="hljs-operator">|</span> <span class="hljs-number">16391</span><br>datname            <span class="hljs-operator">|</span> internals<br>relid              <span class="hljs-operator">|</span> <span class="hljs-number">16479</span><br>phase              <span class="hljs-operator">|</span> vacuuming indexes<br>heap_blks_total    <span class="hljs-operator">|</span> <span class="hljs-number">17242</span><br>heap_blks_scanned  <span class="hljs-operator">|</span> <span class="hljs-number">17242</span><br>heap_blks_vacuumed <span class="hljs-operator">|</span> <span class="hljs-number">6017</span><br>index_vacuum_count <span class="hljs-operator">|</span> <span class="hljs-number">2</span><br>max_dead_tuples    <span class="hljs-operator">|</span> <span class="hljs-number">174761</span><br>num_dead_tuples    <span class="hljs-operator">|</span> <span class="hljs-number">150956</span><br></code></pre></td></tr></table></figure><p>该视图主要显示了：</p><pre><code class="hljs">phase — 当前清理阶段的名称 (我描述了主要的几个阶段，但实际上还有更多 19)heap_blks_total — 表中的页面总数heap_blks_scanned — 已扫描的页面数量heap_blks_vacuumed —已清理的页面数量index_vacuum_count — 索引扫描的次数</code></pre><p>整体的清理进度由 heap_blks_vacuumed 与 heap_blks_total 的比率所定义，但你必须记住，由于索引扫描，这个比率会间歇性变化。事实上，更重要的是要关注清理的循环次数：如果这个值大于 1，说明分配的内存不足以一次性完成清理。</p><p>你可以在 VACUUM VERBOSE 命令的输出中看到整个过程，此时命令已经完成了：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch6/ch6/img.png" alt="img.png"></p><p>总而言之，进行了 3 次索引扫描； 每次扫描最多移除了 174522 个指向死元组的指针。这个值由能放入 maintenance_work_mem 中的 TID 数组指针的数量 (每个指针需要 6 个字节) 所定义。可能的最大大小由 pg_stat_progress_vacuum.max_dead_tuples 显示，但实际使用的空间总是要稍小一些。这保证了当读取下一个页面时，无论这个页面中有多少指向死元组的指针，都将适合剩余的内存。</p><h4 id="6-7-2-监控-Autovacuum"><a href="#6-7-2-监控-Autovacuum" class="headerlink" title="6.7.2 监控 Autovacuum"></a>6.7.2 监控 Autovacuum</h4><p>监控 autovacuum 的主要方式是将其状态信息 (类似于 VACUUM VERBOSE 命令的输出) 打印到服务器日志中，以供进一步的分析。如果 log_autovacuum_min_duration 参数设置为零，则记录所有 autovacuum 的运行状况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">SET</span> log_autovacuum_min_duration <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_reload_conf();<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> vac <span class="hljs-keyword">SET</span> s <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;C&#x27;</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-number">500000</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql">postgres$ tail <span class="hljs-operator">-</span>n <span class="hljs-number">13</span> <span class="hljs-operator">/</span>home<span class="hljs-operator">/</span>postgres<span class="hljs-operator">/</span>logfile<br><span class="hljs-number">2023</span>−<span class="hljs-number">03</span>−<span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">01</span>:<span class="hljs-number">13.727</span> MSK [<span class="hljs-number">17351</span>] LOG:  automatic vacuum <span class="hljs-keyword">of</span> <span class="hljs-keyword">table</span><br>&quot;internals.public.vac&quot;: index scans: <span class="hljs-number">3</span><br>pages: <span class="hljs-number">0</span> removed, <span class="hljs-number">17242</span> remain, <span class="hljs-number">0</span> skipped due <span class="hljs-keyword">to</span> pins, <span class="hljs-number">0</span><br>skipped frozen<br>tuples: <span class="hljs-number">500000</span> removed, <span class="hljs-number">500000</span> remain, <span class="hljs-number">0</span> <span class="hljs-keyword">are</span> dead but <span class="hljs-keyword">not</span><br>yet removable, oldest xmin: <span class="hljs-number">853</span><br>index scan needed: <span class="hljs-number">8622</span> pages <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> (<span class="hljs-number">50.01</span><span class="hljs-operator">%</span> <span class="hljs-keyword">of</span> total)<br>had <span class="hljs-number">500000</span> dead item identifiers removed<br>index &quot;vac_s&quot;: pages: <span class="hljs-number">1428</span> <span class="hljs-keyword">in</span> total, <span class="hljs-number">496</span> newly deleted, <span class="hljs-number">929</span><br>currently deleted, <span class="hljs-number">433</span> reusable<br>avg read rate: <span class="hljs-number">12.404</span> MB<span class="hljs-operator">/</span>s, avg write rate: <span class="hljs-number">14.810</span> MB<span class="hljs-operator">/</span>s<br>buffer usage: <span class="hljs-number">46038</span> hits, <span class="hljs-number">5670</span> misses, <span class="hljs-number">6770</span> dirtied<br>WAL usage: <span class="hljs-number">40390</span> records, <span class="hljs-number">15062</span> <span class="hljs-keyword">full</span> page images, <span class="hljs-number">89188595</span><br>bytes<br><span class="hljs-keyword">system</span> usage: CPU: <span class="hljs-keyword">user</span>: <span class="hljs-number">0.31</span> s, <span class="hljs-keyword">system</span>: <span class="hljs-number">0.33</span> s, elapsed:<br><span class="hljs-number">3.57</span> s<br><span class="hljs-number">2023</span>−<span class="hljs-number">03</span>−<span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">01</span>:<span class="hljs-number">14.117</span> MSK [<span class="hljs-number">17351</span>] LOG:  automatic analyze <span class="hljs-keyword">of</span> <span class="hljs-keyword">table</span><br>&quot;internals.public.vac&quot;<br>avg read rate: <span class="hljs-number">41.081</span> MB<span class="hljs-operator">/</span>s, avg write rate: <span class="hljs-number">0.020</span> MB<span class="hljs-operator">/</span>s<br>buffer usage: <span class="hljs-number">15355</span> hits, <span class="hljs-number">2035</span> misses, <span class="hljs-number">1</span> dirtied<br><span class="hljs-keyword">system</span> usage: CPU: <span class="hljs-keyword">user</span>: <span class="hljs-number">0.14</span> s, <span class="hljs-keyword">system</span>: <span class="hljs-number">0.00</span> s, elapsed:<br><span class="hljs-number">0.38</span> s<br></code></pre></td></tr></table></figure><p>为了跟踪需要被清理和分析的表列表，你可以使用我们已经审阅过的 need_vacuum 和 need_analyze 视图。如果此列表增长，这意味着自动清理无法应对负载，则需要通过减小间隔 (autovacuum_vacuum_cost_delay) 或者增加间隔内完成的工作量 (autovacuum_vacuum_cost_limit) 来加速清理。同时，并行度也可以增加 (autovacuum_max_workers)。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch5. Page Pruning and HOT Updates</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch5/ch5/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch5/ch5/</url>
    
    <content type="html"><![CDATA[<h2 id="ch5-Page-Pruning-and-HOT-Updates"><a href="#ch5-Page-Pruning-and-HOT-Updates" class="headerlink" title="ch5. Page Pruning and HOT Updates"></a>ch5. Page Pruning and HOT Updates</h2><p>页剪枝与HOT更新</p><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">5.1 Page Pruning</a></td></tr><tr><td><a href="#cp2">5.2 HOT Updates</a></td></tr><tr><td><a href="#cp3">5.3 Page Pruning for HOT Updates</a></td></tr><tr><td><a href="#cp4">5.4 HOT Chain Splits</a></td></tr><tr><td><a href="#cp5">5.5 Page Pruning for Indexes</a></td></tr></tbody></table><h3 id="5-1-Page-Pruning"><a href="#5-1-Page-Pruning" class="headerlink" title="5.1 Page Pruning"></a><a name="cp1"></a>5.1 Page Pruning</h3><p>在读取或更新堆页面时，PostgreSQL 可以执行一些快速的页面清理，或称之为剪枝 1。剪枝发生在以下情况：</p><pre><code class="hljs">1. 之前的 UPDATE 操作没有找到足够的空间将新元组放入同一页面中。此事件反映在页头中。2. 堆页面中包含的数据超过了 fillfactor 存储参数所允许的量。仅当此页面的填充率低于 fillfactor 百分比时，INSERT 操作才能将新行添加到页面中。其余空间会保留，用于 UPDATE 操作 (默认情况下不保留此空间) 。</code></pre><p>页剪枝会移除在任何快照中都不再可见的元组 (即超出数据库视界的元组)。页剪枝永远不会超出单个堆页面的范围，但相对得，它执行得非常快。指向剪枝后的元组指针仍在原处，它们可能会被不同的页面所引用。</p><p>出于同样的原因，也不会刷新可见性映射和空闲空间映射 (因此回收的空间是为更新留存的，而不是用于插入)。</p><p>由于可以在读取过程中修剪页面，因此任何的 SELECT 语句都可能导致页面修改。这是除了延迟设置提示位之外的另一种情况。</p><p>让我们看一下页剪枝实际是如何工作的。我们将创建一个含有两列的表，并在每一列上创建一个索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE TABLE</span> hot(id <span class="hljs-type">integer</span>, s <span class="hljs-type">char</span>(<span class="hljs-number">2000</span>)) <span class="hljs-keyword">WITH</span> (fillfactor <span class="hljs-operator">=</span> <span class="hljs-number">75</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX hot_id <span class="hljs-keyword">ON</span> hot(id);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX hot_s <span class="hljs-keyword">ON</span> hot(s);<br></code></pre></td></tr></table></figure><p>如果 s 列仅包含拉丁字母，那么每个堆元组将具有 2004 字节的固定大小，加上 24 个字节的元组头。fillfactor 存储参数设置为 75%。这意味着页面有足够的空间容纳四个元组，但我们只能插入三个。</p><p>让我们插入一行数据并多次更新：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> hot <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> hot <span class="hljs-keyword">SET</span> s <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;B&#x27;</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> hot <span class="hljs-keyword">SET</span> s <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;C&#x27;</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> hot <span class="hljs-keyword">SET</span> s <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;D&#x27;</span>;<br></code></pre></td></tr></table></figure><p>现在页面包含四个元组：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;hot&#x27;</span>,<span class="hljs-number">0</span>);<br>  ctid <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin  <span class="hljs-operator">|</span> xmax<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">801</span> c <span class="hljs-operator">|</span> <span class="hljs-number">802</span> c<br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">802</span> c <span class="hljs-operator">|</span> <span class="hljs-number">803</span> c<br> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">803</span> c <span class="hljs-operator">|</span> <span class="hljs-number">804</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">804</span>   <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>不出所料，我们刚刚超过了 fillfactor 阈值。你可以通过 pagesize 和 upper 之间的差值来判断 — 它大于页面大小的 75 %，即 6144 个字节：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> upper, pagesize <span class="hljs-keyword">FROM</span> page_header(get_raw_page(<span class="hljs-string">&#x27;hot&#x27;</span>,<span class="hljs-number">0</span>));<br> upper <span class="hljs-operator">|</span> pagesize<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<br>    <span class="hljs-number">64</span> <span class="hljs-operator">|</span>     <span class="hljs-number">8192</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>下一次页面访问将会触发页剪枝，移除所有过期元组。然后，在释放的空间中添加一个新的元组 (0,5)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> hot <span class="hljs-keyword">SET</span> s <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;E&#x27;</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;hot&#x27;</span>,<span class="hljs-number">0</span>);<br>  ctid <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin <span class="hljs-operator">|</span> xmax<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> dead   <span class="hljs-operator">|</span>       <span class="hljs-operator">|</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> dead   <span class="hljs-operator">|</span>       <span class="hljs-operator">|</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> dead   <span class="hljs-operator">|</span>       <span class="hljs-operator">|</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">804</span> c <span class="hljs-operator">|</span> <span class="hljs-number">805</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">5</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">805</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>剩余的堆元组在物理上会被移向页面的最高地址处，以便所有空闲空间汇聚成一个连续的块。元组指针也相应地被修改。这样的话，页面中便没有空闲空间碎片。</p><p>指向被剪枝元组的指针还不能被删除，因为它们仍然被索引引用；PostgreSQL 将它们的状态从 normal 修改为 dead。让我们看看 hot_s 索引的第一个页面 (第零页用于存储元数据)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> index_page(<span class="hljs-string">&#x27;hot_s&#x27;</span>,<span class="hljs-number">1</span>);<br> itemoffset <span class="hljs-operator">|</span> htid<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br>          <span class="hljs-number">1</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>          <span class="hljs-number">2</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)<br>          <span class="hljs-number">3</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)<br>          <span class="hljs-number">4</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">4</span>)<br>          <span class="hljs-number">5</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>我们在另一个索引中也可以看到相同的情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> index_page(<span class="hljs-string">&#x27;hot_id&#x27;</span>,<span class="hljs-number">1</span>);<br> itemoffset <span class="hljs-operator">|</span> htid<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br>          <span class="hljs-number">1</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>          <span class="hljs-number">2</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)<br>          <span class="hljs-number">3</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)<br>          <span class="hljs-number">4</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">4</span>)<br>          <span class="hljs-number">5</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>索引扫描返回 (0,1)、(0,2) 和 (0,3) 作为元组标识符。服务器尝试读取相应的堆元组，但发现指针是 dead 的状态；这意味着这个元组不再存在，应该被忽略。并且在处理的同时，服务器还会改变索引页中的指针状态，以避免重复访问堆页面 2。</p><p>让我们扩展显示索引页面的函数，以显示指针是否是 dead 的状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FUNCTION</span> index_page(text, <span class="hljs-type">integer</span>);<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> index_page(relname text, pageno <span class="hljs-type">integer</span>)<br><span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">TABLE</span>(itemoffset <span class="hljs-type">smallint</span>, htid tid, dead <span class="hljs-type">boolean</span>)<br><span class="hljs-keyword">AS</span> $$<br><span class="hljs-keyword">SELECT</span> itemoffset,<br>       htid,<br>       dead <span class="hljs-comment">-- starting from v.13</span><br><span class="hljs-keyword">FROM</span> bt_page_items(relname,pageno);<br>$$ <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">sql</span>;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> index_page(<span class="hljs-string">&#x27;hot_id&#x27;</span>,<span class="hljs-number">1</span>);<br> itemoffset <span class="hljs-operator">|</span> htid  <span class="hljs-operator">|</span> dead<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>          <span class="hljs-number">1</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> f<br>          <span class="hljs-number">2</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> f<br>          <span class="hljs-number">3</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> f<br>          <span class="hljs-number">4</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) <span class="hljs-operator">|</span> f<br>          <span class="hljs-number">5</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">5</span>) <span class="hljs-operator">|</span> f<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>到目前为止，索引页中的所有指针都处于活跃状态。但是一旦第一次索引扫描发生之后，指针状态就会改变：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, costs off, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> hot <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>                       QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> hot_id <span class="hljs-keyword">on</span> hot (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   Index Cond: (id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> index_page(<span class="hljs-string">&#x27;hot_id&#x27;</span>,<span class="hljs-number">1</span>);<br> itemoffset <span class="hljs-operator">|</span> htid  <span class="hljs-operator">|</span> dead<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>          <span class="hljs-number">1</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> t<br>          <span class="hljs-number">2</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> t<br>          <span class="hljs-number">3</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> t<br>          <span class="hljs-number">4</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) <span class="hljs-operator">|</span> t<br>          <span class="hljs-number">5</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">5</span>) <span class="hljs-operator">|</span> f<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>虽然第四个指针引用的堆元组还没有被剪枝，处于正常状态，但它已经超出了数据库视界。这就是为什么这个指针在索引中也被标记为 dead 的原因。</p><h3 id="5-2-HOT-Updates"><a href="#5-2-HOT-Updates" class="headerlink" title="5.2 HOT Updates"></a><a name="cp2"></a>5.2 HOT Updates</h3><p>在索引中保留对所有堆元组的引用是非常低效的。</p><p>首先，每次行修改都会触发表上所有索引的更新：一旦出现一条新的堆元组，每个索引都必须包含对该元组的引用，即使修改的字段没有被索引。</p><p>此外，索引积累了对历史堆元组的引用，因此它们必须与这些元组一起被剪枝。</p><p>随着在表上创建的索引越来越多，情况会变得更糟。</p><p>但是，如果更新的列不是任何索引的一部分，那么创建另一个包含相同键值的索引条目是没有意义的。为了避免这种冗余项，PostgreSQL 提供了一种称为 Heap-Only Tuple update 的优化机制 3。</p><p>如果执行这样的更新，索引页面对于每一行只包含一个条目。这个条目指向该行的第一个版本；所有后续位于同一页面中的行版本通过元组头中的 ctid 指针形成一条链。</p><p>未被任何索引引用的行版本使用 Heap-Only Tuple 位进行标记。如果一个行版本包含在 HOT 链中，那么会使用 Heap Hot Updated 位进行标记。</p><p>如果索引扫描访问堆页面并找到标记为 Heap Hot Updated 的行版本，这意味着扫描应该继续进行，因此它会沿着 HOT 更新链进一步扫描。显然，在将结果返回给客户端之前，所有获取的行版本都会检查其可见性。</p><p>为了了解 HOT 更新是如何执行的，让我们删除其中一个索引并截断表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DROP</span> INDEX hot_s;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> hot;<br></code></pre></td></tr></table></figure><p>为方便起见，我们将重新定义 heap_page 函数，使其输出包含另外三个字段：ctid 以及与 HOT 更新相关的两个位：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FUNCTION</span> heap_page(text,<span class="hljs-type">integer</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> heap_page(relname text, pageno <span class="hljs-type">integer</span>)<br><span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">TABLE</span>(<br>  ctid tid, state text,<br>  xmin text, xmax text,<br>  hhu text, hot text, t_ctid tid<br>) <span class="hljs-keyword">AS</span> $$<br><span class="hljs-keyword">SELECT</span> (pageno,lp)::text::tid <span class="hljs-keyword">AS</span> ctid,<br>       <span class="hljs-keyword">CASE</span> lp_flags<br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;unused&#x27;</span><br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;normal&#x27;</span><br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;redirect to &#x27;</span><span class="hljs-operator">||</span>lp_off<br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">3</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;dead&#x27;</span><br>       <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> state,<br>       t_xmin <span class="hljs-operator">||</span> <span class="hljs-keyword">CASE</span><br>         <span class="hljs-keyword">WHEN</span> (t_infomask <span class="hljs-operator">&amp;</span> <span class="hljs-number">256</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27; c&#x27;</span><br>         <span class="hljs-keyword">WHEN</span> (t_infomask <span class="hljs-operator">&amp;</span> <span class="hljs-number">512</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27; a&#x27;</span><br>         <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;&#x27;</span><br>       <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> xmin,<br>       t_xmax <span class="hljs-operator">||</span> <span class="hljs-keyword">CASE</span><br>         <span class="hljs-keyword">WHEN</span> (t_infomask <span class="hljs-operator">&amp;</span> <span class="hljs-number">1024</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27; c&#x27;</span><br>         <span class="hljs-keyword">WHEN</span> (t_infomask <span class="hljs-operator">&amp;</span> <span class="hljs-number">2048</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27; a&#x27;</span><br>         <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;&#x27;</span><br>       <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> xmax,<br>       <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> (t_infomask2 <span class="hljs-operator">&amp;</span> <span class="hljs-number">16384</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;t&#x27;</span> <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> hhu,<br>       <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> (t_infomask2 <span class="hljs-operator">&amp;</span> <span class="hljs-number">32768</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;t&#x27;</span> <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> hot,<br>       t_ctid<br><span class="hljs-keyword">FROM</span> heap_page_items(get_raw_page(relname,pageno))<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> lp;<br>$$ <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">sql</span>;<br></code></pre></td></tr></table></figure><p>让我们重复插入和更新操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> hot <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> hot <span class="hljs-keyword">SET</span> s <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;B&#x27;</span>;<br></code></pre></td></tr></table></figure><p>页面现在包含了一个 HOT 更新链：</p><pre><code class="hljs">Heap Hot Updated 位表示执行器需要沿着 CTID 链继续扫描。Heap Only Tuple 位表示这个元组没有被任何索引引用。</code></pre><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch5/ch5/img.png" alt="img.png"></p><p>随着我们进一步更新，链会增长 — 但仅限于页面范围内</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch5/ch5/img_1.png" alt="img_1.png"></p><p>索引仍然只包含一个引用，它指向这个链的头部：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> index_page(<span class="hljs-string">&#x27;hot_id&#x27;</span>,<span class="hljs-number">1</span>);<br> itemoffset <span class="hljs-operator">|</span> htid  <span class="hljs-operator">|</span> dead<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>          <span class="hljs-number">1</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> f<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>如果被修改的字段不是任何索引的一部分，那么就可以进行 HOT 更新。否则，某些索引将包含对出现在链中间的堆元组的引用，这与此优化的想法相矛盾。由于 HOT 链只能在单个页面内增长，遍历整个链永远不需要访问其他页面，因此不会损害性能。</p><h3 id="5-3-Page-Pruning-for-HOT-Updates"><a href="#5-3-Page-Pruning-for-HOT-Updates" class="headerlink" title="5.3 Page Pruning for HOT Updates"></a><a name="cp3"></a>5.3 Page Pruning for HOT Updates</h3><p>页剪枝的一个特殊情况 — 也同样重要，是 HOT 更新链的剪枝。</p><p>在上面的例子中，已经超过了 fillfactor 阈值，因此下一次更新会触发页剪枝。但这一次，页面包含了 HOT 链。这个链的头部必须始终保持原位，因为它被索引引用，但其他指针可以被释放，因为它们肯定没有外部引用。</p><p>为了避免移动头部，PostgreSQL 使用双重寻址：索引引用的指针 (在本例中为 (0,1)) 获取到的是 redirect 状态，因为它指向了当前链开始的元组：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch5/ch5/img_2.png" alt="img_2.png"></p><p>元组 (0,1)，(0,2)，(0,3) 被剪枝了；头指针 1 被保留，用于重定向，而指针 2 和 3 已被释放 (unused 的状态) ，因此，它们保证没有来自索引的引用。新的元组作为元组 (0,2) 写入到空闲空间中。</p><p>让我们再做一些更新：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch5/ch5/img_3.png" alt="img_3.png"></p><p>下一次更新会触发页剪枝：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch5/ch5/img_4.png" alt="img_4.png"></p><p>同样，一些元组被剪枝，指向链头的指针也相应地被移动。</p><p>如果经常修改非索引列，那么减少 fillfactor 的值是有意义的，从而在页面中保留一些空间用于更新。当然，你必须牢记，fillfactor 值越低，页面中剩余的空闲空间就越多，因此表的物理大小会增长。</p><h3 id="5-4-HOT-Chain-Splits"><a href="#5-4-HOT-Chain-Splits" class="headerlink" title="5.4 HOT Chain Splits"></a><a name="cp4"></a>5.4 HOT Chain Splits</h3><p>如果页面没有更多空间来容纳新的元组，那么链将被切断。PostgreSQL 将不得不添加一个单独的索引条目来引用位于另一个页面的元组。</p><p>为了观察这种情况，让我们开启一个并发事务，其快照会阻止页剪枝：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL REPEATABLE READ;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>现在我们在第一个会话中执行一些更新操作：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch5/ch5/img_5.png" alt="img_5.png"></p><p>当下一次更新发生时，此页面将无法容纳另一个元组，并且页剪枝将无法释放任何空间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> hot <span class="hljs-keyword">SET</span> s <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;L&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>; <span class="hljs-comment">-- the snapshot is not required anymore</span><br></code></pre></td></tr></table></figure><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch5/ch5/img_6.png" alt="img_6.png"></p><p>元组 (0,5) 包含跳转到第一个页面的引用 (1,1)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;hot&#x27;</span>,<span class="hljs-number">1</span>);<br>  ctid <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin <span class="hljs-operator">|</span> xmax <span class="hljs-operator">|</span> hhu <span class="hljs-operator">|</span> hot <span class="hljs-operator">|</span> t_ctid<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−−<span class="hljs-operator">+</span>−−−−−<span class="hljs-operator">+</span>−−−−−−−−<br> (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">823</span>  <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a  <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span> (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>但是，这个引用并未被使用：元组 (0,5) 没有设置 Heap Hot Updated 位。至于元组 (1,1)，可以从当前含有两个条目的索引中访问。它们中的每一个都指向其自己的 HOT 链头：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> index_page(<span class="hljs-string">&#x27;hot_id&#x27;</span>,<span class="hljs-number">1</span>);<br> itemoffset <span class="hljs-operator">|</span> htid  <span class="hljs-operator">|</span> dead<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br>          <span class="hljs-number">1</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> f<br>          <span class="hljs-number">2</span> <span class="hljs-operator">|</span> (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> f<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><h3 id="5-5-Page-Pruning-for-Indexes"><a href="#5-5-Page-Pruning-for-Indexes" class="headerlink" title="5.5 Page Pruning for Indexes"></a><a name="cp5"></a>5.5 Page Pruning for Indexes</h3><p>我已经声明，页剪枝仅限于单个堆页面，并且不会影响索引。但是，索引也有自己的剪枝机制 4，它也清理单个页面 — 在这种情况下是索引页面。</p><p>当向 B 树中的插入操作即将使页面一分为二时，就会发生索引剪枝，因为原始页面已经没有足够的空间了。问题是，即使稍后删除了一些索引条目，两个单独的索引页也不会合并为一个。这会导致索引膨胀，一旦膨胀，即使删除了很大一部分数据，索引也无法收缩。但是，如果剪枝可以删除一些元组，那么页面分裂可能会被推迟。</p><p>可以从索引中剪枝两种类型的元组。</p><p>首先，PostgreSQL 会剪枝那些被标记为 dead 的元组 5。正如我之前所说，如果 PostgreSQL 在索引扫描过程中，检测到索引条目指向一个在任何快照中均不再可见或根本不存在的元组，便会设置这样的标记。</p><p>如果没有元组已知是 dead 的状态，PostgreSQL 会检查那些引用同一个表行的不同版本的索引条目。6 因为 MVCC，更新操作可能会生成大量的行版本，而其中许多可能很快就会消失在数据库视界之外。HOT 更新减缓了这种影响，但它们并不总是适用：如果要更新的列是索引的一部分，那么相应的引用将传播到所有索引。在页面分裂之前，搜索尚未标记为 dead 但已经可以剪枝的行是有意义的。为了实现这一点，PostgreSQL 必须检查堆元组的可见性。此类检查需要访问表，因此仅针对”有希望的”的索引元组执行，这些元组是为了 MVCC 目的而创建的现有元组的副本。进行这样的检查比允许额外的页面分裂成本更低。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch4. Snapshot</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch4/ch4/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch4/ch4/</url>
    
    <content type="html"><![CDATA[<h2 id="ch4-Snapshot"><a href="#ch4-Snapshot" class="headerlink" title="ch4. Snapshot"></a>ch4. Snapshot</h2><p>快照</p><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">4.1 What is a Snapshot?</a></td></tr><tr><td><a href="#cp2">4.2 RowVersion Visibility</a></td></tr><tr><td><a href="#cp3">4.3 Snapshot Structure</a></td></tr><tr><td><a href="#cp4">4.4 Visibility of Transactions’Own Changes</a></td></tr><tr><td><a href="#cp5">4.5 Transaction Horizon</a></td></tr><tr><td><a href="#cp6">4.6 System Catalog Snapshots</a></td></tr><tr><td><a href="#cp7">4.7 Exporting Snapshots</a></td></tr></tbody></table><h3 id="4-1-What-is-a-Snapshot"><a href="#4-1-What-is-a-Snapshot" class="headerlink" title="4.1 What is a Snapshot"></a><a name="cp1"></a>4.1 What is a Snapshot</h3><p>数据页可以包含同一行的多个版本，尽管每个事务最多只能看到其中一个版本。所有不同行的可见版本共同构成一个快照。快照仅包括在获取时已提交的当前数据，因此为这一特定时刻提供了一致的 (在 ACID 意义上) 数据视图。</p><p>为了确保隔离性，每个事务都使用其自己的快照。这意味着不同的事务可以看到在不同时间点获取的不同快照，但这些快照仍然是一致的。</p><p>在读已提交隔离级别下，每个语句开始时获取一个快照，并且仅在该语句期间内保持活跃状态。</p><p>在可重复读和可序列化隔离级别下，在事务内的第一条语句开始时获取一个快照，并且会保持活跃状态直到整个事务完成。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch4/ch4/img.png" alt="img.png"></p><h3 id="4-2-RowVersion-Visibility"><a href="#4-2-RowVersion-Visibility" class="headerlink" title="4.2 RowVersion Visibility"></a><a name="cp2"></a>4.2 RowVersion Visibility</h3><p>快照并不是所有所需元组的物理拷贝。相反，它由几个数字定义，而元组的可见性则由特定规则决定。</p><p>元组可见性由元组头中的 xmin 和 xmax 字段 (即执行插入和删除的事务 ID) 和相应的提示位定义。由于 xmin–xmax 区间不相交，因此在任何快照中，每一行仅由其版本中的一个所表示。</p><p>确切的可见性规则十分复杂 1，因为考虑到了各种不同的场景和极端情况。非常粗略地，我们可以这样描述它们：一个元组在包括 xmin 事务更改但不包括 xmax 事务更改的快照中是可见的 (换句话说，该元组已经出现并且尚未被删除)。</p><p>如果事务在快照创建之前提交，那么事务更改在快照中是可见的。作为一个例外，事务可以看到自己未提交的更改。如果事务被中止，其更改不会在任何快照中可见。</p><p>让我们看一个简单的例子。在此图中，线段代表事务 (从它们的开始时间到提交时间)：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch4/ch4/img_1.png" alt="img_1.png"></p><p>此处，应用于事务的可见性规则如下：</p><pre><code class="hljs">1. 事务 2 在快照创建之前已提交，因此其更改是可见的。2. 事务 1 在快照创建时仍处于活跃状态，因此其更改不可见。3. 事务 3 是在快照创建后启动的，因此它的更改也不可见 (无论此事务完成与否都没有区别)。</code></pre><h3 id="4-3-Snapshot-Structure"><a href="#4-3-Snapshot-Structure" class="headerlink" title="4.3 Snapshot Structure"></a><a name="cp3"></a>4.3 Snapshot Structure</h3><p>不幸的是，前面的示例与 PostgreSQL 实际看到的情况并不相符 （include&#x2F;utils&#x2F;snapshot.h backend&#x2F;utils&#x2F;time&#x2F;snapmgr.c ）。问题在于，系统不知道事务何时提交。仅知道它们是何时开始的 (这一时刻由事务 ID 定义)，事务何时完成的未在任何地方记录。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">如果启用了 track_commit_timestamp 参数，可以跟踪事务的提交时间 3，但它们不会以任何方式参与可见性检查 (尽管出于其他目的跟踪它们仍然是有用的，例如，应用于外部复制解决方案)。<br><br>此外，PostgreSQL 总是在相应的 WAL 条目中记录提交和回滚的时间，但这些信息仅用于时间点恢复。<br></code></pre></td></tr></table></figure><p>我们只能了解到事务的当前状态。此信息可以在服务器的共享内存中获取：ProcArray 结构包含所有活跃会话及其事务的列表。一旦事务完成，就无法确定它在快照创建时是否处于活跃状态。</p><p>因此创建快照仅记录获取的时刻是不够的：还需要收集在那一时刻所有事务的状态。否则，之后将无法确定哪些元组在快照中必须可见，哪些必须被排除。</p><p>让我们看一下系统在获取快照时以及一段时间后可用的信息，白色圆圈表示活跃事务，黑色圆圈表示已完成的事务：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch4/ch4/img_2.png" alt="img_2.png"></p><p>假设我们不知道在获取快照时第一个事务仍在执行中，而第三个事务尚未开始。那么看起来它们就像第二个事务 (在那个时刻已提交) 一样，无法将它们过滤掉。</p><p>因此，即使所有需要的元组都存在于堆页面中，PostgreSQL 也无法创建一个快照来显示过去某个任意时间点的数据一致状态。所以，PostgreSQL 无法实现回溯查询 (有时也称为时间或闪回查询)。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">有趣的是，该功能被宣布为 Postgres 的目标之一，并在初期就实现了，但是当项目支持转交给社区时，它被从数据库系统中移除了 (Joseph M. Hellerstein, Looking Back at Postgres. https://arxiv.org/pdf/1901.01973.pdf)。<br></code></pre></td></tr></table></figure><p>因此，快照由创建时保存的几个值所组成 5：</p><p><strong>xmin</strong> 是快照的下边界，由最老的活跃事务 ID 表示。</p><p>所有 ID 更小的事务要么已提交 (因此它们的更改包含在快照中)，要么已中止 (因此它们的更改会被忽略)。</p><p><strong>xmax</strong> 是快照的上边界，由最新已提交的事务 ID 加 1 所表示。上边界定义了获取快照的时刻。</p><p>所有 ID 大于或等于 xmax 的事务要么仍在运行中，要么不存在，因此它们的更改不可见。</p><p><strong>xip_list</strong> 是除了虚拟事务之外的所有活跃事务 ID 的列表，虚拟事务不会以任何方式影响可见性。</p><p>快照还包括其他几个参数，但此处我们将忽略它们。</p><p>以图形表示，快照可以表示为一个矩形，包括从 xmin 到 xmax 的事务。<br><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch4/ch4/img_3.png" alt="img_3.png"></p><p>为了理解快照是如何定义可见性规则的，我们将在 accounts 表上复现上述场景。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> accounts;<br></code></pre></td></tr></table></figure><p>第一个事务向表中插入第一行，并保持开启状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> accounts <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-number">1000.00</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_xact_id();<br> pg_current_xact_id<br>−−−−−−−−−−−−−−−−−−−−<br>                <span class="hljs-number">790</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>第二个事务插入第二行，并立即提交此更改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> accounts <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-number">100.00</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_xact_id();<br> pg_current_xact_id<br>−−−−−−−−−−−−−−−−−−−−<br>                <span class="hljs-number">791</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>此时，让我们在另一个会话中创建一个新的快照。 为此，我们可以简单地运行任何查询，但我们将使用一个特殊函数来立即查看此快照：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL REPEATABLE READ;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-comment">-- txid_current_snapshot() before v.13</span><br><span class="hljs-keyword">SELECT</span> pg_current_snapshot();<br> pg_current_snapshot<br>−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-number">790</span>:<span class="hljs-number">792</span>:<span class="hljs-number">790</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>此函数显示了快照的组成，以冒号分隔：xmin、xmax 和 xip_list (活跃事务列表；在这个特定案例中，它由单个条目组成)。</p><p>一旦获取了快照之后，提交第一个事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>第三个事务是在快照创建后开始的。它修改了第二行，所以出现了一个新的元组：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_xact_id();<br> pg_current_xact_id<br>−−−−−−−−−−−−−−−−−−−−<br>                <span class="hljs-number">792</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>我们的快照只看到一个元组：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> ctid, <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts;<br>  ctid <span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> client <span class="hljs-operator">|</span> amount<br>−−−−−−−<span class="hljs-operator">+</span>−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> <span class="hljs-number">2</span>  <span class="hljs-operator">|</span> bob    <span class="hljs-operator">|</span> <span class="hljs-number">100.00</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>但是表中包含了三个元组：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;accounts&#x27;</span>,<span class="hljs-number">0</span>);<br>  ctid <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin  <span class="hljs-operator">|</span> xmax<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">790</span> c <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">791</span> c <span class="hljs-operator">|</span> <span class="hljs-number">792</span> c<br> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">792</span> c <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>那么 PostgreSQL 是如何选择要显示哪些版本的呢？ 根据上述规则，仅当满足以下条件的已提交事务执行的更改，才会被包含在快照中：</p><pre><code class="hljs">1. 如果 xid &lt; xmin，那么更改会无条件显示 (就像创建 accounts 表的事务一样)。2. 如果 xmin ⩽ xid &lt; xmax，那么仅当相应的事务 ID 不在 xip_list 中时，更改才会被显示。</code></pre><p>第一行 (0,1) 是不可见的，因为插入它的事务出现在了 xip_list 中 (即使该事务落在了快照范围内)。</p><p>第二行 (0,3) 的最新版本是不可见的，因为相应的事务 ID 超过了快照的上边界。</p><p>但是第二行的第一个版本 (0,2) 是可见的：插入行的事务落在了快照范围内，并且没有出现在 xip_list 中 (插入是可见的)，而删除行的事务，其 ID 超过了快照的上边界 (删除是不可见的)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><h3 id="4-4-Visibility-of-Transactions’Own-Changes"><a href="#4-4-Visibility-of-Transactions’Own-Changes" class="headerlink" title="4.4 Visibility of Transactions’Own Changes"></a><a name="cp4"></a>4.4 Visibility of Transactions’Own Changes</h3><p>在定义事务自身更改的可见性规则时，事情变得更加复杂：在某些情况下，只有部分更改必须是可见的。例如，无论隔离级别如何，在特定时间点打开的游标不能看到之后发生的任何更改。</p><p>为了解决这类情况，元组头提供了一个特殊字段 (cmin 和 cmax 伪列)，用于显示事务内操作的序号。cmin 列用于标识插入，而 cmax 用于删除操作。为了节省空间，这些值存储在元组头的单个字段中，而不是存储在两个不同的字段中。考虑到同一行几乎永远不会在单个事务中既被插入又被删除。(如果确实发生了，PostgreSQL 会在这个字段中写入一个特殊的 combo 标识符，在这种情况下，实际的 cmin 和 cmax 值由后端进程存储 (backend&#x2F;utils&#x2F;time&#x2F;combocid.c))。</p><p>作为示例，让我们启动一个事务并在表中插入一行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> accounts <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;charlie&#x27;</span>, <span class="hljs-number">100.00</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_xact_id();<br> pg_current_xact_id<br>−−−−−−−−−−−−−−−−−−−−<br>                <span class="hljs-number">793</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>然后打开一个游标，用于执行返回表中行数的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DECLARE</span> c <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> accounts;<br></code></pre></td></tr></table></figure><p>再插入一行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> accounts <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;charlie&#x27;</span>, <span class="hljs-number">200.00</span>);<br></code></pre></td></tr></table></figure><p>现在用另一列来扩展输出，以显示插入行的 cmin 值 (对于其他行没有意义)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> xmin, <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> xmin <span class="hljs-operator">=</span> <span class="hljs-number">793</span> <span class="hljs-keyword">THEN</span> cmin <span class="hljs-keyword">END</span> cmin, <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> accounts;<br> xmin <span class="hljs-operator">|</span> cmin <span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> client  <span class="hljs-operator">|</span> amount<br>−−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<br>  <span class="hljs-number">790</span> <span class="hljs-operator">|</span>      <span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> alice <span class="hljs-operator">|</span> <span class="hljs-number">1000.00</span><br>  <span class="hljs-number">792</span> <span class="hljs-operator">|</span>      <span class="hljs-operator">|</span>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> bob     <span class="hljs-operator">|</span>  <span class="hljs-number">200.00</span><br>  <span class="hljs-number">793</span> <span class="hljs-operator">|</span>   <span class="hljs-number">0</span> <span class="hljs-operator">|</span>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> charlie <span class="hljs-operator">|</span>  <span class="hljs-number">100.00</span><br>  <span class="hljs-number">793</span> <span class="hljs-operator">|</span>   <span class="hljs-number">1</span>  <span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> charlie <span class="hljs-operator">|</span>  <span class="hljs-number">200.00</span><br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>游标查询只获取到三行；在游标已经打开时插入的行未包含在快照中，因为它不满足 cmin &lt; 1 的条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FETCH</span> c;<br> count<br>−−−−−−−<br>     <span class="hljs-number">3</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>当然，这个 cmin 数字也存储在快照中，但无法使用任何 SQL 手段显示它。</p><h3 id="4-5-Transaction-Horizon"><a href="#4-5-Transaction-Horizon" class="headerlink" title="4.5 Transaction Horizon"></a><a name="cp5"></a>4.5 Transaction Horizon</h3><p>如前文所述，快照的下边界由 xmin 表示，xmin 是快照创建时处于活跃状态的最老的事务 ID。这个值非常重要，因为它定义了使用这个快照的事务视界。</p><p>如果一个事务没有活跃的快照 (例如，在读已提交隔离级别的语句执行之间)，那么其视界由它自己的 ID 定义(如果已分配)。</p><p>所有超出视界的事务 (那些 xid &lt; xmin 的事务) 都保证已提交。这意味着，一个事务只能看到其视界之外的当前行版本。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">如你所料，这个术语的灵感来自物理学中的事件视界概念。<br></code></pre></td></tr></table></figure><p>PostgreSQL 跟踪所有进程的当前视界；事务可以在 pg_stat_activity 表中看到它们自己的视界：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> backend_xmin <span class="hljs-keyword">FROM</span> pg_stat_activity<br><span class="hljs-keyword">WHERE</span> pid <span class="hljs-operator">=</span> pg_backend_pid();<br> backend_xmin<br>−−−−−−−−−−−−−−<br>          <span class="hljs-number">793</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>虚拟事务没有真正的 ID，但它们仍然像常规事务一样使用快照，因此它们有自己的视界。唯一例外是没有活跃快照的虚拟事务：视界的概念对于它们来说毫无意义，当涉及到快照和可见性时，它们对系统是完全”透明的” (尽管 pg_stat_activity.backend_xmin 中仍可能包含旧快照的 xmin)。</p><p>我们也可以用类似的方式去定义数据库视界。为此，我们应当获取这个数据库中所有事务的视界，并选择最远的一个，其 xmin 最老 7。在这个视界之外，过期的堆元组将永远不会对这个数据库中的任何事务可见。这样的元组便可以被 vacuum 安全地清理掉 — 这正是从实际角度来看，为什么视界的概念如此重要的原因。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch4/ch4/img_4.png" alt="img_4.png"></p><p>让我们总结一下：</p><pre><code class="hljs">1. 如果处于可重复读或可序列化隔离级别下的事务 (无论是真实的还是虚拟的) 运行了很长时间，它会保持数据库视界并推迟清理。2. 处于读已提交隔离级别下的真实事务以相同的方式保持数据库视界，即使它没有执行任何操作符 (处于 “idle in transaction” 状态)。3. 处于读已提交隔离级别下的虚拟事务仅在执行操作符时才保持视界。</code></pre><p>整个数据库只有一个视界，因此如果它被一个事务持有，那么这个视界内的任何数据都无法进行清理 — 即使这个事务没有访问这些数据。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">集簇范围的系统目录表有一个单独的视界，该视界考虑了所有数据库中的所有事务。相反，临时表不需要关注除当前进程正在执行的事务之外的任何事务。<br></code></pre></td></tr></table></figure><p>让我们回到当前的实验。第一个会话的活跃事务仍然持有数据库视界；我们可以通过增加事务计数器来看到这一点：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_xact_id();<br> pg_current_xact_id<br>−−−−−−−−−−−−−−−−−−−−<br>                <span class="hljs-number">794</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> backend_xmin <span class="hljs-keyword">FROM</span> pg_stat_activity<br><span class="hljs-keyword">WHERE</span> pid <span class="hljs-operator">=</span> pg_backend_pid();<br> backend_xmin<br>−−−−−−−−−−−−−−<br>          <span class="hljs-number">793</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>只有当这个事务完成时，视界才会向前推动，过期的元组才能被清理掉：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> backend_xmin <span class="hljs-keyword">FROM</span> pg_stat_activity<br><span class="hljs-keyword">WHERE</span> pid <span class="hljs-operator">=</span> pg_backend_pid();<br> backend_xmin<br>−−−−−−−−−−−−−−<br>          <span class="hljs-number">795</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>在理想情况下，你应该避免将长事务与频繁更新 (产生新的行版本) 相结合，因为这会导致表和索引膨胀。</p><h3 id="4-6-System-Catalog-Snapshots"><a href="#4-6-System-Catalog-Snapshots" class="headerlink" title="4.6 System Catalog Snapshots"></a><a name="cp6"></a>4.6 System Catalog Snapshots</h3><p>尽管系统目录由常规表组成，但它们不能通过事务或操作符使用的快照来访问。快照必须足够”新鲜”以包含所有最新的更改，否则事务可能会看到过时的列定义或错过新添加的完整性约束。</p><p>此处是一个简单的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>; <span class="hljs-comment">-- a snapshot for the transaction is taken</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER TABLE</span> accounts<br>  <span class="hljs-keyword">ALTER</span> amount <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NOT NULL</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> accounts(client, amount)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-keyword">NULL</span>);<br>ERROR: <span class="hljs-keyword">null</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">column</span> &quot;amount&quot; <span class="hljs-keyword">of</span> relation &quot;accounts&quot;<br>violates <span class="hljs-keyword">not</span>−<span class="hljs-keyword">null</span> <span class="hljs-keyword">constraint</span><br>DETAIL: Failing <span class="hljs-type">row</span> <span class="hljs-keyword">contains</span> (<span class="hljs-number">1</span>, alice, <span class="hljs-keyword">null</span>).<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><p>快照创建之后出现的完整性约束对 INSERT 命令是可见的。看起来这种行为打破了隔离性，但是如果插入的事务在 ALTER TABLE 命令之前就访问了 accounts 表，那么后者就会被阻塞，直至该事务完成。</p><p>通常，服务器的行为就像为每个系统目录查询创建了一个单独的快照。但是实现当然要复杂得多 8，因为频繁创建快照会对性能产生负面影响；此外，许多系统目录对象都被缓存了，这也是必须考虑的。</p><h3 id="4-7-Exporting-Snapshots"><a href="#4-7-Exporting-Snapshots" class="headerlink" title="4.7 Exporting Snapshots"></a><a name="cp7"></a>4.7 Exporting Snapshots</h3><p>在某些情况下，必须确保并发事务无论如何都能看到同一个快照。例如，如果 pg_dump 工具以并行模式运行，所有的进程必须看到相同的数据库状态，以产生一致的备份。</p><p>我们不能仅仅因为事务是”同时”启动的，就假设快照也是相同的。为了确保所有事务看到相同的数据，我们必须使用快照导出机制。</p><p>pg_export_snapshot 函数返回一个快照 ID，这个 ID 可以传递给另一个事务 (在数据库系统之外)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL REPEATABLE READ;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> accounts;<br> count<br>−−−−−−−<br>     <span class="hljs-number">4</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_export_snapshot();<br> pg_export_snapshot<br>−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-number">00000004</span>−<span class="hljs-number">0000006</span>E−<span class="hljs-number">1</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>在执行第一个语句之前，另一个事务可以通过运行 SET TRANSACTION SNAPSHOT 命令来导入快照。隔离级别必须设置为可重复读或可序列化，因为在读已提交级别下，操作符使用它们自己的快照：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> accounts;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL REPEATABLE READ;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> TRANSACTION SNAPSHOT <span class="hljs-string">&#x27;00000004-0000006E-1&#x27;</span>;<br></code></pre></td></tr></table></figure><p>现在第二个事务将使用第一个事务的快照，因此，它将看到四行 (而不是零)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> accounts;<br> count<br>−−−−−−−<br>   <span class="hljs-number">4</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>显然，在快照导出后，第二个事务不会看到第一个事务所做的任何更改 (反之亦然)：常规的可见性规则仍然适用。</p><p>导出快照的生命周期与导出事务的生命周期相同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch3. Pages and Tuples</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch3/ch3/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch3/ch3/</url>
    
    <content type="html"><![CDATA[<h2 id="ch3-Pages-and-Tuples"><a href="#ch3-Pages-and-Tuples" class="headerlink" title="ch3. Pages and Tuples"></a>ch3. Pages and Tuples</h2><p>页与元组</p><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#Page-Structure">3.1 Page Structure</a></td></tr><tr><td><a href="#Row-Version">3.2 Row Version Layout</a></td></tr><tr><td><a href="#Operations-on-Tuples">3.3 Operations on Tuples</a></td></tr><tr><td><a href="#Indexes">3.4 Indexes</a></td></tr><tr><td><a href="#TOAST">3.5 TOAST</a></td></tr><tr><td><a href="#Virtual-Transactions">3.6 Virtual Transactions</a></td></tr><tr><td><a href="#Subtransactions">3.7 Subtransactions</a></td></tr></tbody></table><h3 id="3-1-Page-Structure"><a href="#3-1-Page-Structure" class="headerlink" title="3.1 Page Structure"></a><a name="data-Organization"></a>3.1 Page Structure</h3><p>页面结构</p><p>每个页面都有特定的内部布局，通常由以下部分组成 (postgresql.org&#x2F;docs&#x2F;14&#x2F;storage-page-layout.html \ include&#x2F;storage&#x2F;bufpage.h)：</p><p>页头<br>项指针数组<br>空闲空间<br>项 (行版本)<br>特殊空间</p><h4 id="3-1-1-页头"><a href="#3-1-1-页头" class="headerlink" title="3.1.1 页头"></a>3.1.1 页头</h4><p>页头位于地址的最低处，其大小固定。它存储着关于页面的各种信息，比如校验和以及页面其他所有部分的大小。</p><p>这些大小可以通过 pageinspect 扩展 (postgresql.org&#x2F;docs&#x2F;14&#x2F;pageinspect.html) 查看。让我们看下表的第一个页面，页号从零开始：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> EXTENSION pageinspect;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> lower, upper, special, pagesize<br><span class="hljs-keyword">FROM</span> page_header(get_raw_page(<span class="hljs-string">&#x27;accounts&#x27;</span>,<span class="hljs-number">0</span>));<br> lower <span class="hljs-operator">|</span> upper <span class="hljs-operator">|</span> special <span class="hljs-operator">|</span> pagesize<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<br>   <span class="hljs-number">152</span> <span class="hljs-operator">|</span>  <span class="hljs-number">6904</span> <span class="hljs-operator">|</span>    <span class="hljs-number">8192</span> <span class="hljs-operator">|</span>     <span class="hljs-number">8192</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch3/ch3/img.png" alt="img.png"></p><h4 id="3-1-2-特殊空间"><a href="#3-1-2-特殊空间" class="headerlink" title="3.1.2 特殊空间"></a>3.1.2 特殊空间</h4><p>特殊空间位于页面的另一边，占据最高地址。它被某些索引用来存储辅助信息；在其他索引和表页面中，这个空间的大小为零。</p><p>一般来说，索引页面的布局相当多样；它们的内容很大程度上取决于特定的索引类型。即使是同一个索引也可以有不同类型的页面：例如，B 树有一个特殊结构的元数据页面 (第零页) 和与表页面非常相似的常规页面。</p><h4 id="3-1-3-元组"><a href="#3-1-3-元组" class="headerlink" title="3.1.3 元组"></a>3.1.3 元组</h4><p>行 (rows) 包含存储在数据库中的实际数据以及一些额外信息。它们位于特殊空间之前。</p><p>在处理表时，我们需要处理的是行版本而不是行，因为多版本并发控制意味着同一行有多个版本。索引不使用这种 MVCC 机制；相反，它们必须引用所有可用的行版本，然后依靠可见性规则来选择合适的行版本。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">表的行版本和索引条目通常都被称为元组。这个术语源自关系理论 — 这是 PostgreSQL 学术历史的另一项遗产。<br></code></pre></td></tr></table></figure><h4 id="3-1-4-项指针"><a href="#3-1-4-项指针" class="headerlink" title="3.1.4 项指针"></a>3.1.4 项指针</h4><p>指向元组的指针数组作为页面的目录。它位于页头之后。</p><p>索引条目必须以某种方式引用特定的堆元组。为此 PostgreSQL 使用六字节的元组标识符 (TIDS)。每个 TID 由主分支的页号以及对该页面中特定行版本的引用所组成。</p><p>理论上，元组可以通过它们从页面开始的偏移量来引用。但这样一来，如果不破坏这些引用，就无法在页面内移动元组，进而导致页面碎片以及其他不愉快的后果。</p><p>为此，PostgreSQL 使用间接寻址：元组标识符指向相应的指针号，而这个指针指定了元组的当前偏移量。如果元组在页面内移动，其 TID 仍然保持不变，只需修改位于该页面中的指针即可。</p><p>每个指针占用四个字节，并包含以下数据：</p><pre><code class="hljs">元组从页面开始的偏移量元组长度定义元组状态的若干比特位</code></pre><h4 id="3-1-5-空闲空间"><a href="#3-1-5-空闲空间" class="headerlink" title="3.1.5 空闲空间"></a>3.1.5 空闲空间</h4><p>页面在指针和元组之间会留下一些空闲空间 (这反映在空闲空间映射中)。页面不会碎片化：所有可用的空闲空间总是聚集成一个块 (backend&#x2F;storage&#x2F;page&#x2F;bufpage.c, PageRepairFragmentation function)。</p><h3 id="3-2-Row-Version-Layout"><a href="#3-2-Row-Version-Layout" class="headerlink" title="3.2 Row Version Layout"></a><a name="data-Organization"></a>3.2 Row Version Layout</h3><p>行版本布局</p><p>每个行版本都包含一个行头，后面跟着实际的数据。行头由多个字段组成，包括以下内容：</p><p>xmin, xmax 代表事务 ID；它们用于区分同一行的当前版本与其他版本。</p><p>infomask 提供了一组用于定义行版本属性的信息位。</p><p>ctid 是指向同一行的下一个更新版本的指针。</p><p>null bitmap 是一个位数组，用于标记列中是否包含空值。</p><p>因此，行头会变得非常大：每个元组至少需要 23 个字节，并且由于空值位图以及用于数据对齐的强制填充，通常情况下会超过此值。在”窄”表中，各种元数据的大小很容易超过实际存储数据的大小。</p><p>磁盘上的数据布局与 RAM 中的数据表示完全一致。页面及其元组按原样读入缓冲区缓存中，无需任何转换。这就是为什么数据文件在不同平台之间不兼容的原因 4。</p><p>不兼容的原因之一是字节序。例如，x86 架构是小端序，z&#x2F;Architecture 是大端序，而 ARM 的字节序是可配置的。</p><p>另一个原因是按照机器字边界进行数据对齐，这也是许多架构所要求的。例如，在 32 位 x86 系统中，整数 (integer 类型，占用四个字节) 按四字节字边界对齐，就像双精度浮点数 (double precision 类型，占用八个字节)。但在 64 位系统中，双精度数按八字节字边界对齐。</p><p>数据对齐使得元组的大小取决于表中字段的顺序。这种影响通常可以忽略不计，但在某些情况下，它会导致大小显著增加。此处是一个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE TABLE</span> padding(<br>  b1 <span class="hljs-type">boolean</span>,<br>  i1 <span class="hljs-type">integer</span>,<br>  b2 <span class="hljs-type">boolean</span>,<br>  i2 <span class="hljs-type">integer</span><br>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> padding <span class="hljs-keyword">VALUES</span> (<span class="hljs-literal">true</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>,<span class="hljs-number">2</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> lp_len <span class="hljs-keyword">FROM</span> heap_page_items(get_raw_page(<span class="hljs-string">&#x27;padding&#x27;</span>, <span class="hljs-number">0</span>));<br> lp_len<br>−−−−−−−−<br>     <span class="hljs-number">40</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>我使用了 pageinspect 扩展中的 heap_page_items 函数来显示关于指针和元组的一些细节。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">在 PostgreSQL 中，表通常被称为堆 (heap)。这是另一个晦涩的术语，暗示了元组的空间分配和动态内存分配之间的相似性。确实可以看到某种类比，但表由完全不同的算法管理。与有序索引相比，我们可以将这个术语理解为&quot;一切都堆积成堆&quot;。<br></code></pre></td></tr></table></figure><p>这一行的大小是 40 个字节，其行头占 24 个字节，integer 类型的列占用 4 个字节，每个 boolean 类型的列占用 1 个字节。总共 34 个字节，因此浪费了 6 个字节用于整数列的四字节对齐。</p><p>如果我们重建表，空间将被更有效地利用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> padding;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE TABLE</span> padding(<br>  i1 <span class="hljs-type">integer</span>,<br>  i2 <span class="hljs-type">integer</span>,<br>  b1 <span class="hljs-type">boolean</span>,<br>  b2 <span class="hljs-type">boolean</span><br>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> padding <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> lp_len <span class="hljs-keyword">FROM</span> heap_page_items(get_raw_page(<span class="hljs-string">&#x27;padding&#x27;</span>, <span class="hljs-number">0</span>));<br> lp_len<br>−−−−−−−−<br>     <span class="hljs-number">34</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>另一种可能的微优化是在表的开头放置不包含空值的固定长度的列。对这些列的访问会更有效率，因为可以缓存它们在元组内的偏移量 (backend&#x2F;access&#x2F;common&#x2F;heaptuple.c, heap_deform_tuple function)。</p><h3 id="3-3-Operations-on-Tuples"><a href="#3-3-Operations-on-Tuples" class="headerlink" title="3.3 Operations on Tuples"></a><a name="data-Organization"></a>3.3 Operations on Tuples</h3><p>元组操作</p><p>为了识别同一行的不同版本，PostgreSQL 使用两个值来标记每个版本：xmin 和 xmax。这些值定义了每个行版本的”有效时间”，但它们不是实际时间，而是依赖于不断增加的事务 ID。</p><p>当创建一行时，其 xmin 值被设置为 INSERT 命令的事务 ID。</p><p>当删除一行时，其当前版本的 xmax 值被设置为 DELETE 命令的事务 ID。</p><p>UPDATE 命令具有一定程度的抽象性，可以将其看作是两个独立的操作：DELETE 和 INSERT。首先，当前行版本的 xmax 值设置为 UPDATE 命令的事务 ID。然后创建该行的新版本；其 xmin 值与前一个版本的 xmax 值相同。</p><p>现在，让我们深入了解一些关于元组操作的底层细节 (backend&#x2F;access&#x2F;transam&#x2F;README)。</p><p>对于这些实验，我们需要一个含有两列的表，并在其中一列上创建索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE TABLE</span> t(<br>  id <span class="hljs-type">integer</span> GENERATED ALWAYS <span class="hljs-keyword">AS</span> <span class="hljs-keyword">IDENTITY</span>,<br>  s text<br>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> t(s);<br></code></pre></td></tr></table></figure><h4 id="3-3-1-插入"><a href="#3-3-1-插入" class="headerlink" title="3.3.1 插入"></a>3.3.1 插入</h4><p>开启一个事务并插入一行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> t(s) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;FOO&#x27;</span>);<br></code></pre></td></tr></table></figure><p>这是当前的事务ID</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-comment">-- txid_current() before v.13</span><br><span class="hljs-keyword">SELECT</span> pg_current_xact_id();<br> pg_current_xact_id<br>−−−−−−−−−−−−−−−−−−−−<br>                <span class="hljs-number">776</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">为了表示事务的概念，PostgreSQL 使用了术语 xact，这个术语可以在 SQL 函数名和源代码中找到。因此，事务 ID 可以称为 xact ID、TXID 或简称为 XID。我们会反复遇到这些缩写。<br></code></pre></td></tr></table></figure><p>让我们看一下页面内容。heap_page_items 函数可以提供我们所有需要的信息，但是它”按原样”显示数据，因此输出格式有点难以理解：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> heap_page_items(get_raw_page(<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-number">0</span>)) \gx<br>−[ RECORD <span class="hljs-number">1</span> ]−−−−−−−−−−−−−−−−−−−<br>lp          <span class="hljs-operator">|</span> <span class="hljs-number">1</span><br>lp_off      <span class="hljs-operator">|</span> <span class="hljs-number">8160</span><br>lp_flags    <span class="hljs-operator">|</span> <span class="hljs-number">1</span><br>lp_len      <span class="hljs-operator">|</span> <span class="hljs-number">32</span><br>t_xmin      <span class="hljs-operator">|</span> <span class="hljs-number">776</span><br>t_xmax      <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br>t_field3    <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br>t_ctid      <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>t_infomask2 <span class="hljs-operator">|</span> <span class="hljs-number">2</span><br>t_infomask <span class="hljs-operator">|</span> <span class="hljs-number">2050</span><br>t_hoff      <span class="hljs-operator">|</span> <span class="hljs-number">24</span><br>t_bits      <span class="hljs-operator">|</span><br>t_oid       <span class="hljs-operator">|</span><br>t_data      <span class="hljs-operator">|</span> \x0100000009464f4f<br></code></pre></td></tr></table></figure><p>为了使其更具有可读性，我们可以省略一些信息并扩展一些列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;(0,&#x27;</span><span class="hljs-operator">||</span>lp<span class="hljs-operator">||</span><span class="hljs-string">&#x27;)&#x27;</span> <span class="hljs-keyword">AS</span> ctid,<br>     <span class="hljs-keyword">CASE</span> lp_flags<br>       <span class="hljs-keyword">WHEN</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;unused&#x27;</span><br>       <span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;normal&#x27;</span><br>       <span class="hljs-keyword">WHEN</span> <span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;redirect to &#x27;</span><span class="hljs-operator">||</span>lp_off<br>       <span class="hljs-keyword">WHEN</span> <span class="hljs-number">3</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;dead&#x27;</span><br>     <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> state,<br>     t_xmin <span class="hljs-keyword">as</span> xmin,<br>     t_xmax <span class="hljs-keyword">as</span> xmax,<br>     (t_infomask <span class="hljs-operator">&amp;</span> <span class="hljs-number">256</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">AS</span> xmin_committed,<br>     (t_infomask <span class="hljs-operator">&amp;</span> <span class="hljs-number">512</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">AS</span> xmin_aborted,<br>     (t_infomask <span class="hljs-operator">&amp;</span> <span class="hljs-number">1024</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">AS</span> xmax_committed,<br>     (t_infomask <span class="hljs-operator">&amp;</span> <span class="hljs-number">2048</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">AS</span> xmax_aborted<br><span class="hljs-keyword">FROM</span> heap_page_items(get_raw_page(<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-number">0</span>)) \gx<br><br>−[ RECORD <span class="hljs-number">1</span> ]−−<span class="hljs-operator">+</span>−−−−−−−<br>ctid           <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>state          <span class="hljs-operator">|</span> normal<br>xmin           <span class="hljs-operator">|</span> <span class="hljs-number">776</span><br>xmax           <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br>xmin_committed <span class="hljs-operator">|</span> f<br>xmin_aborted   <span class="hljs-operator">|</span> f<br>xmax_committed <span class="hljs-operator">|</span> f<br>xmax_aborted   <span class="hljs-operator">|</span> t<br></code></pre></td></tr></table></figure><p>此查询完成了以下操作：</p><pre><code class="hljs">1. lp 指针被转换为元组 ID 的标准格式：页号，指针号。2. lp_flags 的状态被详细展示出来。此处它被设为 normal，意味着确实指向一个元组。3. 在所有信息位中，到目前为止我们只挑选出了两对。xmin_committed 和 xmin_aborted 表示 xmin 对应的事务已提交或者已中止。xmax_committed 和 xmax_aborted 提供了关于 xmax 事务的类似信息。</code></pre><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">pageinspect 扩展提供了 heap_tuple_infomask_flags 函数，用于解释所有的信息位 ，但我目前只检索需要的那些信息位，并以更简洁的形式展示。<br></code></pre></td></tr></table></figure><p>让我们回到我们的实验。INSERT 命令已将指针 1 添加到堆页面中，它引用第一个元组，这也是目前唯一的一个元组。</p><p>元组的 xmin 字段被设置为当前事务 ID。此事务目前仍然活跃，因此 xmin_committed 和 xmin_aborted 位均还没有设置。</p><p>xmax 字段包含 0，这是一个虚拟数字，用于表示该元组尚未被删除，并且代表该行的当前版本。事务会忽略这个数字，因为 xmax_aborted 位被设置了。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">为尚未发生的事务设置对应于已中止事务的位可能看起来有些奇怪。但是从隔离的角度来看，这些事务之间没有区别：一个已中止的事务不留下任何痕迹，因此就好像它从未存在过一样。<br></code></pre></td></tr></table></figure><p>我们会多次使用这个查询，所以我将它封装成一个函数。同时，我还会隐藏信息位的列，并将事务的状态与其 ID 一起显示，以使输出更加简洁。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs text">=&gt; CREATE FUNCTION heap_page(relname text, pageno integer)<br>RETURNS TABLE(ctid tid, state text, xmin text, xmax text)<br>AS $$<br>SELECT (pageno,lp)::text::tid AS ctid,<br>     CASE lp_flags<br>       WHEN 0 THEN &#x27;unused&#x27;<br>       WHEN 1 THEN &#x27;normal&#x27;<br>       WHEN 2 THEN &#x27;redirect to &#x27;||lp_off<br>       WHEN 3 THEN &#x27;dead&#x27;<br>     END AS state,<br>     t_xmin || CASE<br>       WHEN (t_infomask &amp; 256) &gt; 0 THEN &#x27; c&#x27;<br>       WHEN (t_infomask &amp; 512) &gt; 0 THEN &#x27; a&#x27;<br>       ELSE &#x27;&#x27;<br>     END AS xmin,<br>     t_xmax || CASE<br>       WHEN (t_infomask &amp; 1024) &gt; 0 THEN &#x27; c&#x27;<br>       WHEN (t_infomask &amp; 2048) &gt; 0 THEN &#x27; a&#x27;<br>       ELSE &#x27;&#x27;<br>     END AS xmax<br>FROM heap_page_items(get_raw_page(relname,pageno))<br>ORDER BY lp;<br>$$ LANGUAGE sql;<br></code></pre></td></tr></table></figure><p>现在，元组头中发生的事情更加清晰了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-number">0</span>);<br>  ctid <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin <span class="hljs-operator">|</span> xmax<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">776</span>  <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>通过查询 xmin 和 xmax 伪列，你可以从表本身获得类似但不太详细的信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> xmin, xmax, <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t;<br> xmin <span class="hljs-operator">|</span> xmax <span class="hljs-operator">|</span> id <span class="hljs-operator">|</span>  s<br>−−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−<span class="hljs-operator">+</span>−−−−−<br>  <span class="hljs-number">776</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0</span> <span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> FOO<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><h4 id="3-3-2-提交"><a href="#3-3-2-提交" class="headerlink" title="3.3.2 提交"></a>3.3.2 提交</h4><p>一旦事务成功完成，其状态必须以某种方式存储 — 必须记录该事务已提交。为此，PostgreSQL 使用了一种特殊的 CLOG (提交日志) 结构 7。它作为文件存储在 PGDATA&#x2F;pg_xact 目录中，而不是系统表。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">以前，这些文件位于 PGDATA/pg_clog，但在 10 版本中，该目录被重命名了 8：对于不熟悉 PostgreSQL 的数据库管理员来说，认为&quot;日志&quot;是不必要的，因此删除它们以释放可用磁盘空间的情况并不少见。<br></code></pre></td></tr></table></figure><p>CLOG 被划分成多个文件只是为了方便。这些文件通过服务器共享内存中的缓冲区逐页访问 9。</p><p>就像元组头一样，CLOG 用两个位表示每个事务：已提交和已中止。</p><p>一旦提交，事务会在 CLOG 中被标记为 committed。当任何其他事务访问堆页面时，它必须回答以下问题：xmin 事务是否已经完成？</p><pre><code class="hljs">1.如果没有，那么创建的元组一定是不可见的。为了检查事务是否仍处于活跃状态，PostgreSQL 使用了另一个位于实例共享内存中的结构；它被称为 ProcArray。该结构包含所有活动进程的列表，每个进程对应的当前 (活动) 事务也在其中指定。    2. 如果是的，它是已提交还是已中止了？如果是后者，相应的元组也不可见。正是这种检查需要查询 CLOG。尽管最近的 CLOG 页面存储在内存缓冲区中，每次执行这种检查仍然很昂贵。一旦确定，事务状态就被写入到元组头部 — 更具体地说，写入 xmin_committed 和 xmin_aborted 信息位，也被称为提示位。如果设置了这些位中的一个，则认为 xmin 事务状态是已知的，并且下一个事务将不需要再访问 CLOG 或 ProcArray。</code></pre><p>为什么插入这些行的事务没有设置这些提示位？问题在于，当时尚不知道此事务是否会成功完成。并且当事务提交时，已经不清楚哪些元组和页面被更改了。如果一个事务影响了许多页面，那么跟踪它们的成本可能太高。此外，其中一些页面可能已不在缓存中了；再次读取它们仅仅为了更新提示位会严重降低提交的速度。</p><p>这种成本削减的负面影响是任何事务 (甚至是只读 SELECT 命令) 都可以设置提示位，从而在缓冲区缓存中留下脏页的痕迹。</p><p>最后，让我们提交以 INSERT 语句开始的事务：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">=&gt; COMMIT;<br></code></pre></td></tr></table></figure><p>页面中没有任何变化 (但我们知道事务状态已经写入 CLOG)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-number">0</span>);<br>  ctid <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin <span class="hljs-operator">|</span> xmax<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">776</span>  <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>现在，第一个访问页面的事务 (以”标准”方式，不使用 pageinspect) 必须确认 xmin 事务的状态，并更新了提示位：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t;<br> id <span class="hljs-operator">|</span>  s<br>−−−−<span class="hljs-operator">+</span>−−−−−<br>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> FOO<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-number">0</span>);<br>  ctid <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin <span class="hljs-operator">|</span> xmax<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">776</span> c <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><h4 id="3-3-3-删除"><a href="#3-3-3-删除" class="headerlink" title="3.3.3 删除"></a>3.3.3 删除</h4><p>当删除一行时，其当前版本的 xmax 字段被设置为执行删除操作的事务 ID，并且 xmax_aborted 位还未被设置。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">当此事务处于活跃状态时，xmax 值用于行锁。如果另一个事务打算更新或删除这一行，则必须等待，直至 xmax 事务完成。<br></code></pre></td></tr></table></figure><p>让我们删除一行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> t;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_xact_id();<br> pg_current_xact_id<br>−−−−−−−−−−−−−−−−−−−−<br>                <span class="hljs-number">777</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>事务 ID 已写入 xmax 字段，但信息位尚未被设置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">=&gt; SELECT * FROM heap_page(&#x27;t&#x27;,0);<br>  ctid | state  | xmin  | xmax<br>−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−<br> (0,1) | normal | 776 c | 777<br>(1 row)<br></code></pre></td></tr></table></figure><h4 id="3-3-4-中止"><a href="#3-3-4-中止" class="headerlink" title="3.3.4 中止"></a>3.3.4 中止</h4><p>事务中止的机制与提交类似，同样迅速，但它在 CLOG 中设置的是中止位而不是提交位。尽管相应的命令称为 ROLLBACK，但实际上并没有发生数据回滚：数据页中被中止事务所做的所有更改都保持原样。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ROLLBACK</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-number">0</span>);<br> ctid  <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin  <span class="hljs-operator">|</span> xmax<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">776</span> c <span class="hljs-operator">|</span> <span class="hljs-number">777</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>当访问页面时，会检查事务状态，然后元组接收到 xmax_aborted 提示位。xmax 数字本身仍然保留在页面中，但没有人会再关注它：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t;<br> id <span class="hljs-operator">|</span>  s<br>−−−−<span class="hljs-operator">+</span>−−−−−<br>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> FOO<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-number">0</span>);<br>  ctid <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin  <span class="hljs-operator">|</span> xmax<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">776</span> c <span class="hljs-operator">|</span> <span class="hljs-number">777</span> a<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><h4 id="3-3-5-更新"><a href="#3-3-5-更新" class="headerlink" title="3.3.5 更新"></a>3.3.5 更新</h4><p>更新的执行方式就像删除当前元组，然后插入一个新元组：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> t <span class="hljs-keyword">SET</span> s <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;BAR&#x27;</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_xact_id();<br> pg_current_xact_id<br>−−−−−−−−−−−−−−−−−−−−<br>                <span class="hljs-number">778</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>查询返回一行 (其新版本)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t;<br> id <span class="hljs-operator">|</span>  s<br>−−−−<span class="hljs-operator">+</span>−−−−−<br>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> BAR<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>但是页面中保留了两个版本：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-number">0</span>);<br>  ctid <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin  <span class="hljs-operator">|</span> xmax<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">776</span> c <span class="hljs-operator">|</span> <span class="hljs-number">778</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">778</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>之前删除的版本的 xmax 字段包含当前事务 ID。这个值被写入到旧值之上，因为前一个事务被中止了。xmax_aborted 位未被设置，因为当前事务仍然属于未知状态。</p><p>为了完成这个实验，让我们提交事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><h3 id="3-4-Indexes"><a href="#3-4-Indexes" class="headerlink" title="3.4 Indexes"></a><a name="data-Organization"></a>3.4 Indexes</h3><p>不管索引的类型如何，均不使用行版本控制；每行都由一个确切的元组表示。换句话说，索引行头不包含 xmin 和 xmax 字段。索引条目指向相应表行的所有版本。要确定哪个行版本是可见的，事务必须访问表 (除非所需的页面出现在可见性映射中)。</p><p>为方便起见，让我们创建一个简单的函数，该函数使用 pageinspect 显示页面中的所有索引条目 (B 树索引页将它们存储为一个扁平列表)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> index_page(relname text, pageno <span class="hljs-type">integer</span>)<br><span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">TABLE</span>(itemoffset <span class="hljs-type">smallint</span>, htid tid)<br><span class="hljs-keyword">AS</span> $$<br><span class="hljs-keyword">SELECT</span> itemoffset,<br>       htid <span class="hljs-comment">-- ctid before v.13</span><br><span class="hljs-keyword">FROM</span> bt_page_items(relname,pageno);<br>$$ <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">sql</span>;<br></code></pre></td></tr></table></figure><p>页面引用了两个堆元组，当前的和之前的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> index_page(<span class="hljs-string">&#x27;t_s_idx&#x27;</span>,<span class="hljs-number">1</span>);<br> itemoffset <span class="hljs-operator">|</span> htid<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br>          <span class="hljs-number">1</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)<br>          <span class="hljs-number">2</span> <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>由于 BAR &lt; FOO，因此在索引中指向第二个元组的指针排在前面。</p><h3 id="3-5-TOAST"><a href="#3-5-TOAST" class="headerlink" title="3.5 TOAST"></a><a name="data-Organization"></a>3.5 TOAST</h3><p>TOAST 表实际上是一个普通的表，并且它有自己的版本控制，不依赖于主表的行版本。但是，TOAST 表里的行永远不会被更新；要么添加，要么删除，因此其版本控制在某种程度上是人为的。</p><p>每次数据修改都会在主表中创建一条新元组。但是，如果更新不影响存储在 TOAST 中的任何长值，则新元组将引用现有的 TOAST 值。只有当长值被更新时，PostgreSQL 才会在主表中创建一个新元组和新的 “toasts”。</p><h3 id="3-6-Virtual-Transactions"><a href="#3-6-Virtual-Transactions" class="headerlink" title="3.6 Virtual Transactions"></a><a name="data-Organization"></a>3.6 Virtual Transactions</h3><p>为了节约使用事务 ID，PostgreSQL 提供了一种特殊的优化机制。</p><p>如果事务是只读的，它不会以任何方式影响行的可见性。这就是为什么这样一个事务首先被赋予一个虚拟的 XID 10，它由后端进程 ID 和一个序号组成。分配虚拟 XID 不需要不同进程之间的任何同步，所以分配的速度非常快。此时，事务还没有真正的 ID：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-comment">-- txid_current_if_assigned() before v.13</span><br><span class="hljs-keyword">SELECT</span> pg_current_xact_id_if_assigned();<br> pg_current_xact_id_if_assigned<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>在不同的时间点，系统可以包含一些已经使用过的虚拟 XID。这是完全正常的：虚拟 XID 只存在于 RAM 中，并且仅在相应的事务处于活动状态时才存在；虚拟 ID 永远不会写入数据页面，也永远不会存储到磁盘上。</p><p>一旦事务开始修改数据，它便会收到一个真实的唯一 ID：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts<br><span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">-</span> <span class="hljs-number">1.00</span>;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_xact_id_if_assigned();<br> pg_current_xact_id_if_assigned<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br>                            <span class="hljs-number">780</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><h3 id="3-7-Subtransactions"><a href="#3-7-Subtransactions" class="headerlink" title="3.7 Subtransactions"></a><a name="data-Organization"></a>3.7 Subtransactions</h3><h4 id="3-7-1-保存点"><a href="#3-7-1-保存点" class="headerlink" title="3.7.1 保存点"></a>3.7.1 保存点</h4><p>SQL 支持保存点，允许在不中止整个事务的情况下取消事务内的某些操作。但是这样的场景不适合上面描述的操作过程：事务的状态应用到其所有操作，并且不会执行物理数据回滚。</p><p>为了实现这个功能，一个包含保存点的事务被分成若干子事务 11，这样它们的状态就可以分别管理。</p><p>子事务有其自己的 ID (比主事务 ID 大)。子事务的状态以往常的方式写入到 CLOG 中；但是，已提交的子事务会同时接收到已提交和已中止的位。最终决定取决于主事务的状态：如果主事务被中止，那么它所有的子事务也将被视为已中止。</p><p>有关子事务的信息存储在 PGDATA&#x2F;pg_subtrans 目录下。文件访问通过实例共享内存中的缓冲区进行，这些缓冲区的结构与 CLOG 缓冲区 (backend&#x2F;access&#x2F;transam&#x2F;subtrans.c ) 相同。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">不要将子事务与自治事务相混淆。与子事务不同，后者彼此之间完全互不依赖。原生的 PostgreSQL 不支持自治事务，这可能是最好的：它们在极少数情况下才需要，但在其他数据库系统中的可用性往往会引起误用，这可能会导致很多麻烦。<br></code></pre></td></tr></table></figure><p>让我们截断表，开启一个新的事务并插入一行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> t;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> t(s) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;FOO&#x27;</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_xact_id();<br> pg_current_xact_id<br>−−−−−−−−−−−−−−−−−−−−<br>                <span class="hljs-number">782</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>现在创建一个保存点，并插入另一行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SAVEPOINT</span> sp;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> t(s) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;XYZ&#x27;</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_xact_id();<br> pg_current_xact_id<br>−−−−−−−−−−−−−−−−−−−−<br>                <span class="hljs-number">782</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>请注意，pg_current_xact_id 函数返回的是主事务 ID，而不是子事务 ID。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-number">0</span>) p<br>  <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t <span class="hljs-keyword">ON</span> p.ctid <span class="hljs-operator">=</span> t.ctid;<br>  ctid <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin <span class="hljs-operator">|</span> xmax <span class="hljs-operator">|</span> id <span class="hljs-operator">|</span>  s<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−<span class="hljs-operator">+</span>−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">782</span>  <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a  <span class="hljs-operator">|</span>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> FOO<br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">783</span>  <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a  <span class="hljs-operator">|</span>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> XYZ<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>让我们回滚到保存点，并插入第三行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> sp;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> t(s) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;BAR&#x27;</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-number">0</span>) p<br>  <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> t <span class="hljs-keyword">ON</span> p.ctid <span class="hljs-operator">=</span> t.ctid;<br>  ctid <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin <span class="hljs-operator">|</span> xmax <span class="hljs-operator">|</span> id <span class="hljs-operator">|</span>  s<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−<span class="hljs-operator">+</span>−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">782</span>  <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a  <span class="hljs-operator">|</span> <span class="hljs-number">2</span>  <span class="hljs-operator">|</span> FOO<br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">783</span>  <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a  <span class="hljs-operator">|</span>    <span class="hljs-operator">|</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">784</span>  <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a  <span class="hljs-operator">|</span> <span class="hljs-number">4</span>  <span class="hljs-operator">|</span> BAR<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>页面仍然包含由已中止的子事务添加的行。</p><p>提交更改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t;<br> id <span class="hljs-operator">|</span> s<br>−−−−<span class="hljs-operator">+</span>−−−−−<br>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> FOO<br>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> BAR<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-number">0</span>);<br>  ctid <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin  <span class="hljs-operator">|</span> xmax<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">782</span> c <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">783</span> a <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">784</span> c <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>现在我们可以清楚地看到，每个子事务都有其自己的状态。</p><p>SQL 不允许直接使用子事务，也就是说，你不能在完成当前事务之前开始一个新事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br>WARNING: there <span class="hljs-keyword">is</span> already a transaction <span class="hljs-keyword">in</span> progress<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-keyword">COMMIT</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br>WARNING: there <span class="hljs-keyword">is</span> <span class="hljs-keyword">no</span> transaction <span class="hljs-keyword">in</span> progress<br><span class="hljs-keyword">COMMIT</span><br></code></pre></td></tr></table></figure><p>子事务是隐式使用的：为了实现保存点，处理 PL&#x2F;pgSQL 中的异常，以及一些其他更罕见的情况。</p><h4 id="3-7-2-错误与原子性"><a href="#3-7-2-错误与原子性" class="headerlink" title="3.7.2 错误与原子性"></a>3.7.2 错误与原子性</h4><p>在执行语句期间，如果出现了错误会发生什么？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t;<br> id <span class="hljs-operator">|</span>  s<br>−−−−<span class="hljs-operator">+</span>−−−−−<br>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> FOO<br>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> BAR<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> t <span class="hljs-keyword">SET</span> s <span class="hljs-operator">=</span> repeat(<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-number">1</span><span class="hljs-operator">/</span>(id<span class="hljs-number">-4</span>));<br>ERROR: division <span class="hljs-keyword">by</span> zero<br></code></pre></td></tr></table></figure><p>失败后，整个事务将被视为已中止，并且无法执行任何进一步的操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t;<br>ERROR: <span class="hljs-keyword">current</span> transaction <span class="hljs-keyword">is</span> aborted, commands ignored until <span class="hljs-keyword">end</span> <span class="hljs-keyword">of</span> transaction block<br></code></pre></td></tr></table></figure><p>并且即使你尝试提交更改，PostgreSQL 也会提示事务已回滚：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-keyword">ROLLBACK</span><br></code></pre></td></tr></table></figure><p>为什么在失败之后禁止继续执行事务？因为已执行的操作永远不会回滚，我们将能够访问在错误之前所做的一些更改 — 这将打破语句的原子性，从而破坏事务本身的原子性。</p><p>例如，在我们的实验中，操作符在失败之前，已经成功更新了两行中的一行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-number">0</span>);<br>  ctid <span class="hljs-operator">|</span> state  <span class="hljs-operator">|</span> xmin  <span class="hljs-operator">|</span> xmax<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<span class="hljs-operator">+</span>−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">782</span> c <span class="hljs-operator">|</span> <span class="hljs-number">785</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">783</span> a <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">784</span> c <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br> (<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) <span class="hljs-operator">|</span> normal <span class="hljs-operator">|</span> <span class="hljs-number">785</span> <span class="hljs-operator">|</span> <span class="hljs-number">0</span> a<br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>顺带说明一下，psql 提供了一种特殊模式，允许在失败后继续执行事务，就好像错误的语句已经回滚了一样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> \<span class="hljs-keyword">set</span> ON_ERROR_ROLLBACK <span class="hljs-keyword">on</span><br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> t <span class="hljs-keyword">SET</span> s <span class="hljs-operator">=</span> repeat(<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-number">1</span><span class="hljs-operator">/</span>(id<span class="hljs-number">-4</span>));<br>ERROR: division <span class="hljs-keyword">by</span> zero<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t;<br> id <span class="hljs-operator">|</span>  s<br>−−−−<span class="hljs-operator">+</span>−−−−−<br>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> FOO<br>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> BAR<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-keyword">COMMIT</span><br></code></pre></td></tr></table></figure><p>如你所料，psql 在此模式下运行时，会在每个命令之前隐式添加一个保存点；如果发生错误，则会执行回滚。默认情况下不会使用此模式，因为执行保存点 (即使它们没有被回滚) 会产生大量开销。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch29. BRIN</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch29/ch29/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch29/ch29/</url>
    
    <content type="html"><![CDATA[<h2 id="ch29-BRIN"><a href="#ch29-BRIN" class="headerlink" title="ch29. BRIN"></a>ch29. BRIN</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">29.1 Overview</a></td></tr><tr><td><a href="#cp2">29.2 Example</a></td></tr><tr><td><a href="#cp3">29.3 Page Layout</a></td></tr><tr><td><a href="#cp4">29.4 Search</a></td></tr><tr><td><a href="#cp5">29.5 Summary Information Updates</a></td></tr><tr><td><a href="#cp6">29.6 Minmax Classes</a></td></tr><tr><td><a href="#cp7">29.7 Minmax-Multi Classes</a></td></tr><tr><td><a href="#cp8">29.8 Inclusion Classes</a></td></tr><tr><td><a href="#cp9">29.9 Bloom Classes</a></td></tr></tbody></table><h3 id="29-1-Overview"><a href="#29-1-Overview" class="headerlink" title="29.1 Overview"></a><a name="cp1"></a>29.1 Overview</h3><h3 id="29-2-Example"><a href="#29-2-Example" class="headerlink" title="29.2 Example"></a><a name="cp2"></a>29.2 Example</h3><h3 id="29-3-Page-Layout"><a href="#29-3-Page-Layout" class="headerlink" title="29.3 Page Layout"></a><a name="cp3"></a>29.3 Page Layout</h3><h3 id="29-4-Search"><a href="#29-4-Search" class="headerlink" title="29.4 Search"></a><a name="cp4"></a>29.4 Search</h3><h3 id="29-5-Summary-Information-Updates"><a href="#29-5-Summary-Information-Updates" class="headerlink" title="29.5 Summary Information Updates"></a><a name="cp5"></a>29.5 Summary Information Updates</h3><h3 id="29-6-Minmax-Classes"><a href="#29-6-Minmax-Classes" class="headerlink" title="29.6 Minmax Classes"></a><a name="cp6"></a>29.6 Minmax Classes</h3><h3 id="29-7-Minmax-Multi-Classes"><a href="#29-7-Minmax-Multi-Classes" class="headerlink" title="29.7 Minmax-Multi Classes"></a><a name="cp6"></a>29.7 Minmax-Multi Classes</h3><h3 id="29-8-Inclusion-Classes"><a href="#29-8-Inclusion-Classes" class="headerlink" title="29.8 Inclusion Classes"></a><a name="cp6"></a>29.8 Inclusion Classes</h3><h3 id="29-9-Bloom-Classes"><a href="#29-9-Bloom-Classes" class="headerlink" title="29.9 Bloom Classes"></a><a name="cp6"></a>29.9 Bloom Classes</h3>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch28. GIN</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch28/ch28/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch28/ch28/</url>
    
    <content type="html"><![CDATA[<h2 id="ch28-GIN"><a href="#ch28-GIN" class="headerlink" title="ch28. GIN"></a>ch28. GIN</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">28.1 Overview</a></td></tr><tr><td><a href="#cp2">28.2 Index for Full-Text Search</a></td></tr><tr><td><a href="#cp3">28.3 Trigrams</a></td></tr><tr><td><a href="#cp4">28.4 Indexing Arrays</a></td></tr><tr><td><a href="#cp5">28.5 Indexing JSON</a></td></tr><tr><td><a href="#cp6">28.6 Indexing Other Data Types</a></td></tr></tbody></table><h3 id="28-1-Overview"><a href="#28-1-Overview" class="headerlink" title="28.1 Overview"></a><a name="cp1"></a>28.1 Overview</h3><h3 id="28-2-Index-for-Full-Text-Search"><a href="#28-2-Index-for-Full-Text-Search" class="headerlink" title="28.2 Index for Full-Text Search"></a><a name="cp2"></a>28.2 Index for Full-Text Search</h3><h3 id="28-3-Trigrams"><a href="#28-3-Trigrams" class="headerlink" title="28.3 Trigrams"></a><a name="cp3"></a>28.3 Trigrams</h3><h3 id="28-4-Indexing-Arrays"><a href="#28-4-Indexing-Arrays" class="headerlink" title="28.4 Indexing Arrays"></a><a name="cp4"></a>28.4 Indexing Arrays</h3><h3 id="28-5-Indexing-JSON"><a href="#28-5-Indexing-JSON" class="headerlink" title="28.5 Indexing JSON"></a><a name="cp5"></a>28.5 Indexing JSON</h3><h3 id="28-6-Indexing-Other-Data-Types"><a href="#28-6-Indexing-Other-Data-Types" class="headerlink" title="28.6 Indexing Other Data Types"></a><a name="cp6"></a>28.6 Indexing Other Data Types</h3>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch27. SP-GiST</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch27/ch27/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch27/ch27/</url>
    
    <content type="html"><![CDATA[<h2 id="ch27-SP-GiST"><a href="#ch27-SP-GiST" class="headerlink" title="ch27. SP-GiST"></a>ch27. SP-GiST</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">27.1 Overview</a></td></tr><tr><td><a href="#cp2">27.2 Quadtrees for Points</a></td></tr><tr><td><a href="#cp3">27.3 K-Dimensional Trees for Points</a></td></tr><tr><td><a href="#cp4">27.4 Radix Trees for Strings</a></td></tr><tr><td><a href="#cp5">27.5 Other Data Types</a></td></tr></tbody></table><h3 id="27-1-Overview"><a href="#27-1-Overview" class="headerlink" title="27.1 Overview"></a><a name="cp1"></a>27.1 Overview</h3><h3 id="27-2-Quadtrees-for-Points"><a href="#27-2-Quadtrees-for-Points" class="headerlink" title="27.2 Quadtrees for Points"></a><a name="cp2"></a>27.2 Quadtrees for Points</h3><h3 id="27-3-K-Dimensional-Trees-for-Points"><a href="#27-3-K-Dimensional-Trees-for-Points" class="headerlink" title="27.3 K-Dimensional Trees for Points"></a><a name="cp3"></a>27.3 K-Dimensional Trees for Points</h3><h3 id="27-4-Radix-Trees-for-Strings"><a href="#27-4-Radix-Trees-for-Strings" class="headerlink" title="27.4 Radix Trees for Strings"></a><a name="cp4"></a>27.4 Radix Trees for Strings</h3><h3 id="27-5-Other-Data-Types"><a href="#27-5-Other-Data-Types" class="headerlink" title="27.5 Other Data Types"></a><a name="cp5"></a>27.5 Other Data Types</h3>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch26. GiST</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch26/ch26/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch26/ch26/</url>
    
    <content type="html"><![CDATA[<h2 id="ch26-GiST"><a href="#ch26-GiST" class="headerlink" title="ch26. GiST"></a>ch26. GiST</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">26.1 Overview</a></td></tr><tr><td><a href="#cp2">26.2 R-Trees for Points</a></td></tr><tr><td><a href="#cp3">26.3 RD-Trees for Full-Text Search</a></td></tr><tr><td><a href="#cp4">26.4 Other Data Types</a></td></tr></tbody></table><h3 id="26-1-Overview"><a href="#26-1-Overview" class="headerlink" title="26.1 Overview"></a><a name="cp1"></a>26.1 Overview</h3><h3 id="26-2-R-Trees-for-Points"><a href="#26-2-R-Trees-for-Points" class="headerlink" title="26.2 R-Trees for Points"></a><a name="cp2"></a>26.2 R-Trees for Points</h3><h3 id="26-3-RD-Trees-for-Full-Text-Search"><a href="#26-3-RD-Trees-for-Full-Text-Search" class="headerlink" title="26.3 RD-Trees for Full-Text Search"></a><a name="cp3"></a>26.3 RD-Trees for Full-Text Search</h3><h3 id="26-4-Other-Data-Types"><a href="#26-4-Other-Data-Types" class="headerlink" title="26.4 Other Data Types"></a><a name="cp4"></a>26.4 Other Data Types</h3>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch25. B-tree</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch25/ch25/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch25/ch25/</url>
    
    <content type="html"><![CDATA[<h2 id="ch25-B-tree"><a href="#ch25-B-tree" class="headerlink" title="ch25. B-tree"></a>ch25. B-tree</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">25.1 Overview</a></td></tr><tr><td><a href="#cp2">25.2 Search and Insertions</a></td></tr><tr><td><a href="#cp3">25.3 Page Layout</a></td></tr><tr><td><a href="#cp4">25.4 Operator Class</a></td></tr><tr><td><a href="#cp5">25.5 Properties</a></td></tr></tbody></table><h3 id="25-1-Overview"><a href="#25-1-Overview" class="headerlink" title="25.1 Overview"></a><a name="cp1"></a>25.1 Overview</h3><h3 id="25-2-Search-and-Insertions"><a href="#25-2-Search-and-Insertions" class="headerlink" title="25.2 Search and Insertions"></a><a name="cp2"></a>25.2 Search and Insertions</h3><h3 id="25-3-Page-Layout"><a href="#25-3-Page-Layout" class="headerlink" title="25.3 Page Layout"></a><a name="cp3"></a>25.3 Page Layout</h3><h3 id="25-4-Operator-Class"><a href="#25-4-Operator-Class" class="headerlink" title="25.4 Operator Class"></a><a name="cp4"></a>25.4 Operator Class</h3><h3 id="25-5-Properties"><a href="#25-5-Properties" class="headerlink" title="25.5 Properties"></a><a name="cp5"></a>25.5 Properties</h3>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch24. Hash</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch24/ch24/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch24/ch24/</url>
    
    <content type="html"><![CDATA[<h2 id="ch24-Hash"><a href="#ch24-Hash" class="headerlink" title="ch24. Hash"></a>ch24. Hash</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">24.1 Overview</a></td></tr><tr><td><a href="#cp2">24.2 Page Layout</a></td></tr><tr><td><a href="#cp3">24.3 Operator Class</a></td></tr><tr><td><a href="#cp4">24.4 Properties</a></td></tr></tbody></table><h3 id="24-1-Overview"><a href="#24-1-Overview" class="headerlink" title="24.1 Overview"></a><a name="cp1"></a>24.1 Overview</h3><h3 id="24-2-Page-Layout"><a href="#24-2-Page-Layout" class="headerlink" title="24.2 Page Layout"></a><a name="cp2"></a>24.2 Page Layout</h3><h3 id="24-3-Operator-Class"><a href="#24-3-Operator-Class" class="headerlink" title="24.3 Operator Class"></a><a name="cp3"></a>24.3 Operator Class</h3><h3 id="24-4-Properties"><a href="#24-4-Properties" class="headerlink" title="24.4 Properties"></a><a name="cp4"></a>24.4 Properties</h3>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch23. Sorting and Merging</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch23/ch23/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch23/ch23/</url>
    
    <content type="html"><![CDATA[<h2 id="ch23-Sorting-and-Merging"><a href="#ch23-Sorting-and-Merging" class="headerlink" title="ch23. Sorting and Merging"></a>ch23. Sorting and Merging</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">23.1 Merge Joins</a></td></tr><tr><td><a href="#cp2">23.2 Sorting</a></td></tr><tr><td><a href="#cp3">23.3 Distinct Values and Grouping</a></td></tr><tr><td><a href="#cp4">23.4 Comparison of Join Methods</a></td></tr></tbody></table><h3 id="23-1-Merge-Joins"><a href="#23-1-Merge-Joins" class="headerlink" title="23.1 Merge Joins"></a><a name="cp1"></a>23.1 Merge Joins</h3><h3 id="23-2-Sorting"><a href="#23-2-Sorting" class="headerlink" title="23.2 Sorting"></a><a name="cp2"></a>23.2 Sorting</h3><h3 id="23-3-Distinct-Values-and-Grouping"><a href="#23-3-Distinct-Values-and-Grouping" class="headerlink" title="23.3 Distinct Values and Grouping"></a><a name="cp3"></a>23.3 Distinct Values and Grouping</h3><h3 id="23-4-Comparison-of-Join-Methods"><a href="#23-4-Comparison-of-Join-Methods" class="headerlink" title="23.4 Comparison of Join Methods"></a><a name="cp4"></a>23.4 Comparison of Join Methods</h3>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch21. Nested Loop</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch21/ch21/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch21/ch21/</url>
    
    <content type="html"><![CDATA[<h2 id="ch21-Nested-Loop"><a href="#ch21-Nested-Loop" class="headerlink" title="ch21. Nested Loop"></a>ch21. Nested Loop</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">21.1 Join Types and Methods</a></td></tr><tr><td><a href="#cp2">21.2 Nested Loop Joins</a></td></tr></tbody></table><h3 id="21-1-Join-Types-and-Methods"><a href="#21-1-Join-Types-and-Methods" class="headerlink" title="21.1 Join Types and Methods"></a><a name="cp1"></a>21.1 Join Types and Methods</h3><h3 id="21-2-Nested-Loop-Joins"><a href="#21-2-Nested-Loop-Joins" class="headerlink" title="21.2 Nested Loop Joins"></a><a name="cp2"></a>21.2 Nested Loop Joins</h3>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch22. Hashing</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch22/ch22/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch22/ch22/</url>
    
    <content type="html"><![CDATA[<h2 id="ch22-Hashing"><a href="#ch22-Hashing" class="headerlink" title="ch22. Hashing"></a>ch22. Hashing</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">22.1 Hash Joins</a></td></tr><tr><td><a href="#cp2">22.2 Distinct Values and Grouping</a></td></tr></tbody></table><h3 id="22-1-Join-Types-and-Methods"><a href="#22-1-Join-Types-and-Methods" class="headerlink" title="22.1 Join Types and Methods"></a><a name="cp1"></a>22.1 Join Types and Methods</h3><h3 id="22-2-Nested-Loop-Joins"><a href="#22-2-Nested-Loop-Joins" class="headerlink" title="22.2 Nested Loop Joins"></a><a name="cp2"></a>22.2 Nested Loop Joins</h3>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch20. Index Scans</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch20/ch20/</url>
    
    <content type="html"><![CDATA[<h2 id="ch20-Index-Scans"><a href="#ch20-Index-Scans" class="headerlink" title="ch20. Index Scans"></a>ch20. Index Scans</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">20.1 Regular Index Scans</a></td></tr><tr><td><a href="#cp2">20.2 Index-Only Scans</a></td></tr><tr><td><a href="#cp3">20.3 Bitmap Scans</a></td></tr><tr><td><a href="#cp4">20.4 Parallel Index Scans</a></td></tr><tr><td><a href="#cp5">20.5 Comparison of Various Access Methods</a></td></tr></tbody></table><h3 id="20-1-Regular-Index-Scans"><a href="#20-1-Regular-Index-Scans" class="headerlink" title="20.1 Regular Index Scans"></a><a name="cp1"></a>20.1 Regular Index Scans</h3><h3 id="20-2-Index-Only-Scans"><a href="#20-2-Index-Only-Scans" class="headerlink" title="20.2 Index-Only Scans"></a><a name="cp2"></a>20.2 Index-Only Scans</h3><h3 id="20-3-Bitmap-Scans"><a href="#20-3-Bitmap-Scans" class="headerlink" title="20.3 Bitmap Scans"></a><a name="cp3"></a>20.3 Bitmap Scans</h3><h3 id="20-4-Parallel-Index-Scans"><a href="#20-4-Parallel-Index-Scans" class="headerlink" title="20.4 Parallel Index Scans"></a><a name="cp4"></a>20.4 Parallel Index Scans</h3><h3 id="20-5-Comparison-of-Various-Access-Methods"><a href="#20-5-Comparison-of-Various-Access-Methods" class="headerlink" title="20.5 Comparison of Various Access Methods"></a><a name="cp5"></a>20.5 Comparison of Various Access Methods</h3>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch2. Isolation</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch2/ch2/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch2/ch2/</url>
    
    <content type="html"><![CDATA[<h2 id="ch2-Isolation"><a href="#ch2-Isolation" class="headerlink" title="ch2. Isolation"></a>ch2. Isolation</h2><p>隔离性</p><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#Consistency">2.1 Consistency</a></td></tr><tr><td><a href="#isolation-sql">2.2 Isolation Levels and Anomalies in SQL Standard</a></td></tr><tr><td><a href="#isolation-pg">2.3 Isolation Levels in PostgreSQL</a></td></tr><tr><td><a href="#isolation-use">2.4 Which Isolation Level to Use?</a></td></tr></tbody></table><h3 id="2-1-Consistency"><a href="#2-1-Consistency" class="headerlink" title="2.1 Consistency"></a><a name="Consistency"></a>2.1 Consistency</h3><p>一致性</p><p>关系型数据库的关键特征是它们能够保证数据的一致性，即数据的正确性。</p><p>众所周知，在数据库层面可以创建完整性约束，例如 NOT NULL 或 UNIQUE。数据库系统确保这些约束永远不会被破坏，从而保证数据的完整性。</p><p>如果所有需要的约束都能在数据库层面上制定，那么一致性就能得到保证。但有些条件过于复杂，无法通过数据库层面的约束来实现，例如，它们可能一次涉及多个表。而且即使某个约束可以在数据库中定义，但由于某些原因没有被定义，也并不意味着这个约束条件可以被违反。</p><p>因此，数据的一致性比完整性更严格，但是数据库系统并不清楚”一致性”实际上意味着什么。如果应用程序在不破坏完整性的情况下破坏了一致性，那么数据库系统是没有办法发现的。因此，必须由应用程序来制定数据一致性的标准，而且我们必须相信它编写得正确，且永远不会有任何错误。</p><p>但是，如果应用程序始终只执行正确的操作符序列，那么数据库系统的作用何在呢？</p><p>首先，正确的操作符序列可以暂时破坏数据一致性，并且 — 虽然这听起来可能很奇怪 — 这是完全正常的。</p><p>一个老套但浅显易懂的例子是将资金从一个账户转移到另一个账户。一致性规则可能是这样的：资金转移绝不能改变受影响账户的总余额。将此规则表述为 SQL 中的完整性约束是相当困难的 (尽管可能)，因此让我们假设它是在应用程序层面定义的，并且对数据库系统保持不透明。转账包括两个操作：第一个操作从其中一个账户中提取一些钱，而第二个操作将这笔钱添加到另一个账户。第一个操作破坏了数据的一致性，但第二个操作恢复了一致性。</p><p>如果第一个操作成功了，但第二个操作失败了 (因为一些故障)，数据一致性将被打破。这种情况是无法接受的，但是在应用程序层面检测和解决它们需要付出很大的努力。幸运的是，这并不是必要的 — 如果数据库系统知道这两个操作构成一个不可分割的整体，即一个事务，那么这个问题完全可以由数据库系统本身解决。</p><p>但这里还有一个更微妙的方面。事务本身是绝对正确的，但当并行运行时，事务可能会开始不正确地运行。这是因为属于不同事务的操作经常会被混合在一起。如果数据库系统先完成一个事务的所有操作，然后再进行下一个事务，就不会出现此类问题，但顺序执行的性能会低得令人难以置信。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">真正的事务同时执行只能在具有适当硬件的系统上实现：多核处理器、磁盘阵列等。但同样的推断也适用于以分时模式顺序执行命令的服务器。为了概括起见，这两种情况有时统称为并发执行。<br></code></pre></td></tr></table></figure><p>正确的事务在一起运行时表现异常会导致并发异常，或称为并发现象。</p><p>此处是一个简单的例子。为了从数据库中获取一致的数据，应用程序至少不能看到其他未提交事务所做的任何更改。否则 (如果某些事务回滚)，它将看到从未存在过的数据库状态。这种异常称为脏读，还有很多其他更为复杂的异常。</p><p>当并发运行事务时，数据库必须保证这种执行的结果与某种可能的顺序执行结果相同。换句话说，它必须将事务彼此隔离，从而处理任何可能的异常。</p><p>总而言之，事务是一组将数据库从一个正确状态转变到另一个正确状态 (一致性) 的操作，前提是它完全执行 (原子性) 并且不受其他事务的影响 (隔离性)。这个定义结合了 ACID 首字母缩写中前三个字母所暗示的要求。它们交织在一起，一起讨论它们是有意义的。事实上，持久性要求也几乎不可能分开：在系统崩溃之后，系统中可能仍然包含一些由未提交事务所做的更改，你必须采取措施来恢复数据的一致性。</p><p>因此，即使数据库系统对隐含的一致性规则一无所知，它也通过考虑事务边界来帮助应用程序维护数据一致性。</p><p>不幸的是，完全隔离很难实现，并且会对性能产生负面影响。大多数实际系统使用较弱的隔离级别，这可以防止一些异常，但并非全部。这意味着维护数据一致性的部分工作落在了应用程序上。这也正是为什么了解系统中使用的隔离级别非常重要的原因，以及在这个级别下保证了什么、没有保证什么，以及如何确保在这种条件下代码是正确的。</p><h3 id="2-2-Isolation-Levels-and-Anomalies-in-SQL-Standard"><a href="#2-2-Isolation-Levels-and-Anomalies-in-SQL-Standard" class="headerlink" title="2.2 Isolation Levels and Anomalies in SQL Standard"></a><a name="isolation-sql"></a>2.2 Isolation Levels and Anomalies in SQL Standard</h3><p>SQL 标准中的隔离级别与异常</p><h4 id="2-2-1-更新丢失"><a href="#2-2-1-更新丢失" class="headerlink" title="2.2.1 更新丢失"></a>2.2.1 更新丢失</h4><p>当两个事务读取同一行表数据，然后其中一个事务更新该行，最后另一个事务在不考虑第一个事务所做的任何更改的情况下更新同一行时，就会发生更新丢失异常。</p><p>假设有两个事务打算使同一账户的余额增加 100 美元。第一个事务读取了当前值 ($100)，然后第二个事务读取了相同的值。第一个事务增加了余额 (使余额变为 1100 美元)，并将新值写入数据库中。第二个事务也是如此：在增加余额后获得 1100 美元，并写入该值。结果，客户损失了 100 美元。</p><p>在所有隔离级别下，SQL 标准都禁止更新丢失。</p><h4 id="2-2-2-脏读与读未提交"><a href="#2-2-2-脏读与读未提交" class="headerlink" title="2.2.2 脏读与读未提交"></a>2.2.2 脏读与读未提交</h4><p>当一个事务读取了另一个事务所做的未提交的更改时，就会发生脏读异常。</p><p>例如，第一个事务将 100 美元转移到一个空账户，但没有提交此更改。另一个事务读取了帐户的状态 (已被更新但还未提交)，并允许客户提取这笔钱 — 即使第一个事务中断并且其更改被回滚，所以帐户其实是空的。</p><p>SQL 标准允许在读未提交隔离级别下发生脏读。</p><h4 id="2-2-3-不可重复读与读已提交"><a href="#2-2-3-不可重复读与读已提交" class="headerlink" title="2.2.3 不可重复读与读已提交"></a>2.2.3 不可重复读与读已提交</h4><p>当一个事务两次读取同一行数据，而在这两次读取之间，另一个事务更新 (或删除) 了这一行并提交了更改时，就会发生不可重复读异常。最终，第一个事务得到了不同的结果。</p><p>例如，假设有一条一致性规则，禁止银行账户中出现负余额。第一个事务准备使账户余额减少 100 美元。它检查当前值，得到 1000 美元，因此认定此操作是可行的。同时，另一个事务从该账户中取出了所有钱并提交更改。如果第一个事务在此时再次检查余额，它会得到 0 美元 (但取钱的决定已经做出，那么这个操作会导致透支)。</p><p>SQL 标准允许在读未提交和读已提交隔离级别下发生不可重复读。</p><h4 id="2-2-4-幻读与可重复读"><a href="#2-2-4-幻读与可重复读" class="headerlink" title="2.2.4 幻读与可重复读"></a>2.2.4 幻读与可重复读</h4><p>当同一个事务执行两次相同的查询，返回一组满足特定条件的行，而在这两次查询期间，另一个事务添加了一些满足此条件的其他行，并提交了此更改，就会出现幻读异常。最终，第一个事务获得了两组不同的行。</p><p>例如，假设有一个一致性规则，禁止客户拥有三个以上的帐户。第一个事务打算开一个新帐户，因此它检查当前有多少个帐户可用 (假设有两个)，并认定此操作是可行的。此时，第二个事务也为该客户开了一个新帐户并提交了更改。如果第一个事务再次检查打开的账户数量，它会得到三个 (但它已经在开另一个账户，客户最终拥有了四个账户)。</p><p>SQL 标准允许在读未提交、读已提交和可重复读隔离级别下发生幻读。</p><h4 id="2-2-5-无异常与可串行化"><a href="#2-2-5-无异常与可串行化" class="headerlink" title="2.2.5 无异常与可串行化"></a>2.2.5 无异常与可串行化</h4><p>SQL 标准还定义了可串行化隔离级别，该级别不允许任何异常。这与禁止更新丢失、脏读、不可重复读和幻读不同。事实上，已知异常的数量远远超过标准定义的数量，还有未知数量的未知异常。</p><p>可串行化隔离级别必须防止任何异常。这意味着应用程序开发人员不必考虑隔离问题。如果事务在单独运行时执行正确的操作符序列，那么并发执行也不能破坏数据的一致性。</p><p>为了阐述这个概念，我将使用标准中提供的一个众所周知的表格；为清晰起见，此处还添加了最后一列：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch2/ch2/img.png" alt="img.png"></p><h4 id="2-2-6-为什么是这些异常？"><a href="#2-2-6-为什么是这些异常？" class="headerlink" title="2.2.6 为什么是这些异常？"></a>2.2.6 为什么是这些异常？</h4><p>为什么标准只提到了某些可能的异常，而且为什么是这些异常呢？</p><p>似乎没有人确切知道。但很有可能是在制定最初版本的标准时，其他异常没有被考虑进去，<strong>因为那时理论远远落后于实践。</strong></p><p>此外，当时的假设是隔离必须基于锁。广泛使用的两阶段锁定协议 (2PL) 要求事务在执行期间锁定受影响的行，并在完成时释放锁。简单来说，事务获取的锁越多，它与其他事务的隔离程度就越好。相应地，系统的性能就越差，因为事务开始排队访问同一行，而不是并发运行。</p><p><strong>我相信，在很大程度上，标准隔离级别之间的区别是由实现它们所需的锁数量来定义的。</strong></p><p>如果要更新的行对写入锁定但对读取不锁定，我们便会得到读未提交隔离级别，允许在提交前读取数据。</p><p>如果要更新的行对读取和写入都锁定，我们便会得到读已提交隔离级别：禁止读取未提交的数据，但如果查询多次运行，可能返回不同的值 (不可重复读)。</p><p>在所有操作中锁定要读取和更新的行，我们便会得到可重复读隔离级别：重复查询将返回相同的结果。</p><p>然而，可串行化隔离级别带来了一个问题：无法锁定尚不存在的行。这为幻读的发生留下了可能性：一个事务可以添加满足先前查询条件的行，并且这一行将出现在下一个查询结果中。</p><p>因此，常规的锁无法提供完全隔离：要实现这一点，我们必须锁定条件 (谓词) 而不是行。谓词锁早在 1976 年 System R 开发时就被引入了；然而，它们的实际适用范围有限，只适用于那些很容易判断两个不同谓词是否可能冲突的简单条件。据我所知，在任何系统中从未实现过预期形式的谓词锁。</p><h3 id="2-3-Isolation-Levels-in-PostgreSQL"><a href="#2-3-Isolation-Levels-in-PostgreSQL" class="headerlink" title="2.3 Isolation Levels in PostgreSQL"></a><a name="isolation-pg"></a>2.3 Isolation Levels in PostgreSQL</h3><p>PostgreSQL 中的隔离级别</p><p>随着时间的推移，基于锁的事务管理协议被快照隔离 (SI) 协议所取代。这种方法的思想是，每个事务访问的是在特定时间点呈现的数据一致性快照。这个快照包括在快照生成之前提交的所有当前更改。</p><p>快照隔离最大限度地减少了所需的锁数量。实际上，只有在尝试并发更新时，行才会被锁定。在所有其他情况下，操作均可以并发执行：写操作不会锁定读操作，读操作也永远不会锁定任何东西。</p><p>PostgreSQL 使用了 SI 协议的多版本形式。多版本并发控制意味着，在任何时候数据库系统都可以包含同一行的多个版本，因此 PostgreSQL 可以将适当的版本包含在快照中，而不是中止尝试读取老版本数据的事务。</p><p>基于快照，PostgreSQL 的隔离级别与标准中指定的要求有所不同 — 实际上，它甚至更加严格。脏读从设计上是禁止的。技术上，你可以指定读未提交级别，但其行为与读已提交相同，因此我将不再提及这个级别。可重复读既不允许不可重复读，也不允许幻读 (尽管它不保证完全隔离)。但在某些情况下，读已提交隔离级别存在更新丢失的风险。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch2/ch2/img_1.png" alt="img_1.png"></p><p>在探讨隔离的内部机制之前，让我们从用户的角度分别讨论这三个隔离级别。</p><p>为此，我们将创建一个账户表；Alice 和 Bob 分别拥有 1000 美元，但 Bob 拥有两个账户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE TABLE</span> accounts(<br>  id <span class="hljs-type">integer</span> <span class="hljs-keyword">PRIMARY KEY</span> GENERATED <span class="hljs-keyword">BY</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">AS</span> <span class="hljs-keyword">IDENTITY</span>,<br>  client text,<br>  amount <span class="hljs-type">numeric</span><br>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> accounts <span class="hljs-keyword">VALUES</span><br>  (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-number">1000.00</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-number">100.00</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-number">900.00</span>);<br></code></pre></td></tr></table></figure><h4 id="2-3-1-读已提交"><a href="#2-3-1-读已提交" class="headerlink" title="2.3.1 读已提交"></a>2.3.1 读已提交</h4><p><strong>不会脏读。</strong> 很容易验证无法读取脏数据。让我们开启一个事务。默认情况下，它使用读已提交 2 隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> transaction_isolation;<br> transaction_isolation<br>−−−−−−−−−−−−−−−−−−−−−−−<br> read committed<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>更确切地说，默认级别由以下参数设置，可以按需修改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> default_transaction_isolation;<br> default_transaction_isolation<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> read committed<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>在第二个会话中，我们启动另一个事务，此事务也在读已提交级别下运行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;alice&#x27;</span>;<br> id <span class="hljs-operator">|</span> client <span class="hljs-operator">|</span> amount<br>−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<br>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> alice  <span class="hljs-operator">|</span> <span class="hljs-number">1000.00</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>可以预见的是，第二个事务看不到任何未提交的更改 — 因为脏读是被禁止的。</p><p><strong>不可重复读。</strong> 现在提交第一个事务的更改。然后第二个事务执行相同的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br>    <br>    <span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;alice&#x27;</span>;<br>     id <span class="hljs-operator">|</span> client <span class="hljs-operator">|</span> amount<br>    −−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<br>      <span class="hljs-number">1</span> <span class="hljs-operator">|</span> alice  <span class="hljs-operator">|</span> <span class="hljs-number">800.00</span><br>    (<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br>    <span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>查询接收到的是更新后的数据版本 — 这正是在读已提交级别下允许的不可重复读异常。</p><p><strong>一个实用的见解是：在事务中，你不能基于之前操作符读取的数据做出任何决策，因为中间的一切都可能发生变化。这里有一个例子，其变体经常出现在应用程序代码中，可以被认为是一个经典的反模式：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">IF (<span class="hljs-keyword">SELECT</span> amount <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">THEN</span><br>  <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">-</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">END</span> IF;<br></code></pre></td></tr></table></figure><p>在检查和更新期间，其他事务可以随意改变账户的状态，因此这样的”检查”是毫无作用的。为了更好地理解，你可以想象其他事务的随机操作符被”楔入”到当前事务的操作符之间。例如，像这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">IF (<span class="hljs-keyword">SELECT</span> amount <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">THEN</span><br><br><span class="hljs-operator">|</span>   <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">-</span> <span class="hljs-number">200</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-operator">|</span>   <span class="hljs-keyword">COMMIT</span>;<br><br>  <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">-</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">END</span> IF;<br></code></pre></td></tr></table></figure><p>**你该如何修正此代码？**有几个选项：</p><p>(1) 使用声明式代码替换过程式代码。</p><p>例如，在这个特定案例中，很容易将 IF 语句转换为 CHECK 约束：</p><p>ALTER TABLE accounts ADD CHECK amount &gt;&#x3D; 0;</p><p>现在你不需要在代码中进行任何检查：只需简单地运行命令，并处理在尝试违反完整性约束时引发的异常就足够了。</p><p>(2) 使用单个 SQL 操作符。</p><p>如果一个事务在另一个事务的操作符之间的时间间隙内提交，那么数据一致性可能会受到影响，从而改变数据的可见性。如果只有一个操作符，则不存在这样的间隙。</p><p>PostgreSQL 有足够的能力用单个 SQL 语句解决复杂的任务。特别是，它提供了可以包含诸如 INSERT、UPDATE、DELETE 此类操作符的通用表达式 (CTE)，以及实现以下逻辑的 INSERT ON CONFLICT 操作符：如果行不存在，则插入；否则执行更新。</p><p>(3) 使用显式锁定。</p><p>最后的手段是手动对所有需要的行 (SELECT FOR UPDATE) 甚至整个表 (LOCK TABLE) 设置排它锁。这种方法总是有效的，但它使 MVCC 的所有优势都失效了：一些本可以并发执行的操作将顺序执行。</p><p><strong>读偏序。</strong> 然而，事情并非总是那么简单。PostgreSQL 的实现方式允许一些其他鲜为人知的异常，这些异常并不受标准约束。</p><p>假设第一个事务已经开始在 Bob 的账户之间转移资金：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">-</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>与此同时，另一个事务开始遍历 Bob 所有的账户以计算它们的总余额。它从第一个帐户开始 (当然，查看的是它之前的状态)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> amount <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br> amount<br>−−−−−−−−<br> <span class="hljs-number">100.00</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>此时，第一个事务成功完成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>第二个事务读取第二个账户的状态 (并且看到已经更新的值)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> amount <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>  amount<br>−−−−−−−−−<br> <span class="hljs-number">1000.00</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>结果，第二个事务得到了 1100 美元，因为它读取了不正确的数据。这种异常称为读偏序。</p><p>在读已提交级别该如何避免这种异常？答案很明显：使用单个操作符。例如，像这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(amount) <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bob&#x27;</span>;<br></code></pre></td></tr></table></figure><p>到目前为止，我一直在强调数据的可见性只能在操作符之间发生变化，但事实真的如此吗？如果查询运行了很长时间呢？在这种情况下，它能否看到处于不同状态的数据的不同部分？</p><p>让我们试试。一种便捷的方式是通过调用 pg_sleep 函数为操作符添加延迟。然后立即读取第一行，但第二行将不得不等待两秒钟：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> amount, pg_sleep(<span class="hljs-number">2</span>) <span class="hljs-comment">-- two seconds</span><br><span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bob&#x27;</span>;<br></code></pre></td></tr></table></figure><p>在执行这条语句时，让我们开启另一个事务将钱转回去：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">-</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>结果表明，操作符看到的所有数据都处于其执行开始时的状态，这当然是正确的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"> amount  <span class="hljs-operator">|</span> pg_sleep<br>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<br>    <span class="hljs-number">0.00</span> <span class="hljs-operator">|</span><br> <span class="hljs-number">1000.00</span> <span class="hljs-operator">|</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>但情况也并非那么简单。如果查询中包含一个声明为 VOLATILE 的函数，而这个函数执行了另一个查询，那么这个嵌套查询看到的数据将与主查询的结果不一致。</p><p>让我们使用以下函数检查 Bob 帐户中的余额：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> get_amount(id <span class="hljs-type">integer</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">numeric</span><br><span class="hljs-keyword">AS</span> $$<br><span class="hljs-keyword">SELECT</span> amount <span class="hljs-keyword">FROM</span> accounts a <span class="hljs-keyword">WHERE</span> a.id <span class="hljs-operator">=</span> get_amount.id;<br>  $$ VOLATILE <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">sql</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> get_amount(id), pg_sleep(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bob&#x27;</span>;<br></code></pre></td></tr></table></figure><p>我们将在延迟查询执行时，再次在账户之间转移资金：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">-</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>在这种情况下，我们将获得不一致的数据 — 100 美元丢失了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"> get_amount <span class="hljs-operator">|</span> pg_sleep<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<br>     <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span><br>     <span class="hljs-number">800.00</span> <span class="hljs-operator">|</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>我想强调的是，这种情况仅在读已提交隔离级别并且仅当函数被声明为 VOLATILE 时。可问题在于， PostgreSQL 默认使用这种隔离级别和这种稳定性类别。因此，我们不得不承认，这个陷阱设置得非常狡猾。</p><p><strong>读偏序而不是更新丢失。</strong> 读偏序异常也可能在更新过程中的单个操作符内发生 — 即使是以某种出乎意料的方式。</p><p>让我们看看如果两个事务试图修改同一行时会发生什么。目前 Bob 的两个账户中总共有 1000 美元：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bob&#x27;</span>;<br> id <span class="hljs-operator">|</span> client <span class="hljs-operator">|</span> amount<br>−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<br>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> bob  <span class="hljs-operator">|</span> <span class="hljs-number">200.00</span><br>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> bob  <span class="hljs-operator">|</span> <span class="hljs-number">800.00</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>开启一个事务，减少 Bob 的余额：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">-</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>同时，另一笔事务将计算总余额为 1000 美元或者更多的所有客户账户的利息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">*</span> <span class="hljs-number">1.01</span><br><span class="hljs-keyword">WHERE</span> client <span class="hljs-keyword">IN</span> (<br>  <span class="hljs-keyword">SELECT</span> client<br>  <span class="hljs-keyword">FROM</span> accounts<br>  <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client<br>  <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">sum</span>(amount) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1000</span><br>);<br></code></pre></td></tr></table></figure><p>UPDATE 操作符的执行实际上包含两个阶段。首先，根据提供的条件选择要更新的行。由于第一个事务尚未提交，第二个事务无法看到其结果，因此选择用于计算利息的行不受影响。所以，Bob 的账户满足条件，一旦 UPDATE 操作完成，他的余额必须增加 10 美元。</p><p>在第二阶段，逐个更新所选行。第二个事务必须等待，因为 id &#x3D; 3 的行被锁定：它正在被第一个事务更新。</p><p>与此同时，第一个事务提交了它的更改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bob&#x27;</span>;<br> id <span class="hljs-operator">|</span> client <span class="hljs-operator">|</span>  amount<br>−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<br>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> bob  <span class="hljs-operator">|</span> <span class="hljs-number">202.0000</span><br>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> bob  <span class="hljs-operator">|</span> <span class="hljs-number">707.0000</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>一方面，UPDATE 命令不能看到第一个事务所做的任何更改。但另一方面，它不能丢失任何已提交的更改。</p><p>一旦锁被释放，UPDATE 操作符重新读取要更新的行 (但仅限这一行！)。结果，基于总额 900 美元，Bob 获得了 9 美元的利息。但如果他有 900 美元，他的账户本就不应该包含在查询结果中。</p><p>因此，我们的事务返回了不正确的数据：从不同的快照中读取了不同的行。我们再次观察到读偏序异常，而不是更新丢失。</p><p><strong>更新丢失。</strong> 但是，如果数据被不同的 SQL 操作符修改，那么重新读取锁定行的技巧将无法防止更新丢失。</p><p>此处是一个我们已经见过的例子。应用程序读取并记录 (在数据库外) Alice 账户的当前余额：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> amount <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br> amount<br>−−−−−−−−<br> <span class="hljs-number">800.00</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>同时，另一个事务也做同样的事情：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> amount <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br> amount<br>−−−−−−−−<br> <span class="hljs-number">800.00</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>第一个事务将先前记录的值增加了 100 美元，并提交了这个更改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> <span class="hljs-number">800.00</span> <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>RETURNING amount;<br> amount<br>−−−−−−−−<br> <span class="hljs-number">900.00</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-number">1</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>第二个事务也做同样的事情：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> <span class="hljs-number">800.00</span> <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>RETURNING amount;<br> amount<br>−−−−−−−−<br> <span class="hljs-number">900.00</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>不幸的是，Alice 丢失了 100 美元。数据库系统不知道记录的 800 美元值与 accounts.amount 有某种关联，因此无法防止更新丢失异常。在读已提交隔离级别下，这段代码是不正确的。</p><h4 id="2-3-2-可重复读"><a href="#2-3-2-可重复读" class="headerlink" title="2.3.2 可重复读"></a>2.3.2 可重复读</h4><p><strong>不会出现不可重复读和幻读。</strong> 顾名思义，可重复读隔离 (postgresql.org&#x2F;docs&#x2F;14&#x2F;transaction-iso.html#XACT-REPEATABLE-READ) 级别必须保证可重复读取。让我们确认一下，确保幻读也不会发生。为此，我们开启一个事务，将 Bob 的账户恢复到之前的状态，并为 Charlie 创建一个新账户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> <span class="hljs-number">200.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> <span class="hljs-number">800.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> accounts <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;charlie&#x27;</span>, <span class="hljs-number">100.00</span>);<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id;<br> id <span class="hljs-operator">|</span> client  <span class="hljs-operator">|</span> amount<br>−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<br>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> alice   <span class="hljs-operator">|</span> <span class="hljs-number">900.00</span><br>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> bob     <span class="hljs-operator">|</span> <span class="hljs-number">200.00</span><br>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> bob     <span class="hljs-operator">|</span> <span class="hljs-number">800.00</span><br>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> charlie <span class="hljs-operator">|</span> <span class="hljs-number">100.00</span><br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>在第二个会话中，让我们开启另一个事务，在 BEGIN 命令中明确指定可重复读级别 (第一个事务的隔离级别并不重要)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL REPEATABLE READ;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id;<br>   id <span class="hljs-operator">|</span> client <span class="hljs-operator">|</span>  amount<br>−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<br>    <span class="hljs-number">1</span> <span class="hljs-operator">|</span> alice  <span class="hljs-operator">|</span>   <span class="hljs-number">900.00</span><br>    <span class="hljs-number">2</span> <span class="hljs-operator">|</span> bob    <span class="hljs-operator">|</span> <span class="hljs-number">202.0000</span><br>    <span class="hljs-number">3</span> <span class="hljs-operator">|</span> bob    <span class="hljs-operator">|</span> <span class="hljs-number">707.0000</span><br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>现在，第一个事务提交其更改，第二个事务重复相同的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id;<br>  id <span class="hljs-operator">|</span> client <span class="hljs-operator">|</span>  amount<br>−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<br>   <span class="hljs-number">1</span> <span class="hljs-operator">|</span> alice  <span class="hljs-operator">|</span>   <span class="hljs-number">900.00</span><br>   <span class="hljs-number">2</span> <span class="hljs-operator">|</span> bob   <span class="hljs-operator">|</span> <span class="hljs-number">202.0000</span><br>   <span class="hljs-number">3</span> <span class="hljs-operator">|</span> bob   <span class="hljs-operator">|</span> <span class="hljs-number">707.0000</span><br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>第二个事务仍然看到和之前相同的数据：新行与更新的行都不可见。在这个隔离级别下，你不必担心在操作符之间会发生某些变化。</p><p><strong>序列化失败而不是更新丢失。</strong> 正如我们已经看到的，如果两个事务在读已提交级别下更新同一个行，它可能会导致读偏序异常：等待的事务必须重新读取锁定的行，因此它看到这一行的状态与其他行相比处于不同的时间点。</p><p>在可重复读隔离级别下，不允许出现这种异常，如果确实发生了，事务只能因序列化失败而中止。我们可以通过重复带利息计算的场景来确认这一点：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bob&#x27;</span>;<br> id <span class="hljs-operator">|</span> client <span class="hljs-operator">|</span> amount<br>−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<br>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> bob  <span class="hljs-operator">|</span> <span class="hljs-number">200.00</span><br>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> bob  <span class="hljs-operator">|</span> <span class="hljs-number">800.00</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">-</span> <span class="hljs-number">100.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL REPEATABLE READ;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">*</span> <span class="hljs-number">1.01</span><br><span class="hljs-keyword">WHERE</span> client <span class="hljs-keyword">IN</span> (<br>  <span class="hljs-keyword">SELECT</span> client<br>  <span class="hljs-keyword">FROM</span> accounts<br>  <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client<br>  <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">sum</span>(amount) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1000</span><br>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">ERROR: could <span class="hljs-keyword">not</span> serialize access due <span class="hljs-keyword">to</span> concurrent <span class="hljs-keyword">update</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><p>数据保持一致：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bob&#x27;</span>;<br> id <span class="hljs-operator">|</span> client <span class="hljs-operator">|</span> amount<br>−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<br>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> bob  <span class="hljs-operator">|</span> <span class="hljs-number">200.00</span><br>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> bob  <span class="hljs-operator">|</span> <span class="hljs-number">700.00</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>任何并发行更新，即使它们影响的是不同的列，也会引发同样的错误。</p><p>如果我们尝试基于之前存储的值更新余额，我们也会遇到这个错误：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL REPEATABLE READ;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> amount <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br> amount<br>−−−−−−−−<br> <span class="hljs-number">900.00</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL REPEATABLE READ;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> amount <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br> amount<br>−−−−−−−−<br> <span class="hljs-number">900.00</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> <span class="hljs-number">900.00</span> <span class="hljs-operator">+</span> <span class="hljs-number">100.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>RETURNING amount;<br> amount<br>−−−−−−−−−<br> <span class="hljs-number">1000.00</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-number">1</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> <span class="hljs-number">900.00</span> <span class="hljs-operator">+</span> <span class="hljs-number">100.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>RETURNING amount;<br>ERROR: could <span class="hljs-keyword">not</span> serialize access due <span class="hljs-keyword">to</span> concurrent <span class="hljs-keyword">update</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><p>一个实用的见解是：如果你的应用程序对写事务使用可重复读隔离级别，那么必须准备好重试那些由于序列化失败而结束的事务。对于只读事务，这种结果是不会发生的。</p><p><strong>写偏序。</strong> 正如我们所见，PostgreSQL 对可重复读隔离级别的实现可以防止标准中描述的所有异常。但并非所有可能的异常都可以防止：没有人知道存在多少异常。然而，有一点是确凿无疑的：无论还有多少其他类型的异常，快照隔离仅无法防止两种异常。</p><p>第一个异常是写偏序。</p><p>让我们定义以下一致性规则：只要总余额不是负数，就允许某些客户的账户余额为负数。</p><p>第一个事务获取 Bob 账户的总余额：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL REPEATABLE READ;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(amount) <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bob&#x27;</span>;<br>sum<br>−−−−−−−−<br> <span class="hljs-number">900.00</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>第二个事务获得了相同的余额：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL REPEATABLE READ;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(amount) <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bob&#x27;</span>;<br>  sum<br>−−−−−−−−<br> <span class="hljs-number">900.00</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>第一个事务合理地假设它可以从其中一个账户中扣除 600 美元：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">-</span> <span class="hljs-number">600.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>第二个事务也得出相同的结论，但是从另外一个账户中扣除了资金：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">-</span> <span class="hljs-number">600.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bob&#x27;</span>;<br> id <span class="hljs-operator">|</span> client <span class="hljs-operator">|</span> amount<br>−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<br>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> bob  <span class="hljs-operator">|</span> −<span class="hljs-number">400.00</span><br>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> bob  <span class="hljs-operator">|</span>  <span class="hljs-number">100.00</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>Bob 的总余额现在是负数，尽管如果两个事务分开运行，都是正确的。</p><p><strong>只读事务异常。</strong> 只读事务异常是可重复读隔离级别所允许的第二个异常，也是最后一个异常。要观察此异常，我们需要运行三个事务：其中两个事务将更新数据，而第三个事务是只读的。</p><p>首先让我们先恢复 Bob 的余额：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> <span class="hljs-number">900.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bob&#x27;</span>;<br> id <span class="hljs-operator">|</span> client <span class="hljs-operator">|</span> amount<br>−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<br>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> bob  <span class="hljs-operator">|</span> <span class="hljs-number">100.00</span><br>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> bob  <span class="hljs-operator">|</span> <span class="hljs-number">900.00</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>第一个事务计算 Bob 总余额应累积的利息，并将此金额添加到他的一个账户中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL REPEATABLE READ; <span class="hljs-comment">-- 1</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">+</span> (<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(amount) <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bob&#x27;</span><br>) <span class="hljs-operator">*</span> <span class="hljs-number">0.01</span><br><span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>然后第二个事务从 Bob 的其他账户中取出一些钱并提交此更改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL REPEATABLE READ; <span class="hljs-comment">-- 2</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">-</span> <span class="hljs-number">100.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>如果第一个事务在此时提交，就不会出现异常：我们可以假设第一个事务在第二事务之前提交 (但反之则不行 — 在第二个事务进行任何更新之前，第一个事务已经看到了 id &#x3D; 3 的账户的状态)。</p><p>但是让我们想象一下，在这一刻，我们开启一个只读事务，查询不受前两个事务影响的账户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL REPEATABLE READ; <span class="hljs-comment">-- 3</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;alice&#x27;</span>;<br> id <span class="hljs-operator">|</span> client <span class="hljs-operator">|</span> amount<br>−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<br>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> alice  <span class="hljs-operator">|</span> <span class="hljs-number">1000.00</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>直到现在才提交第一个事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>此时第三个事务应该看到哪个状态？开启后，它可以看到第二个事务 (已经提交) 所做的更改，但看不到第一个 (尚未提交) 事务所做的更改。但是正如我们已经确定的那样，第二个事务应该被视为在第一个事务之后开启的。第三个事务看到的任何状态都将是不一致的 — 这正是只读事务异常的含义：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bob&#x27;</span>;<br> id <span class="hljs-operator">|</span> client <span class="hljs-operator">|</span> amount<br>−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<br>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> bob  <span class="hljs-operator">|</span> <span class="hljs-number">900.00</span><br>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> bob  <span class="hljs-operator">|</span>   <span class="hljs-number">0.00</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><h4 id="2-3-3-可序列化"><a href="#2-3-3-可序列化" class="headerlink" title="2.3.3 可序列化"></a>2.3.3 可序列化</h4><p>可序列化 4 隔离级别可防止所有可能的异常。这个隔离级别实际上建立在快照隔离之上。在可重复读隔离级别不会出现的异常 (例如脏读、不可重复读或幻读) 在可序列化级别也不会出现。并且确实发生的那两个异常 (写偏序和只读事务异常) 会以特殊方式进行检测并中止事务，从而导致我们所熟知的序列化失败。</p><p><strong>没有异常。</strong> 让我们确保写偏序场景最终会以序列化失败结束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL SERIALIZABLE;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(amount) <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bob&#x27;</span>;<br>   sum<br>−−−−−−−−−−<br> <span class="hljs-number">910.0000</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL SERIALIZABLE;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(amount) <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bob&#x27;</span>;<br>   sum<br>−−−−−−−−−−<br> <span class="hljs-number">910.0000</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">-</span> <span class="hljs-number">600.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">-</span> <span class="hljs-number">600.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-keyword">COMMIT</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br>ERROR: could <span class="hljs-keyword">not</span> serialize access due <span class="hljs-keyword">to</span> read<span class="hljs-operator">/</span>write dependencies<br>among transactions<br>DETAIL: Reason code: Canceled <span class="hljs-keyword">on</span> identification <span class="hljs-keyword">as</span> a pivot, during<br><span class="hljs-keyword">commit</span> attempt.<br>HINT: The transaction might succeed if retried.<br></code></pre></td></tr></table></figure><p>只读事务异常的场景也将导致同样的错误。</p><p><strong>延迟只读事务。</strong> 为了避免只读事务可能导致损害数据一致性的异常情况，PostgreSQL 提供了一个有趣的解决方案：可以推迟此事务，直到其执行变得安全。这是 SELECT 语句唯一可能被更新阻塞的情况。</p><p>我们将通过重复演示只读事务异常的场景来确认这一点：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> <span class="hljs-number">900.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> <span class="hljs-number">100.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bob&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id;<br> id <span class="hljs-operator">|</span> client <span class="hljs-operator">|</span> amount<br>−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<br>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> bob  <span class="hljs-operator">|</span> <span class="hljs-number">900.00</span><br>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> bob  <span class="hljs-operator">|</span> <span class="hljs-number">100.00</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL SERIALIZABLE; <span class="hljs-comment">-- 1</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">+</span> (<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(amount) <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bob&#x27;</span><br>) <span class="hljs-operator">*</span> <span class="hljs-number">0.01</span><br><span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL SERIALIZABLE; <span class="hljs-comment">-- 2</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">-</span> <span class="hljs-number">100.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>让我们明确声明第三个事务为 READ ONLY 和 DEFERRABLE：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL SERIALIZABLE READ <span class="hljs-keyword">ONLY</span> DEFERRABLE; <span class="hljs-comment">-- 3</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;alice&#x27;</span>;<br></code></pre></td></tr></table></figure><p>尝试运行查询会阻塞事务 — 否则，它将导致异常。</p><p>只有当第一个事务提交后，第三个事务才能继续执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"> id <span class="hljs-operator">|</span> client <span class="hljs-operator">|</span> amount<br>−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<br>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> alice  <span class="hljs-operator">|</span> <span class="hljs-number">1000.00</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> client <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bob&#x27;</span>;<br> id <span class="hljs-operator">|</span> client <span class="hljs-operator">|</span>  amount<br>−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<br>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> bob  <span class="hljs-operator">|</span> <span class="hljs-number">910.0000</span><br>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> bob  <span class="hljs-operator">|</span>     <span class="hljs-number">0.00</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>因此，如果应用程序使用可序列化隔离级别，那么必须准备好重试那些由于序列化失败而结束的事务。(可重复读级别也需要相同的方式，除非应用程序仅限于只读事务。)</p><p>可序列化隔离级别为编程带来了便利性，但是付出的代价是异常检测带来的开销以及部分事务被强制终止。你可以通过在声明只读事务时显式使用 READ ONLY 子句来降低这种影响。但主要问题当然是被中止事务的比例有多大 — 因为这些事务将不得不重试。如果 PostgreSQL 只中止那些导致数据冲突并且确实不兼容的事务，那情况就不会那么糟糕了。但这种方法不可避免地会消耗太多资源，因为会涉及到对每一行的跟踪操作。</p><p>当前的实现允许误判：PostgreSQL 可以中止一些绝对安全的事务，这些事务仅仅是运气不佳。他们的”运气”取决于许多因素，例如是否存在适当的索引或可用的 RAM 量，因此很难提前预测实际行为。</p><p>如果你使用了可序列化隔离级别，所有应用程序的事务都需要遵守。当与其它级别结合使用时，可序列化的行为与可重复读一样，并且没有任何通知。因此，如果你决定使用可序列化级别，相应地修改 default_transaction_isolation 参数值是有意义的 — 尽管仍然可以通过显式设置不同的级别以覆盖它。</p><p>还有其他限制(V12)；例如，在可序列化级别运行的查询不能在备库上执行。尽管这个级别的功能在不断改进，但当前的限制和开销使其变得不那么吸引人。</p><h3 id="2-4-Which-Isolation-Level-to-Use"><a href="#2-4-Which-Isolation-Level-to-Use" class="headerlink" title="2.4 Which Isolation Level to Use?"></a><a name="isolation-use"></a>2.4 Which Isolation Level to Use?</h3><p>PostgreSQL 中的默认隔离级别是读已提交，显然绝大多数的应用程序都使用该级别。这个级别很方便，因为它只允许在失败的情况下中止事务；它不会为了保持数据一致性而中止任何事务。换句话说，不会发生序列化失败，因此你无需关心事务重试。</p><p>这个级别的缺点是可能发生大量异常，这在上面已经详细讨论过。开发人员必须始终牢记这些异常，并以防止它们发生的方式编写代码。如果无法在单个 SQL 语句中定义所有需要的操作，那么你必须使用显式锁定。最困难的部分是，代码很难测试与数据不一致相关的错误；这些错误可能以不可预测且几乎无法重现的方式出现，因此也很难修复。</p><p>可重复读隔离级别消除了一些不一致问题，但遗憾的是，并非全部。因此，你不仅要谨记剩余的异常，还要修改应用程序以正确处理序列化失败，这当然很不方便。但是，对于只读事务，此级别是对读已提交的完美补充；它对于生成涉及多个 SQL 查询的报告等场景非常有用。</p><p>最后，可序列化隔离级别使你完全不用担心数据一致性，这在很大程度上简化了代码的编写。应用程序唯一需要做的是能够重试因序列化失败而中止的任何事务。然而，被中止事务的数量和相关开销会显著降低系统吞吐量。同时你还应该记住，备库上不支持可序列化隔离级别，并且不能与其他隔离级别结合使用。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch19. Index Access Methods</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch19/ch19/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch19/ch19/</url>
    
    <content type="html"><![CDATA[<h2 id="ch19-Index-Access-Methods"><a href="#ch19-Index-Access-Methods" class="headerlink" title="ch19. Index Access Methods"></a>ch19. Index Access Methods</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">19.1 Indexes and Extensibility</a></td></tr><tr><td><a href="#cp2">19.2 Operator Classes and Families</a></td></tr><tr><td><a href="#cp3">19.3 Indexing Engine Interface</a></td></tr></tbody></table><h3 id="19-1-Indexes-and-Extensibility"><a href="#19-1-Indexes-and-Extensibility" class="headerlink" title="19.1 Indexes and Extensibility"></a><a name="cp1"></a>19.1 Indexes and Extensibility</h3><p>索引是一种数据库对象，主要用于加速数据访问。它们是辅助数据结构：任何索引都可以基于堆数据删除并重建。除了加速数据访问之外，索引还用于强制执行某些完整性约束。</p><p>PostgreSQL 内核提供了六种内置的索引访问方法 (索引类型)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> amname <span class="hljs-keyword">FROM</span> pg_am <span class="hljs-keyword">WHERE</span> amtype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;i&#x27;</span>;<br> amname<br>−−−−−−−−<br> btree<br> hash<br> gist<br> gin<br> spgist<br> brin<br>(<span class="hljs-number">6</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>PostgresSQL 的可扩展性意味着可以在不修改内核的情况下添加新的访问方法。其中一个此类扩展 (bloom 方法) 被包含在标准模块集中。</p><p>尽管各种索引类型之间存在诸多差异，但最终都是将键 (例如索引列的值) 与包含该键的堆元组进行匹配。元组由 6 字节的元组 ID (TID) 引用。知道键或者关于键的一些信息，就可以快速读取可能包含所需数据的元组，而无需扫描整个表。</p><p>为了确保新的访问方法可以作为扩展被添加，PostgreSQL 实现了一个通用的索引引擎。其主要目标是检索和处理特定访问方法返回的 TID：</p><pre><code class="hljs">从相应的堆元组中读取数据检查特定快照中元组的可见性如果访问方法的评估并不明确，则重新检查条件</code></pre><p>索引引擎还参与在优化阶段所构建的计划的执行。在评估各种执行路径时，优化器需要知道所有可能适用的访问方法的属性：此方法能否按照要求的顺序返回数据，还是需要一个单独的排序阶段？是否可以立即返回前几个值，还是说必须等待整个结果集被获取？诸如此类。</p><p>不仅仅是优化器需要了解访问方法的特定信息。索引的创建也提出了更多需要解答的问题：访问方法是否支持多列索引？这个索引能否保证唯一性？</p><p>索引引擎允许使用多种访问方法；为了得以支持，访问方法必须实现一个特定的接口来声明其特性和属性。</p><p>访问方法用于解决以下问题：</p><pre><code class="hljs">实现建立索引的算法，以及插入和删除索引条目在页面之间分配索引条目 (由缓冲区缓存管理器进一步处理)实现清理的算法获取锁以确保正确的并发操作生成 WAL 条目根据键查找索引数据评估索引扫描的成本</code></pre><p>PostgreSQL 的可扩展性还体现在能够添加新数据类型的能力上，而访问方法事先对此一无所知。因此，访问方法必须定义它们自己的接口，以便插入任意数据类型。</p><p>为了特定的访问方法能够使用新的数据类型，需要实现相应的接口，即提供可与索引一起使用的操作符，可能还包括一些辅助支持函数。这样的一组操作符和函数被称为操作符类。</p><p>索引逻辑由访问方法自身实现了部分，但有些则交由操作符类。这种分配相当随意：虽然 B 树将所有逻辑内置于访问方法中，但其他一些方法可能只提供主框架，将所有实现细节留给特定的操作符类来决定。同一数据类型通常由若干个操作符类支持，用户可以选择行为最合适的一个。</p><p>以下是整体概况的一小部分：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch19/ch19/img.png" alt="img.png"></p><h3 id="19-2-Operator-Classes-and-Families"><a href="#19-2-Operator-Classes-and-Families" class="headerlink" title="19.2 Operator Classes and Families"></a><a name="cp2"></a>19.2 Operator Classes and Families</h3><h4 id="19-2-1-操作符类"><a href="#19-2-1-操作符类" class="headerlink" title="19.2.1 操作符类"></a>19.2.1 操作符类</h4><p>访问方法接口 1 由操作符类实现，2 操作符类是访问方法应用于特定数据类型的一组操作符和支持函数。</p><p>操作符类存储在系统目录的 pg_opclass 表中。以下查询返回上述所说的完整数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> amname, opcname, opcintype::regtype<br><span class="hljs-keyword">FROM</span> pg_am am<br>  <span class="hljs-keyword">JOIN</span> pg_opclass opc <span class="hljs-keyword">ON</span> opcmethod <span class="hljs-operator">=</span> am.oid;<br> amname <span class="hljs-operator">|</span>           opcname            <span class="hljs-operator">|</span>          opcintype<br>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> btree <span class="hljs-operator">|</span> array_ops                    <span class="hljs-operator">|</span> anyarray<br> hash <span class="hljs-operator">|</span> array_ops                    <span class="hljs-operator">|</span> anyarray<br> btree  <span class="hljs-operator">|</span> bit_ops                      <span class="hljs-operator">|</span> bit<br> btree  <span class="hljs-operator">|</span> bool_ops                     <span class="hljs-operator">|</span> <span class="hljs-type">boolean</span><br> ...<br> brin <span class="hljs-operator">|</span> pg_lsn_minmax_multi_ops      <span class="hljs-operator">|</span> pg_lsn<br> brin <span class="hljs-operator">|</span> pg_lsn_bloom_ops             <span class="hljs-operator">|</span> pg_lsn<br> brin   <span class="hljs-operator">|</span> box_inclusion_ops            <span class="hljs-operator">|</span> box<br>(<span class="hljs-number">177</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>在大多数情况下，我们不必了解任何有关操作符类的信息。我们只需简单地创建一个默认使用某个操作符类的索引。</p><p>例如，此处是支持文本类型的 B 树操作符类。其中一个类总是被标记为默认类：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> opcname, opcdefault<br><span class="hljs-keyword">FROM</span> pg_am am<br>  <span class="hljs-keyword">JOIN</span> pg_opclass opc <span class="hljs-keyword">ON</span> opcmethod <span class="hljs-operator">=</span> am.oid<br><span class="hljs-keyword">WHERE</span> amname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;btree&#x27;</span><br>  <span class="hljs-keyword">AND</span> opcintype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;text&#x27;</span>::regtype;<br>       opcname       <span class="hljs-operator">|</span> opcdefault<br>−−−−−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br> text_ops            <span class="hljs-operator">|</span> t<br> varchar_ops         <span class="hljs-operator">|</span> f<br> text_pattern_ops    <span class="hljs-operator">|</span> f<br> varchar_pattern_ops <span class="hljs-operator">|</span> f<br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>一个典型的索引创建命令如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> aircrafts(model, <span class="hljs-keyword">range</span>);<br></code></pre></td></tr></table></figure><p>但这只是一种简写，它可以展开为以下语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> aircrafts<br><span class="hljs-keyword">USING</span> btree <span class="hljs-comment">-- the default access method</span><br>(<br>  model text_ops, <span class="hljs-comment">-- the default operator class for text</span><br>  <span class="hljs-keyword">range</span> int4_ops <span class="hljs-comment">-- the default operator class for integer</span><br>);<br></code></pre></td></tr></table></figure><p>如果你想使用不同类型的索引或实现某些自定义行为，那么你必须明确指定所需的访问方法或操作符类。</p><p>为特定访问方法和数据类型定义的每个操作符类必须包含一组处理此类型参数的操作符，并实现该访问方法的语义。</p><p>例如，btree 访问方法定义了五个强制性的比较操作符。任何 btree 操作符类都必须包含这五个操作符：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> opcname, amopstrategy, amopopr::regoperator<br><span class="hljs-keyword">FROM</span> pg_am am<br>  <span class="hljs-keyword">JOIN</span> pg_opfamily opf <span class="hljs-keyword">ON</span> opfmethod <span class="hljs-operator">=</span> am.oid<br>  <span class="hljs-keyword">JOIN</span> pg_opclass opc <span class="hljs-keyword">ON</span> opcfamily <span class="hljs-operator">=</span> opf.oid<br>  <span class="hljs-keyword">JOIN</span> pg_amop amop <span class="hljs-keyword">ON</span> amopfamily <span class="hljs-operator">=</span> opcfamily<br>  <span class="hljs-keyword">WHERE</span> amname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;btree&#x27;</span><br>  <span class="hljs-keyword">AND</span> opcname <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;text_ops&#x27;</span>, <span class="hljs-string">&#x27;text_pattern_ops&#x27;</span>)<br>  <span class="hljs-keyword">AND</span> amoplefttype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;text&#x27;</span>::regtype<br>  <span class="hljs-keyword">AND</span> amoprighttype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;text&#x27;</span>::regtype<br>  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> opcname, amopstrategy;<br>     opcname      <span class="hljs-operator">|</span> amopstrategy <span class="hljs-operator">|</span>     amopopr<br>−−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−<br> text_ops         <span class="hljs-operator">|</span>            <span class="hljs-number">1</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(text,text)<br> text_ops         <span class="hljs-operator">|</span>            <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;=</span>(text,text)<br> text_ops         <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span> <span class="hljs-operator">=</span>(text,text)<br> text_ops         <span class="hljs-operator">|</span>            <span class="hljs-number">4</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&gt;=</span>(text,text)<br> text_ops         <span class="hljs-operator">|</span>            <span class="hljs-number">5</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&gt;</span>(text,text)<br> text_pattern_ops <span class="hljs-operator">|</span>            <span class="hljs-number">1</span> <span class="hljs-operator">|</span> <span class="hljs-operator">~</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">~</span>(text,text)<br> text_pattern_ops <span class="hljs-operator">|</span>            <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-operator">~</span><span class="hljs-operator">&lt;=</span><span class="hljs-operator">~</span>(text,text)<br> text_pattern_ops <span class="hljs-operator">|</span>            <span class="hljs-number">3</span> <span class="hljs-operator">|</span> <span class="hljs-operator">=</span>(text,text)<br> text_pattern_ops <span class="hljs-operator">|</span>            <span class="hljs-number">4</span> <span class="hljs-operator">|</span> <span class="hljs-operator">~</span><span class="hljs-operator">&gt;=</span><span class="hljs-operator">~</span>(text,text)<br> text_pattern_ops <span class="hljs-operator">|</span>            <span class="hljs-number">5</span> <span class="hljs-operator">|</span> <span class="hljs-operator">~</span><span class="hljs-operator">&gt;</span><span class="hljs-operator">~</span>(text,text)<br>(<span class="hljs-number">10</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>访问方法所暗示的操作符的语义由显示为 amopstrategy 的策略编号反映。3 例如，对于 btree 来说，策略 1 表示小于，策略 2 表示小于或等于，依此类推。操作符本身可以有任意名称。</p><p>上面的示例显示了两种类型的操作符。普通操作符和带有波浪线的操作符之间的区别在于，后者不考虑排序规则 4 并执行字符串的逐位比较。尽管如此，两种风格的操作符都实现了相同的逻辑比较操作。</p><p>text_pattern_ops 操作符类旨在解决对 ‘~~’ 操作符 (对应于 LIKE 操作符) 的支持限制。在使用非 C 排序规则的数据库中，这个操作符不能使用文本字段上的常规索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> lc_collate;<br> lc_collate<br>−−−−−−−−−−−−−<br> en_US.UTF−<span class="hljs-number">8</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> tickets(passenger_name);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tickets <span class="hljs-keyword">WHERE</span> passenger_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;ELENA%&#x27;</span>;<br>                  QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> tickets<br>   <span class="hljs-keyword">Filter</span>: (passenger_name <span class="hljs-operator">~</span><span class="hljs-operator">~</span> <span class="hljs-string">&#x27;ELENA%&#x27;</span>::text)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>使用 text_pattern_ops 操作符类的索引行为有所不同：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX tickets_passenger_name_pattern_idx<br><span class="hljs-keyword">ON</span> tickets(passenger_name text_pattern_ops);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tickets <span class="hljs-keyword">WHERE</span> passenger_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;ELENA%&#x27;</span>;<br>                          QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Bitmap Heap Scan <span class="hljs-keyword">on</span> tickets<br>   <span class="hljs-keyword">Filter</span>: (passenger_name <span class="hljs-operator">~</span><span class="hljs-operator">~</span> <span class="hljs-string">&#x27;ELENA%&#x27;</span>::text)<br>   −<span class="hljs-operator">&gt;</span> Bitmap Index Scan <span class="hljs-keyword">on</span> tickets_passenger_name_pattern_idx<br>       Index Cond: ((passenger_name <span class="hljs-operator">~</span><span class="hljs-operator">&gt;=</span><span class="hljs-operator">~</span> <span class="hljs-string">&#x27;ELENA&#x27;</span>::text) <span class="hljs-keyword">AND</span><br>       (passenger_name <span class="hljs-operator">~</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">~</span> <span class="hljs-string">&#x27;ELENB&#x27;</span>::text))<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>注意 Index Cond 中过滤表达式的变化。搜索现在仅使用 % 之前的模板前缀，而 false-positive 会在基于 Filter 条件的重新检查期间被过滤掉。btree 访问方法的操作符类没有提供用于比较模板的操作符，而使用 B 树的唯一方法是使用比较操作符重写此条件。text_pattern_ops 类的操作符不考虑排序规则，这让我们有机会使用等价条件代替。5</p><p>如果满足以下两个前置条件，则可以使用索引来加速过滤条件的访问：</p><pre><code class="hljs">1. 条件写成 “indexed-column operator expression” (如果操作符有指定的可交换操作符 6，条件也可以写成 “expression operator indexed-column” 的形式)。72. 操作符属于索引声明中为索引列指定的操作符类。</code></pre><p>例如，以下查询便可以使用索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tickets <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;ELENA BELOVA&#x27;</span> <span class="hljs-operator">=</span> passenger_name;<br>                       QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> tickets_passenger_name_idx <span class="hljs-keyword">on</span> tickets<br>   Index Cond: (passenger_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ELENA BELOVA&#x27;</span>::text)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>请注意 Index Cond 条件中参数的位置：在执行阶段，索引字段必须在左侧。当参数被置换时，操作符被一个可交换的操作符替换；在此例中，它是相同的操作符，因为等值关系是可交换的。</p><p>在接下来的查询中，由于条件中的列名被函数调用替换，因此技术上不可能使用常规索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tickets <span class="hljs-keyword">WHERE</span> initcap(passenger_name) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Elena Belova&#x27;</span>;<br>                         QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> tickets<br>   <span class="hljs-keyword">Filter</span>: (initcap(passenger_name) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Elena Belova&#x27;</span>::text)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>此处你可以使用表达式索引 8，它在声明中指定了一个任意表达式，而不是列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> tickets( (initcap(passenger_name)) );<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tickets <span class="hljs-keyword">WHERE</span> initcap(passenger_name) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Elena Belova&#x27;</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Bitmap Heap Scan <span class="hljs-keyword">on</span> tickets<br>   Recheck Cond: (initcap(passenger_name) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Elena Belova&#x27;</span>::text)<br>   −<span class="hljs-operator">&gt;</span> Bitmap Index Scan <span class="hljs-keyword">on</span> tickets_initcap_idx<br>       Index Cond: (initcap(passenger_name) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Elena Belova&#x27;</span>::text)<br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>索引表达式只能依赖于堆元组值，不能受到数据库中存储的其他数据或配置参数 (如区域设置) 的影响。换句话说，如果表达式包含任何函数调用，这些函数必须是 IMMUTABLE 9，并且它们必须遵循这个稳定性分类。否则，针对同一查询，索引扫描和堆扫描可能会返回不同的结果。</p><p>除了常规操作符之外，操作符类可以提供访问方法所需的支持函数 10。例如，btree 访问方法定义了五个支持函数 11；第一个 (比较两个值) 函数是必需的，而所有其他函数都可以不存在：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> amprocnum, amproc::regproc<br><span class="hljs-keyword">FROM</span> pg_am am<br>  <span class="hljs-keyword">JOIN</span> pg_opfamily opf <span class="hljs-keyword">ON</span> opfmethod <span class="hljs-operator">=</span> am.oid<br>  <span class="hljs-keyword">JOIN</span> pg_opclass opc <span class="hljs-keyword">ON</span> opcfamily <span class="hljs-operator">=</span> opf.oid<br>  <span class="hljs-keyword">JOIN</span> pg_amproc amproc <span class="hljs-keyword">ON</span> amprocfamily <span class="hljs-operator">=</span> opcfamily<br><span class="hljs-keyword">WHERE</span> amname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;btree&#x27;</span><br>  <span class="hljs-keyword">AND</span> opcname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;text_ops&#x27;</span><br>  <span class="hljs-keyword">AND</span> amproclefttype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;text&#x27;</span>::regtype<br>  <span class="hljs-keyword">AND</span> amprocrighttype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;text&#x27;</span>::regtype<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> amprocnum;<br> amprocnum <span class="hljs-operator">|</span>       amproc<br>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−<br>         <span class="hljs-number">1</span> <span class="hljs-operator">|</span> bttextcmp<br>         <span class="hljs-number">2</span> <span class="hljs-operator">|</span> bttextsortsupport<br>         <span class="hljs-number">4</span> <span class="hljs-operator">|</span> btvarstrequalimage<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><h4 id="19-2-2-操作符族"><a href="#19-2-2-操作符族" class="headerlink" title="19.2.2 操作符族"></a>19.2.2 操作符族</h4><p>每个操作符类始终属于某个操作符族 12 (在 pg_opfamily 表中列出)。一个操作符族可以包含多个以相同方式处理相似数据类型的操作符类。</p><p>例如，integer_ops 族包括几个用于整数数据类型的类，这些类的语义相同，但大小有所不同：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> opcname, opcintype::regtype<br><span class="hljs-keyword">FROM</span> pg_am am<br>  <span class="hljs-keyword">JOIN</span> pg_opfamily opf <span class="hljs-keyword">ON</span> opfmethod <span class="hljs-operator">=</span> am.oid<br>  <span class="hljs-keyword">JOIN</span> pg_opclass opc <span class="hljs-keyword">ON</span> opcfamily <span class="hljs-operator">=</span> opf.oid<br><span class="hljs-keyword">WHERE</span> amname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;btree&#x27;</span><br>  <span class="hljs-keyword">AND</span> opfname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;integer_ops&#x27;</span>;<br> opcname  <span class="hljs-operator">|</span> opcintype<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−<br> int2_ops <span class="hljs-operator">|</span> <span class="hljs-type">smallint</span><br> int4_ops <span class="hljs-operator">|</span> <span class="hljs-type">integer</span><br> int8_ops <span class="hljs-operator">|</span> <span class="hljs-type">bigint</span><br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>datetime_ops 族包含用于处理日期的操作符类：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> opcname, opcintype::regtype<br><span class="hljs-keyword">FROM</span> pg_am am<br>  <span class="hljs-keyword">JOIN</span> pg_opfamily opf <span class="hljs-keyword">ON</span> opfmethod <span class="hljs-operator">=</span> am.oid<br>  <span class="hljs-keyword">JOIN</span> pg_opclass opc <span class="hljs-keyword">ON</span> opcfamily <span class="hljs-operator">=</span> opf.oid<br><span class="hljs-keyword">WHERE</span> amname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;btree&#x27;</span><br>  <span class="hljs-keyword">AND</span> opfname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;datetime_ops&#x27;</span>;<br>     opcname     <span class="hljs-operator">|</span>          opcintype<br>−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> date_ops        <span class="hljs-operator">|</span> <span class="hljs-type">date</span><br> timestamptz_ops <span class="hljs-operator">|</span> <span class="hljs-type">timestamp</span> <span class="hljs-keyword">with</span> <span class="hljs-type">time</span> zone<br> timestamp_ops  <span class="hljs-operator">|</span> <span class="hljs-type">timestamp</span> <span class="hljs-keyword">without</span> <span class="hljs-type">time</span> zone<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>虽然每个操作符类支持单一数据类型，但一个族可以包含用于不同数据类型的操作符类：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> opcname, amopopr::regoperator<br><span class="hljs-keyword">FROM</span> pg_am am<br>  <span class="hljs-keyword">JOIN</span> pg_opfamily opf <span class="hljs-keyword">ON</span> opfmethod <span class="hljs-operator">=</span> am.oid<br>  <span class="hljs-keyword">JOIN</span> pg_opclass opc <span class="hljs-keyword">ON</span> opcfamily <span class="hljs-operator">=</span> opf.oid<br>  <span class="hljs-keyword">JOIN</span> pg_amop amop <span class="hljs-keyword">ON</span> amopfamily <span class="hljs-operator">=</span> opcfamily<br><span class="hljs-keyword">WHERE</span> amname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;btree&#x27;</span><br>  <span class="hljs-keyword">AND</span> opfname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;integer_ops&#x27;</span><br>  <span class="hljs-keyword">AND</span> amoplefttype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;integer&#x27;</span>::regtype<br>  <span class="hljs-keyword">AND</span> amopstrategy <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> opcname;<br> opcname  <span class="hljs-operator">|</span>       amopopr<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−<br> int2_ops <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(<span class="hljs-type">integer</span>,<span class="hljs-type">bigint</span>)<br> int2_ops <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(<span class="hljs-type">integer</span>,<span class="hljs-type">smallint</span>)<br> int2_ops <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(<span class="hljs-type">integer</span>,<span class="hljs-type">integer</span>)<br> int4_ops <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(<span class="hljs-type">integer</span>,<span class="hljs-type">bigint</span>)<br> int4_ops <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(<span class="hljs-type">integer</span>,<span class="hljs-type">smallint</span>)<br> int4_ops <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(<span class="hljs-type">integer</span>,<span class="hljs-type">integer</span>)<br> int8_ops <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(<span class="hljs-type">integer</span>,<span class="hljs-type">bigint</span>)<br> int8_ops <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(<span class="hljs-type">integer</span>,<span class="hljs-type">smallint</span>)<br> int8_ops <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>(<span class="hljs-type">integer</span>,<span class="hljs-type">integer</span>)<br>(<span class="hljs-number">9</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>由于将各种操作符分组至一个单独的操作符族中，规划器在使用索引处理涉及不同类型的值的条件时，可以不需要进行类型转换。</p><h3 id="19-3-Indexing-Engine-Interface"><a href="#19-3-Indexing-Engine-Interface" class="headerlink" title="19.3 Indexing Engine Interface"></a><a name="cp3"></a>19.3 Indexing Engine Interface</h3><p>如同表访问方法一样 ，pg_am 表的 amhandler 列包含实现了接口的函数名称：13</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> amname, amhandler <span class="hljs-keyword">FROM</span> pg_am <span class="hljs-keyword">WHERE</span> amtype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;i&#x27;</span>;<br> amname <span class="hljs-operator">|</span>  amhandler<br>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−<br> btree  <span class="hljs-operator">|</span> bthandler<br> hash <span class="hljs-operator">|</span> hashhandler<br> gist <span class="hljs-operator">|</span> gisthandler<br> gin    <span class="hljs-operator">|</span> ginhandler<br> spgist <span class="hljs-operator">|</span> spghandler<br> brin <span class="hljs-operator">|</span> brinhandler<br>(<span class="hljs-number">6</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>此函数用真实值填充接口结构 14 中的占位符。其中一些是负责与索引访问相关的独立任务的函数 (例如，它们可以执行索引扫描并返回堆元组 ID)，而其他一些是索引引擎必须知晓的索引方法的属性。</p><p>所有属性分为三类：15</p><pre><code class="hljs">访问方法属性特定索引的属性索引的列级属性</code></pre><p>访问方法和索引级属性之间的区别是为了将来考虑：目前，基于特定访问方法的所有索引在这两个层次上始终具有相同的属性。</p><h4 id="19-3-1-访问方法属性"><a href="#19-3-1-访问方法属性" class="headerlink" title="19.3.1 访问方法属性"></a>19.3.1 访问方法属性</h4><p>以下五个属性在访问方法层面定义 (此处以 B 树方法为例)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> a.amname, p.name, pg_indexam_has_property(a.oid, p.name)<br><span class="hljs-keyword">FROM</span> pg_am a, <span class="hljs-built_in">unnest</span>(<span class="hljs-keyword">array</span>[<br>  <span class="hljs-string">&#x27;can_order&#x27;</span>, <span class="hljs-string">&#x27;can_unique&#x27;</span>, <span class="hljs-string">&#x27;can_multi_col&#x27;</span>,<br>  <span class="hljs-string">&#x27;can_exclude&#x27;</span>, <span class="hljs-string">&#x27;can_include&#x27;</span><br>]) p(name)<br><span class="hljs-keyword">WHERE</span> a.amname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;btree&#x27;</span>;<br> amname <span class="hljs-operator">|</span>     name      <span class="hljs-operator">|</span> pg_indexam_has_property<br>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−−−<br> btree  <span class="hljs-operator">|</span> can_order     <span class="hljs-operator">|</span> t<br> btree  <span class="hljs-operator">|</span> can_unique    <span class="hljs-operator">|</span> t<br> btree  <span class="hljs-operator">|</span> can_multi_col <span class="hljs-operator">|</span> t<br> btree  <span class="hljs-operator">|</span> can_exclude <span class="hljs-operator">|</span> t<br> btree  <span class="hljs-operator">|</span> can_include <span class="hljs-operator">|</span> t<br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p><strong>CAN ORDER</strong>：接收排序数据的能力 16。这个属性目前只有 B 树支持。</p><p>要按要求的顺序获取结果，始终可以先扫描表，然后对获取的数据进行排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> seats <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> seat_no;<br>       QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−<br> Sort<br>   Sort Key: seat_no<br>   −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> seats<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>但是如果有支持该属性的索引，那么数据可以立即按照所需顺序返回：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> seats <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> aircraft_code;<br>              QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> seats_pkey <span class="hljs-keyword">on</span> seats<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p><strong>CAN UNIQUE</strong>：支持唯一约束和主键约束 17。此属性仅适用于 B 树。</p><p>每次声明唯一约束或主键约束时，PostgreSQL 会自动创建一个唯一索引用于支持这个约束。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> bookings(book_ref, book_date, total_amount)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;000004&#x27;</span>, now(), <span class="hljs-number">100.00</span>);<br>ERROR: duplicate key <span class="hljs-keyword">value</span> violates <span class="hljs-keyword">unique</span> <span class="hljs-keyword">constraint</span><br>&quot;bookings_pkey&quot;<br>DETAIL: Key (book_ref)<span class="hljs-operator">=</span>(<span class="hljs-number">000004</span>) already exists.<br></code></pre></td></tr></table></figure><p>也就是说，如果你只是简单地创建了一个唯一索引而没有明确声明一个完整性约束，效果似乎是完全一样的：索引列将不允许重复。那么区别是什么呢？</p><p>完整性约束定义了一个绝不能违反的属性，而索引只是保证这一属性的一种机制。理论上，约束也可以通过其他手段施加。</p><p>例如，PostgreSQL 不支持分区表全局索引，但你仍然可以在这样的表上创建唯一约束 (如果它包含分区键)。在这种情况下，全局唯一性由每个分区的本地唯一索引来确保，因为不同分区不能有相同的分区键。</p><p><strong>CAN MULTI COL</strong>：创建多列索引的能力。18</p><p>多列索引可以加速对不同列施加的多个条件的搜索。例如，ticket_flights 表有一个复合主键，所以相应的索引是建立在多个列上的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> \d ticket_flights_pkey<br>     Index &quot;bookings.ticket_flights_pkey&quot;<br>  <span class="hljs-keyword">Column</span>   <span class="hljs-operator">|</span>     Type      <span class="hljs-operator">|</span> Key? <span class="hljs-operator">|</span> Definition<br>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br> ticket_no <span class="hljs-operator">|</span> <span class="hljs-type">character</span>(<span class="hljs-number">13</span>) <span class="hljs-operator">|</span> yes  <span class="hljs-operator">|</span> ticket_no<br> flight_id <span class="hljs-operator">|</span> <span class="hljs-type">integer</span>       <span class="hljs-operator">|</span> yes  <span class="hljs-operator">|</span> flight_id<br><span class="hljs-keyword">primary key</span>, btree, <span class="hljs-keyword">for</span> <span class="hljs-keyword">table</span> &quot;bookings.ticket_flights&quot;<br></code></pre></td></tr></table></figure><p>根据票号和航班 ID 搜索航班使用的是索引扫描：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> ticket_flights<br><span class="hljs-keyword">WHERE</span> ticket_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0005432001355&#x27;</span><br>  <span class="hljs-keyword">AND</span> flight_id <span class="hljs-operator">=</span> <span class="hljs-number">51618</span>;<br>                        QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> ticket_flights_pkey <span class="hljs-keyword">on</span> ticket_flights<br>   Index Cond: ((ticket_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0005432001355&#x27;</span>::bpchar) <span class="hljs-keyword">AND</span><br>   (flight_id <span class="hljs-operator">=</span> <span class="hljs-number">51618</span>))<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>通常情况下，即使过滤条件只涉及其某些列，多列索引也可以加速搜索。对于 B 树，如果过滤条件涵盖了索引声明中最先出现的相关列，搜索将会很高效：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> ticket_flights<br><span class="hljs-keyword">WHERE</span> ticket_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0005432001355&#x27;</span>;<br>                        QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> ticket_flights_pkey <span class="hljs-keyword">on</span> ticket_flights<br>   Index Cond: (ticket_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0005432001355&#x27;</span>::bpchar)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>在所有其他情况下 (例如，如果条件仅包含 flights_id)，搜索实际上将仅限于初始列 (如果查询包含相应的条件)，而其他条件仅用于过滤返回的结果。其他类型的索引可能会有不同的行为。</p><p><strong>CAN EXCLUDE</strong>：支持排它约束。19</p><p>排它约束保证表中任何两行都不会满足由操作符定义的条件。为了施加这个约束，PostgreSQL 会自动创建一个索引；必须有一个操作符类，其中包含约束条件中使用的操作符。</p><p>通常用于此目的的是交集操作符 &amp;&amp;。例如，你可以使用它来明确声明会议室不能在同一时间被预订两次，或者地图上的建筑物不能重叠。</p><p>有了相等运算符，排它约束就具有了唯一性的含义：禁止表中有两行具有相同的键值。尽管如此，它与唯一约束不同：特别是，排它约束的键无法被外键引用，也不能在 ON CONFLICT 子句中使用。</p><p><strong>CAN INCLUDE</strong>：向索引中添加非键列的能力，使得这个索引成为覆盖索引。</p><p>使用这个属性，你可以用额外的列扩展唯一索引。这样的索引仍然可以保证所有键列的值都是唯一的，同时从包含的列中检索数据可以不需要访问堆：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX <span class="hljs-keyword">ON</span> flights(flight_id) INCLUDE (status);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> status <span class="hljs-keyword">FROM</span> flights<br><span class="hljs-keyword">WHERE</span> flight_id <span class="hljs-operator">=</span> <span class="hljs-number">51618</span>;<br>                          QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index <span class="hljs-keyword">Only</span> Scan <span class="hljs-keyword">using</span> flights_flight_id_status_idx <span class="hljs-keyword">on</span> flights<br> Index Cond: (flight_id <span class="hljs-operator">=</span> <span class="hljs-number">51618</span>)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><h4 id="19-3-2-索引级属性"><a href="#19-3-2-索引级属性" class="headerlink" title="19.3.2 索引级属性"></a>19.3.2 索引级属性</h4><p>以下是与索引相关的属性 (显示现有索引)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> p.name, pg_index_has_property(<span class="hljs-string">&#x27;seats_pkey&#x27;</span>, p.name)<br><span class="hljs-keyword">FROM</span> <span class="hljs-built_in">unnest</span>(<span class="hljs-keyword">array</span>[<br>  <span class="hljs-string">&#x27;clusterable&#x27;</span>, <span class="hljs-string">&#x27;index_scan&#x27;</span>, <span class="hljs-string">&#x27;bitmap_scan&#x27;</span>, <span class="hljs-string">&#x27;backward_scan&#x27;</span><br>]) p(name);<br>     name      <span class="hljs-operator">|</span> pg_index_has_property<br>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−<br> clusterable   <span class="hljs-operator">|</span> t<br> index_scan    <span class="hljs-operator">|</span> t<br> bitmap_scan   <span class="hljs-operator">|</span> t<br> backward_scan <span class="hljs-operator">|</span> t<br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>CLUSTERABLE：根据索引扫描返回的 ID 顺序物理移动堆元组的能力。此属性显示是否支持 CLUSTER 命令。</p><p>INDEX SCAN：支持索引扫描。这个属性意味着访问方法可以逐个返回 TIDs。尽管看起来奇怪，但有些索引不提供这个功能。</p><p>BITMAP SCAN：支持位图扫描。这个属性定义了访问方法是否可以一次性创建并返回所有 TIDs 的位图。</p><p>BACKWARD SCAN：与索引创建时指定的顺序相比，能够以相反的顺序返回结果。只有当访问方法支持索引扫描时，这个属性才有意义。</p><h4 id="19-3-3-列级属性"><a href="#19-3-3-列级属性" class="headerlink" title="19.3.3 列级属性"></a>19.3.3 列级属性</h4><p>最后，让我们看一下列属性：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> p.name,<br>  pg_index_column_has_property(<span class="hljs-string">&#x27;seats_pkey&#x27;</span>, <span class="hljs-number">1</span>, p.name)<br><span class="hljs-keyword">FROM</span> <span class="hljs-built_in">unnest</span>(<span class="hljs-keyword">array</span>[<br>  <span class="hljs-string">&#x27;asc&#x27;</span>, <span class="hljs-string">&#x27;desc&#x27;</span>, <span class="hljs-string">&#x27;nulls_first&#x27;</span>, <span class="hljs-string">&#x27;nulls_last&#x27;</span>, <span class="hljs-string">&#x27;orderable&#x27;</span>,<br>  <span class="hljs-string">&#x27;distance_orderable&#x27;</span>, <span class="hljs-string">&#x27;returnable&#x27;</span>, <span class="hljs-string">&#x27;search_array&#x27;</span>, <span class="hljs-string">&#x27;search_nulls&#x27;</span><br>]) p(name);<br>        name        <span class="hljs-operator">|</span> pg_index_column_has_property<br>−−−−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-keyword">asc</span>                <span class="hljs-operator">|</span> t<br> <span class="hljs-keyword">desc</span>               <span class="hljs-operator">|</span> f<br> nulls_first        <span class="hljs-operator">|</span> f<br> nulls_last         <span class="hljs-operator">|</span> t<br> orderable          <span class="hljs-operator">|</span> t<br> distance_orderable <span class="hljs-operator">|</span> f<br> returnable         <span class="hljs-operator">|</span> t<br> search_array       <span class="hljs-operator">|</span> t<br> search_nulls       <span class="hljs-operator">|</span> t<br>(<span class="hljs-number">9</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>ASC，DESC，NULLS FIRST，NULLS LAST：用于排序列值。</p><p>这些属性定义了列值应按升序还是降序存储，以及空值是应该出现在常规值之前还是之后。所有这些属性仅适用于 B 树。</p><p>ORDERABLE：使用 ORDER BY 子句对列值进行排序的能力。此属性仅适用于 B 树。</p><p>DISTANCE ORDERABLE：支持排序操作符。20</p><p>与返回逻辑值的常规索引操作符不同，排序操作符返回了一个实数，表示从一个参数到另一个参数的”距离”。索引支持查询的 ORDER BY 子句中指定的此类操作符。</p><p>例如，排序操作符 &lt;-&gt; 可以找到距指定点最近的机场：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> airports_data <span class="hljs-keyword">USING</span> gist(coordinates);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> airports<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> coordinates <span class="hljs-operator">&lt;</span><span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> point (<span class="hljs-number">43.578</span>,<span class="hljs-number">57.593</span>)<br>LIMIT <span class="hljs-number">3</span>;<br>                            QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Limit<br>   −<span class="hljs-operator">&gt;</span> Index Scan <span class="hljs-keyword">using</span> airports_data_coordinates_idx <span class="hljs-keyword">on</span> airpo...<br>       <span class="hljs-keyword">Order</span> <span class="hljs-keyword">By</span>: (coordinates <span class="hljs-operator">&lt;</span>−<span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;(43.578,57.593)&#x27;</span>::point)<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>RETURNABLE：无需访问表即可返回数据的能力 (支持仅索引扫描)。</p><p>这个属性定义了索引结构是否允许检索索引值。这并不总是可能的：例如，某些索引可能存储哈希码而不是实际的值。在这种情况下，CAN INCLUDE 属性也将不可用。</p><p>SEARCH ARRAY：支持在数组中搜索多个元素。</p><p>数组的显式使用并不是唯一可能需要的情况。例如，规划器将 IN (list) 表达式转换为数组扫描：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookings<br><span class="hljs-keyword">WHERE</span> book_ref <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;C7C821&#x27;</span>, <span class="hljs-string">&#x27;A5D060&#x27;</span>, <span class="hljs-string">&#x27;DDE1BB&#x27;</span>);<br>                 QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> bookings_pkey <span class="hljs-keyword">on</span> bookings<br>   Index Cond: (book_ref <span class="hljs-operator">=</span> <span class="hljs-keyword">ANY</span><br>   (<span class="hljs-string">&#x27;&#123;C7C821,A5D060,DDE1BB&#125;&#x27;</span>::bpchar[]))<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>如果索引方法不支持此类操作符，执行器可能不得不进行多次迭代来查找特定值 (这可能会降低索引扫描的效率)。</p><p>SEARCH NULLS ：搜索 IS NULL 和 IS NOT NULL 条件。</p><p>我们应该索引空值吗？一方面，这允许我们对 IS [NOT] NULL 等条件进行索引扫描，以及在没有提供过滤条件的情况下将索引用作覆盖索引 (在这种情况下，索引必须返回所有堆元组数据，包括那些包含空值的堆元组)。但另一方面，跳过空值可以减小索引的大小。</p><p>这个决定留给访问方法开发者自行决定，但通常空值确实会被索引。</p><p>如果不需要在索引中包含空值，你可以通过创建只覆盖所需行的部分索引 21 来排除它们。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> flights(actual_arrival)<br><span class="hljs-keyword">WHERE</span> actual_arrival <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT NULL</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights<br><span class="hljs-keyword">WHERE</span> actual_arrival <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2017-06-13 10:33:00+03&#x27;</span>;<br>                           QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> flights_actual_arrival_idx <span class="hljs-keyword">on</span> flights<br>   Index Cond: (actual_arrival <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2017−06−13 10:33:00+03&#x27;</span>::ti...<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>部分索引比完整索引小，并且仅当被索引的行发生变化时才会更新，这有时可以带来明显的性能提升。显然，除了空值检查之外，WHERE 子句可以提供任何条件 (可以与 IMMUTABLE 函数一起使用)。</p><p>建立部分索引的能力由索引引擎提供，因此不依赖于访问方法。</p><p>接口只包括索引方法的那些必须提前知道以做出正确决策的属性。例如，它没有列出任何支持谓词锁或非阻塞索引创建 (CONCURRENTLY) 等特性的属性。这些属性在实现接口的函数代码中定义。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch18. Table Access Methods</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch18/ch18/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch18/ch18/</url>
    
    <content type="html"><![CDATA[<h2 id="ch18-Table-Access-Methods"><a href="#ch18-Table-Access-Methods" class="headerlink" title="ch18. Table Access Methods"></a>ch18. Table Access Methods</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">18.1 Pluggable Storage Engines</a></td></tr><tr><td><a href="#cp2">18.2 Sequential Scans</a></td></tr><tr><td><a href="#cp3">18.3 Parallel Plans</a></td></tr><tr><td><a href="#cp4">18.4 Parallel Sequential Scans</a></td></tr><tr><td><a href="#cp5">18.5 Parallel Execution Limitations</a></td></tr></tbody></table><h3 id="18-1-Pluggable-Storage-Engines"><a href="#18-1-Pluggable-Storage-Engines" class="headerlink" title="18.1 Pluggable Storage Engines"></a><a name="cp1"></a>18.1 Pluggable Storage Engines</h3><p>PostgreSQL 使用的数据布局既不是唯一可能的，也不是所有负载类型的最佳选择。遵循可扩展性的理念，PostgreSQL 允许创建和新增表访问方法 (可插拔存储引擎)，但目前仅有一种开箱即用的引擎：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> amname, amhandler <span class="hljs-keyword">FROM</span> pg_am <span class="hljs-keyword">WHERE</span> amtype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;t&#x27;</span>;<br> amname <span class="hljs-operator">|</span>  amhandler<br>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−<br> heap <span class="hljs-operator">|</span> heap_tableam_handler<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>在建表时，你可以指定要使用的引擎 (CREATE TABLE … USING)；否则，将使用 default_table_access_method 参数中列出的默认引擎。</p><p>为了让 PostgreSQL 内核部分以相同的方式与不同的引擎协作，表访问方法必须实现一个特殊的接口。1 在 amhandler 列中指定的函数，其返回的接口结构 2 包含内核所需的所有信息。</p><p>以下核心组件可被所有表访问方法使用：</p><pre><code class="hljs">事务管理器，包括 ACID 和快照隔离支持缓冲区管理I/O 子系统TOAST优化器和执行器索引支持</code></pre><p>即使存储引擎并不使用这些组件中的所有部分，这些组件也始终可供引擎使用。</p><p>而引擎定义了：</p><pre><code class="hljs">元组格式和数据结构表扫描的实现和成本预估插入、删除、更新和锁操作的实现可见性规则清理和分析过程</code></pre><p>从历史上看，PostgreSQL 使用了一个单一的内置数据存储，而没有任何适当的编程接口，因此现在很难提出一个好的设计，既能考虑到标准引擎的所有特点，又不干扰其他方法。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">比如，目前仍不清楚如何处理 WAL。新的访问方法可能需要记录自己的操作，而内核并不知道这些操作。现有的通用 WAL 机制 3 通常是一个糟糕的选择，因为它会产生过多的开销。你可以添加另一个接口来处理新类型的 WAL 条目，但是这样一来，崩溃恢复将依赖于外部代码，这是非常不可取的。到目前为止，唯一看似可行的解决方案是为每个特定引擎修补内核。<br></code></pre></td></tr></table></figure><p>因此，我没有严格区分表访问方法和内核。本书前面部分描述的许多功能从形式上讲属于堆访问方法，而不属于内核本身。这种方法很可能始终是 PostgreSQL 的最终标准引擎，而其他方法将填补各自的空白，以应对特定负载类型的挑战。</p><p>在目前正在开发的所有新引擎中，我想提及以下几种：</p><p>Zheap 旨在处理表膨胀 4。它实现了原地更新，并将与 MVCC 相关的历史数据移动到一个单独的回滚段中。这种引擎对于涉及频繁数据更新的负载将非常有用。</p><p>Zheap 的架构对于 Oracle 用户来说会感到很熟悉，尽管它确实有一些细微差别 (例如，索引访问方法的接口不允许使用其自己的版本创建索引)。</p><p>Zedstore 实现了列式存储 5，这种存储方式可能对 OLAP 查询最为高效。</p><p>存储的数据其结构是一棵元组 ID 的 B 树；每一列都存储在与主树相关的自己的 B 树中。未来，可能会在一个 B 树中存储多个列，从而获得混合存储。</p><h3 id="18-2-Sequential-Scans"><a href="#18-2-Sequential-Scans" class="headerlink" title="18.2 Sequential Scans"></a><a name="cp2"></a>18.2 Sequential Scans</h3><p>存储引擎定义了表数据的物理布局，并提供访问方法。唯一支持的方法是顺序扫描，它完整地读取表主分支的文件 (或多个文件)。每次页面读取，都会检查每条元组的可见性；那些不满足查询的元组会被过滤掉。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch18/ch18/img.png" alt="img.png"></p><p>扫描进程会遍历缓冲区缓存；为了确保大表不会淘汰有用的数据，PostgreSQL 使用了一个小型的环形缓冲区。扫描同一张表的其他进程会加入到这个环形缓冲区，从而避免额外的磁盘读取；这种扫描被称为同步扫描。这样一来，扫描就不必总是从文件开头开始。</p><p>顺序扫描是读取整个表或其中大部分数据的最有效的方式。换句话说，当选择率较低时，顺序扫描带来的价值最大。(如果选择率高，意味着查询只需要选择几行，那么最好使用索引)。</p><h4 id="18-2-1-成本估算"><a href="#18-2-1-成本估算" class="headerlink" title="18.2.1 成本估算"></a>18.2.1 成本估算</h4><p>在查询的执行计划中，Seq Scan 节点表示顺序扫描：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> flights;<br>                         QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> flights (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.4772</span><span class="hljs-number">.67</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">214867</span> width<span class="hljs-operator">=</span><span class="hljs-number">63</span>)<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>预估的行数是作为基本统计信息的一部分提供的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> reltuples <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;flights&#x27;</span>;<br> reltuples<br>−−−−−−−−−−−<br>    <span class="hljs-number">214867</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>在估算成本时，优化器会考虑以下两个组成部分：磁盘 IO 和 CPU 资源。6</p><p><strong>I&#x2F;O 成本</strong> 的计算方法是将表中的页面数量乘以读取单个页面的成本 (假设页面是按顺序读取的)。当缓冲区管理器请求一个页面时，操作系统实际上从磁盘读取了更多的数据，所以后续的几个页面很可能在操作系统缓存中找到。因此，使用顺序扫描读取单个页面的成本 (规划器按 seq_page_cost 预估) 低于随机访问的成本 (由 random_page_cost 值定义)。</p><p>默认设置适用于 HDD；如果你使用的是 SSD，那么显著降低 random_page_cost 值是有意义的 (seq_page_cost 参数通常保持原样，作为参考值)。由于这些参数之间的最佳比例取决于硬件，因此通常在表空间级别设置 (ALTER TABLESPACE …SET)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> relpages,<br>  current_setting(<span class="hljs-string">&#x27;seq_page_cost&#x27;</span>) <span class="hljs-keyword">AS</span> seq_page_cost,<br>  relpages <span class="hljs-operator">*</span> current_setting(<span class="hljs-string">&#x27;seq_page_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-keyword">AS</span> total<br><span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;flights&#x27;</span>;<br> relpages <span class="hljs-operator">|</span> seq_page_cost <span class="hljs-operator">|</span> total<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br>     <span class="hljs-number">2624</span> <span class="hljs-operator">|</span> <span class="hljs-number">1</span>             <span class="hljs-operator">|</span>  <span class="hljs-number">2624</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>这些计算清楚地显示了不及时清理所导致的表膨胀的后果：表的主分支越大，需要扫描的页面就越多，无论包含多少活跃元组。</p><p><strong>CPU 资源预估</strong> 包括处理每个元组的成本 (规划器按 cpu_tuple_cost 预估)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> reltuples,<br>  current_setting(<span class="hljs-string">&#x27;cpu_tuple_cost&#x27;</span>) <span class="hljs-keyword">AS</span> cpu_tuple_cost,<br>  reltuples <span class="hljs-operator">*</span> current_setting(<span class="hljs-string">&#x27;cpu_tuple_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-keyword">AS</span> total<br><span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;flights&#x27;</span>;<br> reltuples <span class="hljs-operator">|</span> cpu_tuple_cost <span class="hljs-operator">|</span>  total<br>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<br>    <span class="hljs-number">214867</span> <span class="hljs-operator">|</span> <span class="hljs-number">0.01</span>           <span class="hljs-operator">|</span> <span class="hljs-number">2148.67</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>这两个预估值的总和表示计划的总成本。启动成本为零，因为顺序扫描没有前置条件。</p><p>如果需要过滤扫描的表，应用的过滤条件会出现在 Seq Scan 节点的 Filter 部分。预估的行数取决于这些条件的选择率，而成本预估包括了相关的计算开销。</p><p>EXPLAIN ANALYZE 命令显示了实际返回的行数以及被过滤掉的行数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights<br><span class="hljs-keyword">WHERE</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Scheduled&#x27;</span>;<br>                   QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> flights<br>   (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.5309</span><span class="hljs-number">.84</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">15383</span> width<span class="hljs-operator">=</span><span class="hljs-number">63</span>)<br>   (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">15383</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   <span class="hljs-keyword">Filter</span>: ((status)::text <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Scheduled&#x27;</span>::text)<br>   <span class="hljs-keyword">Rows</span> Removed <span class="hljs-keyword">by</span> <span class="hljs-keyword">Filter</span>: <span class="hljs-number">199484</span><br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>让我们看一个更加复杂的执行计划，使用到了聚合：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> seats;<br>                          QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Aggregate (cost<span class="hljs-operator">=</span><span class="hljs-number">24.74</span>.<span class="hljs-number">.24</span><span class="hljs-number">.75</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">8</span>)<br>   −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> seats (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.21</span><span class="hljs-number">.39</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1339</span> width<span class="hljs-operator">=</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>该计划由两个节点组成：上层节点 (Aggregate) 用于计算函数 count，从下层节点 (Seq Scan) 拉取数据，后者负责扫描表。</p><p>Aggregate 节点的启动成本包括聚合本身：在从下层节点获取所有行之前，不可能返回第一行 (在这个例子中只有一行)。聚合成本是根据每个输入行的条件操作的执行成本 (按 cpu_operator_cost 估算) 来估算的：7</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> reltuples,<br>  current_setting(<span class="hljs-string">&#x27;cpu_operator_cost&#x27;</span>) <span class="hljs-keyword">AS</span> cpu_operator_cost,<br>  round((<br>    reltuples <span class="hljs-operator">*</span> current_setting(<span class="hljs-string">&#x27;cpu_operator_cost&#x27;</span>)::<span class="hljs-type">real</span><br>  )::<span class="hljs-type">numeric</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> cpu_cost<br><span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;seats&#x27;</span>;<br> reltuples <span class="hljs-operator">|</span> cpu_operator_cost <span class="hljs-operator">|</span> cpu_cost<br>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<br>      <span class="hljs-number">1339</span> <span class="hljs-operator">|</span> <span class="hljs-number">0.0025</span>            <span class="hljs-operator">|</span>     <span class="hljs-number">3.35</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>计算出的估算值被添加到 Seq Scan 节点的总成本中。</p><p>Aggregate 节点的总成本还包括处理待返回行的成本，按 cpu_tuple_cost 估算：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WITH</span> t(cpu_cost) <span class="hljs-keyword">AS</span> (<br>  <span class="hljs-keyword">SELECT</span> round((<br>    reltuples <span class="hljs-operator">*</span> current_setting(<span class="hljs-string">&#x27;cpu_operator_cost&#x27;</span>)::<span class="hljs-type">real</span><br>  )::<span class="hljs-type">numeric</span>, <span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;seats&#x27;</span><br>)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">21.39</span> <span class="hljs-operator">+</span> t.cpu_cost <span class="hljs-keyword">AS</span> startup_cost,<br>  round((<br>    <span class="hljs-number">21.39</span> <span class="hljs-operator">+</span> t.cpu_cost <span class="hljs-operator">+</span><br>    <span class="hljs-number">1</span> <span class="hljs-operator">*</span> current_setting(<span class="hljs-string">&#x27;cpu_tuple_cost&#x27;</span>)::<span class="hljs-type">real</span><br>  )::<span class="hljs-type">numeric</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> total_cost<br><span class="hljs-keyword">FROM</span> t;<br> startup_cost <span class="hljs-operator">|</span> total_cost<br>−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br>        <span class="hljs-number">24.74</span> <span class="hljs-operator">|</span>      <span class="hljs-number">24.75</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>因此，成本估算的依赖关系如下图所示：<br><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch18/ch18/img_1.png" alt="img_1.png"></p><h3 id="18-3-Parallel-Plans"><a href="#18-3-Parallel-Plans" class="headerlink" title="18.3 Parallel Plans"></a><a name="cp3"></a>18.3 Parallel Plans</h3><p>PostgreSQL 支持并行查询。8 执行查询的领导者进程生成 (通过 postmaster) 多个工作进程，这些进程同时执行计划中相同的并行部分。结果会传递给领导者进程，领导者进程将它们汇总在 Gather 9 节点中。当不接收数据时，领导者进程也可以参与执行计划的并行部分。</p><p>如果需要，你可以通过关闭 parallel_leader_participation 参数来禁止领导者进程参与并行计划的执行。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch18/ch18/img_2.png" alt="img_2.png"></p><p>当然，启动这些进程并在它们之间传递数据并不是没有成本的，因此到目前为止并不是所有的查询都应该并行化。</p><p>此外，即使允许并行执行，也并非计划的所有部分都可以同时处理。一些操作由领导者进程单独以顺序模式执行。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">PostgreSQL 不支持另一种并行计划执行方式，即由多个工作进程执行数据处理，这些工作进程实际上形成了一条流水线 (粗略地说，每个计划节点都由一个单独的进程执行) ; PostgreSQL 开发人员认为这种机制效率低下。<br></code></pre></td></tr></table></figure><h3 id="18-4-Parallel-Sequential-Scans"><a href="#18-4-Parallel-Sequential-Scans" class="headerlink" title="18.4 Parallel Sequential Scans"></a><a name="cp4"></a>18.4 Parallel Sequential Scans</h3><p>为并行处理设计的节点之一是 Parallel Seq Scan 节点，负责执行并行顺序扫描。</p><p>这个名字听起来有点矛盾 (扫描究竟是顺序的还是并行的？)，但无论如何，它反映了操作的本质。如果我们观察文件访问，会发现表页面是顺序读取的，遵循它们在简单顺序扫描中读取的顺序。然而，这个操作是由多个并发进程执行的。为了避免重复扫描同一个页面，执行器通过共享内存来同步这些进程。</p><p>此处有一个微妙的问题，操作系统无法获得典型的顺序扫描的全貌；相反，它看到的是多个执行随机读取的进程。因此，通常用于加速顺序扫描的数据预取几乎变得毫无用处。为了尽量减少这种不愉快的影响 ，PostgreSQL 为每个进程分配的不是一个页面，而是多个连续的页面进行读取。10</p><p>因此，并行扫描看起来并没有多大意义，因为通常的读取成本因进程间的数据传输开销而增加。然而，如果工作进程对获取的行进行了后续处理 (如聚合)，那么总执行时间可能会大大缩短。</p><h4 id="18-4-1-成本估算"><a href="#18-4-1-成本估算" class="headerlink" title="18.4.1 成本估算"></a>18.4.1 成本估算</h4><p>让我们看一个对大表执行聚合的查询。执行计划使用了并行：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch18/ch18/img_3.png" alt="img_3.png"></p><p>所有位于 Gather 节点下方的节点都属于计划的并行部分。这些节点由各个工作进程执行 (这里规划了两个工作进程) ，可能也由领导者进程执行 (除非通过 parallel_leader_participation 参数将此功能关闭)。Gather 节点自身以及所有它上方的节点构成了计划的顺序部分，并仅由领导者进程执行。</p><p>Parallel Seq Scan 节点表示并行堆扫描。rows 字段显示了单个进程要处理的预估平均行数。总而言之，执行必须由三个进程 (一个领导者进程和两个工作进程) 来完成，但是领导者进程将处理较少的行：随着工作进程数量的增加，其工作比重会变小。11 在这个特定的例子中，因子是 2.4。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> reltuples::<span class="hljs-type">numeric</span>, round(reltuples <span class="hljs-operator">/</span> <span class="hljs-number">2.4</span>) <span class="hljs-keyword">AS</span> per_process<br><span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bookings&#x27;</span>;<br> reltuples <span class="hljs-operator">|</span> per_process<br>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−<br>   <span class="hljs-number">2111110</span> <span class="hljs-operator">|</span>      <span class="hljs-number">879629</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>Parallel Seq Scan 的成本计算方式类似于顺序扫描。计算出的值较小，因为每个进程处理的行数较少；I&#x2F;O 部分是完整包含的，因为仍然需要逐页读取整个表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> round((<br>  relpages <span class="hljs-operator">*</span> current_setting(<span class="hljs-string">&#x27;seq_page_cost&#x27;</span>)::<span class="hljs-type">real</span> <span class="hljs-operator">+</span><br>  reltuples <span class="hljs-operator">/</span> <span class="hljs-number">2.4</span> <span class="hljs-operator">*</span> current_setting(<span class="hljs-string">&#x27;cpu_tuple_cost&#x27;</span>)::<span class="hljs-type">real</span><br>)::<span class="hljs-type">numeric</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bookings&#x27;</span>;<br>  round<br>−−−−−−−−−−<br> <span class="hljs-number">22243.29</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>接下来 Partial Aggregate 节点对获取到的数据进行聚合；在此例中，它用于计算行数。</p><p>聚合成本按往常方式进行估算，并添加到表扫描的成本中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WITH</span> t(startup_cost)<br><span class="hljs-keyword">AS</span> (<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-number">22243.29</span> <span class="hljs-operator">+</span> round((<br>    reltuples <span class="hljs-operator">/</span> <span class="hljs-number">2.4</span> <span class="hljs-operator">*</span> current_setting(<span class="hljs-string">&#x27;cpu_operator_cost&#x27;</span>)::<span class="hljs-type">real</span><br>  )::<span class="hljs-type">numeric</span>, <span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">FROM</span> pg_class<br>  <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bookings&#x27;</span><br>)<br><span class="hljs-keyword">SELECT</span> startup_cost,<br>  startup_cost <span class="hljs-operator">+</span> round((<br>    <span class="hljs-number">1</span> <span class="hljs-operator">*</span> current_setting(<span class="hljs-string">&#x27;cpu_tuple_cost&#x27;</span>)::<span class="hljs-type">real</span><br>  )::<span class="hljs-type">numeric</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> total_cost<br><span class="hljs-keyword">FROM</span> t;<br> startup_cost <span class="hljs-operator">|</span> total_cost<br>−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br>     <span class="hljs-number">24442.36</span> <span class="hljs-operator">|</span>   <span class="hljs-number">24442.37</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>下一个节点 (Gather) 由领导者进程执行。该节点负责启动工作进程并收集他们返回的数据。</p><p>在规划过程中，启动进程 (无论数量如何) 的成本估算由 parallel_setup_cost 参数定义，而进程之间每行数据传输的成本按 parallel_tuple_cost 进行估算。</p><p>在这个例子中，启动成本 (用于启动进程) 占大头；这个值被添加到 Partial Aggregate 节点的启动成本中。总成本还包括传输两行的成本；这个值被添加到 Partial Aggregate 节点 12 的总成本中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span><br>  <span class="hljs-number">24442.36</span> <span class="hljs-operator">+</span> round(<br>    current_setting(<span class="hljs-string">&#x27;parallel_setup_cost&#x27;</span>)::<span class="hljs-type">numeric</span>,<br>  <span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> setup_cost,<br>  <span class="hljs-number">24442.37</span> <span class="hljs-operator">+</span> round(<br>    current_setting(<span class="hljs-string">&#x27;parallel_setup_cost&#x27;</span>)::<span class="hljs-type">numeric</span> <span class="hljs-operator">+</span><br>    <span class="hljs-number">2</span> <span class="hljs-operator">*</span> current_setting(<span class="hljs-string">&#x27;parallel_tuple_cost&#x27;</span>)::<span class="hljs-type">numeric</span>,<br>    <span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> total_cost;<br> setup_cost <span class="hljs-operator">|</span> total_cost<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br>   <span class="hljs-number">25442.36</span> <span class="hljs-operator">|</span>   <span class="hljs-number">25442.57</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>最后要说的是，Finalize Aggregate 节点负责聚合 Gather 节点从并行进程接收到的所有部分结果。</p><p>最后的聚合估算与其他任何聚合一样。启动成本基于聚合三行数据的成本；这个值被添加到 Gather 的总成本中 (因为需要所有行来计算结果)。Finalize Aggregate 的总成本还包括返回一行的成本。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WITH</span> t(startup_cost) <span class="hljs-keyword">AS</span> (<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-number">25442.57</span> <span class="hljs-operator">+</span> round((<br>    <span class="hljs-number">3</span> <span class="hljs-operator">*</span> current_setting(<span class="hljs-string">&#x27;cpu_operator_cost&#x27;</span>)::<span class="hljs-type">real</span><br>  )::<span class="hljs-type">numeric</span>, <span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;bookings&#x27;</span><br>)<br><span class="hljs-keyword">SELECT</span> startup_cost,<br>  startup_cost <span class="hljs-operator">+</span> round((<br>    <span class="hljs-number">1</span> <span class="hljs-operator">*</span> current_setting(<span class="hljs-string">&#x27;cpu_tuple_cost&#x27;</span>)::<span class="hljs-type">real</span><br>  )::<span class="hljs-type">numeric</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> total_cost<br><span class="hljs-keyword">FROM</span> t;<br> startup_cost <span class="hljs-operator">|</span> total_cost<br>−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br>     <span class="hljs-number">25442.58</span> <span class="hljs-operator">|</span>   <span class="hljs-number">25442.59</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>成本估算之间的依赖关系取决于节点是否需要在将结果传递给其父节点之前积累数据。聚合操作在获取所有输入行之前无法返回结果，因此其启动成本基于下层节点的总成本。相反，Gather 节点一旦获取到行就开始向上层节点发送，因此，该操作的启动成本取决于下层节点的启动成本，而它的总成本则基于下层节点的总成本。</p><p>以下是依赖关系图：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch18/ch18/img_4.png" alt="img_4.png"></p><h3 id="18-5-Parallel-Execution-Limitations"><a href="#18-5-Parallel-Execution-Limitations" class="headerlink" title="18.5 Parallel Execution Limitations"></a><a name="cp5"></a>18.5 Parallel Execution Limitations</h3><h4 id="18-5-1-后台工作进程数量"><a href="#18-5-1-后台工作进程数量" class="headerlink" title="18.5.1 后台工作进程数量"></a>18.5.1 后台工作进程数量</h4><p>进程数量由三个参数层级控制。同时运行的后台工作进程的最大数量由 max_worker_processes 定义。</p><p>然而，并行查询执行并不是唯一需要后台工作进程的操作。例如，后台工作进程也参与逻辑复制以及被扩展使用。专门为并行计划执行所分配的进程数量受到 max_parallel_workers 的限制。</p><p>在此数字中，最多 max_parallel_workers_per_gather 个进程可以服务于一个领导者进程。</p><p>这些参数的选择取决于以下因素：</p><pre><code class="hljs">硬件能力：系统中必须有专门用于并行执行的空闲核心。表的大小：数据库必须含有大表。典型负载：必须有可能从并行执行中受益的查询。</code></pre><p>这些标准通常适用于 OLAP 系统，而不是 OLTP 系统。</p><p>如果预估要读取的堆数据大小不超过 min_parallel_table_scan_size 值，那么规划器将根本不会考虑并行执行。</p><p>除非特定表在 parallel_workers 存储参数中明确指定了进程数量，否则将按照以下公式计算：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch18/ch18/img_5.png" alt="img_5.png"></p><p>这意味着每当一个表增大三倍时，PostgreSQL 就会为它的处理分配一个额外的并行工作进程。默认设置可以得出以下数据：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch18/ch18/img_6.png" alt="img_6.png"></p><p>无论如何，并行工作进程的数量都不能超过 max_parallel_workers_per_gather 参数定义的限制。</p><p>如果我们查询一个 19MB 的小表 ，那么只会计划并启动一个工作进程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, costs off, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> flights;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Finalize Aggregate (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   −<span class="hljs-operator">&gt;</span> Gather (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">2</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>      Workers Planned: <span class="hljs-number">1</span><br>      Workers Launched: <span class="hljs-number">1</span><br>      −<span class="hljs-operator">&gt;</span> Partial Aggregate (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> loops<span class="hljs-operator">=</span><span class="hljs-number">2</span>)<br>          −<span class="hljs-operator">&gt;</span> Parallel Seq Scan <span class="hljs-keyword">on</span> flights (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">107434</span> lo...<br>(<span class="hljs-number">6</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>对 105 MB 大小的表进行查询，只会获得两个工作进程，因为达到了 max_parallel_workers_per_gather 工作进程数量的限制：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, costs off, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> bookings;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Finalize Aggregate (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   −<span class="hljs-operator">&gt;</span> Gather (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">3</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>      Workers Planned: <span class="hljs-number">2</span><br>      Workers Launched: <span class="hljs-number">2</span><br>      −<span class="hljs-operator">&gt;</span> Partial Aggregate (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> loops<span class="hljs-operator">=</span><span class="hljs-number">3</span>)<br>          −<span class="hljs-operator">&gt;</span> Parallel Seq Scan <span class="hljs-keyword">on</span> bookings (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">703703</span> l...<br>(<span class="hljs-number">6</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>如果我们移除这个限制，那么我们将预估得到三个工作进程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">SET</span> max_parallel_workers_per_gather <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_reload_conf();<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, costs off, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> bookings;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Finalize Aggregate (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   −<span class="hljs-operator">&gt;</span> Gather (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">4</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>      Workers Planned: <span class="hljs-number">3</span><br>      Workers Launched: <span class="hljs-number">3</span><br>      −<span class="hljs-operator">&gt;</span> Partial Aggregate (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> loops<span class="hljs-operator">=</span><span class="hljs-number">4</span>)<br>          −<span class="hljs-operator">&gt;</span> Parallel Seq Scan <span class="hljs-keyword">on</span> bookings (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">527778</span> l...<br>(<span class="hljs-number">6</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>如果在查询执行期间可用的槽数量小于规划的值，那么只会启动可用数量的工作进程。</p><p>让我们将并行进程的总数限制为五个，并同时运行两个查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">SET</span> max_parallel_workers <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_reload_conf();<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, costs off, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> bookings;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Finalize Aggregate (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   −<span class="hljs-operator">&gt;</span> Gather (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">4</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>       Workers Planned: <span class="hljs-number">3</span><br>       Workers Launched: <span class="hljs-number">3</span><br>       −<span class="hljs-operator">&gt;</span> Partial Aggregate (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> loops<span class="hljs-operator">=</span><span class="hljs-number">4</span>)<br>       −<span class="hljs-operator">&gt;</span> Parallel Seq Scan <span class="hljs-keyword">on</span> bookings (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">527778</span> l...<br>(<span class="hljs-number">6</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>尽管在这两种情况下都期望获得三个进程，但其中一个查询只获得了两个。</p><p>让我们恢复默认设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> RESET <span class="hljs-keyword">ALL</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_reload_conf();<br></code></pre></td></tr></table></figure><h4 id="18-5-2-无法并行化的查询"><a href="#18-5-2-无法并行化的查询" class="headerlink" title="18.5.2 无法并行化的查询"></a>18.5.2 无法并行化的查询</h4><p>并非所有查询都可以并行化。13 特别地，以下类型的查询无法使用并行计划：</p><pre><code class="hljs">1. 修改或锁定数据的查询 (UPDATE、DELETE、SELECT FOR UPDATE 等)。此限制不适用于以下命令中的子查询：— CREATE TABLE AS，SELECT INTO，CREATE MATERIALIZED VIEW— REFRESH MATERIALIZED VIEW但是，在所有这些情况下，行插入仍然是顺序执行的。2. 可以暂停的查询。这适用于游标内运行的查询，包括 PL/pgSQL 中的 FOR 循环。3. 调用 PARALLEL UNSAFE 函数的查询。默认情况下，这些都是用户定义的函数和一些标准函数。你可以通过查询系统表来获取完整 unsafe 函数的列表：SELECT * FROM pg_proc WHERE proparallel = ‘u’;4. 函数内的查询，如果这些函数是从一个并行查询中调用的 (为了避免工作进程数量的递归增长)。</code></pre><p>在 PostgreSQL 的未来版本中可能会移除其中一些限制。例如，已经存在在可串行化隔离级别下并行化查询的能力。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">使用诸如 INSERT 和 COPY 等命令并行插入行的方式目前正在开发中。14<br></code></pre></td></tr></table></figure><p>出于以下几个原因，查询可能仍然无法并行化：</p><pre><code class="hljs">此类型的查询根本不支持并行。服务器配置禁止使用并行计划 (例如，由于施加的表大小限制)。并行计划比顺序计划的成本更高。</code></pre><p>要检查查询是否可以并行化，你可以暂时打开 force_parallel_mode 参数。然后规划器将尽可能创建并行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights;<br>                           QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> flights (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.4772</span><span class="hljs-number">.67</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">214867</span> width<span class="hljs-operator">=</span><span class="hljs-number">63</span>)<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> force_parallel_mode <span class="hljs-operator">=</span> <span class="hljs-keyword">on</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Gather (cost<span class="hljs-operator">=</span><span class="hljs-number">1000.00</span>.<span class="hljs-number">.27259</span><span class="hljs-number">.37</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">214867</span> width<span class="hljs-operator">=</span><span class="hljs-number">63</span>)<br> Workers Planned: <span class="hljs-number">1</span><br> Single <span class="hljs-keyword">Copy</span>: <span class="hljs-literal">true</span><br> −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> flights (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.4772</span><span class="hljs-number">.67</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">214867</span> width<span class="hljs-operator">=</span><span class="hljs-number">63</span>)<br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><h4 id="18-5-3-并行限制的查询"><a href="#18-5-3-并行限制的查询" class="headerlink" title="18.5.3 并行限制的查询"></a>18.5.3 并行限制的查询</h4><p>计划中的并行部分越大，潜在的性能提升就越多。然而，某些操作仅由领导者进程严格顺序执行 15，即使它们本身并不干扰并行化。换句话说，这些操作不能出现在 Gather 节点下方的计划树中。</p><p><strong>不可扩展的子查询。</strong> 不可扩展子查询的一个最明显例子 16 是扫描一个 CTE 结果 (在计划中由 CTE Scan 节点表示)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">WITH</span> t <span class="hljs-keyword">AS</span> MATERIALIZED (<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights<br>)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> t;<br>         QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Aggregate<br>   CTE t<br>     −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> flights<br>   −<span class="hljs-operator">&gt;</span> CTE Scan <span class="hljs-keyword">on</span> t<br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>如果 CTE 没有被物化，那么计划中就不会包含 CTE Scan 节点，因此这个限制就不适用。</p><p>但是请注意，如果以并行模式计算 CTE 的成本更低，CTE 本身可以在并行模式下进行计算。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">WITH</span> t <span class="hljs-keyword">AS</span> MATERIALIZED (<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> flights<br>)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t;<br>                   QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> CTE Scan <span class="hljs-keyword">on</span> t<br>   CTE t<br>     −<span class="hljs-operator">&gt;</span> Finalize Aggregate<br>         −<span class="hljs-operator">&gt;</span> Gather<br>             Workers Planned: <span class="hljs-number">1</span><br>             −<span class="hljs-operator">&gt;</span> Partial Aggregate<br>                 −<span class="hljs-operator">&gt;</span> Parallel Seq Scan <span class="hljs-keyword">on</span> flights<br>(<span class="hljs-number">7</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>另一个不可扩展子查询的示例如下图中的 SubPlan 节点所示：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch18/ch18/img_7.png" alt="img_7.png"></p><p>前两行表示主查询的计划：顺序扫描 flights 表，并根据提供的过滤条件检查每一行。过滤条件包含一个子查询；这个子查询的计划从第三行开始。因此，SubPlan 节点在这种情况下会被多次执行，每次顺序扫描获取一行数据时执行一次。</p><p>此计划上层的 Seq Scan 节点不能参与并行执行，因为它依赖于 SubPlan 节点返回的数据。</p><p>最后要提及的是，这里还有一个由 InitPlan 节点表示的不可扩展子查询：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch18/ch18/img_8.png" alt="img_8.png"></p><p>不同于 SubPlan 节点，InitPlan 仅评估一次 (在此例中，每次执行 SubPlan 2 节点时评估一次)。</p><p>InitPlan 的父节点不能参与并行执行 (但是那些接收 InitPlan 评估结果的节点可以，就像在这个例子中一样)。</p><p><strong>临时表。</strong> 临时表不支持并行扫描，因为临时表只能由创建它们的进程独占式访问。临时表的页面在本地缓冲区缓存中处理。要使本地缓存能够被多个进程访问，将需要像在共享缓存中那样的锁定机制，这会使它的其他好处变得不那么明显。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> TEMPORARY <span class="hljs-keyword">TABLE</span> flights_tmp <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> flights_tmp;<br>          QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Aggregate<br>   −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> flights_tmp<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p><strong>并行限制函数。</strong> 定义为 PARALLEL RESTRICTED 的函数仅允许出现在计划的顺序部分中。你可以通过运行以下查询从系统表中获取此类函数的列表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pg_proc <span class="hljs-keyword">WHERE</span> proparallel <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;r&#x27;</span>;<br></code></pre></td></tr></table></figure><p>只有在完全了解所有相关影响，并已经仔细研究了所有施加的限制后，才能将函数标记为 PARALLEL RESTRICTED (更不用说 PARALLEL SAFE)。17</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch17. Statistics</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch17/ch17/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch17/ch17/</url>
    
    <content type="html"><![CDATA[<h2 id="ch17-Statistics"><a href="#ch17-Statistics" class="headerlink" title="ch17. Statistics"></a>ch17. Statistics</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">17.1 Basic Statistics</a></td></tr><tr><td><a href="#cp2">17.2 NULL Values</a></td></tr><tr><td><a href="#cp3">17.3 Distinct Values</a></td></tr><tr><td><a href="#cp4">17.4 Most Common Values</a></td></tr><tr><td><a href="#cp5">17.5 Histogram</a></td></tr><tr><td><a href="#cp6">17.6 Statistics for Non-Scalar Data Types</a></td></tr><tr><td><a href="#cp7">17.7 Average Field Width</a></td></tr><tr><td><a href="#cp8">17.8 Correlation</a></td></tr><tr><td><a href="#cp9">17.9 Expression Statistics</a></td></tr><tr><td><a href="#cp10">17.10 Multivariate Statistics</a></td></tr></tbody></table><h3 id="17-1-Basic-Statistics"><a href="#17-1-Basic-Statistics" class="headerlink" title="17.1 Basic Statistics"></a><a name="cp1"></a>17.1 Basic Statistics</h3><p>基础的关系级统计信息 1 存储在 pg_class 系统目录表中，其中包括以下数据：</p><pre><code class="hljs">关系中元组的数量 (reltuples)关系大小，以页为单位 (relpages)可见性映射中标记的页面数量 (relallvisible)</code></pre><p>以下是 flights 表的这些值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> reltuples, relpages, relallvisible<br><span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;flights&#x27;</span>;<br> reltuples <span class="hljs-operator">|</span> relpages <span class="hljs-operator">|</span> relallvisible<br>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<br>    <span class="hljs-number">214867</span> <span class="hljs-operator">|</span>     <span class="hljs-number">2624</span> <span class="hljs-operator">|</span>          <span class="hljs-number">2624</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>如果查询没有施加任何过滤条件，那么 reltuples 值将作为基数进行估算：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights;<br>                           QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> flights (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.4772</span><span class="hljs-number">.67</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">214867</span> width<span class="hljs-operator">=</span><span class="hljs-number">63</span>)<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>统计信息在表分析期间收集，包括手动收集和自动收集。2 此外，由于基础统计信息至关重要，因此在其他某些操作 (比如 VACUUM FULL 和 CLUSTER、3 CREATE INDEX 和 REINDEX 4 ) 期间也会计算这些数据，并在清理期间进行细化。5</p><p>出于分析目的，会从表中随机选择 300 × default_statistics_target 行进行采样。建立特定精度的统计信息所需的样本大小与进行分析的数据量关系不大，因此不需要考虑表的大小。6</p><p>采样行数取自相同数量 (300 × default_statistics_target) 的随机页面。7 显然，如果表本身越小，那么就可能读取更少的页面，并且为分析选择的行数也会更少。</p><p>在大表中，统计信息收集不包括所有行，因此估算值可能与实际值有所不同。这是完全正常的：如果数据在变化，统计信息无论如何都不可能始终准确。达到数量级的准确度就足以选择一个合适的计划。</p><p>让我们创建一个 flights 表的副本，并禁用自动清理以便可以控制自动分析的开始时间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE TABLE</span> flights_copy(<span class="hljs-keyword">LIKE</span> flights)<br><span class="hljs-keyword">WITH</span> (autovacuum_enabled <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>新表目前还没有统计信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> reltuples, relpages, relallvisible<br><span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;flights_copy&#x27;</span>;<br> reltuples <span class="hljs-operator">|</span> relpages <span class="hljs-operator">|</span> relallvisible<br>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<br>        −<span class="hljs-number">1</span> <span class="hljs-operator">|</span>       <span class="hljs-number">0</span>  <span class="hljs-operator">|</span>            <span class="hljs-number">0</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>值 reltuples &#x3D; −1 用于区分尚未分析的表和没有任何行的真正的空表。</p><p>在表创建后不久，很有可能会有一些行被插入到表中。因此，对当前情况一无所知的规划器会假设表包含 10 个页面：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights_copy;<br>                           QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> flights_copy (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.14</span><span class="hljs-number">.10</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">410</span> width<span class="hljs-operator">=</span><span class="hljs-number">170</span>)<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>行数基于单行的大小进行估算，在计划中显示为 width。行宽度通常是分析期间计算出的平均值，但由于尚未收集过统计信息，因此此处只是基于列数据类型的一个近似值。8</p><p>现在让我们从 flights 表中复制数据并进行分析：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> flights_copy <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-number">0</span> <span class="hljs-number">214867</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> ANALYZE flights_copy;<br></code></pre></td></tr></table></figure><p>收集的统计信息反映了实际的行数 (表的大小足够小，分析器可以收集所有数据的统计信息)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> reltuples, relpages, relallvisible<br><span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;flights_copy&#x27;</span>;<br> reltuples <span class="hljs-operator">|</span> relpages <span class="hljs-operator">|</span> relallvisible<br>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<br>    <span class="hljs-number">214867</span> <span class="hljs-operator">|</span>     <span class="hljs-number">2624</span> <span class="hljs-operator">|</span>             <span class="hljs-number">0</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>relallvisible 值用于估算仅索引扫描的成本。这个值由 VACUUM 更新：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> VACUUM flights_copy;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> relallvisible <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;flights_copy&#x27;</span>;<br> relallvisible<br>−−−−−−−−−−−−−−−<br>          <span class="hljs-number">2624</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>现在让我们在不更新统计信息的情况下将行数翻倍，然后检查计划中的基数预估：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> flights_copy <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> flights_copy;<br> count<br>−−−−−−−−<br> <span class="hljs-number">429734</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights_copy;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> flights_copy (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.9545</span><span class="hljs-number">.34</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">429734</span> width<span class="hljs-operator">=</span><span class="hljs-number">63</span>)<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>尽管 pg_class 的数据是过时的，但预估的结果是准确的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> reltuples, relpages<br><span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;flights_copy&#x27;</span>;<br> reltuples <span class="hljs-operator">|</span> relpages<br>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<br>    <span class="hljs-number">214867</span> <span class="hljs-operator">|</span>     <span class="hljs-number">2624</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>问题在于，如果规划器发现 relpages 和实际文件大小之间存在差距，它可以缩放 reltuples 值以提高预估的准确性。9 由于与 relpages 相比文件大小增加了一倍，规划器调整了预估的行数，并假设数据密度保持不变：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> reltuples <span class="hljs-operator">*</span><br>  (pg_relation_size(<span class="hljs-string">&#x27;flights_copy&#x27;</span>) <span class="hljs-operator">/</span> <span class="hljs-number">8192</span>) <span class="hljs-operator">/</span> relpages <span class="hljs-keyword">AS</span> tuples<br><span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;flights_copy&#x27;</span>;<br> tuples<br>−−−−−−−−<br> <span class="hljs-number">429734</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>当然，这样的调整可能并不总是有效 (例如，如果我们删除了一些行，预估值将保持不变)，但在某些情况下，它允许规划器保持，直到发生了显著变化，触发下一次分析的运行。</p><h3 id="17-2-NULL-Values"><a href="#17-2-NULL-Values" class="headerlink" title="17.2 NULL Values"></a><a name="cp2"></a>17.2 NULL Values</h3><p>尽管理论家们对此不赞成 10，但空值在关系数据库中仍然扮演着重要角色：它们提供了一种简便的方式来反映某个值是未知的或不存在的。</p><p>但是，特殊值需要特殊处理。除了理论上的不一致之外，还有许多实际挑战需要考虑。常规的布尔逻辑被三值逻辑所取代，因此 NOT IN 的行为出人意料。尚不清楚是否应该将空值视为大于或小于常规值 (因此排序时有 NULLS FIRST 和 NULLS LAST 子句)。不太明显的是，聚合函数是否应该考虑空值。严格来说，空值根本就不是一个值，因此规划器需要额外的信息来处理它们。</p><p>除了在关系级收集的最简单的基础统计信息之外，分析器还为关系的每一列收集统计信息。这些数据存储在系统目录表 pg_statistic 中 11，你也可以通过 pg_stats 视图访问，pg_stats 以更简便的格式提供这些信息。</p><p>空值的比例属于列级统计信息；在分析过程中计算，显示为 null_frac 属性。</p><p>例如，在搜索尚未起飞的航班时，我们可以依赖尚未定义的起飞时间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights <span class="hljs-keyword">WHERE</span> actual_departure <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br>                           QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> flights (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.4772</span><span class="hljs-number">.67</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">16702</span> width<span class="hljs-operator">=</span><span class="hljs-number">63</span>)<br>   <span class="hljs-keyword">Filter</span>: (actual_departure <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>为了预估结果，规划器将总行数乘以空值的比例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> round(reltuples <span class="hljs-operator">*</span> s.null_frac) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">rows</span><br><span class="hljs-keyword">FROM</span> pg_class<br>  <span class="hljs-keyword">JOIN</span> pg_stats s <span class="hljs-keyword">ON</span> s.tablename <span class="hljs-operator">=</span> relname<br><span class="hljs-keyword">WHERE</span> s.tablename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;flights&#x27;</span><br>  <span class="hljs-keyword">AND</span> s.attname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;actual_departure&#x27;</span>;<br> <span class="hljs-keyword">rows</span><br>−−−−−−−<br> <span class="hljs-number">16702</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>以下是实际的行数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> flights <span class="hljs-keyword">WHERE</span> actual_departure <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br> count<br>−−−−−−−<br> <span class="hljs-number">16348</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><h3 id="17-3-Distinct-Values"><a href="#17-3-Distinct-Values" class="headerlink" title="17.3 Distinct Values"></a><a name="cp3"></a>17.3 Distinct Values</h3><p>pg_stats 视图中的 n_distinct 字段显示了列中非重复值的数量。</p><p>如果 n_distinct 为负数，其绝对值表示列中非重复值的比例，而不是它们实际的数量。例如，-1 表示所有列值都是唯一的，而 -3 意味着每个值平均出现在三行中。如果非重复值的预估数量超过了总行数的 10%，那么分析器会使用一个比例值来显式；在这种情况下，进一步的数据更新不太可能改变这个比例值。12</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch17/ch17/img.png" alt="img.png"></p><p>如果预期数据分布均匀，那么会使用非重复值的数量。例如，在评估 “column &#x3D; expression” 条件的基数时，如果在规划阶段无法知道表达式的确切值，那么规划器假设该表达式可以以相等的概率取任何列值：13</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch17/ch17/img_1.png" alt="img_1.png"></p><p>如果非重复值的预估数量不正确 (因为分析的行数有限)，那么你可以在列级别覆盖它：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> ...<br>  <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> ...<br>  <span class="hljs-keyword">SET</span> (n_distinct <span class="hljs-operator">=</span> ...);<br></code></pre></td></tr></table></figure><p>如果所有的数据始终均匀分布，则此信息 (加上最小值和最大值) 就足够了。然而，对于非均匀分布 (在实际中更为常见) ，这样的估算是不准确的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">min</span>(cnt), round(<span class="hljs-built_in">avg</span>(cnt)) avg, <span class="hljs-built_in">max</span>(cnt)<br><span class="hljs-keyword">FROM</span> (<br>  <span class="hljs-keyword">SELECT</span> departure_airport, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) cnt<br>  <span class="hljs-keyword">FROM</span> flights<br>  <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> departure_airport<br>) t;<br> min <span class="hljs-operator">|</span> avg  <span class="hljs-operator">|</span>  max<br>−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br> <span class="hljs-number">113</span> <span class="hljs-operator">|</span> <span class="hljs-number">2066</span> <span class="hljs-operator">|</span> <span class="hljs-number">20875</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><h3 id="17-4-Most-Common-Values"><a href="#17-4-Most-Common-Values" class="headerlink" title="17.4 Most Common Values"></a><a name="cp4"></a>17.4 Most Common Values</h3><p>如果数据分布不均，那么会根据高频值 (MCV) 及其频率的统计信息对预估值进行微调。pg_stats 视图分别在 most_common_vals 和 most_common_freqs 字段中显示这些数组。</p><p>以下是各种类型的飞机关于此类统计信息的一个例子：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch17/ch17/img_2.png" alt="img_2.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> most_common_vals <span class="hljs-keyword">AS</span> mcv,<br>  <span class="hljs-keyword">left</span>(most_common_freqs::text,<span class="hljs-number">60</span>) <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;...&#x27;</span> <span class="hljs-keyword">AS</span> mcf<br><span class="hljs-keyword">FROM</span> pg_stats<br><span class="hljs-keyword">WHERE</span> tablename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;flights&#x27;</span> <span class="hljs-keyword">AND</span> attname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;aircraft_code&#x27;</span> \gx<br>−[ RECORD <span class="hljs-number">1</span> ]−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br>mcv <span class="hljs-operator">|</span> &#123;CN1,CR2,SU9,<span class="hljs-number">321</span>,<span class="hljs-number">733</span>,<span class="hljs-number">763</span>,<span class="hljs-number">319</span>,<span class="hljs-number">773</span>&#125;<br>mcf <span class="hljs-operator">|</span> &#123;<span class="hljs-number">0.27886668</span>,<span class="hljs-number">0.27266666</span>,<span class="hljs-number">0.26176667</span>,<span class="hljs-number">0.057166666</span>,<span class="hljs-number">0.037666667</span>,<span class="hljs-number">0.</span>...<br></code></pre></td></tr></table></figure><p>为了预估 “column &#x3D; value” 条件的选择率，只需在 most_common_vals 数组中找到这个值，并从具有相同位置的 most_common_freqs 数组元素中获取其频率即可：14</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights <span class="hljs-keyword">WHERE</span> aircraft_code <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;733&#x27;</span>;<br>                          QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> flights (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.5309</span><span class="hljs-number">.84</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">8093</span> width<span class="hljs-operator">=</span><span class="hljs-number">63</span>)<br>   <span class="hljs-keyword">Filter</span>: (aircraft_code <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;733&#x27;</span>::bpchar)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> round(reltuples <span class="hljs-operator">*</span> s.most_common_freqs[<br>  array_position((s.most_common_vals::text::text[]),<span class="hljs-string">&#x27;733&#x27;</span>)<br>])<br><span class="hljs-keyword">FROM</span> pg_class<br>  <span class="hljs-keyword">JOIN</span> pg_stats s <span class="hljs-keyword">ON</span> s.tablename <span class="hljs-operator">=</span> relname<br><span class="hljs-keyword">WHERE</span> s.tablename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;flights&#x27;</span><br>  <span class="hljs-keyword">AND</span> s.attname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;aircraft_code&#x27;</span>;<br> round<br>−−−−−−−<br>  <span class="hljs-number">8093</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>显然，这样的估算值与实际值相近：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> flights <span class="hljs-keyword">WHERE</span> aircraft_code <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;733&#x27;</span>;<br> count<br>−−−−−−−<br>  <span class="hljs-number">8263</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>MCV 列表还用于预估不等条件的选择率。例如，”column &lt; value” 这样的条件要求分析器在 most_common_vals 中搜索所有小于目标值的值，并将 most_common_freqs 中列出的相应频率相加。15</p><p>当非重复值不是太多时，MCV 统计信息效果最佳。数组的最大大小由 default_statistics_target 参数定义，该参数也限制了用于分析目的而随机采样的行数。</p><p>在某些情况下，增加默认参数值是有意义的，从而扩大 MCV 列表并提高预估的准确性。你可以在列级别执行该操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> ...<br>  <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> ...<br>  <span class="hljs-keyword">SET</span> STATISTICS ...;<br></code></pre></td></tr></table></figure><p>采样大小也会增长，但仅限于指定的表。</p><p>由于 MCV 数组存储了实际的值，因此可能会占用相当多的空间。为了控制 pg_statistic 大小并避免给规划器增加无用功，大于 1 kB 的值会被排除在分析和统计之外。但由于如此大的值可能是唯一的，它们可能本来就不会出现在 most_common_vals 中。</p><h3 id="17-5-Histogram"><a href="#17-5-Histogram" class="headerlink" title="17.5 Histogram"></a><a name="cp5"></a>17.5 Histogram</h3><p>如果非重复值太多以至于无法存储在数组中，PostgreSQL 便会使用直方图。在这种情况下，值会分布在直方图的多个桶之间。桶的数量也受到 default_statistics_target 参数的限制。</p><p>桶宽度的选择方式是使每个桶获得大致相同数量的值 (这个特性在图中通过面积相等的阴影矩形来体现)。直方图不考虑包含在 MCV 列表中的值。因此，每个桶中值的累积频率等于</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch17/ch17/img_3.png" alt="img_3.png"></p><p>直方图作为桶的边界值数组存储在 pg_stats 视图的 histogram_bounds 字段中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">left</span>(histogram_bounds::text,<span class="hljs-number">60</span>) <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;...&#x27;</span> <span class="hljs-keyword">AS</span> hist_bounds<br><span class="hljs-keyword">FROM</span> pg_stats s<br><span class="hljs-keyword">WHERE</span> s.tablename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;boarding_passes&#x27;</span> <span class="hljs-keyword">AND</span> s.attname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;seat_no&#x27;</span>;<br>                           hist_bounds<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> &#123;<span class="hljs-number">10</span>B,<span class="hljs-number">10</span>E,<span class="hljs-number">10</span>F,<span class="hljs-number">10</span>F,<span class="hljs-number">11</span>H,<span class="hljs-number">12</span>B,<span class="hljs-number">13</span>B,<span class="hljs-number">14</span>B,<span class="hljs-number">14</span>H,<span class="hljs-number">15</span>G,<span class="hljs-number">16</span>B,<span class="hljs-number">17</span>B,<span class="hljs-number">17</span>H,<span class="hljs-number">19</span>B,<span class="hljs-number">19</span>B...<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>结合 MCV 列表，直方图用于估算大于和小于条件的选择率等操作 16。例如，让我们看一下为后排座位签发的登机牌数量：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch17/ch17/img_4.png" alt="img_4.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> boarding_passes <span class="hljs-keyword">WHERE</span> seat_no <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;30B&#x27;</span>;<br> QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> boarding_passes (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.157350</span><span class="hljs-number">.10</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">2983242</span> ...<br>   <span class="hljs-keyword">Filter</span>: ((seat_no)::text <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;30B&#x27;</span>::text)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>我特意选择了位于两个直方图桶之间边界上的座位号。这个条件的选择率将估算为<br><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch17/ch17/img_5.png" alt="img_5.png"><br>，其中 N 是包含满足条件的值 (即位于指定值右侧的桶) 的桶数量。同时还需要考虑到 MCV 不包含在直方图中。</p><p>顺便说一下，空值也不会出现在直方图中，但 seat_no 列本来就没有这样的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> s.null_frac <span class="hljs-keyword">FROM</span> pg_stats s<br><span class="hljs-keyword">WHERE</span> s.tablename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;boarding_passes&#x27;</span> <span class="hljs-keyword">AND</span> s.attname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;seat_no&#x27;</span>;<br> null_frac<br>−−−−−−−−−−−<br>         <span class="hljs-number">0</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>首先，让我们找出满足条件的 MCV 的比例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(s.most_common_freqs[<br>  array_position((s.most_common_vals::text::text[]),v)<br>])<br><span class="hljs-keyword">FROM</span> pg_stats s, <span class="hljs-built_in">unnest</span>(s.most_common_vals::text::text[]) v<br><span class="hljs-keyword">WHERE</span> s.tablename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;boarding_passes&#x27;</span> <span class="hljs-keyword">AND</span> s.attname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;seat_no&#x27;</span><br>  <span class="hljs-keyword">AND</span> v <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;30B&#x27;</span>;<br>    sum<br>−−−−−−−−−−−−<br> <span class="hljs-number">0.21226665</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>整体 MCV 的占比 (直方图忽略的部分) 为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(s.most_common_freqs[<br>  array_position((s.most_common_vals::text::text[]),v)<br>])<br><span class="hljs-keyword">FROM</span> pg_stats s, <span class="hljs-built_in">unnest</span>(s.most_common_vals::text::text[]) v<br><span class="hljs-keyword">WHERE</span> s.tablename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;boarding_passes&#x27;</span> <span class="hljs-keyword">AND</span> s.attname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;seat_no&#x27;</span>;<br>    sum<br>−−−−−−−−−−−−<br> <span class="hljs-number">0.67816657</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>由于符合指定条件的值恰好占据了 𝑁 个桶 (在可能的 100 个桶中)，我们得到以下估算：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> round( reltuples <span class="hljs-operator">*</span> (<br>    <span class="hljs-number">0.21226665</span> <span class="hljs-comment">-- MCV share</span><br>  <span class="hljs-operator">+</span> (<span class="hljs-number">1</span> <span class="hljs-operator">-</span> <span class="hljs-number">0.67816657</span> <span class="hljs-operator">-</span> <span class="hljs-number">0</span>) <span class="hljs-operator">*</span> (<span class="hljs-number">51</span> <span class="hljs-operator">/</span> <span class="hljs-number">100.0</span>) <span class="hljs-comment">-- histogram share</span><br>))<br><span class="hljs-keyword">FROM</span> pg_class<br><span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;boarding_passes&#x27;</span>;<br>  round<br>−−−−−−−−−<br> <span class="hljs-number">2983242</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch17/ch17/img_6.png" alt="img_6.png"></p><p>在非边界值的一般情况下，规划器采用线性插值来考虑包含目标值的桶的部分。</p><p>以下是后座的实际数量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> boarding_passes <span class="hljs-keyword">WHERE</span> seat_no <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;30B&#x27;</span>;<br>  count<br>−−−−−−−−−<br> <span class="hljs-number">2993735</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>随着增加 default_statistics_target 值，估算的准确性可能会提高，但正如我们的例子所示，即使列包含许多唯一值，直方图与 MCV 列表相结合通常也可以提供很好的结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> n_distinct <span class="hljs-keyword">FROM</span> pg_stats<br><span class="hljs-keyword">WHERE</span> tablename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;boarding_passes&#x27;</span> <span class="hljs-keyword">AND</span> attname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;seat_no&#x27;</span>;<br> n_distinct<br>−−−−−−−−−−−−<br>        <span class="hljs-number">461</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>只有当能产生更好的规划时，提高预估的准确性才有意义。不加思考便增加 default_statistics_target 值可能会减慢规划和分析的速度，而不会带来任何好处。话虽如此，减小此参数值 (降至零) 可能会导致选择不良的计划，即使这确实加快了规划和分析的速度。这种节省通常是不合理的。</p><h3 id="17-6-Statistics-for-Non-Scalar-Data-Types"><a href="#17-6-Statistics-for-Non-Scalar-Data-Types" class="headerlink" title="17.6 Statistics for Non-Scalar Data Types"></a><a name="cp6"></a>17.6 Statistics for Non-Scalar Data Types</h3><p>对于非标量数据类型，PostgreSQL 不仅可以收集值的分布统计信息，还可以收集用于构造这些值的元素的分布信息。当查询不符合第一范式的列时，它可以提高规划的准确性。</p><pre><code class="hljs">most_common_elems 和 most_common_elem_freqs 数组显示了高频元素列表及其使用频率。收集这些统计信息用于估算在数组 17 和 tsvector 18 数据类型上的操作选择率。elem_count_histogram 数组显示了值中不同元素的数量的直方图，收集此数据仅用于估算在数组上操作的选择率。对于范围类型，PostgreSQL 为范围长度以及范围的下边界与上边界构建了分布直方图。这些直方图用于估算在这些类型上各种操作的选择率 19，但 pg_stats 视图没有显示它们。</code></pre><p>multirange 数据类型也会收集类似的统计信息。20</p><h3 id="17-7-Average-Field-Width"><a href="#17-7-Average-Field-Width" class="headerlink" title="17.7 Average Field Width"></a><a name="cp7"></a>17.7 Average Field Width</h3><p>pg_stats 视图中的 avg_width 字段显示了存储在列中的值的平均大小。当然，对于像 integer 或 char(3) 这样的类型，这个大小总是相同的，但是对于变长的数据类型，比如 text，列与列之间可能有很大的不同：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> attname, avg_width <span class="hljs-keyword">FROM</span> pg_stats<br><span class="hljs-keyword">WHERE</span> (tablename, attname) <span class="hljs-keyword">IN</span> ( <span class="hljs-keyword">VALUES</span><br>  (<span class="hljs-string">&#x27;tickets&#x27;</span>, <span class="hljs-string">&#x27;passenger_name&#x27;</span>), (<span class="hljs-string">&#x27;ticket_flights&#x27;</span>,<span class="hljs-string">&#x27;fare_conditions&#x27;</span>)<br>);<br>     attname     <span class="hljs-operator">|</span> avg_width<br>−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−<br> fare_conditions <span class="hljs-operator">|</span>         <span class="hljs-number">8</span><br> passenger_name  <span class="hljs-operator">|</span>        <span class="hljs-number">16</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>该统计信息用于估算排序或哈希等这类操作所需的内存量。</p><h3 id="17-8-Correlation"><a href="#17-8-Correlation" class="headerlink" title="17.8 Correlation"></a><a name="cp8"></a>17.8 Correlation</h3><p>pg_stats 视图中的 correlation 字段显示了数据的物理顺序和比较操作所定义的逻辑顺序之间的相关性。如果值严格按升序存储，那么它们的相关性将接近于 1；<br>如果按降序排列，那么相关性将接近 -1。数据在磁盘上的分布越混乱，相关性越接近于零。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> attname, correlation<br><span class="hljs-keyword">FROM</span> pg_stats <span class="hljs-keyword">WHERE</span> tablename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;airports_data&#x27;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">abs</span>(correlation) <span class="hljs-keyword">DESC</span>;<br>  attname     <span class="hljs-operator">|</span> correlation<br>−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−<br> coordinates  <span class="hljs-operator">|</span><br> airport_code <span class="hljs-operator">|</span> −<span class="hljs-number">0.21120238</span><br> city         <span class="hljs-operator">|</span>  −<span class="hljs-number">0.1970127</span><br> airport_name <span class="hljs-operator">|</span> −<span class="hljs-number">0.18223621</span><br> timezone     <span class="hljs-operator">|</span>  <span class="hljs-number">0.17961165</span><br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>注意，此统计信息不适用于 coordinates 列：对于 point 类型，没有定义小于和大于操作符。</p><p>相关性用于估算索引扫描的成本。</p><h3 id="17-9-Expression-Statistics"><a href="#17-9-Expression-Statistics" class="headerlink" title="17.9 Expression Statistics"></a><a name="cp9"></a>17.9 Expression Statistics</h3><p>仅当比较操作的左侧或右侧部分引用了列本身并且不包含任何表达式时，才能使用列级统计信息。例如，规划器无法预测对列进行函数计算将如何影响统计信息，因此对于 “function-call &#x3D; constant” 这样的条件，选择率总是估算为 0.5%：21</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights<br><span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">extract</span>(<br>  <span class="hljs-keyword">month</span> <span class="hljs-keyword">FROM</span> scheduled_departure <span class="hljs-keyword">AT</span> <span class="hljs-type">TIME</span> ZONE <span class="hljs-string">&#x27;Europe/Moscow&#x27;</span><br>) <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> flights (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.6384</span><span class="hljs-number">.17</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1074</span> width<span class="hljs-operator">=</span><span class="hljs-number">63</span>)<br>   <span class="hljs-keyword">Filter</span>: (<span class="hljs-built_in">EXTRACT</span>(<span class="hljs-keyword">month</span> <span class="hljs-keyword">FROM</span> (scheduled_departure <span class="hljs-keyword">AT</span> <span class="hljs-type">TIME</span> ZONE ...<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> round(reltuples <span class="hljs-operator">*</span> <span class="hljs-number">0.005</span>)<br><span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;flights&#x27;</span>;<br> round<br>−−−−−−−<br>  <span class="hljs-number">1074</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>规划器对函数的语义一无所知，即使是标准函数也是如此。我们的常识表明，在一月份执飞的航班数量大约占总航班数量的 1&#x2F;12 左右，这一数字比预测值高出一个数量级。</p><p>为了提高估算的准确性，我们需要收集表达式统计信息，而不是依赖于列级别的统计信息。有两种方法可以做到这一点。</p><h4 id="17-9-1-扩展表达式统计信息"><a href="#17-9-1-扩展表达式统计信息" class="headerlink" title="17.9.1 扩展表达式统计信息"></a>17.9.1 扩展表达式统计信息</h4><p>第一个方法是使用扩展表达式统计信息 22。默认情况下不会收集此类统计信息；你必须通过运行 CREATE STATISTICS 命令手动创建相应的数据库对象：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> STATISTICS flights_expr <span class="hljs-keyword">ON</span> (<span class="hljs-built_in">extract</span>(<br>    <span class="hljs-keyword">month</span> <span class="hljs-keyword">FROM</span> scheduled_departure <span class="hljs-keyword">AT</span> <span class="hljs-type">TIME</span> ZONE <span class="hljs-string">&#x27;Europe/Moscow&#x27;</span><br>))<br><span class="hljs-keyword">FROM</span> flights;<br></code></pre></td></tr></table></figure><p>数据收集之后，估算的准确性便会提高：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> ANALYZE flights;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights<br><span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">extract</span>(<br>  <span class="hljs-keyword">month</span> <span class="hljs-keyword">FROM</span> scheduled_departure <span class="hljs-keyword">AT</span> <span class="hljs-type">TIME</span> ZONE <span class="hljs-string">&#x27;Europe/Moscow&#x27;</span><br>) <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> flights (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.6384</span><span class="hljs-number">.17</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">16667</span> width<span class="hljs-operator">=</span><span class="hljs-number">63</span>)<br>   <span class="hljs-keyword">Filter</span>: (<span class="hljs-built_in">EXTRACT</span>(<span class="hljs-keyword">month</span> <span class="hljs-keyword">FROM</span> (scheduled_departure <span class="hljs-keyword">AT</span> <span class="hljs-type">TIME</span> ZONE ...<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>要应用所收集的统计信息，查询必须指定和 CREATE STATISTICS 命令形式完全相同的表达式。</p><p>扩展统计信息的大小限制可以通过运行 ALTER STATISTICS 命令单独调整。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> STATISTICS flights_expr <span class="hljs-keyword">SET</span> STATISTICS <span class="hljs-number">42</span>;<br></code></pre></td></tr></table></figure><p>所有与扩展统计信息相关的元数据都存储在系统目录的 pg_statistic_ext 表中，而收集的数据本身位于一个名为 pg_statistic_ext_data 的单独的表中。这种分离用于实现对敏感信息的访问控制。</p><p>特定用户可用的扩展表达式统计信息位于一个单独的视图中，以一种更简便的格式显示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">left</span>(expr,<span class="hljs-number">50</span>) <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;...&#x27;</span> <span class="hljs-keyword">AS</span> expr,<br>  null_frac, avg_width, n_distinct,<br>  most_common_vals <span class="hljs-keyword">AS</span> mcv,<br>  <span class="hljs-keyword">left</span>(most_common_freqs::text,<span class="hljs-number">50</span>) <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;...&#x27;</span> <span class="hljs-keyword">AS</span> mcf,<br>  correlation<br><span class="hljs-keyword">FROM</span> pg_stats_ext_exprs<br><span class="hljs-keyword">WHERE</span> statistics_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;flights_expr&#x27;</span> \gx<br>−[ RECORD <span class="hljs-number">1</span> ]−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br>expr        <span class="hljs-operator">|</span> <span class="hljs-built_in">EXTRACT</span>(<span class="hljs-keyword">month</span> <span class="hljs-keyword">FROM</span> (scheduled_departure <span class="hljs-keyword">AT</span> <span class="hljs-type">TIME</span> ZO...<br>null_frac   <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br>avg_width   <span class="hljs-operator">|</span> <span class="hljs-number">8</span><br>n_distinct  <span class="hljs-operator">|</span> <span class="hljs-number">12</span><br>mcv         <span class="hljs-operator">|</span> &#123;<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">10</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>&#125;<br>mcf         <span class="hljs-operator">|</span> &#123;<span class="hljs-number">0.12053333</span>,<span class="hljs-number">0.11326667</span>,<span class="hljs-number">0.0802</span>,<span class="hljs-number">0.07976667</span>,<span class="hljs-number">0.0775666</span>...<br>correlation <span class="hljs-operator">|</span> <span class="hljs-number">0.08355749</span><br></code></pre></td></tr></table></figure><h4 id="17-9-2-表达式索引统计信息"><a href="#17-9-2-表达式索引统计信息" class="headerlink" title="17.9.2 表达式索引统计信息"></a>17.9.2 表达式索引统计信息</h4><p>另一种改善基数估算的方式是使用为表达式索引收集的特殊统计信息；创建此类索引时会自动收集这些统计信息，就像对表进行收集一样。如果确实需要索引，这种方法会非常方便。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DROP</span> STATISTICS flights_expr;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> flights(<span class="hljs-built_in">extract</span>(<br><span class="hljs-keyword">month</span> <span class="hljs-keyword">FROM</span> scheduled_departure <span class="hljs-keyword">AT</span> <span class="hljs-type">TIME</span> ZONE <span class="hljs-string">&#x27;Europe/Moscow&#x27;</span><br>));<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> ANALYZE flights;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights<br><span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">extract</span>(<br>  <span class="hljs-keyword">month</span> <span class="hljs-keyword">FROM</span> scheduled_departure <span class="hljs-keyword">AT</span> <span class="hljs-type">TIME</span> ZONE <span class="hljs-string">&#x27;Europe/Moscow&#x27;</span><br>) <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Bitmap Heap Scan <span class="hljs-keyword">on</span> flights (cost<span class="hljs-operator">=</span><span class="hljs-number">324.86</span>.<span class="hljs-number">.3247</span><span class="hljs-number">.92</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">17089</span> wi...<br>   Recheck Cond: (<span class="hljs-built_in">EXTRACT</span>(<span class="hljs-keyword">month</span> <span class="hljs-keyword">FROM</span> (scheduled_departure <span class="hljs-keyword">AT</span> TIME...<br>   −<span class="hljs-operator">&gt;</span> Bitmap Index Scan <span class="hljs-keyword">on</span> flights_extract_idx (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.320</span><span class="hljs-number">.5</span>...<br>       Index Cond: (<span class="hljs-built_in">EXTRACT</span>(<span class="hljs-keyword">month</span> <span class="hljs-keyword">FROM</span> (scheduled_departure <span class="hljs-keyword">AT</span> TI...<br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>表达式索引的统计信息与表上的统计信息以相同的方式存储。例如，当查询 pg_stats 时，你可以通过指定索引名称为 tablename 来获取非重复值的数量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> n_distinct <span class="hljs-keyword">FROM</span> pg_stats<br><span class="hljs-keyword">WHERE</span> tablename <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;flights_extract_idx&#x27;</span>;<br> n_distinct<br>−−−−−−−−−−−−<br>         <span class="hljs-number">12</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>你可以使用 ALTER INDEX 命令来调整与索引相关的统计信息的准确性。如果你不知道索引表达式对应的列名，则需要先找出它。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> attname <span class="hljs-keyword">FROM</span> pg_attribute<br><span class="hljs-keyword">WHERE</span> attrelid <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;flights_extract_idx&#x27;</span>::regclass;<br> attname<br>−−−−−−−−−<br> <span class="hljs-built_in">extract</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> INDEX flights_extract_idx<br>  <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> extract <span class="hljs-keyword">SET</span> STATISTICS <span class="hljs-number">42</span>;<br></code></pre></td></tr></table></figure><h3 id="17-10-Multivariate-Statistics"><a href="#17-10-Multivariate-Statistics" class="headerlink" title="17.10 Multivariate Statistics"></a><a name="cp10"></a>17.10 Multivariate Statistics</h3><p>你还可以收集涵盖多个列的多元统计信息。作为前置条件，你必须使用 CREATE STATISTICS 命令手动创建相应的扩展统计信息。</p><p>PostgreSQL 实现了三种类型的多元统计信息。</p><h4 id="17-10-1-列之间的函数依赖"><a href="#17-10-1-列之间的函数依赖" class="headerlink" title="17.10.1 列之间的函数依赖"></a>17.10.1 列之间的函数依赖</h4><p>如果一列中的值 (完全或部分) 依赖于另一列中的值，并且过滤条件包括这两列，那么基数预估会偏低。</p><p>让我们考虑一个包含两个过滤条件的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> flights<br><span class="hljs-keyword">WHERE</span> flight_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;PG0007&#x27;</span> <span class="hljs-keyword">AND</span> departure_airport <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;VKO&#x27;</span>;<br> count<br>−−−−−−−<br>   <span class="hljs-number">396</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>估算值被严重低估：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights<br><span class="hljs-keyword">WHERE</span> flight_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;PG0007&#x27;</span> <span class="hljs-keyword">AND</span> departure_airport <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;VKO&#x27;</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Bitmap Heap Scan <span class="hljs-keyword">on</span> flights (cost<span class="hljs-operator">=</span><span class="hljs-number">10.49</span>.<span class="hljs-number">.816</span><span class="hljs-number">.84</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">15</span> width<span class="hljs-operator">=</span><span class="hljs-number">63</span>)<br>   Recheck Cond: (flight_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;PG0007&#x27;</span>::bpchar)<br>   <span class="hljs-keyword">Filter</span>: (departure_airport <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;VKO&#x27;</span>::bpchar)<br>   −<span class="hljs-operator">&gt;</span> Bitmap Index Scan <span class="hljs-keyword">on</span> flights_flight_no_scheduled_departure_key<br>       (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.10</span><span class="hljs-number">.49</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">276</span> width<span class="hljs-operator">=</span><span class="hljs-number">0</span>)<br>       Index Cond: (flight_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;PG0007&#x27;</span>::bpchar)<br>(<span class="hljs-number">6</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>这是关联谓词的一个众所周知的问题。规划器会假设谓词之间互不依赖，因此整体选择率被估算为逻辑与连接的过滤条件的选择率之积。上面的计划清楚地说明了这个问题：一旦 Bitmap Heap Scan 节点按 departure_airport 列的条件过滤结果，那么 Bitmap Index Scan 在 flight_no 列上的条件的预估值就会大大减少。</p><p>然而，我们确实知道飞机是由航班号明确定义的：第二个条件实际上是多余的 (当然，除非机场名称有误)。在这种情况下，我们可以通过应用函数依赖的扩展统计信息来改善估算。</p><p>让我们在两个列之间的函数依赖上创建一个扩展统计信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> STATISTICS flights_dep(dependencies)<br><span class="hljs-keyword">ON</span> flight_no, departure_airport <span class="hljs-keyword">FROM</span> flights;<br></code></pre></td></tr></table></figure><p>下一次分析将收集此统计信息，并且预估值得到了改善：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> ANALYZE flights;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights<br><span class="hljs-keyword">WHERE</span> flight_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;PG0007&#x27;</span><br>  <span class="hljs-keyword">AND</span> departure_airport <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;VKO&#x27;</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Bitmap Heap Scan <span class="hljs-keyword">on</span> flights (cost<span class="hljs-operator">=</span><span class="hljs-number">10.57</span>.<span class="hljs-number">.819</span><span class="hljs-number">.51</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">277</span> width<span class="hljs-operator">=</span><span class="hljs-number">63</span>)<br>   Recheck Cond: (flight_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;PG0007&#x27;</span>::bpchar)<br>   <span class="hljs-keyword">Filter</span>: (departure_airport <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;VKO&#x27;</span>::bpchar)<br>   −<span class="hljs-operator">&gt;</span> Bitmap Index Scan <span class="hljs-keyword">on</span> flights_flight_no_scheduled_departure_key<br>       (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.10</span><span class="hljs-number">.50</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">277</span> width<span class="hljs-operator">=</span><span class="hljs-number">0</span>)<br>       Index Cond: (flight_no <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;PG0007&#x27;</span>::bpchar)<br>(<span class="hljs-number">6</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>收集的统计信息存储在系统目录中，可以像这样访问：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> dependencies<br><span class="hljs-keyword">FROM</span> pg_stats_ext <span class="hljs-keyword">WHERE</span> statistics_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;flights_dep&#x27;</span>;<br>               dependencies<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> &#123;&quot;2 =&gt; 5&quot;: <span class="hljs-number">1.000000</span>, &quot;5 =&gt; 2&quot;: <span class="hljs-number">0.010200</span>&#125;<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>此处的 2 和 5 是存储在 pg_attribute 表中的列编号，而相应的值定义了函数依赖的程度：从 0 (无依赖) 到 1 (第二列中的值完全依赖于第一列中的值)。</p><h4 id="17-10-2-多元非重复值的数量"><a href="#17-10-2-多元非重复值的数量" class="headerlink" title="17.10.2 多元非重复值的数量"></a>17.10.2 多元非重复值的数量</h4><p>不同列中值的唯一组合的统计信息可以改善在多个列上执行的 GROUP BY 操作的基数估算。</p><p>例如，此处估算的可能的出发机场和到达机场的配对数量是机场总数的平方；然而，实际值要小得多，因为并非所有的机场对都通过直达航班连接：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">FROM</span> (<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> departure_airport, arrival_airport <span class="hljs-keyword">FROM</span> flights<br>) t;<br> count<br>−−−−−−−<br>   <span class="hljs-number">618</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> departure_airport, arrival_airport<br><span class="hljs-keyword">FROM</span> flights;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> HashAggregate (cost<span class="hljs-operator">=</span><span class="hljs-number">5847.01</span>.<span class="hljs-number">.5955</span><span class="hljs-number">.16</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">10816</span> width<span class="hljs-operator">=</span><span class="hljs-number">8</span>)<br>   <span class="hljs-keyword">Group</span> Key: departure_airport, arrival_airport<br>   −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> flights (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.4772</span><span class="hljs-number">.67</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">214867</span> width<span class="hljs-operator">=</span><span class="hljs-number">8</span>)<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>让我们定义并收集非重复值的扩展统计信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> STATISTICS flights_nd(ndistinct)<br><span class="hljs-keyword">ON</span> departure_airport, arrival_airport <span class="hljs-keyword">FROM</span> flights;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> ANALYZE flights;<br></code></pre></td></tr></table></figure><p>现在基数估算得到改善：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> departure_airport, arrival_airport<br><span class="hljs-keyword">FROM</span> flights;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> HashAggregate (cost<span class="hljs-operator">=</span><span class="hljs-number">5847.01</span>.<span class="hljs-number">.5853</span><span class="hljs-number">.19</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">618</span> width<span class="hljs-operator">=</span><span class="hljs-number">8</span>)<br>   <span class="hljs-keyword">Group</span> Key: departure_airport, arrival_airport<br>   −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> flights (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.4772</span><span class="hljs-number">.67</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">214867</span> width<span class="hljs-operator">=</span><span class="hljs-number">8</span>)<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>你可以在系统目录中查看收集的统计信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> n_distinct<br><span class="hljs-keyword">FROM</span> pg_stats_ext <span class="hljs-keyword">WHERE</span> statistics_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;flights_nd&#x27;</span>;<br>  n_distinct<br>−−−−−−−−−−−−−−−<br> &#123;&quot;5, 6&quot;: <span class="hljs-number">618</span>&#125;<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><h4 id="17-10-3-多元-MCV-列表"><a href="#17-10-3-多元-MCV-列表" class="headerlink" title="17.10.3 多元 MCV 列表"></a>17.10.3 多元 MCV 列表</h4><p>如果值的分布不均，仅依赖函数依赖可能是不够的，因为估算的准确性高度依赖于特定的一组值。例如，规划器低估了波音 737 从谢列梅捷沃机场出发的航班数量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> flights<br><span class="hljs-keyword">WHERE</span> departure_airport <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SVO&#x27;</span> <span class="hljs-keyword">AND</span> aircraft_code <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;733&#x27;</span>;<br> count<br>−−−−−−−<br>  <span class="hljs-number">2037</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights<br><span class="hljs-keyword">WHERE</span> departure_airport <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SVO&#x27;</span> <span class="hljs-keyword">AND</span> aircraft_code <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;733&#x27;</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> flights (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.5847</span><span class="hljs-number">.00</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">736</span> width<span class="hljs-operator">=</span><span class="hljs-number">63</span>)<br>   <span class="hljs-keyword">Filter</span>: ((departure_airport <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SVO&#x27;</span>::bpchar) <span class="hljs-keyword">AND</span> (aircraft_cod...<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>在这种情况下，你可以通过收集多元 MCV 列表的统计信息来改善估算：23</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> STATISTICS flights_mcv(mcv)<br><span class="hljs-keyword">ON</span> departure_airport, aircraft_code <span class="hljs-keyword">FROM</span> flights;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> ANALYZE flights;<br></code></pre></td></tr></table></figure><p>新的基数估算更加准确：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> flights<br><span class="hljs-keyword">WHERE</span> departure_airport <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SVO&#x27;</span> <span class="hljs-keyword">AND</span> aircraft_code <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;733&#x27;</span>;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> flights (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.5847</span><span class="hljs-number">.00</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1927</span> width<span class="hljs-operator">=</span><span class="hljs-number">63</span>)<br>   <span class="hljs-keyword">Filter</span>: ((departure_airport <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SVO&#x27;</span>::bpchar) <span class="hljs-keyword">AND</span> (aircraft_cod...<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>为了得到此估算值，规划器依赖于存储在系统目录中的频率值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">values</span>, frequency<br><span class="hljs-keyword">FROM</span> pg_statistic_ext stx<br>  <span class="hljs-keyword">JOIN</span> pg_statistic_ext_data stxd <span class="hljs-keyword">ON</span> stx.oid <span class="hljs-operator">=</span> stxd.stxoid,<br>  pg_mcv_list_items(stxdmcv) m<br><span class="hljs-keyword">WHERE</span> stxname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;flights_mcv&#x27;</span><br><span class="hljs-keyword">AND</span> <span class="hljs-keyword">values</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;&#123;SVO,773&#125;&#x27;</span>;<br>  <span class="hljs-keyword">values</span>   <span class="hljs-operator">|</span>      frequency<br>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−<br> &#123;SVO,<span class="hljs-number">773</span>&#125; <span class="hljs-operator">|</span> <span class="hljs-number">0.005266666666666667</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>就像常规 MCV 列表一样，多元 MCV 列表包含 default_statistics_target 个值 (如果在列级别也设置了该参数，则使用其最大值)。</p><p>如果需要，你也可以像对扩展表达式统计信息那样更改列表大小：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> STATISTICS ... <span class="hljs-keyword">SET</span> STATISTICS ...;<br></code></pre></td></tr></table></figure><p>在所有这些示例中，我只使用了两列，但你同样可以收集更多列的多元统计信息。</p><p>要在一个对象中组合多种类型的统计信息，你可以在其定义中提供这些类型的逗号分隔列表。如果没有指定类型，那么 PostgresSQL 会收集指定列的所有可能类型的统计信息。</p><p>除了实际的列名，多元统计信息还可以使用任意表达式，就像表达式统计信息一样。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch16. Query Execution Stages</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch16/ch16/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch16/ch16/</url>
    
    <content type="html"><![CDATA[<h2 id="ch16-Query-Execution-Stages"><a href="#ch16-Query-Execution-Stages" class="headerlink" title="ch16. Query Execution Stages"></a>ch16. Query Execution Stages</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">16.1 Demo Database</a></td></tr><tr><td><a href="#cp2">16.2 Simple Query Protocol</a></td></tr><tr><td><a href="#cp3">16.3 Extended Query Protocol</a></td></tr></tbody></table><h3 id="16-1-Demo-Database"><a href="#16-1-Demo-Database" class="headerlink" title="16.1 Demo Database"></a><a name="cp1"></a>16.1 Demo Database</h3><p>本书前面部分的示例都是基于仅有少量行的表。此章节及后续部分将讨论查询执行，这方面的要求会更高：我们需要行数更多的表。我没有为每个例子都创建一个新的数据集，而是使用了一个现有的示例数据库，其展示了俄罗斯的客运航空量 1。它有多个版本；我们将使用于 2017 年 8 月 15 日创建的数据量更大的版本。要安装此版本，你需要从归档中提取包含数据库副本的文件 2，并在 psql 中运行此文件。</p><p>在开发这个示例数据库时，我们尽量让其模式简单到无需额外解释即可理解；同时，我们希望它也足够复杂，能够编写有意义的查询语句。数据库中填充了贴近现实的数据，这使得示例更加全面，使用起来应该会很有趣。</p><p>此处我只会简要介绍主要的数据库对象；如果你想查看整个模式，可以查看脚注中引用的完整描述。</p><p>主要实体是预订 (映射到 bookings 表)。一次预订可以包含几个乘客，每个乘客都有一张单独的电子机票 (tickets)。乘客不构成单独的实体；为了我们的实验，我们将假设所有的乘客都是唯一的。</p><p>每张机票包括一个或多个航段 (映射到 ticket_fights 表)。在两种情况下，单张机票可以有多个航段：要么是往返机票，要么是为转机而签发的。尽管在模式中没有相应的约束，但假定一个预订中的所有机票都有相同的航段。</p><p>每个航班 (flights) 从一个机场 (airports) 飞往另一个机场。具有相同航班号的航班具有相同的出发点和目的地，但出发日期不同。</p><p>routes 视图基于 flights 表；它显示了与特定航班日期无关的航线信息。</p><p>在办理登机手续时，每位乘客都会被签发一张带有座位号的登机牌 (boarding_passes)。只有在机票中包含该航班时，乘客才能办理登机手续。航班与座位的组合必须是唯一的，因此不可能为同一个座位签发两张登机牌。</p><p>飞机上的座位 (seats) 数量及其在不同舱位之间的分布取决于执飞的特定飞机模型 (aircrafts)。假设每个飞机模型只能有一个座舱配置。</p><p>一些表有代理主键，而其他表使用原生主键 (其中一些是复合主键)。这仅仅是出于演示的目的，并不是一个可以效仿的例子。</p><p>示例数据库可以被视为真实系统的转储：它包含了过去某个特定时刻获取的数据快照。要显示此时间，你可以调用 bookings.now() 函数。在示例查询中使用此函数，需要在现实世界中使用 now() 函数。</p><p>机场名、城市名和飞机型号的名称存储在 airports_data 和 aircrafts_data 表中；它们有两种语言，英语和俄语。为了构造本章中的示例，我通常会查询实体关系图中显示的 airports 和 aircrafts 视图；这些视图基于 bookings.lang 参数的值选择输出语言。尽管如此，一些基表的名称仍可能出现在查询计划中。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch16/ch16/img.png" alt="img.png"></p><h3 id="16-2-Simple-Query-Protocol"><a href="#16-2-Simple-Query-Protocol" class="headerlink" title="16.2 Simple Query Protocol"></a><a name="cp2"></a>16.2 Simple Query Protocol</h3><p>一个简单版本的 client-server 协议 3 支持执行 SQL 查询：它将查询文本发送至服务器，并获得完整的执行结果，无论其中包含多少行数据 4。发送到服务器的查询历经几个阶段：解析、转换、规划，然后执行。</p><h4 id="16-2-1-解析"><a href="#16-2-1-解析" class="headerlink" title="16.2.1 解析"></a>16.2.1 解析</h4><p>首先，PostgreSQL 需要解析 5 查询文本以了解需要执行什么。</p><p><strong>词法和语法分析。</strong> 词法分析器将查询文本分割为一组词素 6 (如关键字、字符串字面量和数值字面量)，而语法分析器根据 SQL 语言的语法 7 验证这组词素。PostgreSQL 依赖标准解析工具，即 Flex 和 Bison 工具。</p><p>解析后的查询在后端进程的内存中体现为一颗抽象语法树。</p><p>例如，让我们看一下以下查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> schemaname, tablename<br><span class="hljs-keyword">FROM</span> pg_tables<br><span class="hljs-keyword">WHERE</span> tableowner <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;postgres&#x27;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> tablename;<br></code></pre></td></tr></table></figure><p>词法分析器识别出五个关键字、五个标识符、一个字符串字面量和三个单字母词素 (逗号、等号和分号)。语法分析器使用这些词素来构建语法树，下图以非常简化的形式显示了语法树。树节点旁边的说明文字指定了查询的相应部分：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch16/ch16/img_1.png" alt="img_1.png"></p><p>一个相当晦涩的 RTE 缩写代表 Range Table Entry。PostgreSQL 源代码中使用术语 range table 来表示表、子查询、关联结果，换句话说，指那些可以由 SQL 操作符处理的任何行集。8</p><p><strong>语义分析。</strong> 语义分析 9 的目的是确认数据库中是否包含查询根据名称引用的表或其他对象，以及用户是否具有访问这些对象的权限。所有语义分析需要的信息都存储在系统表中。</p><p>获得语法分析树后，语义分析器执行进一步的重构，包括添加对特定数据库对象、数据类型和其他信息的引用。</p><p>如果打开了 debug_print_parse 参数，你可以在服务器日志中看到完整的语法分析树，尽管这没有什么实际的意义。</p><h4 id="16-2-2-转换"><a href="#16-2-2-转换" class="headerlink" title="16.2.2 转换"></a>16.2.2 转换</h4><p>在下一阶段，查询会被转换(重写)。10</p><p>内核出于多种目的使用转换。其中之一是用视图的基本查询所对应的子树来替换语法树中的视图名称。</p><p>另一种使用转换的情况是行级安全的实现。11</p><p>递归查询的 SEARCH 和 CYCLE 子句也在此阶段进行转换。12</p><p>在上面的示例中，pg_tables 是一个视图；如果我们将其定义放在查询文本中，它将如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> schemaname, tablename<br><span class="hljs-keyword">FROM</span> (<br>    <span class="hljs-comment">-- pg_tables</span><br>    <span class="hljs-keyword">SELECT</span> n.nspname <span class="hljs-keyword">AS</span> schemaname,<br>      c.relname <span class="hljs-keyword">AS</span> tablename,<br>      pg_get_userbyid(c.relowner) <span class="hljs-keyword">AS</span> tableowner,<br>      ...<br>    <span class="hljs-keyword">FROM</span> pg_class c<br>      <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> pg_namespace n <span class="hljs-keyword">ON</span> n.oid <span class="hljs-operator">=</span> c.relnamespace<br>      <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> pg_tablespace t <span class="hljs-keyword">ON</span> t.oid <span class="hljs-operator">=</span> c.reltablespace<br>    <span class="hljs-keyword">WHERE</span> c.relkind <span class="hljs-operator">=</span> <span class="hljs-keyword">ANY</span> (<span class="hljs-keyword">ARRAY</span>[<span class="hljs-string">&#x27;r&#x27;</span>::<span class="hljs-type">char</span>, <span class="hljs-string">&#x27;p&#x27;</span>::<span class="hljs-type">char</span>])<br>)<br><span class="hljs-keyword">WHERE</span> tableowner <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;postgres&#x27;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> tablename;<br></code></pre></td></tr></table></figure><p>然而，服务器并不处理查询的文本表示；所有操作都在语法树上执行。下图显示了转换后树的简化版本 (如果打开了 debug_print_rewrite 参数，你可以在服务器日志中看到其完整版本)。</p><p>语法树反映了查询的语法结构，但它并没有说明操作应该以何种顺序执行。</p><p>PostgreSQL 还支持用户通过重写规则系统实现的自定义转换。13</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch16/ch16/img_2.png" alt="img_2.png"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">规则系统的支持被宣称为 Postgres 发展的主要目标之一；14 当规则首次实现时，它还是一个学术项目，但从那时起，规则已经被多次重新设计。规则系统是一个非常强大的机制，但理解和调试它相当困难。甚至有人提议完全从 PostgreSQL 中移除规则，但这个想法并没有获得一致支持。在大多数情况下，使用触发器而不是规则会更安全也更容易。<br></code></pre></td></tr></table></figure><h4 id="16-2-3-规划"><a href="#16-2-3-规划" class="headerlink" title="16.2.3 规划"></a>16.2.3 规划</h4><p>SQL 是一种声明式语言：查询仅指定了要获取哪些数据，但没有指定如何去获取。</p><p>任何查询都有多条执行路径。语法树中显示的每个操作都可以通过多种方式完成：例如，可以通过读取整个表以获取结果 (并过滤掉冗余项) ，或者通过索引扫描找到所需的行。数据集总是成对连接的，因此有大量不同的选项，这些选项在连接的顺序上各不相同。除此之外，还有多种连接算法：例如，执行器可以扫描第一个数据集的行，并在另一个数据集中检索匹配的行，或者可以先对两个数据集进行排序，然后合并在一起。对于每种算法，我们都可以找到一个使用案例，其中它的表现优于其他算法。</p><p>最佳和非最佳的计划，其执行时间可能相差几个数量级，因此负责优化解析后的查询的规划器 15 是系统中最复杂的组件之一。</p><p><strong>计划树。</strong> 执行计划也以树的形式表示，但其节点涉及的是数据的物理操作，而非逻辑操作。</p><p>如果你想探索完整的计划树，可以通过打开 debug_print_plan 参数将它们转储到服务器日志中。但在实践中，通常查看 EXPLAIN 命令 16 显示的计划的文本表示就足够了。</p><p>下图着重显示了树的主要节点。这些节点正是 EXPLAIN 命令输出中显示的节点。</p><p>现在，让我们关注以下两点：</p><pre><code class="hljs">树仅包含三个查询表中的两个：规划器发现检索结果并不需要其中一个表，并将其从计划树中移除。对于树中的每个节点，规划器提供了预估成本和预估要处理的行数。</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> schemaname, tablename<br><span class="hljs-keyword">FROM</span> pg_tables<br><span class="hljs-keyword">WHERE</span> tableowner <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;postgres&#x27;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> tablename;<br>                             QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Sort (cost<span class="hljs-operator">=</span><span class="hljs-number">21.03</span>.<span class="hljs-number">.21</span><span class="hljs-number">.04</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">128</span>)<br>   Sort Key: c.relname<br>   −<span class="hljs-operator">&gt;</span> Nested Loop <span class="hljs-keyword">Left</span> <span class="hljs-keyword">Join</span> (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.21</span><span class="hljs-number">.02</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">128</span>)<br>       <span class="hljs-keyword">Join</span> <span class="hljs-keyword">Filter</span>: (n.oid <span class="hljs-operator">=</span> c.relnamespace)<br>       −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> pg_class c (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.19</span><span class="hljs-number">.93</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">72</span>)<br>           <span class="hljs-keyword">Filter</span>: ((relkind <span class="hljs-operator">=</span> <span class="hljs-keyword">ANY</span> (<span class="hljs-string">&#x27;&#123;r,p&#125;&#x27;</span>::&quot;char&quot;[])) <span class="hljs-keyword">AND</span> (pg_g...<br>       −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> pg_namespace n (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.1</span><span class="hljs-number">.04</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">4</span> wid...<br>(<span class="hljs-number">7</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>查询计划中显示的 Seq Scan 节点对应读取表的操作，而 Nested Loop 节点代表连接操作。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch16/ch16/img_3.png" alt="img_3.png"></p><p><strong>计划搜索。</strong> PostgreSQL 使用基于成本的优化器；17 它会检查潜在的计划，并估算执行它们所需的资源 (比如 I&#x2F;O 操作或 CPU 周期)。这种评估会具体细化成一个数字，称为计划的成本。在所有考虑的计划中，优化器会选择成本最低的计划。</p><p>但问题在于，随着连接表的数量增加，潜在可用计划的数量呈指数级增长，因此即使是相对简单的查询，也不可能将全部计划考虑在内。通常情况下，会使用动态规划算法，同时结合一些启发式算法来缩小搜索范围。这使得规划器能够在可接受的时间内为包含大量表的查询找到数学上精确的解决方案。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">精确的解决方案并不能保证所选计划确实是最优的，因为规划器使用的是简化的数学模型，并且可能缺乏可靠的输入数据。<br></code></pre></td></tr></table></figure><p><strong>管理连接顺序。</strong> 查询可以以某种方式构建，以在一定程度上限制搜索范围 (但有可能错过最优计划)。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">通用表表达式 (CTE) 和主查询可以单独优化；为了保证这种行为，你可以指定 MATERIALIZED 子句。18<br>在非 SQL 函数中运行的子查询总是单独优化的。(SQL 函数有时可以内联到主查询中。19）<br>如果设置了 join_collapse_limit 参数并在查询中使用显式 join 子句，那么某些连接的顺序将由查询语法结构定义；from_cllapse_limit 参数对子查询有相同的影响。20<br></code></pre></td></tr></table></figure><p>最后一点可能需要解释一下。让我们看一个查询，它没有为 FROM 子句中列出的表指定任何显式连接：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ...<br><span class="hljs-keyword">FROM</span> a, b, c, d, e<br><span class="hljs-keyword">WHERE</span> ...<br></code></pre></td></tr></table></figure><p>此处，规划期必须考虑所有可能的连接组合。查询由语法树的以下部分表示 (示意性地展示)：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch16/ch16/img_4.png" alt="img_4.png"></p><p>在下一个示例中，连接有一个由 JOIN 子句定义的特定结构。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ...<br><span class="hljs-keyword">FROM</span> a, b <span class="hljs-keyword">JOIN</span> c <span class="hljs-keyword">ON</span> ..., d, e<br><span class="hljs-keyword">WHERE</span> ...<br></code></pre></td></tr></table></figure><p>语法分析树表明了这种结构：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch16/ch16/img_5.png" alt="img_5.png"></p><p>规划器通常会展平连接树，使其看起来像第一个例子中的那样。规划器算法会遍历树，并用其元素的平面列表替换每个 JOINEXPR 节点。21</p><p>然而，只有当生成的平面列表中的元素不超过 join_collapse_limit 时，才会执行这种展平。在这个特定案例中，如果 join_collapse_limit 值小于 5，那么 JOINEXPR 节点将不会被展平。</p><p>对于规划器来说，它意味着：</p><pre><code class="hljs">表 B 必须与表 C 连接 (反之亦然，表 C 必须与表 B 连接；一对连接内的顺序不受限制)。表 A、D、E 以及 B 与 C 的连接结果可以按任何顺序连接。</code></pre><p>如果 join_collapse_limit 参数设置为 1，那么由显式 JOIN 子句定义的顺序会被保留。</p><p>对于 FULL OUTER JOIN 操作，无论 join_collapse_limit 参数的值如何，它们都不会被展平。</p><p>from_collapse_limit 参数以类似的方式控制子查询的展平。尽管子查询看起来不像 JOIN 子句，但在语法分析树级别，这种相似性便会变得很明显。</p><p>这里有一个示例查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ...<br><span class="hljs-keyword">FROM</span> a,<br>  (<br>    <span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FROM</span> b, c <span class="hljs-keyword">WHERE</span> ...<br>  ) bc,<br>  d, e<br><span class="hljs-keyword">WHERE</span> ...<br></code></pre></td></tr></table></figure><p>相应的连接树如下所示。这里唯一的区别是这颗树包含 FROMEXPR 节点，而不是 JOINEXPR (参数名称由此而来)。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch16/ch16/img_6.png" alt="img_6.png"></p><p><strong>遗传查询优化。</strong>  一旦展平之后，树可能在同一层包含太多元素 — 无论是表还是必须单独优化的连接结果。规划时间会随着需要连接的数据集数量指数级增长，因此可能会超出所有合理的限制。</p><p>如果启用了 geqo 参数，且某一层的元素个数超过了 geqo_threshold 值，那么规划器将使用遗传算法来优化查询。22 这种算法比动态规划算法快得多，但不能保证找到的计划是最优的。因此，通常的做法是通过减少必须优化的元素数量来避免使用遗传算法。</p><p>遗传算法有多个可配置的参数，23 但我不打算在这里进行介绍。</p><p><strong>选择最优计划。</strong> 一个计划是否可以被认为是最优的，取决于特定客户端如何使用查询结果。如果客户端需要一次性获取完整结果 (例如，用于创建一份报告)，那么计划应优化对所有行的检索。但如果优先级是尽快返回第一行 (例如，用于屏幕显式)，最优计划可能完全不同。</p><p>为了做出选择，PostgreSQL 会计算成本的两个组成部分：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN<br><span class="hljs-keyword">SELECT</span> schemaname, tablename<br><span class="hljs-keyword">FROM</span> pg_tables<br><span class="hljs-keyword">WHERE</span> tableowner <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;postgres&#x27;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> tablename;<br>                            QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Sort (cost<span class="hljs-operator">=</span><span class="hljs-number">21.03</span>.<span class="hljs-number">.21</span><span class="hljs-number">.04</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">128</span>)<br>  Sort Key: c.relname<br>  −<span class="hljs-operator">&gt;</span> Nested Loop <span class="hljs-keyword">Left</span> <span class="hljs-keyword">Join</span> (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.21</span><span class="hljs-number">.02</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">128</span>)<br>      <span class="hljs-keyword">Join</span> <span class="hljs-keyword">Filter</span>: (n.oid <span class="hljs-operator">=</span> c.relnamespace)<br>      −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> pg_class c (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.19</span><span class="hljs-number">.93</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">72</span>)<br>          <span class="hljs-keyword">Filter</span>: ((relkind <span class="hljs-operator">=</span> <span class="hljs-keyword">ANY</span> (<span class="hljs-string">&#x27;&#123;r,p&#125;&#x27;</span>::&quot;char&quot;[])) <span class="hljs-keyword">AND</span> (pg_g...<br>      −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> pg_namespace n (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.1</span><span class="hljs-number">.04</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">4</span> wid...<br>(<span class="hljs-number">7</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>第一个部分 (启动成本) 表示为节点执行做准备所付出的成本，而第二个部分 (总成本) 包括获取结果所产生的所有开销。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">有时人们说启动成本是检索结果集第一行的成本，但这并不是太准确。<br></code></pre></td></tr></table></figure><p>为了挑选出首选计划，优化器会检查查询是否使用了游标 (通过 SQL 中提供的 DECLARE 命令或在 PL&#x2F;PGSQL 中显式声明)。24 如果没有，则假定客户端需要一次性获取整个结果，那么优化器会选择总成本最低的计划。</p><p>如果查询是通过游标执行的，所选计划必须优化仅检索占所有数据 cursor_tuple_fraction 比例的行。更准确地说，PostgreSQL 会选择以下表达式值最小的计划：25</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">startup cost + cursor_tuple_fraction (total cost − startup cost)<br></code></pre></td></tr></table></figure><p><strong>成本估算概要。</strong> 为了估算计划的总成本，我们必须获取其所有节点的成本估算值。节点的成本取决于它的类型 (很明显，读取堆数据的成本与排序的成本不同) 和该节点处理的数据量 (更大的数据量通常会产生更高的成本) 。虽然节点类型已知，但数据量只能基于输入集的预估基数 (节点需要的行数作为输入) 和节点的选择率 (输出中剩余行的比例) 来估算。这些计算依赖于收集的统计信息，例如表的大小和表列中数据的分布情况。</p><p>因此，执行的优化取决于由 AUTOVACUUM 收集和更新的统计信息的准确性。</p><p>如果每个节点的基数估算都很准确，那么计算出的成本很可能充分反映出实际成本。主要的规划缺陷通常是由于对基数和选择率的估算不准确造成的，这可能是由于不准确或过时的统计信息、无法使用统计信息或者 — 在较小程度上，由于不完善的规划模型造成的。</p><p><strong>基数估算。</strong> 为了计算节点的基数，规划器必须递归完成以下步骤：</p><pre><code class="hljs">1. 估算每个子节点的基数，并评估节点将从这些子节点接收到的输入行数。2. 估算节点的选择率，也就是将保留在输出中的行的比例。</code></pre><p>节点的基数是这两个值的乘积。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">选择率用从 0 到 1 的数字表示。数字越小，选择率越高，反之亦然，数字越接近 1，选择率越低。这似乎不合逻辑，但其想法是，高选择率的条件几乎会排除所有行，而仅排除少数行的条件则具有低选择率。<br></code></pre></td></tr></table></figure><p>首先，规划器估算定义数据访问方法的叶节点的基数。这些计算依赖于收集的统计信息，例如表的总大小。</p><p>过滤条件的选择率取决于它们的类型。在最简单的情况下，可以假设它是一个常数值，尽管规划器试图使用所有可用的信息来细化评估。通常，了解如何估算简单的过滤条件就足够了；如果条件包含逻辑运算，那么选择率按以下公式计算：26</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch16/ch16/img_7.png" alt="img_7.png"></p><p>不幸的是，这些公式假设谓词 x 和 y 不相互依赖。对于相互依赖的谓词，这样的估算是不准确的。</p><p>为了估算连接的基数，规划器必须获得笛卡尔积的基数 (即两个数据集基数的乘积) 并估算连接条件的选择率，这同样取决于条件类型。</p><p>其他节点的基数 (例如排序或聚集) 估算以类似的方式进行。</p><p>需要注意的是，对于下层计划节点的基数若估算不准确会影响所有后续的计算，进而导致总成本估算不准确以及计划选择不佳。更糟糕的是，规划器没有关联结果的统计信息，只有表的统计信息。</p><p><strong>成本估算。</strong> 成本估算的过程也是递归的。要计算一棵子树的成本，需要计算并累加其所有子节点的成本，然后加上父节点本身的成本。</p><p>为了估算一个节点的成本，PostgreSQL 会将已经估算出的节点基数为输入，应用该节点所执行操作的数学模型。对于每个节点，都会计算启动成本和总成本。</p><p>有些操作没有前置条件，因此它们的执行会立即开始；这些节点的启动成本为零。</p><p>相反，其他操作需要等待一些准备动作完成。例如，排序节点通常需要等待其子节点所有的数据到位，才能继续执行自己的任务。此类节点的启动成本通常大于零：即使上层节点 (或客户端) 只需要全部输出中的一行数据，也必须付出此成本。</p><p>规划器执行的所有计算都只是估算，可能与实际执行时间无关。唯一目的是在相同条件下，对同一查询的不同计划进行比较。在其他情况下，比较查询 (尤其是不同的查询) 的成本是没有意义的。例如，由于过时的统计信息，成本可能被低估了；一旦刷新统计信息，计算出的数字可能会上升，随着估算越来越准确，规划器将选择一个更好的计划。</p><h4 id="16-2-4-执行"><a href="#16-2-4-执行" class="headerlink" title="16.2.4 执行"></a>16.2.4 执行</h4><p>查询优化期间创建的计划现在需要被执行。27</p><p>执行器在后端进程内存中打开一个 portal；28 它是一个保持当前正在执行的查询状态的对象。这个状态以一棵树的形式表示，展示了计划树的结构。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch16/ch16/img_8.png" alt="img_8.png"></p><p>这棵树的节点就像一条流水线一样运行，相互请求以及发送数据。</p><p>查询执行从根开始。根节点 (在本例中代表 SORT 操作) 从它的子节点中拉取数据。接收到所有行之后，会对它们进行排序并传递给客户端。</p><p>一些节点 (如本例中所示的 NESTLOOP 节点) 从不同来源接收数据集并进行连接。这样的节点从两个子节点拉取数据，一旦接收到满足连接条件的一对行，就立即向上层传递结果 (不像排序，排序必须先获取所有行)。此时，节点的执行被中断，直到其父节点请求下一行。如果只需要部分结果 (例如，查询中有 LIMIT 子句)，那么操作将不会全部执行。</p><p>树的两个 SEQSCAN 叶节点负责表扫描。当父节点向这些节点请求数据时，它们从相应的表中获取后续的行。</p><p>然而一些节点不存储任何行，而是立即向上传递，但其他节点 (例如 SORT) 需要保留潜在的大量数据。为此，在后端进程内存中分配了一个 work_mem 内存块；如果此内存不够，剩余的数据会溢出到磁盘上的临时文件中。29</p><p>一个计划可能有多个需要存储数据的节点，因此 PostgreSQL 可能会分配多个内存块，每个内存块的大小为 work_mem。查询可使用的总 RAM 大小不受任何限制。</p><h3 id="16-3-Extended-Query-Protocol"><a href="#16-3-Extended-Query-Protocol" class="headerlink" title="16.3 Extended Query Protocol"></a><a name="cp3"></a>16.3 Extended Query Protocol</h3><p>在使用简单查询协议时，每个命令 (即使是重复多次的命令) 都必须经过前面提及的所有阶段：</p><pre><code class="hljs">解析转化规划执行</code></pre><p>然而，多次解析同一个查询是没有意义的。重复解析仅常量不同的查询也没有多大意义 — 语法树的结构仍然是相同的。</p><p>简单查询协议的另一个缺点是，客户端一次性接收整个结果，无论可能包含多少行。</p><p>通常，你可以使用 SQL 命令克服这些限制。为了解决第一个问题，你可以在执行 EXECUTE 命令之前 PREPARE 查询；第二个问题可以通过使用 DECLARE 创建一个游标并通过 FETCH 返回行来解决。但在这种情况下，这些新创建对象的命名必须由客户端来处理，而服务端则需要额外的开销来解析额外的命令。</p><p>扩展 client-server 协议提供了另一种替代解决方案，使得可以在协议本身的命令级别上精确控制各个操作符的执行阶段。</p><h4 id="16-3-1-预备"><a href="#16-3-1-预备" class="headerlink" title="16.3.1 预备"></a>16.3.1 预备</h4><p>在预备阶段，查询像往常一样被解析和转换，但是生成的语法树会保留在后端进程的内存中。</p><p>PostgreSQL 没有用于查询的全局缓存。这种架构的缺点很明显：每个后端进程都必须解析所有传入的查询，即使同一个查询已经被另一个后端进程解析过，但也有一些好处。全局缓存很容易因为锁而成为瓶颈。客户端运行多个短小但不同的查询 (比如那些只有常量有所不同的查询) 会产生大量负载，并且会对整个实例的性能产生负面影响。在 PostgreSQL 中，查询是在本地解析的，因此不会对其他进程产生影响。</p><p>预备查询可以参数化。此处是一个使用 SQL 命令的简单示例 (尽管和协议级别的预备语句不同，但最终的效果是一致的)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">PREPARE</span> plane(text) <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> aircrafts <span class="hljs-keyword">WHERE</span> aircraft_code <span class="hljs-operator">=</span> $<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>所有已命名的预备语句都会显示在 pg_prepared_statements 视图中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> name, statement, parameter_types<br><span class="hljs-keyword">FROM</span> pg_prepared_statements \gx<br>−[ RECORD <span class="hljs-number">1</span> ]−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br>name            <span class="hljs-operator">|</span> plane<br>statement       <span class="hljs-operator">|</span> <span class="hljs-keyword">PREPARE</span> plane(text) <span class="hljs-keyword">AS</span> <span class="hljs-operator">+</span><br>                <span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> aircrafts <span class="hljs-keyword">WHERE</span> aircraft_code <span class="hljs-operator">=</span> $<span class="hljs-number">1</span>;<br>parameter_types <span class="hljs-operator">|</span> &#123;text&#125;<br></code></pre></td></tr></table></figure><p>你不会在此处找到任何未命名的语句 (使用扩展查询协议或 PL&#x2F;pgSQL 的语句)。其他后端进程的预备语句也不会显示：无法访问其他会话的内存。</p><h4 id="16-3-2-参数绑定"><a href="#16-3-2-参数绑定" class="headerlink" title="16.3.2 参数绑定"></a>16.3.2 参数绑定</h4><p>在执行预备语句之前，必须绑定实际参数值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">EXECUTE</span> plane(<span class="hljs-string">&#x27;733&#x27;</span>);<br> aircraft_code <span class="hljs-operator">|</span>     model      <span class="hljs-operator">|</span> <span class="hljs-keyword">range</span><br>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br> <span class="hljs-number">733</span>           <span class="hljs-operator">|</span> Boeing <span class="hljs-number">737</span>−<span class="hljs-number">300</span> <span class="hljs-operator">|</span> <span class="hljs-number">4200</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>在预备语句中绑定参数相较于将字面量与查询字符串拼接起来的优势在于，它使得 SQL 注入变得绝无可能：绑定的参数值无法以任何方式修改已经创建的语法树。</p><p>要在没有预备语句的情况下达到相同的安全级别，你需要仔细转义来自不可信来源的每个值。</p><h4 id="16-3-3-规划和执行"><a href="#16-3-3-规划和执行" class="headerlink" title="16.3.3 规划和执行"></a>16.3.3 规划和执行</h4><p>在执行预备语句时，查询规划是基于实际参数值进行的；然后将计划传递给执行器。</p><p>不同的参数值可能意味着不同的最优计划，因此考虑确切的值很重要。例如，在查找昂贵的预定时，规划器假设匹配的行数不会太多，并使用索引扫描：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> bookings(total_amount);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookings<br><span class="hljs-keyword">WHERE</span> total_amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">1000000</span>;<br>                            QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Bitmap Heap Scan <span class="hljs-keyword">on</span> bookings (cost<span class="hljs-operator">=</span><span class="hljs-number">86.49</span>.<span class="hljs-number">.9245</span><span class="hljs-number">.82</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">4395</span> wid...<br>   Recheck Cond: (total_amount <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;1000000&#x27;</span>::<span class="hljs-type">numeric</span>)<br>   −<span class="hljs-operator">&gt;</span> Bitmap Index Scan <span class="hljs-keyword">on</span> bookings_total_amount_idx (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>....<br>       Index Cond: (total_amount <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;1000000&#x27;</span>::<span class="hljs-type">numeric</span>)<br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>但如果提供的条件适用于所有预订，那么使用索引就没有意义了，因为整个表都需要被扫描：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> bookings <span class="hljs-keyword">WHERE</span> total_amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span>;<br>                            QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> bookings (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.39835</span><span class="hljs-number">.88</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">2111110</span> width<span class="hljs-operator">=</span><span class="hljs-number">21</span>)<br>   <span class="hljs-keyword">Filter</span>: (total_amount <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;100&#x27;</span>::<span class="hljs-type">numeric</span>)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>在某些情况下，规划器可能会同时保留语法树和查询计划以避免重复规划。这样的计划不考虑参数值，因此被称之为 generic plan (与基于实际值的 custom plan 相比)。30</p><p>当服务器在不影响性能的情况下可以使用 generic plan 的一个明显情况是查询中没有参数。</p><p>参数化预备语句的前五次优化始终依赖于实际参数值；规划器会基于这些值计算 custom plan 的平均成本。从第六次执行开始，如果 generic plan 平均比 custom plan 更有效 (考虑到 custom plan 每次都必须重新创建) 31，规划器便会保留 generic plan，并继续使用它，跳过优化阶段。</p><p>plane 预备语句已经执行过一次。在接下来的 3 次执行之后，服务器仍然使用 custom plan — 你可以通过查询计划中的参数值来判断：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">EXECUTE</span> plane(<span class="hljs-string">&#x27;763&#x27;</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">EXECUTE</span> plane(<span class="hljs-string">&#x27;773&#x27;</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">EXECUTE</span> plane(<span class="hljs-string">&#x27;319&#x27;</span>);<br>                            QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> aircrafts_data ml (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.1</span><span class="hljs-number">.39</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">52</span>)<br>   <span class="hljs-keyword">Filter</span>: ((aircraft_code)::text <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;319&#x27;</span>::text)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>在第 5 次执行之后，规划器切换到 generic plan：它与 custom plan 没有区别，成本是一致的，但是后端进程可以一次性创建并跳过优化阶段，从而减少规划开销。现在 EXPLAIN 命令显示参数是按位置引用的，而不是按值引用的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">EXECUTE</span> plane(<span class="hljs-string">&#x27;320&#x27;</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">EXECUTE</span> plane(<span class="hljs-string">&#x27;321&#x27;</span>);<br>                            QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> aircrafts_data ml (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.1</span><span class="hljs-number">.39</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">52</span>)<br>   <span class="hljs-keyword">Filter</span>: ((aircraft_code)::text <span class="hljs-operator">=</span> $<span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>当之前的几个 custom plan 比 generic plan 更昂贵时，我们可以很容易想象出一些不愉快的事情；后续计划本来可以更有效，但规划器根本不会考虑。此外，它比较的是估算值而不是实际成本，这也可能导致计算错误。</p><p>然而，如果规划器做出了错误的选择，你可以通过相应地设置 plan_cache_mode 参数来覆盖自动决策，并选择是 generic plan 还是 custom plan：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> plan_cache_mode <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;force_custom_plan&#x27;</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">EXECUTE</span> plane(<span class="hljs-string">&#x27;CN1&#x27;</span>);<br>                            QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> aircrafts_data ml (cost<span class="hljs-operator">=</span><span class="hljs-number">0.00</span>.<span class="hljs-number">.1</span><span class="hljs-number">.39</span> <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> width<span class="hljs-operator">=</span><span class="hljs-number">52</span>)<br>   <span class="hljs-keyword">Filter</span>: ((aircraft_code)::text <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;CN1&#x27;</span>::text)<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>除了其他信息之外，pg_prepared_statements 视图还显示了所选计划的统计信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> name, generic_plans, custom_plans<br><span class="hljs-keyword">FROM</span> pg_prepared_statements;<br> name  <span class="hljs-operator">|</span> generic_plans <span class="hljs-operator">|</span> custom_plans<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−<br> plane <span class="hljs-operator">|</span>             <span class="hljs-number">1</span> <span class="hljs-operator">|</span>            <span class="hljs-number">6</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><h4 id="16-3-4-获取结果"><a href="#16-3-4-获取结果" class="headerlink" title="16.3.4 获取结果"></a>16.3.4 获取结果</h4><p>扩展查询协议允许批次检索数据，而不是一次性全部检索。SQL 游标几乎具有相同的效果 (除了服务器有一些额外的工作，并且规划器进行了优化，仅获取前面 cursor_tuple_fraction 比例的行，而不是整个结果集)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">DECLARE</span> cur <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span><br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>  <span class="hljs-keyword">FROM</span> aircrafts<br>  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> aircraft_code;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FETCH</span> <span class="hljs-number">3</span> <span class="hljs-keyword">FROM</span> cur;<br> aircraft_code <span class="hljs-operator">|</span>      model      <span class="hljs-operator">|</span> <span class="hljs-keyword">range</span><br>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br> <span class="hljs-number">319</span>           <span class="hljs-operator">|</span> Airbus A319−<span class="hljs-number">100</span> <span class="hljs-operator">|</span>  <span class="hljs-number">6700</span><br> <span class="hljs-number">320</span>           <span class="hljs-operator">|</span> Airbus A320−<span class="hljs-number">200</span> <span class="hljs-operator">|</span> <span class="hljs-number">5700</span><br> <span class="hljs-number">321</span>           <span class="hljs-operator">|</span> Airbus A321−<span class="hljs-number">200</span> <span class="hljs-operator">|</span> <span class="hljs-number">5600</span><br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FETCH</span> <span class="hljs-number">2</span> <span class="hljs-keyword">FROM</span> cur;<br> aircraft_code <span class="hljs-operator">|</span>      model     <span class="hljs-operator">|</span> <span class="hljs-keyword">range</span><br>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br> <span class="hljs-number">733</span>           <span class="hljs-operator">|</span> Boeing <span class="hljs-number">737</span>−<span class="hljs-number">300</span> <span class="hljs-operator">|</span>  <span class="hljs-number">4200</span><br> <span class="hljs-number">763</span>           <span class="hljs-operator">|</span> Boeing <span class="hljs-number">767</span>−<span class="hljs-number">300</span> <span class="hljs-operator">|</span>  <span class="hljs-number">7900</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>如果查询返回了多行，并且客户端需要所有数据，那么系统吞吐量高度依赖于批次的大小。单个批次中的行数越多，那么访问服务器以及获取响应所产生的通信开销就越少。但是随着批次大小的增加，这些好处变得不那么明显了：虽然一次一行与每批十行获取行的差异可能巨大，但如果比较每批 100 行和每批 1000 行，这种差异就不是那么明显了。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch14. Miscellaneous Locks</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch14/ch14/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch14/ch14/</url>
    
    <content type="html"><![CDATA[<h2 id="ch14-Miscellaneous-Locks"><a href="#ch14-Miscellaneous-Locks" class="headerlink" title="ch14. Miscellaneous Locks"></a>ch14. Miscellaneous Locks</h2><p><strong>杂项锁</strong></p><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#Non-Object">14.1 Non-Object Locks</a></td></tr><tr><td><a href="#Relation-Extension">14.2 Relation Extension Locks</a></td></tr><tr><td><a href="#Page-Locks">14.3 Page Locks</a></td></tr><tr><td><a href="#Advisory">14.4 Advisory Locks</a></td></tr><tr><td><a href="#Predicate-Locks">14.5 Predicate Locks</a></td></tr></tbody></table><h3 id="14-1-Non-Object-Locks"><a href="#14-1-Non-Object-Locks" class="headerlink" title="14.1 Non-Object Locks"></a><a name="Non-Object"></a>14.1 Non-Object Locks</h3><p>为了锁定不被视为”关系”的资源，PostgreSQL 使用 object 类型 1 的重锁。你几乎可以锁定存储在系统表中的任何东西：表空间、订阅、模式、角色、策略、枚举数据类型等等。</p><p>让我们开启一个事务创建一张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE TABLE</span> example(n <span class="hljs-type">integer</span>);<br></code></pre></td></tr></table></figure><p>现在让我们看看 pg_locks 表中的非关系锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> database,<br>  (<br>    <span class="hljs-keyword">SELECT</span> datname <span class="hljs-keyword">FROM</span> pg_database <span class="hljs-keyword">WHERE</span> oid <span class="hljs-operator">=</span> database<br>  ) <span class="hljs-keyword">AS</span> dbname,<br>  classid,<br>  (<br>    <span class="hljs-keyword">SELECT</span> relname <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> oid <span class="hljs-operator">=</span> classid<br>  ) <span class="hljs-keyword">AS</span> classname,<br>  objid,<br>  mode,<br>  granted<br><span class="hljs-keyword">FROM</span> pg_locks<br><span class="hljs-keyword">WHERE</span> locktype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;object&#x27;</span><br><span class="hljs-keyword">AND</span> pid <span class="hljs-operator">=</span> pg_backend_pid() \gx<br>−[ RECORD <span class="hljs-number">1</span> ]−−−−−−−−−−−−−−<br>database  <span class="hljs-operator">|</span> <span class="hljs-number">16391</span><br>dbname    <span class="hljs-operator">|</span> internals<br>classid   <span class="hljs-operator">|</span> <span class="hljs-number">2615</span><br>classname <span class="hljs-operator">|</span> pg_namespace<br>objid     <span class="hljs-operator">|</span> <span class="hljs-number">2200</span><br>mode      <span class="hljs-operator">|</span> AccessShareLock<br>granted   <span class="hljs-operator">|</span> t<br></code></pre></td></tr></table></figure><p>此处锁定的资源由三个值定义：</p><p><strong>database</strong> — 包含被锁定对象的数据库 oid (如果此对象是整个集簇共有的，则为零)</p><p><strong>classid</strong> — pg_class 中列出的 oid，对应于定义资源类型的系统目录表的名称</p><p><strong>objid</strong> — 系统目录表中列出的 oid，被 classid 所引用</p><p>database 值指向 internals 数据库；它是当前会话所连接的数据库。classid 列指向 pg_namespace 表，该表列出了模式。</p><p>现在我们可以解读 objid 了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> nspname <span class="hljs-keyword">FROM</span> pg_namespace <span class="hljs-keyword">WHERE</span> oid <span class="hljs-operator">=</span> <span class="hljs-number">2200</span>;<br> nspname<br>−−−−−−−−−<br> public<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>所以，PostgreSQL 已经锁定了 public 模式，以确保事务仍在运行时没有人可以删除它。</p><p>类似的，对象删除需要获取对象本身及其依赖的所有资源的独占锁 2。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><h3 id="14-2-Relation-Extension-Locks"><a href="#14-2-Relation-Extension-Locks" class="headerlink" title="14.2 Relation Extension Locks"></a><a name="Relation-Extension"></a>14.2 Relation Extension Locks</h3><p>随着关系中元组数量的增长，PostgreSQL 会尽可能将新元组插入到现有页面的空闲空间中。但很明显，在某些时候，它将不得不添加新的页面，即扩展表。就物理布局而言，新的页面会被添加到相应文件的末尾 (这会导致创建一个新的文件)。</p><p>为了使新页面一次只能由一个进程添加，这个操作受到一种特殊的 extend 类型 3 的重锁保护。索引清理也使用这种锁来禁止在索引扫描期间添加新的页面。</p><p>关系扩展锁的行为与我们迄今为止看到的有些许不同：</p><p>   一旦扩展完成，它们便会被立即释放，无需等待事务完成。</p><p>   它们不会导致死锁，所以不包含在等待图中。</p><p>然而，如果扩展关系的过程超过了 deadlock_timeout，仍会执行死锁检测。这不是一种典型的情况，但如果大量进程同时执行多个插入操作，就可能会发生。在这种情况下，会多次调用死锁检测，这实际上会导致正常的系统操作瘫痪。</p><p>为了将此风险降至最低，堆文件会一次性扩展多个页面 (与等待锁的进程数成比例，但每次操作不超过 512 个页面) 4。例外的是 B 树索引文件，一次只扩展一个页面 5。</p><h3 id="14-3-Page-Locks"><a href="#14-3-Page-Locks" class="headerlink" title="14.3 Page Locks"></a><a name="Page-Locks"></a>14.3 Page Locks</h3><p>page 类型的页级重锁 6 仅应用于 GIN 索引，并且仅在以下情况使用。</p><p>GIN 索引可以加速复合值中元素的搜索，例如文本文档中的单词。它们大致可以描述为存储单独的单词而不是整个文档的 B 树。当添加新的文档时，必须彻底更新索引，以包含此文档中出现的每个单词。</p><p>为了提高性能，GIN 索引允许延迟插入，由 fastupdate 存储参数控制。新单词首先会被快速添加到一个无序的 pending list 中，一段时间之后，所有累积的条目都会被移动到主索引结构中。由于不同的文档可能包含重复的单词，因此这种方式无疑是十分划算的。</p><p>为了避免多个进程同时转移单词，索引的元页面会以独占模式锁定，直到所有的单词从 pending list 中移动到主索引。这个锁不会干扰正常的索引使用。</p><p>就像关系扩展锁一样，页锁在任务完成后立即释放，无需等待事务结束，因此它们永远不会导致死锁。</p><h3 id="14-4-Advisory-Locks"><a href="#14-4-Advisory-Locks" class="headerlink" title="14.4 Advisory Locks"></a><a name="Advisory"></a>14.4 Advisory Locks</h3><p>与其他重锁 (如关系锁) 不同，咨询锁 7 永远不会自动获取：它们由应用开发人员控制。如果应用程序出于某些特定目的需要使用专门的锁逻辑，这些锁就很方便使用。</p><p>假设我们需要锁定一个不与任何数据库对象对应的资源 (我们可以使用 SELECT FOR 或 LOCK TABLE 命令锁定的资源)。在这种情况下，需要为此资源分配一个数字 ID 。如果该资源有一个唯一的名称，那么最简单的方式是为此名称生成一个哈希码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> hashtext(<span class="hljs-string">&#x27;resource1&#x27;</span>);<br> hashtext<br>−−−−−−−−−−−<br> <span class="hljs-number">991601810</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>PostgreSQL 提供了一整套用于管理咨询锁的函数 8。它们的名称以 pg_advisory 前缀开头，并且包含以下暗示函数用途的单词：</p><p><strong>lock</strong> — 获取锁</p><p><strong>try</strong> — 如果可以无需等待，便获取锁</p><p><strong>unlock</strong> — 释放锁</p><p><strong>share</strong> — 使用共享锁模式 (默认情况下，使用独占模式)</p><p><strong>xact</strong> — 获取并持有锁直至事务结束 (默认情况下，锁会持有至会话结束)</p><p>让我们获取一个独占锁，直至会话结束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_advisory_lock(hashtext(<span class="hljs-string">&#x27;resource1&#x27;</span>));<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> locktype, objid, mode, granted<br><span class="hljs-keyword">FROM</span> pg_locks <span class="hljs-keyword">WHERE</span> locktype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;advisory&#x27;</span> <span class="hljs-keyword">AND</span> pid <span class="hljs-operator">=</span> pg_backend_pid();<br> locktype <span class="hljs-operator">|</span>   objid   <span class="hljs-operator">|</span>     mode      <span class="hljs-operator">|</span> granted<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<br> advisory <span class="hljs-operator">|</span> <span class="hljs-number">991601810</span> <span class="hljs-operator">|</span> ExclusiveLock <span class="hljs-operator">|</span> t<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>为了确保咨询锁实际起作用，其他进程在访问资源时也必须遵守既定的顺序；这必须由应用程序保证。</p><p>即使在事务完成之后，获取的锁也会继续保持：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> locktype, objid, mode, granted<br><span class="hljs-keyword">FROM</span> pg_locks <span class="hljs-keyword">WHERE</span> locktype <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;advisory&#x27;</span> <span class="hljs-keyword">AND</span> pid <span class="hljs-operator">=</span> pg_backend_pid();<br> locktype <span class="hljs-operator">|</span>   objid   <span class="hljs-operator">|</span>     mode      <span class="hljs-operator">|</span> granted<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<br> advisory <span class="hljs-operator">|</span> <span class="hljs-number">991601810</span> <span class="hljs-operator">|</span> ExclusiveLock <span class="hljs-operator">|</span> t<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>一旦对资源的操作结束，锁必须被显式释放：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_advisory_unlock(hashtext(<span class="hljs-string">&#x27;resource1&#x27;</span>));<br></code></pre></td></tr></table></figure><h3 id="14-5-Predicate-Locks"><a href="#14-5-Predicate-Locks" class="headerlink" title="14.5 Predicate Locks"></a><a name="Predicate-Locks"></a>14.5 Predicate Locks</h3><p>谓词锁这个术语最早出现在首次尝试实现基于锁的完全隔离的时候 9。当时面临的问题是，即使锁定了要读取和更新的所有行，仍然无法保证完全隔离。实际上，如果新插入的行满足过滤条件，它们将成为幻象。</p><p>因此，有人建议锁定条件 (谓词) 而不是行。如果使用 a &gt; 10 的谓词运行查询，锁定这个谓词将不允许在满足此条件的情况下向表中添加新行，因此可以避免幻象的出现。麻烦的是，如果出现带有不同谓词的查询，例如 a &lt; 20，你必须找出这些谓词是否重叠。理论上，这个问题在算法上是无解的；实际上，仅仅是非常简单的谓词类别才能解决 (如本例所示)。</p><p>在 PostgreSQL 中，可串行化隔离级别以不同的方式实现：它使用可串行化快照隔离 (SSI) 协议 10。谓词锁这个术语仍然存在，但其含义已经彻底变了。事实上，这种”锁”并不锁定任何东西：它们用于跟踪不同事务之间的数据依赖关系。</p><p>已经证明，可重复读级别的快照隔离除了写偏序和只读事务异常之外，不允许任何异常。这两种异常会导致数据依赖图中的特定模式，这些模式可以以相对较低的成本发现。</p><p>问题是我们必须区分两种类型的依赖关系：</p><p>   第一个事务读取了之后由第二个事务更新的行 (RW 依赖)。<br>   第一个事务修改了之后由第二个事务读取的行 (WR 依赖)。</p><p>WR 依赖可以使用常规锁来检测，但是 RW 依赖必须通过谓词锁来跟踪。这种跟踪在可串行化隔离级别下会自动开启，这也正是为什么将该级别用于所有事务 (或至少所有相互关联的事务) 的重要原因。如果任何事务在不同级别下运行，它将不会设置 (或检查) 谓词锁，因此可串行化级别将降级为可重复读。</p><p>我想再次强调，尽管它们的名字如此，但谓词锁不会锁定任何东西。相反，当一个事务即将提交时，会检查”危险”的依赖关系，如果 PostgreSQL 怀疑有异常，这个事务将被中止。</p><p>让我们创建一个带有索引的表，该索引包括多个页面 (可以通过使用一个较低的 fillfactor 值实现)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE TABLE</span> pred(n <span class="hljs-type">numeric</span>, s text);<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> pred(n) <span class="hljs-keyword">SELECT</span> n <span class="hljs-keyword">FROM</span> generate_series(<span class="hljs-number">1</span>,<span class="hljs-number">10000</span>) n;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> pred(n) <span class="hljs-keyword">WITH</span> (fillfactor <span class="hljs-operator">=</span> <span class="hljs-number">10</span>);<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> ANALYZE pred;<br></code></pre></td></tr></table></figure><p>如果查询执行顺序扫描，将会在整个表上获取一个谓词锁 (即使某些行不满足提供的过滤条件)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_backend_pid();<br> pg_backend_pid<br>−−−−−−−−−−−−−−−−<br>          <span class="hljs-number">34753</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL SERIALIZABLE;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, costs off, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pred <span class="hljs-keyword">WHERE</span> n <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span>;<br>               QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Seq Scan <span class="hljs-keyword">on</span> pred (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">9900</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   <span class="hljs-keyword">Filter</span>: (n <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;100&#x27;</span>::<span class="hljs-type">numeric</span>)<br>   <span class="hljs-keyword">Rows</span> Removed <span class="hljs-keyword">by</span> <span class="hljs-keyword">Filter</span>: <span class="hljs-number">100</span><br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>虽然谓词锁有它们自己的基础设施，但 pg_locks 视图将它们与重锁显示在一起。所有的谓词锁总是以 SIRead 模式获取，这表示可串行化隔离读：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> relation::regclass, locktype, page, tuple<br><span class="hljs-keyword">FROM</span> pg_locks <span class="hljs-keyword">WHERE</span> mode <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SIReadLock&#x27;</span> <span class="hljs-keyword">AND</span> pid <span class="hljs-operator">=</span> <span class="hljs-number">34753</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>;<br> relation <span class="hljs-operator">|</span> locktype <span class="hljs-operator">|</span> page <span class="hljs-operator">|</span> tuple<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br> pred     <span class="hljs-operator">|</span> relation <span class="hljs-operator">|</span>      <span class="hljs-operator">|</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><p>注意，谓词锁的持续时间可能比事务本身更长，因为它们用于跟踪事务之间的依赖关系。但无论如何，这些锁是自动管理的。</p><p>如果查询执行索引扫描，情况就会有所改善。对于 B 树索引，只需在读取的堆元组和扫描过的索引叶子页面上设置谓词锁。它将”锁定”已读取的整个范围，而不仅仅是确切的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span> ISOLATION LEVEL SERIALIZABLE;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, costs off, timing off, summary off)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pred <span class="hljs-keyword">WHERE</span> n <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">1001</span>;<br>                          QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> pred_n_idx <span class="hljs-keyword">on</span> pred (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">2</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   Index Cond: ((n <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;1000&#x27;</span>::<span class="hljs-type">numeric</span>) <span class="hljs-keyword">AND</span> (n <span class="hljs-operator">&lt;=</span> <span class="hljs-string">&#x27;1001&#x27;</span>::<span class="hljs-type">numeric</span>))<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> relation::regclass, locktype, page, tuple<br><span class="hljs-keyword">FROM</span> pg_locks <span class="hljs-keyword">WHERE</span> mode <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SIReadLock&#x27;</span> <span class="hljs-keyword">AND</span> pid <span class="hljs-operator">=</span> <span class="hljs-number">34753</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>;<br>  relation  <span class="hljs-operator">|</span> locktype <span class="hljs-operator">|</span> page <span class="hljs-operator">|</span> tuple<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br> pred       <span class="hljs-operator">|</span> tuple    <span class="hljs-operator">|</span>    <span class="hljs-number">4</span> <span class="hljs-operator">|</span>    <span class="hljs-number">96</span><br> pred       <span class="hljs-operator">|</span> tuple    <span class="hljs-operator">|</span>    <span class="hljs-number">4</span> <span class="hljs-operator">|</span>    <span class="hljs-number">97</span><br> pred_n_idx <span class="hljs-operator">|</span> page     <span class="hljs-operator">|</span>   <span class="hljs-number">28</span> <span class="hljs-operator">|</span><br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>与已扫描元组相对应的叶子页面数量可以发生改变：例如，当向表中插入新行时，索引页面可能会发生分裂。然而，PostgreSQL 会将其考虑在内，并且也会锁定新出现的页面：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> pred<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1000</span><span class="hljs-operator">+</span>(n<span class="hljs-operator">/</span><span class="hljs-number">1000.0</span>) <span class="hljs-keyword">FROM</span> generate_series(<span class="hljs-number">1</span>,<span class="hljs-number">999</span>) n;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> relation::regclass, locktype, page, tuple<br><span class="hljs-keyword">FROM</span> pg_locks <span class="hljs-keyword">WHERE</span> mode <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SIReadLock&#x27;</span> <span class="hljs-keyword">AND</span> pid <span class="hljs-operator">=</span> <span class="hljs-number">34753</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>;<br>  relation  <span class="hljs-operator">|</span> locktype <span class="hljs-operator">|</span> page <span class="hljs-operator">|</span> tuple<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br> pred       <span class="hljs-operator">|</span> tuple    <span class="hljs-operator">|</span>    <span class="hljs-number">4</span> <span class="hljs-operator">|</span>    <span class="hljs-number">96</span><br> pred       <span class="hljs-operator">|</span> tuple    <span class="hljs-operator">|</span>    <span class="hljs-number">4</span> <span class="hljs-operator">|</span>    <span class="hljs-number">97</span><br> pred_n_idx <span class="hljs-operator">|</span> page     <span class="hljs-operator">|</span>   <span class="hljs-number">28</span> <span class="hljs-operator">|</span><br> pred_n_idx <span class="hljs-operator">|</span> page     <span class="hljs-operator">|</span>  <span class="hljs-number">266</span> <span class="hljs-operator">|</span><br> pred_n_idx <span class="hljs-operator">|</span> page     <span class="hljs-operator">|</span>  <span class="hljs-number">267</span> <span class="hljs-operator">|</span><br> pred_n_idx <span class="hljs-operator">|</span> page     <span class="hljs-operator">|</span>  <span class="hljs-number">268</span> <span class="hljs-operator">|</span><br> pred_n_idx <span class="hljs-operator">|</span> page     <span class="hljs-operator">|</span>  <span class="hljs-number">269</span> <span class="hljs-operator">|</span><br>(<span class="hljs-number">7</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>每个读取的元组都会被单独锁定，并且可能有相当多这样的元组。谓词锁使用它们自己的锁池，这个锁池在服务器启动时分配。谓词锁的总数受到 max_pred_locks_per_transaction 乘以 max_connections 的限制 (尽管参数名如此，谓词锁并不是按单独事务计数的)。</p><p>在这里，我们遇到了与行级锁相同的问题，但解决方式不同：应用了锁升级。11</p><p>一旦与单个页面相关的元组锁的数量超过了 max_pred_locks_per_page 参数的值，便会被一个单独的页级锁替代。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (analyze, costs off, timing off, summary off)<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pred <span class="hljs-keyword">WHERE</span> n <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">1002</span>;<br>                            QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> Index Scan <span class="hljs-keyword">using</span> pred_n_idx <span class="hljs-keyword">on</span> pred (actual <span class="hljs-keyword">rows</span><span class="hljs-operator">=</span><span class="hljs-number">3</span> loops<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br>   Index Cond: ((n <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;1000&#x27;</span>::<span class="hljs-type">numeric</span>) <span class="hljs-keyword">AND</span> (n <span class="hljs-operator">&lt;=</span> <span class="hljs-string">&#x27;1002&#x27;</span>::<span class="hljs-type">numeric</span>))<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>现在，不再是三个 tuple 类型的锁，而是一个 page 类型的锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> relation::regclass, locktype, page, tuple<br><span class="hljs-keyword">FROM</span> pg_locks <span class="hljs-keyword">WHERE</span> mode <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;SIReadLock&#x27;</span> <span class="hljs-keyword">AND</span> pid <span class="hljs-operator">=</span> <span class="hljs-number">34753</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>;<br>  relation  <span class="hljs-operator">|</span> locktype <span class="hljs-operator">|</span> page <span class="hljs-operator">|</span> tuple<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br> pred       <span class="hljs-operator">|</span> page     <span class="hljs-operator">|</span>    <span class="hljs-number">4</span> <span class="hljs-operator">|</span><br> pred_n_idx <span class="hljs-operator">|</span> page     <span class="hljs-operator">|</span>   <span class="hljs-number">28</span> <span class="hljs-operator">|</span><br> pred_n_idx <span class="hljs-operator">|</span> page     <span class="hljs-operator">|</span>  <span class="hljs-number">266</span> <span class="hljs-operator">|</span><br> pred_n_idx <span class="hljs-operator">|</span> page     <span class="hljs-operator">|</span>  <span class="hljs-number">267</span> <span class="hljs-operator">|</span><br> pred_n_idx <span class="hljs-operator">|</span> page     <span class="hljs-operator">|</span>  <span class="hljs-number">268</span> <span class="hljs-operator">|</span><br> pred_n_idx <span class="hljs-operator">|</span> page     <span class="hljs-operator">|</span>  <span class="hljs-number">269</span> <span class="hljs-operator">|</span><br>(<span class="hljs-number">6</span> <span class="hljs-keyword">rows</span>)<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><p>页级锁的升级遵循相同的原则。如果某个特定关系的页级锁的数量超过了 max_pred_locks_per_relation 值，他们将被一个单独的关系级锁替代。(如果此参数设置为负数，那么阈值为 max_pred_locks_per_transaction 除以 max_pred_locks_per_relation 的绝对值；因此，默认的阈值为 32)。</p><p>锁升级肯定会导致多次 false-positive 序列化错误，这会对系统吞吐量产生负面影响。所以你必须在性能和在锁上花费的内存之间找到一个合适的平衡点。</p><p>谓词锁支持以下索引类型：</p><p>   B 树<br>   哈希索引，GiST 和 GIN</p><p>如果执行了索引扫描，但索引不支持谓词锁，那么整个索引将被锁定。可以预料，在这种情况下，无故中止的事务数量也会增加。</p><p>为了在可串行化级别下更高效地操作，使用 read only 子句显式声明只读事务是有意义的。如果锁管理器看到只读事务不会与其他事务发生冲突 12，它可以释放已经设置的谓词锁并避免获取新的谓词锁。如果这样的事务也被声明为 DEFERABLE 的，那么也可以避免只读事务异常。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch15. Locks on MemoryStructures</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch15/ch15/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch15/ch15/</url>
    
    <content type="html"><![CDATA[<h2 id="ch15-Locks-on-MemoryStructures"><a href="#ch15-Locks-on-MemoryStructures" class="headerlink" title="ch15. Locks on MemoryStructures"></a>ch15. Locks on MemoryStructures</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#Spinlocks">15.1 Spinlocks</a></td></tr><tr><td><a href="#lwlock">15.2 Lightweight Locks</a></td></tr><tr><td><a href="#example">15.3 Examples</a></td></tr><tr><td><a href="#monitor-wait">15.4 Monitoring Waits</a></td></tr><tr><td><a href="#sampling">15.5 Sampling</a></td></tr></tbody></table><h3 id="15-1-Spinlocks"><a href="#15-1-Spinlocks" class="headerlink" title="15.1 Spinlocks"></a><a name="Spinlocks"></a>15.1 Spinlocks</h3><p>为了保护共享内存中的数据结构，PostgreSQL 使用了几种更加轻量和开销更小的锁，而不是常规的重锁。</p><p>最简单的锁是自旋锁。自旋锁通常仅获取非常短的时间 (不超过几个 CPU 周期)，以保护特定内存单元不受并发更新的影响。</p><p>自旋锁基于原子 CPU 指令，比如 CAS (compare-and-swap) 1。它们仅支持独占锁定模式。如果所需资源已被锁定，那么进程将忙等，并重复命令 (在循环中”自旋”，因此得名)。如果在指定的时间间隔内无法获取锁，进程将暂停一段时间，然后开始另一次循环。</p><p>如果评估冲突的概率非常低，那么这种策略是有意义的，因此在一次失败的尝试之后，锁很有可能在几条指令内被获取。</p><p>自旋锁既没有死锁检测，也没有监测机制。从实际的角度来看，我们只需要知道它们的存在；正确实现的全部责任均落在 PostgreSQL 开发者身上。</p><h3 id="15-2-Lightweight-Locks"><a href="#15-2-Lightweight-Locks" class="headerlink" title="15.2 Lightweight Locks"></a><a name="lwlock"></a>15.2 Lightweight Locks</h3><p>接下来，还有所谓的轻量锁，即 lwlocks 2。轻量锁是在处理数据结构 (例如，哈希表或指针列表) 所需的时间内获取的，通常时间较短；然而，当用于保护 I&#x2F;O 操作时，可能需要更长的时间。</p><p>轻量锁支持两种模式：独占模式 (用于数据修改) 和共享模式 (用于只读操作)。轻量锁没有严格的队列机制：如果有多个进程在等待一个锁，其中一个进程将或多或少以随机的方式获得对资源的访问。在高负载的系统中，特别是那些有多个并发进程的系统中，这种机制可能会导致一些令人不悦的影响。</p><p>轻量锁也没有提供死锁检测机制；我们必须相信 PostgreSQL 开发人员正确实现了这些锁。然而，这些锁确实有监测机制，因此与自旋锁不同，它们是可以被观察到的。</p><h3 id="15-3-Examples"><a href="#15-3-Examples" class="headerlink" title="15.3 Examples"></a><a name="example"></a>15.3 Examples</h3><p>为了了解如何使用以及在何处使用自旋锁和轻量锁，让我们看下两个共享内存结构：缓冲区缓存和 WAL 缓冲区。我只会提到其中一些锁；由于全貌过于复杂，可能只有 PostgreSQL 内核开发人员感兴趣。</p><h4 id="15-3-1-缓冲区缓存"><a href="#15-3-1-缓冲区缓存" class="headerlink" title="15.3.1 缓冲区缓存"></a>15.3.1 缓冲区缓存</h4><p>为了访问用于定位缓存中特定缓冲区的哈希表，进程必须以共享模式获取一个 BufferMapping 轻量锁以进行读取，或者如果预期有任何修改，则以独占模式获取。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch15/ch15/img.png" alt="img.png"></p><p>哈希表的访问十分频繁，因此这个锁经常成为瓶颈。为了最大限度地提高粒度，它被构造为一个由 128 个独立的轻量锁组成的锁集，每个锁用于保护哈希表的一个分区。3</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">早在 2006 年，Postgres 8.2 版本就将哈希表锁转换为包含 16 个锁的锁集；十年后，当 9.5 版本发布时，锁集的大小增加到了 128 个，但对于现代多核系统来说，这可能仍然不够。<br></code></pre></td></tr></table></figure><p>为了访问缓冲区头，进程获取缓冲区头自旋锁 4 (名字是任意的，因为自旋锁没有对用户可见的名字)。某些操作，比如增加使用计数，不需要显式锁定，可以使用原子 CPU 指令执行。</p><p>为了读取缓冲区中的页面，进程需要获取此缓冲区头中的 BufferContent 锁 5。这个锁通常仅在读取元组指针时持有，稍后，缓冲区锁定提供的保护就足够了。如果需要修改缓冲区的内容，那么必须以独占模式获取 BufferContent 锁。当从磁盘读取某个缓冲区 (或写入磁盘) 时，PostgreSQL 还会在缓冲区头中获取 BufferIO 锁；它实际上是一个用作锁的属性，而不是一个真正的锁 6。它向请求访问这个页面的其他进程发出信号，告诉它们必须等到 I&#x2F;O 操作完成。</p><p>指向空闲缓冲区的指针和淘汰机制的时钟指针由一个共同的缓冲区策略自旋锁保护 7。</p><h4 id="15-3-2-WAL-缓冲区"><a href="#15-3-2-WAL-缓冲区" class="headerlink" title="15.3.2 WAL 缓冲区"></a>15.3.2 WAL 缓冲区</h4><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch15/ch15/img_1.png" alt="img_1.png"></p><p>WAL 缓存也使用哈希表将页面映射到缓冲区。不同于缓冲区缓存的哈希表，它由单个 WALBufMapping 轻量锁保护，因为 WAL 缓存较小 (通常是缓冲区缓存大小的 1&#x2F;32 )，并且缓冲区的访问更加有序 8。</p><p>将 WAL 页面写入磁盘受到 WALWrite 轻量锁的保护，以确保此操作一次只由一个进程执行。</p><p>为了创建一个 WAL 条目，进程首先在 WAL 页面内预留一些空间，然后用数据填充。空间预留严格有序；进程必须获取一个插入位置的自旋锁，以保护插入指针 9。但一旦空间被预留后，它就可以由若干并发进程共同填充。为此，每个进程都必须获取构成 WALInsert 锁集的 8 个轻量锁中的任何一个 10。</p><h3 id="15-4-Monitoring-Waits"><a href="#15-4-Monitoring-Waits" class="headerlink" title="15.4 Monitoring Waits"></a><a name="monitor-wait"></a>15.4 Monitoring Waits</h3><p>毫无疑问，锁对于 PostgreSQL 的正确运行是必不可少的，但它们可能导致不希望的等待。追踪这些等待以了解它们的起源是非常有用的。</p><p>获取长锁概览的最简单方式是调整 log_lock_waits 参数为 on。它会详细记录所有导致事务等待时间超过 deadlock_timeout 的锁至日志中。这些数据在死锁检测完成时显示，因此而得名。</p><p>然而，pg_stat_activity 视图提供了更多有用和完整的信息。每当一个进程 (不管是系统进程还是后端进程) 由于在等待某个东西而无法继续其操作时，此等待就会反映在 wait_event_type 和 wait_event 字段中，分别显示等待的类型和名称。</p><p>所有等待可以归类如下 11。</p><p>各种锁的等待组成了一个相当大的群组：</p><p><strong>Lock</strong>：重锁</p><p><strong>LWLock</strong>：轻量锁</p><p><strong>BufferPin</strong>：锁定的缓冲区</p><p>但进程也可能在等待其他事件：</p><p><strong>IO</strong>：输入&#x2F;输出，需要读取或写入某些数据时</p><p><strong>Client</strong>：客户端发送的数据 (psql 大部分时间处于这个状态)</p><p><strong>IPC</strong>：其他进程发送的数据</p><p><strong>Extension</strong>：由扩展注册的特定事件</p><p>有时，一个进程没有执行任何有用的工作。这样的等待通常是”正常”的，意味着它们不表明有任何问题。这类分组包括以下等待：</p><p><strong>Activity</strong>：后台进程在其主循环中</p><p><strong>Timeout</strong>：计时器</p><p>每种等待类型的锁按等待名称进一步分类。例如，等待轻量锁有相应的锁名称或相应的锁集 12。</p><p>你应该记住，pg_stat_activity 视图只显示了那些在源代码中以适当方式处理的等待 13。除非等待的名称出现在这个视图中，否则进程不会处于任何已知类型的等待状态。这样的时间应被视为”未知时间”，这并不一定意味着进程没有任何等待 — 我们只是不知道此刻发生了什么。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> backend_type, wait_event_type <span class="hljs-keyword">AS</span> event_type, wait_event<br><span class="hljs-keyword">FROM</span> pg_stat_activity;<br>        backend_type          <span class="hljs-operator">|</span> event_type <span class="hljs-operator">|</span>     wait_event<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−<br> logical replication launcher <span class="hljs-operator">|</span> Activity   <span class="hljs-operator">|</span> LogicalLauncherMain<br> autovacuum launcher          <span class="hljs-operator">|</span> Activity   <span class="hljs-operator">|</span> AutoVacuumMain<br> client backend               <span class="hljs-operator">|</span>            <span class="hljs-operator">|</span><br> background writer            <span class="hljs-operator">|</span> Activity   <span class="hljs-operator">|</span> BgWriterMain<br> checkpointer                 <span class="hljs-operator">|</span> Activity   <span class="hljs-operator">|</span> CheckpointerMain<br> walwriter                    <span class="hljs-operator">|</span> Activity   <span class="hljs-operator">|</span> WalWriterMain<br>(<span class="hljs-number">6</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>当对视图进行采样时，所有的后台进程都处于空闲状态，而客户端后端进程正忙于执行查询，并且没有等待任何东西。</p><h3 id="15-5-Sampling"><a href="#15-5-Sampling" class="headerlink" title="15.5 Sampling"></a><a name="sampling"></a>15.5 Sampling</h3><p>不幸的是，pg_stat_activity 视图只显示了关于等待的当前信息；统计数据不会累积。收集随时间变化的等待数据的唯一方式是定期采样该视图。</p><p>我们必须考虑到抽样的随机性。与采样间隔相比，等待时间越短，检测到这种等待情况的机会就越低。因此，更长的采样间隔需要更多的样本来反映事物的实际状态 (但随着采样率的增加，开销也会增加)。出于同样的原因，采样对于分析短暂会话几乎没有用处。</p><p>PostgreSQL 没有提供内置的采样工具；但是，我们仍然可以尝试使用 pg_wait_sampling 14 扩展。为此，我们需要在 shared_preload_libraries 参数中指定它的库名，然后重启服务器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">SET</span> shared_preload_libraries <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;pg_wait_sampling&#x27;</span>;<br>postgres$ pg_ctl restart <span class="hljs-operator">-</span>l <span class="hljs-operator">/</span>home<span class="hljs-operator">/</span>postgres<span class="hljs-operator">/</span>logfile<br></code></pre></td></tr></table></figure><p>现在让我们在数据库中安装扩展：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> EXTENSION pg_wait_sampling;<br></code></pre></td></tr></table></figure><p>此扩展可以显示保存在其环形缓冲区中的历史等待情况。然而，更有趣的是获取等待概况 — 整个会话期间的累计统计数据。</p><p>例如，让我们看一下基准测试期间的等待情况。我们需要启动 pgbench 工具，并在其运行时确定其进程 ID：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">/usr/local/pgsql/bin/pgbench -T 60 internals</span><br>=&gt; SELECT pid FROM pg_stat_activity<br>WHERE application_name = &#x27;pgbench&#x27;;<br>  pid<br>−−−−−−−<br> 36367<br>(1 row)<br></code></pre></td></tr></table></figure><p>测试完成之后，等待概况如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pid, event_type, event, count<br><span class="hljs-keyword">FROM</span> pg_wait_sampling_profile <span class="hljs-keyword">WHERE</span> pid <span class="hljs-operator">=</span> <span class="hljs-number">36380</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> count <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">4</span>;<br>  pid  <span class="hljs-operator">|</span> event_type <span class="hljs-operator">|</span>  event     <span class="hljs-operator">|</span> count<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br> <span class="hljs-number">36367</span> <span class="hljs-operator">|</span> IO         <span class="hljs-operator">|</span> WALSync      <span class="hljs-operator">|</span>  <span class="hljs-number">3478</span><br> <span class="hljs-number">36367</span> <span class="hljs-operator">|</span> IO         <span class="hljs-operator">|</span> WALWrite     <span class="hljs-operator">|</span>    <span class="hljs-number">52</span><br> <span class="hljs-number">36367</span> <span class="hljs-operator">|</span> Client     <span class="hljs-operator">|</span> ClientRead   <span class="hljs-operator">|</span>    <span class="hljs-number">30</span><br> <span class="hljs-number">36367</span> <span class="hljs-operator">|</span> IO         <span class="hljs-operator">|</span> DataFileRead <span class="hljs-operator">|</span>     <span class="hljs-number">2</span><br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>默认情况下 (由 pg_wait_sampling.profile_period 参数设置) 每秒采样 100 次。因此，要估算等待时间的秒数，必须将值除以 100。</p><p>在这个特定案例中，大部分等待与将 WAL 条目刷新到磁盘有关。这很好地说明了未知的等待时间：WALSync 事件直到 PostgreSQL 12 才被记录；对于更低的版本，等待概况不会包含第一行，尽管等待本身仍然存在。</p><p>如果我们人为降低文件系统的速度，使每个 I&#x2F;O 操作需要耗时 0.1 秒 (为此，我使用了 slowfs 15)，那么等待概况将如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql">postgres$ <span class="hljs-operator">/</span>usr<span class="hljs-operator">/</span><span class="hljs-keyword">local</span><span class="hljs-operator">/</span>pgsql<span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>pgbench <span class="hljs-operator">-</span>T <span class="hljs-number">60</span> internals<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pid <span class="hljs-keyword">FROM</span> pg_stat_activity<br><span class="hljs-keyword">WHERE</span> application_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;pgbench&#x27;</span>;<br>  pid<br>−−−−−−−<br> <span class="hljs-number">36747</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pid, event_type, event, count<br><span class="hljs-keyword">FROM</span> pg_wait_sampling_profile <span class="hljs-keyword">WHERE</span> pid <span class="hljs-operator">=</span> <span class="hljs-number">36759</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> count <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">4</span>;<br>  pid  <span class="hljs-operator">|</span> event_type <span class="hljs-operator">|</span>     event      <span class="hljs-operator">|</span> count<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−<br> <span class="hljs-number">36747</span> <span class="hljs-operator">|</span> IO         <span class="hljs-operator">|</span> WALWrite       <span class="hljs-operator">|</span> <span class="hljs-number">3603</span><br> <span class="hljs-number">36747</span> <span class="hljs-operator">|</span> LWLock     <span class="hljs-operator">|</span> WALWrite       <span class="hljs-operator">|</span>  <span class="hljs-number">2095</span><br> <span class="hljs-number">36747</span> <span class="hljs-operator">|</span> IO         <span class="hljs-operator">|</span> WALSync        <span class="hljs-operator">|</span>    <span class="hljs-number">22</span><br> <span class="hljs-number">36747</span> <span class="hljs-operator">|</span> IO         <span class="hljs-operator">|</span> DataFileExtend <span class="hljs-operator">|</span>    <span class="hljs-number">19</span><br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>现在，I&#x2F;O 操作是最慢的，主要是以同步模式将 WAL 文件写入磁盘的相关操作。WAL 写入受到 WALWrite 轻量锁的保护，因此相应的行也会出现在等待概况中。</p><p>显然，在前一个示例中也获得了相同的锁，但由于等待时间短于采样间隔，所以要么它很少被采样到，要么根本就没有出现在等待概况中。这再次说明，要分析短暂的等待，你必须对其进行相当长时间的采样。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch13. Row-Level Locks</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch13/ch13/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch13/ch13/</url>
    
    <content type="html"><![CDATA[<h2 id="ch13-Row-Level-Locks"><a href="#ch13-Row-Level-Locks" class="headerlink" title="ch13. Row-Level Locks"></a>ch13. Row-Level Locks</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#lock-design">13.1 Lock Design</a></td></tr><tr><td><a href="#row-level-Locks">13.2 Row-Level Locking Modes</a></td></tr><tr><td><a href="#multixact">13.3 Multitransactions</a></td></tr><tr><td><a href="#row-wait-queue">13.4 Wait Queue</a></td></tr><tr><td><a href="#No-Wait-Locks">13.5 No-Wait Locks</a></td></tr><tr><td><a href="#row-deadlock">13.6 Deadlocks</a></td></tr></tbody></table><h3 id="13-1-Lock-Design"><a href="#13-1-Lock-Design" class="headerlink" title="13.1 Lock Design"></a><a name="lock-design"></a>13.1 Lock Design</h3><p>得益于快照隔离，读取时无需对堆元组加锁。但是，不允许两个写事务同时修改同一行。在这种情况下，必须对行加锁，但为此重锁并不是一个好的选择：每个重锁都会占用服务器共享内存中的空间 (数百字节，更别提所有支持的基础设施了)，而且 PostgreSQL 的内部机制也不适用于处理大量并发的重锁。</p><p>一些数据库系统通过锁升级来解决这个问题：如果行级锁太多，它们会被更细粒度的单个锁替换 (例如，页级锁或表级锁)。这简化了实现，但极大限制了系统的吞吐量。</p><p>在 PostgreSQL 中，某个特定的行是否被锁定的信息仅保存在其当前堆元组的元组头中。行级锁实际上是堆页面中的属性，而不是实际的锁，并且不会以任何方式反映在 RAM 中。</p><p>行通常在被更新或删除时进行加锁。在这两种情况下，行的当前版本都被标记为已删除。用于此目的的属性是在 xmax 字段中指定的当前事务 ID，同时也是这个 ID 表明该行被锁定了 (与额外的提示位相结合)。如果一个事务想要修改一行，但是在其当前版本的 xmax 字段上看到一个活跃的事务 ID，那么它必须等待这个事务完成。一旦事务结束，所有的锁都会被释放，等待的事务便可以继续。</p><p>此机制允许按需锁定任意数量的行，而无需额外成本。</p><p>这种方案的缺点是其他进程无法形成队列，因为 RAM 中不包含关于这种锁的信息。因此，仍然需要重锁：等待行释放的进程会请求当前正在处理该行的事务 ID 上的锁。一旦事务完成，这一行便再次可用。因此，重锁的数量与并发进程的数量成正比，而不是被修改的行数。</p><h3 id="13-2-Row-Level-Locking-Modes"><a href="#13-2-Row-Level-Locking-Modes" class="headerlink" title="13.2 Row-Level Locking Modes"></a><a name="row-level-Locks"></a>13.2 Row-Level Locking Modes</h3><p>行级锁支持四种模式 1。其中两种实现了独占锁，一次只能由一个事务获取，而另外两种提供了共享锁，可以同时由多个事务持有。</p><p>以下是这些模式的兼容性矩阵：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch13/ch13/img.png" alt="img.png"></p><p>####13.2.1 Exclusive Modes<br>Update 模式允许修改任何元组字段，甚至删除整个元组，而 No Key Update 模式只允许那些不涉及与唯一索引相关字段的更改 (换句话说，外键必须不受影响)。</p><p>UPDATE 命令会自动选择可能最弱的锁定模式；键通常保持不变，因此行通常在 No Key Update 模式下被锁定。</p><p>让我们创建一个函数，使用 pageinspect 显示我们感兴趣的一些元组元数据，即 xmax 字段和若干提示位：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> row_locks(relname text, pageno <span class="hljs-type">integer</span>)<br><span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">TABLE</span>(<br>ctid tid, xmax text,<br>lock_only text, is_multi text,<br>keys_upd text, keyshr text,<br>shr text<br>)<br><span class="hljs-keyword">AS</span> $$<br><span class="hljs-keyword">SELECT</span> (pageno,lp)::text::tid,<br>t_xmax,<br><span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> t_infomask <span class="hljs-operator">&amp;</span> <span class="hljs-number">128</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;t&#x27;</span> <span class="hljs-keyword">END</span>,<br><span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> t_infomask <span class="hljs-operator">&amp;</span> <span class="hljs-number">4096</span> <span class="hljs-operator">=</span> <span class="hljs-number">4096</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;t&#x27;</span> <span class="hljs-keyword">END</span>,<br><span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> t_infomask2 <span class="hljs-operator">&amp;</span> <span class="hljs-number">8192</span> <span class="hljs-operator">=</span> <span class="hljs-number">8192</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;t&#x27;</span> <span class="hljs-keyword">END</span>,<br><span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> t_infomask <span class="hljs-operator">&amp;</span> <span class="hljs-number">16</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;t&#x27;</span> <span class="hljs-keyword">END</span>,<br><span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> t_infomask <span class="hljs-operator">&amp;</span> <span class="hljs-number">16</span><span class="hljs-operator">+</span><span class="hljs-number">64</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span><span class="hljs-operator">+</span><span class="hljs-number">64</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;t&#x27;</span> <span class="hljs-keyword">END</span><br><span class="hljs-keyword">FROM</span> heap_page_items(get_raw_page(relname,pageno))<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> lp;<br>$$ <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">sql</span>;<br><br></code></pre></td></tr></table></figure><p>现在在 accounts 表上开启一个事务，以更新第一个帐户的余额 (键保持不变) 和第二个帐户的 ID (键更新了)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">+</span> <span class="hljs-number">100.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> id <span class="hljs-operator">=</span> <span class="hljs-number">20</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>页面现在包含以下元数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> row_locks(<span class="hljs-string">&#x27;accounts&#x27;</span>,<span class="hljs-number">0</span>) LIMIT <span class="hljs-number">2</span>;<br>ctid <span class="hljs-operator">|</span> xmax <span class="hljs-operator">|</span> lock_only <span class="hljs-operator">|</span> is_multi <span class="hljs-operator">|</span> keys_upd <span class="hljs-operator">|</span> keyshr <span class="hljs-operator">|</span> shr<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−<br>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> <span class="hljs-number">134980</span> <span class="hljs-operator">|</span> <span class="hljs-operator">|</span> <span class="hljs-operator">|</span> <span class="hljs-operator">|</span> <span class="hljs-operator">|</span><br>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> <span class="hljs-number">134980</span> <span class="hljs-operator">|</span> <span class="hljs-operator">|</span> <span class="hljs-operator">|</span> t <span class="hljs-operator">|</span> <span class="hljs-operator">|</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>锁定模式由 keys_updated 提示位定义。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">=&gt; ROLLBACK;<br></code></pre></td></tr></table></figure><p>SELECT FOR 命令使用与锁定属性相同的 xmax 字段，但在这种情况下还必须设置 xmax_lock_only 提示位。这个提示位表示这条元组被锁定而不是被删除，这意味着它仍然是当前版本：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">NO</span> KEY <span class="hljs-keyword">UPDATE</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> row_locks(<span class="hljs-string">&#x27;accounts&#x27;</span>,<span class="hljs-number">0</span>) LIMIT <span class="hljs-number">2</span>;<br>ctid  <span class="hljs-operator">|</span>  xmax  <span class="hljs-operator">|</span> lock_only <span class="hljs-operator">|</span> is_multi <span class="hljs-operator">|</span> keys_upd <span class="hljs-operator">|</span> keyshr <span class="hljs-operator">|</span> shr<br>−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−<br>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> <span class="hljs-number">134981</span> <span class="hljs-operator">|</span>      t    <span class="hljs-operator">|</span>          <span class="hljs-operator">|</span>          <span class="hljs-operator">|</span>        <span class="hljs-operator">|</span><br>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> <span class="hljs-number">134981</span> <span class="hljs-operator">|</span>      t    <span class="hljs-operator">|</span>          <span class="hljs-operator">|</span>     t    <span class="hljs-operator">|</span>        <span class="hljs-operator">|</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><p>####13.2.2 Shared Modes<br>当需要读取行时，可以使用共享模式，但必须禁止其他事务对这一行的更改。Key Share 模式允许更新除键属性之外的任何元组字段。</p><p>在所有共享模式中，PostgreSQL 内核仅使用 Key Share 模式，这在检查外键时使用。由于它与 No Key Update 独占模式兼容，因此外键检查不会干扰非键属性的并发更新。至于应用，可以使用任何它们喜欢的共享模式。</p><p>再次强调：简单的 SELECT 命令从不使用行级锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FOR</span> KEY SHARE;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">FOR</span> SHARE;<br></code></pre></td></tr></table></figure><p>以下是我们可以在堆元组中看到的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> row_locks(<span class="hljs-string">&#x27;accounts&#x27;</span>,<span class="hljs-number">0</span>) LIMIT <span class="hljs-number">2</span>;<br>ctid  <span class="hljs-operator">|</span> xmax   <span class="hljs-operator">|</span> lock_only <span class="hljs-operator">|</span> is_multi <span class="hljs-operator">|</span> keys_upd <span class="hljs-operator">|</span> keyshr <span class="hljs-operator">|</span> shr<br>−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−<br>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> <span class="hljs-number">134982</span> <span class="hljs-operator">|</span> t         <span class="hljs-operator">|</span>          <span class="hljs-operator">|</span>          <span class="hljs-operator">|</span> t      <span class="hljs-operator">|</span><br>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span> <span class="hljs-number">134982</span> <span class="hljs-operator">|</span> t         <span class="hljs-operator">|</span>          <span class="hljs-operator">|</span>          <span class="hljs-operator">|</span> t      <span class="hljs-operator">|</span> t<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br><br></code></pre></td></tr></table></figure><p>这两个操作都设置了 xmax_keyshr_lock 位，但你可以通过其他提示位识别 Share 模式。</p><h3 id="13-3-Multitransactions"><a href="#13-3-Multitransactions" class="headerlink" title="13.3 Multitransactions"></a><a name="multixact"></a>13.3 Multitransactions</h3><p>正如我们所见，锁定属性由 xmax 字段表示，该字段被设置为获取锁的事务 ID。那么，当多个事务同时持有共享锁时，这个属性是如何设置的呢？</p><p>在处理共享锁时，PostgreSQL 会使用所谓的组事务 3。组事务是被分配了单独 ID 的一组事务。关于组内成员及其锁定模式的详细信息存储在 PGDATA&#x2F;pg_multixact 目录下。为了更快地访问，锁定的页面会缓存在服务器的共享内存中 4；所有更改都会被记录以确保容错性。</p><p>组事务 ID 与常规的事务 ID 长度相同，均是 32 位，但它们是独立分发的。这意味着事务和组事务可能具有相同的 ID。为了区分两者，PostgreSQL 使用了一个额外的提示位：xmax_is_multi。</p><p>让我们增加由另一个事务获取的独占锁 (Key Share 和 No Key Update 模式兼容)：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch13/ch13/img_1.png" alt="img_1.png"></p><p>xmax_is_multi 位表明第一行使用的是组事务 ID 而不是常规 ID。</p><p>在不深入实现细节的情况下，让我们使用 pgrowlocks 扩展显示所有可能的行级锁信息：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch13/ch13/img_2.png" alt="img_2.png"></p><p>这看起来很像查询 pg_locks 视图，但 pgrowlocks 函数必须访问堆页面，因为 RAM 并不包含关于行级锁的信息。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch13/ch13/img_3.png" alt="img_3.png"></p><p>由于组事务 ID 是 32 位的，因此与常规事务 ID 一样，它们也会因为计数器限制而发生回卷。所以，PostgreSQL 必须以类似于冻结的方式处理组事务 ID：用新的组事务 ID 替换老的 (或者如果当时只有一个事务持有锁，则使用常规事务 ID 替换) 5。</p><p>但常规事务 ID 仅在 xmin 字段中被冻结 (非空的 xmax 字段表示元组已过期，并将很快被删除)，对于组事务，必须冻结 xmax 字段：当前行版本可能会被新事务在共享模式下反复锁定。</p><p>组事务的冻结可以通过服务器参数进行管理，类似于为常规冻结提供的参数：vacuum_multixact_freeze_min_age、vacuum_multixact_freeze_table_age、autovacuum_multixact_freeze_max_age 以及 vacuum_multixact_failsafe_age。</p><h3 id="13-4-Wait-Queue"><a href="#13-4-Wait-Queue" class="headerlink" title="13.4 Wait Queue"></a><a name="row-wait-queue"></a>13.4 Wait Queue</h3><p>####13.4.1 Exclusive Modes<br>虽然行级锁只是一个属性，但是队列的排列方式并不是那么简单。当某个事务准备修改一行时，它必须遵循以下步骤：</p><pre><code class="hljs">1. 如果 xmax 字段和提示位表明该行以不兼容的模式被锁定，那么获取正在被修改元组的独占重锁。2. 如有必要，通过请求 xmax 事务 ID 上的锁 (如果 xmax 包含组事务 ID，则请求多个事务)，直到所有不兼容的锁都被释放。3. 将自己的 ID 写入到元组头中的 xmax 中，并设置所需的提示位。4. 如果元组锁是在第一步中获取的，则释放它。</code></pre><p>元组锁是另一种重锁，具有 tuple 类型 (不要与常规行级锁混淆)。</p><p>似乎步骤 1 和步骤 4 看起来是多余的，只需简单地等待所有锁定的事务结束就足够了。但是，如果多个事务试图更新同一行，那么所有的事务都将等待当前正在处理此行的事务。一旦完成，它们会发现自己陷入了竞争，去争夺锁定该行的权利，一些”倒霉”的事务可能不得不无限期地等待。这种情况被称为资源饥饿。</p><p>元组锁识别队列中的第一个事务，并保证它将是下一个获得锁的事务。</p><p>你可以观察这一点。因为 PostgreSQL 在其操作过程中获取了许多不同的锁，每个锁都在 pg_locks 表中以一个单独的行表示，因此我将在 pg_locks 上创建另一个视图。它将以更简洁的形式显示这些信息，只保留那些我们当前感兴趣的锁 (与 accounts 表和事务本身相关的锁，除了任何虚拟事务 ID 上的锁) ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">=&gt; CREATE VIEW locks_accounts AS<br>SELECT pid,<br>locktype,<br>CASE locktype<br>WHEN &#x27;relation&#x27; THEN relation::regclass::text<br>WHEN &#x27;transactionid&#x27; THEN transactionid::text<br>WHEN &#x27;tuple&#x27; THEN relation::regclass||&#x27;(&#x27;||page||&#x27;,&#x27;||tuple||&#x27;)&#x27;<br>END AS lockid,<br>mode,<br>granted<br>FROM pg_locks<br>WHERE locktype in (&#x27;relation&#x27;,&#x27;transactionid&#x27;,&#x27;tuple&#x27;)<br>AND (locktype != &#x27;relation&#x27; OR relation = &#x27;accounts&#x27;::regclass)<br>ORDER BY 1, 2, 3;<br></code></pre></td></tr></table></figure><p>让我们开启第一个事务并更新一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">=&gt; BEGIN;<br>=&gt; SELECT txid_current(), pg_backend_pid();<br>txid_current | pg_backend_pid<br>−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−<br>122863       | 30723<br>(1 row)<br>=&gt; UPDATE accounts SET amount = amount + 100.00 WHERE id = 1;<br></code></pre></td></tr></table></figure><p>该事务已完成工作流的所有四个步骤，现在正持有表上的锁：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">=&gt; SELECT * FROM locks_accounts WHERE pid = 30723;<br> pid    | locktype      | lockid   | mode             | granted<br> −−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−−−−+−−−−−−−−−<br> 30723  | relation      | accounts | RowExclusiveLock | t<br> 30723  | transactionid | 122863   | ExclusiveLock    | t<br> (2 rows)<br></code></pre></td></tr></table></figure><p>启动第二个事务并尝试更新同一行。该事务将挂起，在等待锁：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch13/ch13/img_4.png" alt="img_4.png"></p><p>第二个事务只进行到第二步。因此，除了锁定表及其自身 ID 之外，它还添加了两个锁，这两个锁也在 pg_locks 视图中反映了出来：第一步获取的元组锁和第二步请求的第二个事务 ID 的锁：</p><p>第三个事务将停在第一步。它尝试获取元组上的锁，并在此处停下：<br><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch13/ch13/img_5.png" alt="img_5.png"></p><p>第四个以及所有后续尝试更新这一行的事务在这方面与第三个事务没有区别：所有事务都将等待相同的元组锁。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch13/ch13/img_6.png" alt="img_6.png"></p><p>要获取当前等待的全貌，可以使用锁定进程的信息扩展 pg_stat_activity 视图：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">=&gt; SELECT pid,<br>wait_event_type,<br>wait_event,<br>pg_blocking_pids(pid)<br>FROM pg_stat_activity<br>WHERE pid IN (30723,30794,30865,30936);<br></code></pre></td></tr></table></figure><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch13/ch13/img_7.png" alt="img_7.png"></p><p>如果中止第一个事务，一切将按预期进行：所有后续事务将在不跳过队列的情况下向前移动一步。</p><p>然而，第一个事务更有可能被提交。在可重复读或可序列化隔离级别下，这将导致序列化失败，因此第二个事务将不得不被中止 7 (队列中所有后续的事务也将被中止)。但在读已提交隔离级别下，修改的行会被重新读取，并重试其更新操作。</p><p>因此，提交第一个事务：</p><p>第二个事务醒来并成功完成了工作流的第三步和第四步：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch13/ch13/img_8.png" alt="img_8.png"></p><p>一旦第二个事务释放了元组锁，第三个事务也会被唤醒，但它发现新元组的 xmax 字段已经包含了一个不同的 ID。</p><p>至此，上述工作流结束了。在读已提交隔离级别下，还会进行一次尝试锁定行的操作，但没有遵循概述的步骤。第三个事务现在正在等待第二个事务完成，而没有尝试获取元组锁：</p><p>第四个事务同样：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch13/ch13/img_9.png" alt="img_9.png"></p><p>现在，第三个和第四个事务都在等待第二个事务完成，有陷入竞争状态的风险。队列实际上已经瓦解了。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch13/ch13/img_10.png" alt="img_10.png"></p><p>如果其他事务在队列还在的时候加入了队列，那么所有事务都会被拖入到这场竞争中。</p><p>结论是：在多个并发进程中更新同一行不是一个好主意。在高负载下，这个热点很快就会变成一个瓶颈，导致性能问题。</p><p>让我们提交所有已开启的事务。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch13/ch13/img_11.png" alt="img_11.png"></p><p>####13.4.2 Shared Modes<br>PostgreSQL 仅在进行参照完整性检查时获取共享锁。在高负载应用中使用共享锁可能会导致资源饥饿，而两级锁定模型无法防止这种情况的发生。</p><p>让我们回顾一下事务锁定一行应采取的步骤：</p><pre><code class="hljs">1. 如果 xmax 字段和提示位表明该行以不兼容的模式被锁定，那么获取正在被修改元组的独占重锁。2. 如有必要，通过请求 xmax 事务 ID 上的锁 (如果 xmax 包含组事务 ID，则请求多个事务)，直到所有不兼容的锁都被释放。3. 将自己的 ID 写入到元组头中的 xmax 中，并设置所需的提示位。4. 如果元组锁是在第一步中获取的，则释放它。</code></pre><p>前两步意味着，如果锁定模式兼容，事务将跳过队列。</p><p>让我们从头开始我们的实验。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">TRUNCATE</span> accounts;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> accounts(id, client, amount)<br><span class="hljs-keyword">VALUES</span><br>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;alice&#x27;</span>,<span class="hljs-number">100.00</span>),<br>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;bob&#x27;</span>,<span class="hljs-number">200.00</span>),<br>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;charlie&#x27;</span>,<span class="hljs-number">300.00</span>);<br></code></pre></td></tr></table></figure><p>开启第一个事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> txid_current(), pg_backend_pid();<br> txid_current <span class="hljs-operator">|</span> pg_backend_pid<br>−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−<br>       <span class="hljs-number">122869</span> <span class="hljs-operator">|</span>          <span class="hljs-number">30723</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>这一行现在以共享模式锁定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FOR</span> SHARE;<br></code></pre></td></tr></table></figure><p>第二个事务尝试更新同一行，但无法做到：Share 模式和 No Key Update 模式不兼容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> txid_current(), pg_backend_pid();<br> txid_current <span class="hljs-operator">|</span> pg_backend_pid<br>−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−<br>       <span class="hljs-number">122870</span> <span class="hljs-operator">|</span>          <span class="hljs-number">30794</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">+</span> <span class="hljs-number">100.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>等待第一个事务完成的同时，第二个事务像之前的例子一样持有元组锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> locks_accounts <span class="hljs-keyword">WHERE</span> pid <span class="hljs-operator">=</span> <span class="hljs-number">30794</span>;<br>  pid  <span class="hljs-operator">|</span>   locktype    <span class="hljs-operator">|</span>    lockid     <span class="hljs-operator">|</span>       mode       <span class="hljs-operator">|</span> granted<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<br> <span class="hljs-number">30794</span> <span class="hljs-operator">|</span> relation      <span class="hljs-operator">|</span> accounts      <span class="hljs-operator">|</span> RowExclusiveLock <span class="hljs-operator">|</span> t<br> <span class="hljs-number">30794</span> <span class="hljs-operator">|</span> transactionid <span class="hljs-operator">|</span> <span class="hljs-number">122869</span>        <span class="hljs-operator">|</span> ShareLock        <span class="hljs-operator">|</span> f<br> <span class="hljs-number">30794</span> <span class="hljs-operator">|</span> transactionid <span class="hljs-operator">|</span> <span class="hljs-number">122870</span>        <span class="hljs-operator">|</span> ExclusiveLock    <span class="hljs-operator">|</span> t<br> <span class="hljs-number">30794</span> <span class="hljs-operator">|</span> tuple         <span class="hljs-operator">|</span> accounts(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> ExclusiveLock    <span class="hljs-operator">|</span> t<br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch13/ch13/im2g.png" alt="img.png"></p><p>现在让第三个事务以共享模式锁定该行。这种锁与已获取的锁兼容，因此这个事务跳过了队列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> txid_current(), pg_backend_pid();<br> txid_current <span class="hljs-operator">|</span> pg_backend_pid<br>−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−<br>       <span class="hljs-number">122871</span> <span class="hljs-operator">|</span>          <span class="hljs-number">30865</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FOR</span> SHARE;<br></code></pre></td></tr></table></figure><p>现在有两个事务锁定了同一行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pgrowlocks(<span class="hljs-string">&#x27;accounts&#x27;</span>) \gx<br>−[ RECORD <span class="hljs-number">1</span> ]−−−−−−−−−−−−−−−<br>locked_row <span class="hljs-operator">|</span> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>locker     <span class="hljs-operator">|</span> <span class="hljs-number">2</span><br>multi      <span class="hljs-operator">|</span> t<br>xids       <span class="hljs-operator">|</span> &#123;<span class="hljs-number">122869</span>,<span class="hljs-number">122871</span>&#125;<br>modes      <span class="hljs-operator">|</span> &#123;Share,Share&#125;<br>pids       <span class="hljs-operator">|</span> &#123;<span class="hljs-number">30723</span>,<span class="hljs-number">30865</span>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch13/ch13/im22g_1.png" alt="img_1.png"></p><p>如果第一个事务在此时完成，第二个事务醒来后发现该行仍被锁定，并回到队列中，但这次它将发现自己位于第三个事务之后：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> locks_accounts <span class="hljs-keyword">WHERE</span> pid <span class="hljs-operator">=</span> <span class="hljs-number">30794</span>;<br>  pid  <span class="hljs-operator">|</span>   locktype    <span class="hljs-operator">|</span>    lockid     <span class="hljs-operator">|</span>       mode       <span class="hljs-operator">|</span> granted<br>−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<br> <span class="hljs-number">30794</span> <span class="hljs-operator">|</span> relation      <span class="hljs-operator">|</span> accounts      <span class="hljs-operator">|</span> RowExclusiveLock <span class="hljs-operator">|</span> t<br> <span class="hljs-number">30794</span> <span class="hljs-operator">|</span> transactionid <span class="hljs-operator">|</span> <span class="hljs-number">122870</span>        <span class="hljs-operator">|</span> ExclusiveLock    <span class="hljs-operator">|</span> t<br> <span class="hljs-number">30794</span> <span class="hljs-operator">|</span> transactionid <span class="hljs-operator">|</span> <span class="hljs-number">122871</span>        <span class="hljs-operator">|</span> ShareLock        <span class="hljs-operator">|</span> f<br> <span class="hljs-number">30794</span> <span class="hljs-operator">|</span> tuple         <span class="hljs-operator">|</span> accounts(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span> ExclusiveLock    <span class="hljs-operator">|</span> t<br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>只有当第三个事务完成时，第二个事务才能进行更新 (除非在此时间间隔内出现了其他共享锁)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br><br><span class="hljs-keyword">UPDATE</span> <span class="hljs-number">1</span><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>外键检查不太可能引起任何问题，因为键属性通常保持不变，Key Share 可以与 No Key Update 一起使用。但在大多数情况下，你应该避免在应用中使用共享行级锁。</p><h3 id="13-5-No-Wait-Locks"><a href="#13-5-No-Wait-Locks" class="headerlink" title="13.5 No-Wait Locks"></a><a name="No-Wait-Locks"></a>13.5 No-Wait Locks</h3><p>SQL 命令通常会等待所请求的资源被释放。但有时如果无法立即获取到锁，取消操作是有意义的。为此，像 SELECT ，LOCK 和 ALTER 命令提供了 NOWAIT 子句。</p><p>让我们锁定一行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">+</span> <span class="hljs-number">100.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>如果请求的资源已被锁定，带有 NOWAIT 子句的命令将立即完成并报错：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span> NOWAIT;<br>ERROR: could <span class="hljs-keyword">not</span> obtain lock <span class="hljs-keyword">on</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> relation &quot;accounts&quot;<br></code></pre></td></tr></table></figure><p>此类错误可以被应用代码捕获并处理。</p><p>UPDATE 和 DELETE 命令没有 NOWAIT 子句。作为替代，你可以尝试使用 SELECT FOR UPDATE NOWAIT 命令锁定行，然后在尝试成功的情况下更新或删除它。</p><p>在一些罕见的情况下，跳过已经被锁定的行并立即开始处理可用的行可能会更方便。这正是带有 SKIP LOCKED 子句的 SELECT FOR 语句所执行的操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">SKIP</span> LOCKED<br>LIMIT <span class="hljs-number">1</span>;<br> id <span class="hljs-operator">|</span> client <span class="hljs-operator">|</span> amount<br>−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<br>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> bob    <span class="hljs-operator">|</span> <span class="hljs-number">200.00</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>在这个例中，第一行 (已被锁定) 被跳过了，查询锁定并返回了第二行。</p><p>此方法使我们能够批量处理行或配置事件队列的并行处理。然而，避免为该命令创建其他用例 — 大多数任务可以使用更简单的方式来处理。</p><p>最后需要提及的是，你可以通过设置超时来避免长时间等待：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> lock_timeout <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1s&#x27;</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER TABLE</span> accounts <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> amount;<br>ERROR: canceling statement due <span class="hljs-keyword">to</span> lock timeout<br></code></pre></td></tr></table></figure><p>由于未能在一秒钟内获取锁，该命令以报错结束。超时不仅可以在会话级别设置，还可以在更低级别设置，例如，对于某个特定的事务。</p><p>这种方法在高负载下执行需要独占锁的命令时，可以防止在表处理期间出现长时间的等待。如果发生错误，可以在一段时间后重试此命令。</p><pre><code class="hljs">statement_timeout 限制了操作执行的总时间，lock_timeout 参数定义了等待锁花费的最长时间。</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><h3 id="13-6-Deadlocks"><a href="#13-6-Deadlocks" class="headerlink" title="13.6 Deadlocks"></a><a name="row-deadlock"></a>13.6 Deadlocks</h3><p>有时，一个事务可能需要另一个事务当前正在使用的资源，而后者又可能在等待第三个事务锁定的资源，依此类推。这样的事务使用重锁排队。</p><p>但是，偶尔已在队列中的事务可能需要另一个资源，因此它必须再次加入同一个队列，并等待这个资源释放。这时便发生了死锁 9：队列现在有一个无法自行解决的循环依赖。</p><p>为了更好地可视化，让我们画一个等待图。它的节点表示活跃进程，而以箭头表示的边从等待锁的进程指向持有这些锁的进程。如果图中有一个循环，即一个节点可以沿着箭头到达自己，则意味着发生了死锁。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">此处的插图显示的是事务而不是进程。这种替代通常是可接受的，因为一个事务由一个进程执行，并且锁只能在事务内获取。但通常来说，谈论进程更为正确，因为有些锁在事务完成时可能不会立即释放。<br></code></pre></td></tr></table></figure><p>如果发生了死锁，并且没有任何参与者设置了超时，那么事务将永远相互等待。这就是为什么锁管理器 10 执行自动死锁检测的原因。</p><p>然而，这种检测需要一些代价，不应该在每次请求锁时都浪费 (毕竟，死锁并不会经常发生)。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch13/ch13/im2222g_2.png" alt="img_2.png"></p><p>因此，如果进程尝试获取锁失败，并在加入队列后进入休眠状态，PostgreSQL 会自动设置一个由 deadlock_timeout 参数 11 定义的超时时间。如果资源在此期间就变得可用，那么很好，这样就可以避免额外的检测成本。但是，如果在 deadlock_timeout 时间单位之后，仍然在等待，等待进程就会醒来并发起检测。12</p><p>这种检测实际上是构建一个等待图，并在其中搜索循环 13。为了”冻结”图的当前状态，PostgreSQL 将在整个检测期间停止对所有重锁的处理。</p><p>如果没有检测到死锁，进程将再次进入休眠状态；迟早会轮到它。</p><p>如果检测到死锁，其中一个事务将被强制终止，从而释放这个事务的锁并使其他事务能够继续执行。在大多数情况下，是发起检测的事务被中断，但如果循环中包括一个 autovacuum 进程，并且当前没有在冻结元组以防止回卷，那么服务器会终止 autovacuum 进程，因为它的优先级较低。</p><p>死锁通常表明应用程序设计不良。要发现这种情况，需要注意两件事：服务器日志中相应的消息以及 pg_stat_database 表中不断增加的 deadlocks 的值。</p><h4 id="13-6-1-行更新导致的死锁"><a href="#13-6-1-行更新导致的死锁" class="headerlink" title="13.6.1 行更新导致的死锁"></a>13.6.1 行更新导致的死锁</h4><p>虽然死锁最终是由重锁导致的，但通常是以不同顺序获取的行级锁导致了死锁。</p><p>假设一个事务打算在两个帐户之间转移 100 美元。首先从第一个账户中提取这笔款项：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">-</span> <span class="hljs-number">100.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>与此同时，另一个事务打算从第二个帐户转移 10 美元到第一个帐户中。首先从第二个账户中提取这笔款项：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">-</span> <span class="hljs-number">10.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>现在，第一个事务尝试增加第二个账户中的金额，但发现相应的行已被锁定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">+</span> <span class="hljs-number">100.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>然后第二个事务尝试更新第一个帐户，但也被锁定了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">+</span> <span class="hljs-number">10.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>这种循环等待永远无法自行解决。由于无法在一秒内获得资源，第一个事务启动死锁检测，并被服务器中止：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">ERROR: deadlock detected<br>DETAIL: Process 30423 waits for ShareLock on transaction 122877;<br>blocked by process 30723.<br>Process 30723 waits for ShareLock on transaction 122876; blocked by<br>process 30423.<br>HINT: See server log for query details.<br>CONTEXT: while updating tuple (0,2) in relation &quot;accounts&quot;<br></code></pre></td></tr></table></figure><p>现在第二个事务可以继续进行，它被唤醒并执行更新：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>让我们结束事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ROLLBACK</span>;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><p>执行此类操作的正确方式是以相同的顺序锁定资源。例如，在这个特定案例中，账户可以根据它们的编号按升序进行锁定。</p><h4 id="13-6-2-两条-UPDATE-语句之间的死锁"><a href="#13-6-2-两条-UPDATE-语句之间的死锁" class="headerlink" title="13.6.2 两条 UPDATE 语句之间的死锁"></a>13.6.2 两条 UPDATE 语句之间的死锁</h4><p>在某些情况下，死锁似乎是不可能的，但确实会发生。</p><p>我们通常认为 SQL 命令是原子的，但它真的是原子的吗？让我们仔细看看 UPDATE：这个命令在更新行的时候才锁定它们，而不是立即全部锁定，而且这种锁定并不是同时发生的。因此如果有一个 UPDATE 命令以一种顺序修改多行，而另一个 UPDATE 命令以不同的顺序执行相同的操作，就可能会发生死锁。</p><p>让我们复现这个场景。首先，我们在 amount 列上降序创建索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> INDEX <span class="hljs-keyword">ON</span> accounts(amount <span class="hljs-keyword">DESC</span>);<br></code></pre></td></tr></table></figure><p>为了能够观察这个过程，我们可以编写一个函数以放慢速度：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> inc_slow(n <span class="hljs-type">numeric</span>)<br><span class="hljs-keyword">RETURNS</span> <span class="hljs-type">numeric</span><br><span class="hljs-keyword">AS</span> $$<br>  <span class="hljs-keyword">SELECT</span> pg_sleep(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">SELECT</span> n <span class="hljs-operator">+</span> <span class="hljs-number">100.00</span>;<br>$$ <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">sql</span>;<br></code></pre></td></tr></table></figure><p>第一个 UPDATE 命令将更新所有元组。执行计划依赖于对整个表的顺序扫描。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> inc_slow(amount);<br>       QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-keyword">Update</span> <span class="hljs-keyword">on</span> accounts<br>  −<span class="hljs-operator">&gt;</span> Seq Scan <span class="hljs-keyword">on</span> accounts<br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>为了确保堆页面基于 amount 列以升序存储行，我们需要截断表并重新插入行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">TRUNCATE</span> accounts;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> accounts(id, client, amount)<br><span class="hljs-keyword">VALUES</span><br>  (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;alice&#x27;</span>,<span class="hljs-number">100.00</span>),<br>  (<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;bob&#x27;</span>,<span class="hljs-number">200.00</span>),<br>  (<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;charlie&#x27;</span>,<span class="hljs-number">300.00</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> ANALYZE accounts;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> ctid, <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> accounts;<br>  ctid <span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> client  <span class="hljs-operator">|</span> amount<br>−−−−−−−<span class="hljs-operator">+</span>−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> alice  <span class="hljs-operator">|</span> <span class="hljs-number">100.00</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-operator">|</span>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> bob     <span class="hljs-operator">|</span> <span class="hljs-number">200.00</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) <span class="hljs-operator">|</span>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> charlie <span class="hljs-operator">|</span> <span class="hljs-number">300.00</span><br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>顺序扫描将以相同的顺序更新行 (但对于大表来说并非总是如此)。</p><p>开始更新：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> inc_slow(amount);<br></code></pre></td></tr></table></figure><p>同时，我们将在另一个会话中禁止顺序扫描：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> enable_seqscan <span class="hljs-operator">=</span> off;<br></code></pre></td></tr></table></figure><p>因此，规划器为下一个 UPDATE 命令选择了索引扫描。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> EXPLAIN (costs off)<br><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> inc_slow(amount)<br><span class="hljs-keyword">WHERE</span> amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">100.00</span>;<br>                       QUERY PLAN<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-keyword">Update</span> <span class="hljs-keyword">on</span> accounts<br>   −<span class="hljs-operator">&gt;</span> Index Scan <span class="hljs-keyword">using</span> accounts_amount_idx <span class="hljs-keyword">on</span> accounts<br>       Index Cond: (amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">100.00</span>)<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>第二行和第三行满足条件；由于索引是降序的，因此行将以相反的顺序被更新。</p><p>让我们开始下一个更新：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> inc_slow(amount)<br><span class="hljs-keyword">WHERE</span> amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">100.00</span>;<br></code></pre></td></tr></table></figure><p>pgrowlocks 扩展显示第一个操作已经更新了第一行 (0,1)，而第二个操作已成功更新了最后一行 (0,3):</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> locked_row, locker, modes <span class="hljs-keyword">FROM</span> pgrowlocks(<span class="hljs-string">&#x27;accounts&#x27;</span>);<br> locked_row <span class="hljs-operator">|</span> locker <span class="hljs-operator">|</span>       modes<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)      <span class="hljs-operator">|</span> <span class="hljs-number">122883</span> <span class="hljs-operator">|</span> &#123;&quot;No Key Update&quot;&#125;    ← <span class="hljs-keyword">first</span><br> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)      <span class="hljs-operator">|</span> <span class="hljs-number">122884</span> <span class="hljs-operator">|</span> &#123;&quot;No Key Update&quot;&#125;    ← <span class="hljs-keyword">second</span><br>(<span class="hljs-number">2</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>又过了一秒。第一个操作已经更新了第二行，另一个操作也希望这样做，但这是不允许的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> locked_row, locker, modes <span class="hljs-keyword">FROM</span> pgrowlocks(<span class="hljs-string">&#x27;accounts&#x27;</span>);<br> locked_row <span class="hljs-operator">|</span> locker <span class="hljs-operator">|</span>       modes<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−<br> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)      <span class="hljs-operator">|</span> <span class="hljs-number">122883</span> <span class="hljs-operator">|</span> &#123;&quot;No Key Update&quot;&#125;<br> (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)      <span class="hljs-operator">|</span> <span class="hljs-number">122883</span> <span class="hljs-operator">|</span> &#123;&quot;No Key Update&quot;&#125;    ← the <span class="hljs-keyword">first</span> <span class="hljs-keyword">one</span> wins<br> (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)      <span class="hljs-operator">|</span> <span class="hljs-number">122884</span> <span class="hljs-operator">|</span> &#123;&quot;No Key Update&quot;&#125;<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>现在，第一个操作想要更新表的最后一行，但它已经被第二个操作锁定。于是发生了死锁。</p><p>其中一个事务被中止：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">ERROR: deadlock detected<br>DETAIL: Process <span class="hljs-number">30794</span> waits <span class="hljs-keyword">for</span> ShareLock <span class="hljs-keyword">on</span> transaction <span class="hljs-number">122883</span>;<br>blocked <span class="hljs-keyword">by</span> process <span class="hljs-number">30723.</span><br>Process <span class="hljs-number">30723</span> waits <span class="hljs-keyword">for</span> ShareLock <span class="hljs-keyword">on</span> transaction <span class="hljs-number">122884</span>; blocked <span class="hljs-keyword">by</span><br>process <span class="hljs-number">30794.</span><br>HINT: See server log <span class="hljs-keyword">for</span> query details.<br>CONTEXT: while updating tuple (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> relation &quot;accounts&quot;<br></code></pre></td></tr></table></figure><p>另一个事务执行完成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>尽管这种情况看似不可能，但在高负载系统中执行批量行更新时，确实会发生。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch12. Relation-Level Locks</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch12/ch12/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch12/ch12/</url>
    
    <content type="html"><![CDATA[<h2 id="ch12-Relation-Level-Locks"><a href="#ch12-Relation-Level-Locks" class="headerlink" title="ch12. Relation-Level Locks"></a>ch12. Relation-Level Locks</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#About-Locks">12.1 About Locks</a></td></tr><tr><td><a href="#Heavyweight-Locks">12.2 Heavyweight Locks</a></td></tr><tr><td><a href="#xid-lock">12.3 Locks on Transaction IDs</a></td></tr><tr><td><a href="#relation-lock">12.4 Relation-Level Locks</a></td></tr><tr><td><a href="#wait-queue">12.5 Wait Queue</a></td></tr></tbody></table><h3 id="12-1-About-Locks"><a href="#12-1-About-Locks" class="headerlink" title="12.1 About Locks"></a><a name="About-Locks"></a>12.1 About Locks</h3><p>锁用于控制对共享资源的并发访问。</p><p>并发访问意味着多个进程试图同时获取同一个资源。这些进程是并行执行 (如果硬件允许) 还是以分时模式顺序执行并没有区别。如果没有并发访问<br>，那么就没有必要获取锁 (例如，共享缓冲区缓存需要加锁，而本地缓存则可以不需要锁)。</p><p>在访问资源之前，进程必须获取该资源上的锁；操作完成之后，必须释放这个锁，以使资源可以供其他进程使用。如果锁由数据库系统管理，那么会自动维护操作的既定顺序；<br>如果锁由应用程序控制，则必须由应用程序本身来执行协议。</p><p>在底层，锁只是一个定义了锁状态 (是否已获得) 的共享内存块；它还可以提供一些附加信息，比如进程号或获取时间。</p><blockquote><p>正如你所猜测的，共享内存段本身就是一种资源。对此类资源的并发访问由操作系统提供的同步原语 (例如信号量或互斥锁) 控制。<br>它们用于保证访问共享资源的代码严格连续执行。在最底层，这些原语基于原子 CPU 指令 (比如 test-and-set 或 compare-and-swap)。</p></blockquote><p>一般来说，我们可以使用锁来保护任何资源，只要它可以被明确识别并分配一个特定的锁地址。</p><p>例如，我们可以锁定一个数据库对象，比如表 (通过系统表中的 oid 标识)、数据页 (通过文件名和该文件中的位置标识)、行版本 (通过页面和该页面内的偏移量标识)。我们还可以锁定内存结构，例如哈希表或者缓冲区 (通过分配的 ID 标识)。 我们甚至可以锁定没有物理表示的抽象资源。</p><p>但锁并不总是能够立即获取到：资源可能已经被其他人锁定。然后，进程要么加入队列 (如果这种特定的锁类型允许的话)，要么稍后再试。无论哪种方式，它都必须等待锁被释放。</p><p>我需要特别指出两个可能极大影响锁定效率的因素。</p><ol><li>粒度，或者说锁的”粒度大小”。在资源形成层次结构时很重要。</li></ol><p>例如，表由页面组成，而页面又由元组组成。所有这些对象都可以被锁保护。表级锁是粗粒度的；即使进程需要访问不同的页面或者行，<br>表级锁也禁止并发访问。行级锁是细粒度的，所以没有这个缺点；但是，锁的数量会增加。为了避免锁相关的元数据占用过多的内存，PostgreSQL<br>可以使用多种方式，其中之一是锁升级：如果细粒度锁的数量超过了一定阈值，那么它们会被更粗粒度的单个锁替换。</p><ol start="2"><li><p>锁模式集合。锁可获取的模式集合。  </p><p>通常，仅应用两种模式。独占模式与所有其它模式不兼容，包括它自己。共享模式允许资源同时被多个进程锁定。<br>共享模式可用于读取，而独占模式用于写入。通常来说，也可能有其他模式。模式的名称并不重要，重要的是它们的兼容性矩阵。</p></li></ol><p>更细的粒度和对多个兼容模式的支持为并发执行提供了更多基础。</p><p>所有锁都可以根据其持续时间进行分类。</p><p>长锁可能会获取很长时间 (在大多数情况下，直到事务结束)；它们通常用于保护诸如关系和行之类的资源。这些锁通常由 PostgreSQL 自动管理，但用户仍然可以控制这个过程。</p><p>长锁提供了多种模式，可以对数据进行各种并发操作。它们通常具有广泛的基础设施 (包括等待队列、死锁检测和监测机制等功能)，其维护成本无论如何都远低于对受保护数据的操作。</p><p>短锁的持续时间只有几分之一秒，而且很少会持续超过几个 CPU 指令；它们通常用于保护共享内存中的数据结构。PostgreSQL 以完全自动化的方式管理这些锁。</p><p>短锁通常只提供非常少的模式和基本的基础设施，可能根本没有监测机制。</p><p>PostgreSQL 支持各种类型的锁 1。重锁 (在关系和其他对象上获取) 和行级锁被视为长锁。短锁包括内存结构上的各种锁。此外，还有一组独特的谓词锁，尽管其名字如此，实际上它根本不是锁。</p><h3 id="12-2-Heavyweight-Locks"><a href="#12-2-Heavyweight-Locks" class="headerlink" title="12.2 Heavyweight Locks"></a><a name="Heavyweight-Locks"></a>12.2 Heavyweight Locks</h3><p>重锁是长锁。在对象级别获取，主要用于表，但也可应用于其他类型的对象。重锁通常用于保护对象不受并发更新的影响，或在重组期间禁止使用它们，但重锁也可以解决其他需求。这种模糊的定义是有意为之：这种类型的锁可以用于各种目的。唯一的共同点是它们的内部结构。</p><p>除非另有明确说明，否则术语 lock 通常意味着重锁。</p><p>重锁位于服务器的共享内存中 2，可以在 pg_locks 视图中查看。重锁的总数受到 max_locks_per_transaction 乘以 max_connections 的限制。</p><p>所有事务都使用一个共同的锁池，因此一个事务可以获取超过 max_locks_per_transaction 数量的锁。真正重要的是，系统中锁的总数不能超过所定义的限制。由于在服务器启动时会初始化锁池，因此更改这两个参数中的任何一个都需要重启服务器。</p><p>如果某个资源已经以一个不兼容的模式锁定，那么试图获取另一个锁的进程会加入到队列之中。等待的进程不会浪费 CPU 时间：它们会进入休眠状态，直到锁被释放并且操作系统将它们唤醒。</p><p>如果第一个事务无法继续其操作，直到它获得另一个事务锁定的资源，而后者又需要第一个事务锁定的资源，那么这两个事务可能会陷入死锁。这种情况相对简单；死锁也可能涉及两个以上的事务。由于死锁会导致无限期等待，PostgreSQL 会自动检测它们，并中止其中一个受影响的事务，以确保可以继续正常操作。</p><p>不同类型的重锁有不同的用途，保护不同的资源，并支持不同的模式，因此我们将分别考虑它们。</p><p>以下列表提供了在 pg_locks 视图的 locktype 列中出现的锁类型名称：</p><p>   transactionid 和 virtualxid — 事务 ID 上的锁</p><p>   relation — 关系级锁</p><p>   tuple — 元组上获取的锁</p><p>   object — 非关系对象上的锁</p><p>   extend — 表扩展锁</p><p>   page — 某些索引类型使用的页级锁</p><p>   advisory — 咨询锁</p><p>几乎所有重锁都是根据需要自动获取的，并在相应事务完成时自动释放。但也有一些例外：例如，可以显式设置关系级锁，而咨询锁始终由用户管理。</p><h3 id="12-3-Locks-on-Transaction-IDs"><a href="#12-3-Locks-on-Transaction-IDs" class="headerlink" title="12.3 Locks on Transaction IDs"></a><a name="xid-lock"></a>12.3 Locks on Transaction IDs</h3><p>每个事务总是持有其自身事务 ID 的独占锁 (无论是虚拟的还是实际的，如果有的话)。</p><p>PostgreSQL 为此提供了两种锁定模式，独占模式和共享模式。其兼容矩阵非常简单：共享模式与自身兼容，而独占模式不能与任何模式组合。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch12/ch12/img.png" alt="img.png"></p><p>为了跟踪特定事务的完成情况，进程可以在任何模式下请求对该事务 ID 的锁。由于事务本身已经持有对其自身 ID 的独占锁，因此无法获取其他的锁。请求该锁的进程会加入队列并进入休眠状态。一旦事务完成，锁就会被释放，排队的进程就会被唤醒。显然，由于相应的资源已经不存在了，它不会设法获取锁，但这个锁本来就不是真正需要的。</p><p>在一个单独的会话中启动一个事务，并获取该后端进程的进程 ID (PID)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">=&gt; BEGIN;<br>=&gt; SELECT pg_backend_pid();<br>pg_backend_pid<br>−−−−−−−−−−−−−−−−<br>28991<br>(1 row)<br><br></code></pre></td></tr></table></figure><p>已启动的事务持有对其自身虚拟 ID 的独占锁：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">=&gt; SELECT locktype, virtualxid, mode, granted<br>FROM pg_locks WHERE pid = 28991;<br>locktype | virtualxid | mode | granted<br>−−−−−−−−−−−−+−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−<br>virtualxid | 5/2 | ExclusiveLock | t<br>(1 row)<br><br></code></pre></td></tr></table></figure><p>此处的 locktype 是锁的类型，virtualxid 是虚拟事务ID (用于标识锁定的资源)，mode 是锁定模式 (在本例中为独占模式)。granted 标志显示是否已获取到请求的锁。</p><p>一旦事务获取了真实 ID，相应的锁就会被添加到这个列表中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">=&gt; SELECT pg_current_xact_id();<br>pg_current_xact_id<br>−−−−−−−−−−−−−−−−−−−−<br>134971<br>(1 row)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">=&gt; SELECT locktype, virtualxid, transactionid AS xid, mode, granted<br>FROM pg_locks WHERE pid = 28991;<br>locktype | virtualxid | xid | mode | granted<br>−−−−−−−−−−−−−−−+−−−−−−−−−−−−+−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−<br>virtualxid | 5/2 | | ExclusiveLock | t<br>transactionid | | 134971 | ExclusiveLock | t<br>(2 rows)<br><br></code></pre></td></tr></table></figure><p>现在，这个事务对其两个 ID 均持有独占锁。</p><h3 id="12-4-Relation-Level-Locks"><a href="#12-4-Relation-Level-Locks" class="headerlink" title="12.4 Relation-Level Locks"></a><a name="relation-lock"></a>12.4 Relation-Level Locks</h3><p>PostgreSQL 提供了多达八种模式的锁，用于锁定关系 (表、索引或任何其他对象) 3。这样的多样性可以使一个关系上允许并发运行的命令数量最大化。</p><p>下面显示了兼容性矩阵，并扩展了需要相应锁模式的命令示例。没有必要记住所有这些模式或试图找出它们命名背后的逻辑，但是翻阅这些数据，得出一些一般性的结论，并在需要时参考这个表肯定是有用的。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch12/ch12/img_1.png" alt="img_1.png"></p><p>Access Share 是最弱的模式；它可以与其他任何模式一起使用，除了 Access Exclusive，后者与所有模式都不兼容。因此，SELECT 命令几乎可以与任何操作并行执行，但不允许删除正在查询的表。</p><p>前四种模式允许并发堆修改，而其他四种模式不允许。例如， CREATE INDEX 命令使用 Share 模式，此模式与自身兼容 (因此你可以在一个表上同时创建多个索引)，并且与只读操作使用的模式相兼容。因此，SELECT 命令可以与索引创建并行运行，而 INSERT，UPDATE 和 DELETE 命令将被阻塞。</p><p>相反，未完成的修改堆数据的事务会阻塞 CREATE INDEX 命令。作为替代，你可以使用 CREATE INEDX CONCURRENTLY，它使用了更弱的 Share Update Exclusive 模式：创建索引需要的时间更长 (此操作甚至可能失败)，但作为回报，它允许并发数据修改。</p><p>ALTER TABLE 命令有多种模式，它们使用不同的锁模式 (Share Update Exclusive、Share Row Exclusive、Access Exclusives)。所有模式都在文档中有所描述 4。</p><p>本书这一部分的例子仍然基于 accounts 表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">=&gt; TRUNCATE accounts;<br>=&gt; INSERT INTO accounts(id, client, amount)<br>VALUES<br>(1, &#x27;alice&#x27;, 100.00),<br>(2, &#x27;bob&#x27;, 200.00),<br>(3, &#x27;charlie&#x27;, 300.00);<br><br></code></pre></td></tr></table></figure><p>我们需要多次访问 pg_locks 表，所以让我们创建一个视图以在单独的列中显示所有 ID，从而使输出更加简洁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> locks <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> pid,<br>locktype,<br><span class="hljs-keyword">CASE</span> locktype<br><span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;relation&#x27;</span> <span class="hljs-keyword">THEN</span> relation::regclass::text<br><span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;transactionid&#x27;</span> <span class="hljs-keyword">THEN</span> transactionid::text<br><span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;virtualxid&#x27;</span> <span class="hljs-keyword">THEN</span> virtualxid<br><span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> lockid,<br>mode,<br>granted<br><span class="hljs-keyword">FROM</span> pg_locks<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>第一个会话中仍在运行的事务将更新一行。这个操作会锁定 accounts 表及其所有索引，从而在 Row Exclusive 模式下获得了两个新的 relation 类型的锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> amount <span class="hljs-operator">=</span> amount <span class="hljs-operator">+</span> <span class="hljs-number">100.00</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">=&gt; SELECT locktype, lockid, mode, granted<br>FROM locks WHERE pid = 28991;<br>locktype | lockid | mode | granted<br>−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−+−−−−−−−−−<br>relation | accounts | RowExclusiveLock | t<br>relation | accounts_pkey | RowExclusiveLock | t<br>transactionid | 134971 | ExclusiveLock | t<br>virtualxid | 5/2 | ExclusiveLock | t<br>(4 rows)<br></code></pre></td></tr></table></figure><h3 id="12-5-Wait-Queue"><a href="#12-5-Wait-Queue" class="headerlink" title="12.5 Wait Queue"></a><a name="wait-queue"></a>12.5 Wait Queue</h3><p>重锁形成了一个公平的等待队列 5。如果进程试图获取与当前锁或与队列中其他进程已请求的锁不兼容的锁，那么这个进程就会加入队列。</p><p>当第一个会话在进行更新时，让我们在另一个会话中尝试在此表上创建索引：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">=&gt; SELECT pg_backend_pid();<br>pg_backend_pid<br>−−−−−−−−−−−−−−−−<br>29470<br>(1 row)<br>=&gt; CREATE INDEX ON accounts(client);<br><br></code></pre></td></tr></table></figure><p>命令会夯住，等待资源的释放。事务试图在共享模式下锁定此表，但无法做到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">=&gt; SELECT locktype, lockid, mode, granted<br>FROM locks WHERE pid = 29470;<br>locktype | lockid | mode | granted<br>−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−<br>relation | accounts | ShareLock | f<br>virtualxid | 6/3 | ExclusiveLock | t<br>(2 rows)<br><br></code></pre></td></tr></table></figure><p>现在于第三个会话中执行 VACUUM FULL 命令。它也会加入队列，因为它需要获取 Access Exclusive 模式的锁，这与其他所有模式冲突：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">=&gt; SELECT pg_backend_pid();<br>pg_backend_pid<br>−−−−−−−−−−−−−−−−<br>29673<br>(1 row)<br>=&gt; VACUUM FULL accounts;<br><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">=&gt; SELECT locktype, lockid, mode, granted<br>FROM locks WHERE pid = 29673;<br>locktype | lockid | mode | granted<br>−−−−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−<br>relation | accounts | AccessExclusiveLock | f<br>transactionid | 134975 | ExclusiveLock | t<br>virtualxid | 7/4 | ExclusiveLock | t<br>(3 rows)<br><br></code></pre></td></tr></table></figure><p>所有后续的竞争者现在都必须加入队列，无论其锁定模式如何。即使是简单的 SELECT 查询也会老老实实排在 VACUUM FULL 之后，尽管它与执行更新的第一个会话所持有的 Row Exclusive 兼容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">=&gt; SELECT pg_backend_pid();<br>pg_backend_pid<br>−−−−−−−−−−−−−−−−<br>29883<br>(1 row)<br>=&gt; SELECT * FROM accounts;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">=&gt; SELECT locktype, lockid, mode, granted<br>FROM locks WHERE pid = 29883;<br>locktype | lockid | mode | granted<br>−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−−−+−−−−−−−−−<br>relation | accounts | AccessShareLock | f<br>virtualxid | 8/3 | ExclusiveLock | t<br>(2 rows)<br><br></code></pre></td></tr></table></figure><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch12/ch12/img_2.png" alt="img_2.png"></p><p>pg_blocking_pids 函数提供了所有等待的高层次概览情况。它显示了排在指定进程前面的所有进程 ID，这些进程已经持有或想要获取一个不兼容的锁：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch12/ch12/img_3.png" alt="img_3.png"></p><p>要获得更多详细信息，你可以查看 pg_locks 表中提供的信息 6。</p><p>一旦事务完成 (无论提交还是中止)，该事务所有的锁都会被释放 7。队列中第一个进程获得所请求的锁并被唤醒。</p><p>此处，提交第一个会话中的事务会使所有排队的进程顺序执行：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch12/ch12/img_4.png" alt="img_4.png"></p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch11. WAL Modes</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch11/ch11/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch11/ch11/</url>
    
    <content type="html"><![CDATA[<h2 id="ch11-WAL-Modes"><a href="#ch11-WAL-Modes" class="headerlink" title="ch11. WAL Modes"></a>ch11. WAL Modes</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">11.1 Performance</a></td></tr><tr><td><a href="#cp2">11.2 Fault Tolerance</a></td></tr><tr><td><a href="#cp3">11.3 WAL Levels</a></td></tr></tbody></table><h3 id="11-1-Performance"><a href="#11-1-Performance" class="headerlink" title="11.1 Performance"></a><a name="cp1"></a>11.1 Performance</h3><p>当服务器正常运行时，WAL 文件会不断写入磁盘。然而，这些写入是顺序的：几乎没有随机访问，因此即使是 HDD 也能应对这项任务。因为这种类型的负载与典型的数据文件访问非常不同，因此可能值得为 WAL 文件设置单独的物理存储，并将 PGDATA&#x2F;pg_wal 目录替换为指向已挂载文件系统中目录的符号链接。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">有几种情况需要同时写入和读取 WAL 文件。第一个显而易见的例子是崩溃恢复；第二个是流复制。walsender 1 进程直接从文件中读取 WAL 条目 2，如果备库没有接收到需要的 WAL 条目，那么 walsender 进程将从文件中读取，只是读取过程是顺序的，而不是随机的 (也有可能在主库的操作系统缓存中找到相应的 WAL 条目)。<br></code></pre></td></tr></table></figure><p>WAL 条目可以按以下模式之一写入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">同步模式在事务提交时，将所有相关的 WAL 条目保存至磁盘之前会禁止任何进一步的操作。<br>异步模式意味着立即提交事务，随后在后台将 WAL 条目写入磁盘。<br></code></pre></td></tr></table></figure><p>当前模式由 synchronous_commit 参数定义。</p><p><strong>同步模式。</strong> 为了可靠地记录提交的事实，仅仅将 WAL 条目传递给操作系统是不够的；你还必须确保磁盘同步已经成功完成。由于同步涉及实际的 IO 操作 (非常慢)，因此尽可能少地执行它是有益的。</p><p>为此，完成事务并将 WAL 条目写入磁盘的后端进程可以按照 commit_delay 参数定义的时间暂停一小会。但是，这只会发生在系统中至少有 commit_siblings 个活跃事务的情况下 3：在这段暂停期间，其中一些事务可能会完成，服务器会设法一次性同步所有的 WAL 条目。这很像扶着电梯门让某人赶上电梯。</p><p>默认情况下不会暂停。只有在执行大量短 OLTP 事务的系统中，修改 commit_delay 参数才有意义。</p><p>在潜在的暂停之后，完成事务的进程将所有累积的 WAL 条目刷新到磁盘并执行同步 (重要的是保存提交记录以及之前与此事务相关的所有条目；其余的被写入，只是因为不会增加成本)。</p><p>从此刻起，ACID 的持久性要求得到保证 — 事务被认为已可靠提交了 4。这就是为什么同步模式是默认模式的原因。</p><p>同步提交的缺点是延迟较长 (COMMIT 命令直到同步结束才返回控制) 和较低的系统吞吐量，尤其是对于 OLTP 负载。</p><p><strong>异步模式。</strong> 为了开启异步提交 5，你需要关闭 synchronous_commit 参数。</p><p>在异步模式下，WAL 条目由 walwriter 6 进程写入磁盘，该进程在工作和休息之间交替。暂停的持续时间由 wal_writer_delay 定义。</p><p>从暂停中醒来后，walwriter 进程检查缓存中是否有新的完全填满的 WAL 页面。如果出现任何此类页面，那么 walwriter 进程会跳过当前的页面，将此类页面写入磁盘。否则，它会写入当前半空的页面，因为它已经被唤醒了 7。</p><p>这个算法的目的是避免多次刷新同一个页面，这对于数据变化密集的工作负载可以带来显著的性能提升。</p><p>虽然 WAL 缓存使用环形缓冲区，但 walwriter 在到达缓存的最后一页时会停止；暂停后，下一个写入周期会从第一页开始。因此，在最坏的情况下，walwriter 需要运行 3 次才能到达特定的 WAL 条目：首先，写入所有位于缓存末尾的完整页面，然后它会回到开头，最后处理包含该条目的未满页面。但在大多数情况下，它只需要一到两个周期。</p><p>每当写入 wal_writer_flush_after 量的数据后，便会执行同步，并在写入周期结束时再次执行同步。</p><p>异步提交比同步提交更快，因为它们不必等待磁盘物理写入。但是可靠性会受到影响：你可能会丢失在故障前三倍 wal_writer_delay 时间范围内提交的数据 (默认为 0.6 秒)。</p><p>在实际情况中，这两种模式相辅相成。在同步模式下，与长事务相关的 WAL 条目仍然可以异步写入以释放 WAL 缓冲区。反之亦然，即使在异步模式下，与即将从缓冲区缓存中逐出的页面相关的 WAL 条目也会立即刷新到磁盘 — 否则无法继续操作。</p><p>在大多数情况下，系统设计人员必须在性能和持久性之间做出艰难的选择。</p><p>synchronous_commit 参数也可以针对特定事务设置。如果可以在应用程序级别将所有事务分类为绝对关键 (如处理财务数据) 或不那么重要，那么你可以提高性能，同时冒着只丢失非关键事务的风险。</p><p>为了了解异步提交潜在的性能增益，让我们使用 pgbench 8 测试比较两种模式下的延迟和吞吐量。</p><p>首先，初始化所需的表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">/usr/local/pgsql/bin/pgbench -i internals</span><br></code></pre></td></tr></table></figure><p>在同步模式下开始一次 30 秒的测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">/usr/local/pgsql/bin/pgbench -T 30 internals</span><br>pgbench (14.7)<br>starting vacuum...end.<br>transaction type: &lt;builtin: TPC−B (sort of)&gt;<br>scaling factor: 1<br>query mode: simple<br>number of clients: 1<br>number of threads: 1<br>duration: 30 s<br>number of transactions actually processed: 20123<br>latency average = 1.491 ms<br>initial connection time = 2.507 ms<br>tps = 670.809688 (without initial connection time)<br></code></pre></td></tr></table></figure><p>现在在异步模式下执行相同的测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">=&gt; ALTER SYSTEM SET synchronous_commit = off;<br>=&gt; SELECT pg_reload_conf();<br><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">/usr/local/pgsql/bin/pgbench -T 30 internals</span><br>pgbench (14.7)<br>starting vacuum...end.<br>transaction type: &lt;builtin: TPC−B (sort of)&gt;<br>scaling factor: 1<br>query mode: simple<br>number of clients: 1<br>number of threads: 1<br>duration: 30 s<br>number of transactions actually processed: 61809<br>latency average = 0.485 ms<br>initial connection time = 1.915 ms<br>tps = 2060.399861 (without initial connection time)<br></code></pre></td></tr></table></figure><p>在异步模式下，这个简单的基准测试体现了显著降低的延迟和更高的吞吐量 (TPS)。 当然，每个特定系统都会根据当前负载有自己的数据，但很明显，对短小 OLTP 事务的影响是非常明显的。</p><p>让我们恢复默认设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> RESET synchronous_commit;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_reload_conf();<br></code></pre></td></tr></table></figure><h3 id="11-2-Fault-Tolerance"><a href="#11-2-Fault-Tolerance" class="headerlink" title="11.2 Fault Tolerance"></a><a name="cp2"></a>11.2 Fault Tolerance</h3><p>不言而喻，预写日志必须保证在任何情况下都能进行崩溃恢复 (除非持久性存储本身损坏了)。影响数据一致性的因素有很多，但我将只介绍最重要的几个：缓存、数据损坏和非原子写入 9。</p><h4 id="11-2-1-缓存"><a href="#11-2-1-缓存" class="headerlink" title="11.2.1 缓存"></a>11.2.1 缓存</h4><p>数据在到达非易失性存储 (比如硬盘) 之前，会通过各种缓存。</p><p>磁盘写入只是指示操作系统将数据放入其缓存中 (这也容易发生崩溃，就像 RAM 的任何其他部分一样)。实际的写入操作是异步执行的，具体由操作系统的 I&#x2F;O 调度器的设置决定。</p><p>一旦调度器决定刷新累积的数据，这些数据就会被转移到存储设备的缓存中 (比如 HDD)。存储设备也可以推迟写入，例如，将相邻的页面组合一起。RAID 控制器在磁盘和操作系统之间又添加了一层缓存。</p><p>除非采取特殊措施，否则数据何时可靠地存储在磁盘上仍然未知。这通常不是那么重要，因为我们有 WAL，但是 WAL 条目本身必须立即可靠地保存在磁盘上 10。异步模式同样如此 — 否则，无法保证 WAL 条目在修改的数据之前到达磁盘。</p><p>检查点进程也必须以可靠的方式保存数据，确保脏页从操作系统缓存进入磁盘。此外，它还必须同步其他进程已经执行的所有文件操作 (如页面写入或文件删除)：当检查点完成时，所有这些操作的结果必须已经保存在磁盘上 11。</p><p>还有一些其他情况需要 fail-safe 写入，例如在 minimal WAL 级别下执行未记录日志的操作。</p><p>操作系统提供了多种方式以保证将数据立即写入非易失性存储。所有方式都可归结为以下两种主要方式：要么在写入后调用单独的同步命令 (例如 fsync 或 fdatasync)，要么在打开或写入文件时指定执行同步的要求 (甚至绕过操作系统缓存的直接写入)。</p><p>pg_test_fsync 工具可以帮助你根据操作系统和文件系统确认同步 WAL 的最佳方式；首选方式可以在 wal_sync_method 参数中指定。对于其他操作，会自动选择合适的同步方式，无法配置 12。</p><p>这里一个微妙的方面是，在每种特定情况下，最合适的方式取决于硬件。例如，如果你使用带有备用电池的控制器，那么可以利用其缓存，因为电池可以在断电时保护数据。</p><p>你应该记住，异步提交和缺乏同步是两个完全不同的事情。关闭同步 (通过 fsync 参数) 可以提高系统性能，但任何故障都会导致致命的数据丢失。异步模式可以保证崩溃恢复到一致的状态，但一些最新的数据更新可能会丢失。</p><h4 id="11-2-2-数据损坏"><a href="#11-2-2-数据损坏" class="headerlink" title="11.2.2 数据损坏"></a>11.2.2 数据损坏</h4><p>技术设备并不是完美无缺的，数据在内存中、磁盘上，或通过接口电缆传输时都可能受损。这类错误通常在硬件层处理，但仍有些可能会遗漏。</p><p>为了及时发现问题，PostgreSQL 始终通过校验和保护 WAL 条目。</p><p>数据页也可以计算校验和 13。这可以在集群初始化期间完成，也可以在服务器停止时 14 通过运行 pg_checksum 15 工具来完成。</p><p>在生产系统中，应该始终启用校验和，尽管有一些 (较小的) 计算和验证的开销。这提高了及时发现数据损坏的机会，即使仍然会存在一些极端的情况：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">只有在访问页面时才会执行校验和检验，因此数据损坏可能会在很长一段时间内都不会被察觉，直到它扩散到所有备份，导致没有了正确数据的来源。<br>被归零的页面被视为是正确的，因此如果文件系统错误地将页面归零，那么这个问题将不会被发现。<br>校验和仅针对表的主分支计算；其他分支和文件 (例如 CLOG 中的事务状态) 仍然不受保护。<br></code></pre></td></tr></table></figure><p>让我们看一下只读 data_checksums 参数，以确保启用了校验和：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SHOW</span> data_checksums;<br> data_checksums<br>−−−−−−−−−−−−−−−−<br> <span class="hljs-keyword">on</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>现在停止服务器，并将表的主分支的第零页中的若干字节清零：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_relation_filepath(<span class="hljs-string">&#x27;wal&#x27;</span>);<br> pg_relation_filepath<br>−−−−−−−−−−−−−−−−−−−−−−<br> base<span class="hljs-operator">/</span><span class="hljs-number">16391</span><span class="hljs-operator">/</span><span class="hljs-number">16562</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><br>postgres$ pg_ctl stop<br>postgres$ dd if<span class="hljs-operator">=</span><span class="hljs-operator">/</span>dev<span class="hljs-operator">/</span>zero <span class="hljs-keyword">of</span><span class="hljs-operator">=</span><span class="hljs-operator">/</span>usr<span class="hljs-operator">/</span><span class="hljs-keyword">local</span><span class="hljs-operator">/</span>pgsql<span class="hljs-operator">/</span>data<span class="hljs-operator">/</span>base<span class="hljs-operator">/</span><span class="hljs-number">16391</span><span class="hljs-operator">/</span><span class="hljs-number">16562</span> \<br>oflag<span class="hljs-operator">=</span>dsync conv<span class="hljs-operator">=</span>notrunc bs<span class="hljs-operator">=</span><span class="hljs-number">1</span> count<span class="hljs-operator">=</span><span class="hljs-number">8</span><br><span class="hljs-number">8</span><span class="hljs-operator">+</span><span class="hljs-number">0</span> records <span class="hljs-keyword">in</span><br><span class="hljs-number">8</span><span class="hljs-operator">+</span><span class="hljs-number">0</span> records <span class="hljs-keyword">out</span><br><span class="hljs-number">8</span> bytes copied, <span class="hljs-number">0</span>,<span class="hljs-number">00776573</span> s, <span class="hljs-number">1</span>,<span class="hljs-number">0</span> kB<span class="hljs-operator">/</span>s<br></code></pre></td></tr></table></figure><p>再次启动服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">pg_ctl start -l /home/postgres/logfile</span><br></code></pre></td></tr></table></figure><p>实际上，我们可以让服务器保持运行 — 只需将页面写入磁盘并将其从缓存中驱逐 (否则，服务器将继续使用其缓存版本)。但这样的工作流程难以复现。</p><p>现在，让我们尝试读取该表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> wal LIMIT <span class="hljs-number">1</span>;<br>WARNING: page verification failed, calculated checksum <span class="hljs-number">20397</span> but<br>expected <span class="hljs-number">28733</span><br>ERROR: invalid page <span class="hljs-keyword">in</span> block <span class="hljs-number">0</span> <span class="hljs-keyword">of</span> relation base<span class="hljs-operator">/</span><span class="hljs-number">16391</span><span class="hljs-operator">/</span><span class="hljs-number">16562</span><br></code></pre></td></tr></table></figure><p>如果无法从备份中恢复数据，那么至少尝试读取损坏的页面是有意义的 (有可能得到混乱的输出)。 为此，你需要启用 ignore_checksum_failure 参数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> ignore_checksum_failure <span class="hljs-operator">=</span> <span class="hljs-keyword">on</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> wal LIMIT <span class="hljs-number">1</span>;<br>WARNING: page verification failed, calculated checksum <span class="hljs-number">20397</span> but<br>expected <span class="hljs-number">28733</span><br> id<br>−−−−<br>  <span class="hljs-number">2</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>在此情况下，一切都进行得很顺利，因为我们损坏的是页头的非关键部分 (最新 WAL 条目的 LSN)，而不是数据本身。</p><h4 id="11-2-3-非原子写"><a href="#11-2-3-非原子写" class="headerlink" title="11.2.3 非原子写"></a>11.2.3 非原子写</h4><p>数据库页面通常占 8 kB，但是在更底层，写入是按块执行的，这些块通常更小 (通常是 512 字节或 4 kB)。 因此，如果发生故障，页面可能仅写入了部分。在恢复期间，将常规的 WAL 条目应用于这类页面是没有意义的。</p><p>为了避免部分写入，PostgreSQL 会在 WAL 中保存检查点启动之后首次被修改页面的完整镜像 (FPI)。此行为由 full_page_writes 参数控制，但将其关闭可能会导致严重的数据损坏。</p><p>如果恢复进程在 WAL 中遇到了 FPI ，那么它将无条件地将其写入磁盘 (不检查它的 LSN )；就像任何 WAL 条目一样，FPI 也受到校验和的保护，因此其损坏不会被忽视。然后，常规 WAL 条目将应用于这一状态，这一状态被保证是正确的。</p><p>没有单独的 WAL 条目类型用于设置提示位：这种操作被认为是非关键性的，因为任何访问页面的查询都会重新设置所需的位。但是，任何提示位的更改都会影响页面的校验和。 因此，如果启用了校验和 (或者打开了 wal_log_hints 参数)，提示位的修改也将记录为 FPIs 16。</p><p>即使日志机制从 FPI 17 中排除了空白空间，生成的 WAL 文件的大小仍然会显著增加。如果通过 wal_compression 参数启用了 WAL 压缩，这种情况可以大大改善。</p><p>让我们使用 pgbench 工具进行一个简单的实验。我们将执行一个检查点，并立即开始一项带有事务数量限制的基准测试：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> CHECKPOINT;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_wal_insert_lsn();<br> pg_current_wal_insert_lsn<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">42</span>CE5DA8<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><br>postgres$ <span class="hljs-operator">/</span>usr<span class="hljs-operator">/</span><span class="hljs-keyword">local</span><span class="hljs-operator">/</span>pgsql<span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>pgbench <span class="hljs-operator">-</span>t <span class="hljs-number">20000</span> internals<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_wal_insert_lsn();<br> pg_current_wal_insert_lsn<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">449113E0</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>这是生成的 WAL 条目的大小：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_size_pretty(<span class="hljs-string">&#x27;0/449755C0&#x27;</span>::pg_lsn <span class="hljs-operator">-</span> <span class="hljs-string">&#x27;0/42CE5DA8&#x27;</span>::pg_lsn);<br> pg_size_pretty<br>−−−−−−−−−−−−−−−−<br> <span class="hljs-number">29</span> MB<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>在此示例中，FPIs 占总 WAL 大小的一半以上。你可以在收集的统计数据中查看，其中显示了每种资源类型 (Type) 的 WAL 条目数量 (N)、常规条目的大小 (Record size) 以及 FPI 大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">/usr/local/pgsql/bin/pg_waldump --stats \</span><br><span class="language-bash">-p /usr/local/pgsql/data/pg_wal -s 0/42CE5DA8 -e 0/449755C0</span><br>Type            N      (%)   Record size      (%)   FPI size      (%)<br>−−−−            −      −−−   −−−−−−−−−−−      −−−   −−−−−−−−      −−−<br>XLOG         4294 (  3,31)        210406 (  2,50)   19820068 ( 93,78)<br>Transaction 20004 ( 15,41)        680536 (  8,10)          0 (  0,00)<br>Storage         1 (  0,00)            42 (  0,00)          0 (  0,00)<br>CLOG            1 (  0,00)            30 (  0,00)          0 (  0,00)<br>Standby         6 (  0,00)           416 (  0,00)          0 (  0,00)<br>Heap2       24774 ( 19,09)       1536253 ( 18,27)      24576 (  0,12)<br>Heap        80234 ( 61,81)       5946242 ( 70,73)     295664 (  1,40)<br>Btree         494 (  0,38)         32747 (  0,39)     993860 (  4,70)<br>           −−−−−−               −−−−−−−−            −−−−−−−−<br>Total      129808                8406672 [28,46%]   21134168 [71,54%]<br></code></pre></td></tr></table></figure><p>如果数据页在检查点之间被多次修改，这个比率会更小。这是另一个减少执行检查点的原因。</p><p>重复相同的实验，看看压缩是否有帮助。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">SET</span> wal_compression <span class="hljs-operator">=</span> <span class="hljs-keyword">on</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_reload_conf();<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> CHECKPOINT;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_wal_insert_lsn();<br> pg_current_wal_insert_lsn<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">44</span>EBC518<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br>postgres$ <span class="hljs-operator">/</span>usr<span class="hljs-operator">/</span><span class="hljs-keyword">local</span><span class="hljs-operator">/</span>pgsql<span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>pgbench <span class="hljs-operator">-</span>t <span class="hljs-number">20000</span> internals<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_wal_insert_lsn();<br> pg_current_wal_insert_lsn<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">45975008</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>这是启用压缩后的 WAL 大小：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_size_pretty(<span class="hljs-string">&#x27;0/457653B0&#x27;</span>::pg_lsn <span class="hljs-operator">-</span> <span class="hljs-string">&#x27;0/44D4C228&#x27;</span>::pg_lsn);<br> pg_size_pretty<br>−−−−−−−−−−−−−−−−<br> <span class="hljs-number">10</span> MB<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br>postgres$ <span class="hljs-operator">/</span>usr<span class="hljs-operator">/</span><span class="hljs-keyword">local</span><span class="hljs-operator">/</span>pgsql<span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>pg_waldump <span class="hljs-comment">--stats \</span><br><span class="hljs-operator">-</span>p <span class="hljs-operator">/</span>usr<span class="hljs-operator">/</span><span class="hljs-keyword">local</span><span class="hljs-operator">/</span>pgsql<span class="hljs-operator">/</span>data<span class="hljs-operator">/</span>pg_wal <span class="hljs-operator">-</span>s <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">44</span>D4C228 <span class="hljs-operator">-</span>e <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">457653</span>B0<br>Type            N      (<span class="hljs-operator">%</span>)       Record size      (<span class="hljs-operator">%</span>)   FPI size      (<span class="hljs-operator">%</span>)<br>−−−−            −      −−−       −−−−−−−−−−−      −−−   −−−−−−−−      −−−<br>XLOG          <span class="hljs-number">344</span> (  <span class="hljs-number">0</span>,<span class="hljs-number">29</span>)             <span class="hljs-number">17530</span> (  <span class="hljs-number">0</span>,<span class="hljs-number">22</span>)     <span class="hljs-number">435492</span> ( <span class="hljs-number">17</span>,<span class="hljs-number">75</span>)<br>Transaction <span class="hljs-number">20001</span> ( <span class="hljs-number">16</span>,<span class="hljs-number">73</span>)            <span class="hljs-number">680114</span> (  <span class="hljs-number">8</span>,<span class="hljs-number">68</span>)          <span class="hljs-number">0</span> (  <span class="hljs-number">0</span>,<span class="hljs-number">00</span>)<br>Storage         <span class="hljs-number">1</span> (  <span class="hljs-number">0</span>,<span class="hljs-number">00</span>)                <span class="hljs-number">42</span> (  <span class="hljs-number">0</span>,<span class="hljs-number">00</span>)          <span class="hljs-number">0</span> (  <span class="hljs-number">0</span>,<span class="hljs-number">00</span>)<br>Standby         <span class="hljs-number">5</span> (  <span class="hljs-number">0</span>,<span class="hljs-number">00</span>)               <span class="hljs-number">330</span> (  <span class="hljs-number">0</span>,<span class="hljs-number">00</span>)          <span class="hljs-number">0</span> (  <span class="hljs-number">0</span>,<span class="hljs-number">00</span>)<br>Heap2       <span class="hljs-number">18946</span> ( <span class="hljs-number">15</span>,<span class="hljs-number">84</span>)           <span class="hljs-number">1207425</span> ( <span class="hljs-number">15</span>,<span class="hljs-number">42</span>)     <span class="hljs-number">101601</span> (  <span class="hljs-number">4</span>,<span class="hljs-number">14</span>)<br>Heap        <span class="hljs-number">80141</span> ( <span class="hljs-number">67</span>,<span class="hljs-number">02</span>)           <span class="hljs-number">5918020</span> ( <span class="hljs-number">75</span>,<span class="hljs-number">56</span>)    <span class="hljs-number">1627008</span> ( <span class="hljs-number">66</span>,<span class="hljs-number">31</span>)<br>Btree         <span class="hljs-number">143</span> (  <span class="hljs-number">0</span>,<span class="hljs-number">12</span>)              <span class="hljs-number">8443</span> (  <span class="hljs-number">0</span>,<span class="hljs-number">11</span>)     <span class="hljs-number">289654</span> ( <span class="hljs-number">11</span>,<span class="hljs-number">80</span>)<br>           −−−−−−                   −−−−−−−−            −−−−−−−−<br>Total      <span class="hljs-number">119581</span>                    <span class="hljs-number">7831904</span> [<span class="hljs-number">76</span>,<span class="hljs-number">14</span><span class="hljs-operator">%</span>]    <span class="hljs-number">2453755</span> [<span class="hljs-number">23</span>,<span class="hljs-number">86</span><span class="hljs-operator">%</span>]<br></code></pre></td></tr></table></figure><p>总而言之，当启用了校验和或 full_page_writes 导致了大量 FPI 时 (几乎总是如此)，尽管会有一些额外的 CPU 开销，使用压缩仍是有意义的。</p><h3 id="11-3-WAL-Levels"><a href="#11-3-WAL-Levels" class="headerlink" title="11.3 WAL Levels"></a><a name="cp3"></a>11.3 WAL Levels</h3><p>预写日志的主要目的是实现崩溃恢复。但是，如果你扩展了记录信息的范围，那么 WAL 也可以用于其他目的。PostgreSQL 提供了 minimal、replica 和 logical 三个日志级别。每个级别包括前一个级别记录的所有内容，并增加了一些额外信息。</p><p>正在使用的级别由 wal_level 参数定义；修改这个参数需要重启服务器。</p><h4 id="11-3-1-Minimal"><a href="#11-3-1-Minimal" class="headerlink" title="11.3.1 Minimal"></a>11.3.1 Minimal</h4><p>minimal 级别仅保证崩溃恢复。为了节省空间，如果当前事务中创建或截断表的操作涉及大量数据插入 (比如 CREATE TABLE AS SELECT 或者 CREATE INDEX 命令) 18，则不记录这些操作。所有需要的数据都会立即刷新到磁盘，而不是记录这些操作，并且系统表的更改在事务提交后立即可见。</p><p>如果此类操作因故障而中断，那么已写入磁盘的数据会不可见，一致性不会受到影响。如果操作完成时发生了故障，所有需要应用后续 WAL 条目的数据都已保存至磁盘上了。</p><p>对于新创建的表，必须写入以使此优化生效的数据量由 wal_skip_threshold 参数定义。</p><p>让我们看看在 minimal 级别记录了什么。</p><p>默认情况下，使用了更高的 replica 级别，此级别支持数据复制。如果选择 minimal 级别，还必须在 max_wal_senders 参数中将允许的 walsender 进程数设置为零：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">SET</span> wal_level <span class="hljs-operator">=</span> minimal;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">SET</span> max_wal_senders <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>为使这些更改生效，需要重启服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">pg_ctl restart -l /home/postgres/logfile</span><br></code></pre></td></tr></table></figure><p>注意此时 WAL 的位置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_wal_insert_lsn();<br> pg_current_wal_insert_lsn<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">45767698</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>截断表并在同一事务中继续插入新行，直至超过了 wal_skip_threshold：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> wal;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> wal<br>     <span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> generate_series(<span class="hljs-number">1</span>,<span class="hljs-number">100000</span>) id;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_wal_insert_lsn();<br> pg_current_wal_insert_lsn<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">45767840</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">我使用了 TRUNCATE 命令而不是创建新表，因为这生成的 WAL 条目更少。<br></code></pre></td></tr></table></figure><p>让我们使用已经掌握的 pg_waldump 工具来检查生成的 WAL。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">/usr/local/pgsql/bin/pg_waldump \</span><br><span class="language-bash">-p /usr/local/pgsql/data/pg_wal -s 0/45767698 -e 0/45767840#</span><br>rmgr: Storage     len (rec/tot):     42/    42, tx:          0, lsn:<br>0/45767698, prev 0/45767660, desc: CREATE base/16391/24784<br>rmgr: Heap        len (rec/tot):    123/   123, tx:     122844, lsn:<br>0/457676C8, prev 0/45767698, desc: UPDATE off 45 xmax 122844 flags<br>0x60 ; new off 48 xmax 0, blkref #0: rel 1663/16391/1259 blk 0<br>rmgr: Btree       len (rec/tot):     64/    64, tx:     122844, lsn:<br>0/45767748, prev 0/457676C8, desc: INSERT_LEAF off 176, blkref #0:<br>rel 1663/16391/2662 blk 2<br>rmgr: Btree       len (rec/tot):    64/     64, tx:     122844, lsn:<br>0/45767788, prev 0/45767748, desc: INSERT_LEAF off 147, blkref #0:<br>rel 1663/16391/2663 blk 2<br>rmgr: Btree       len (rec/tot):    64/     64, tx:     122844, lsn:<br>0/457677C8, prev 0/45767788, desc: INSERT_LEAF off 254, blkref #0:<br>rel 1663/16391/3455 blk 4<br>rmgr: Transaction len (rec/tot):    54/     54, tx:     122844, lsn:<br>0/45767808, prev 0/457677C8, desc: COMMIT 2023−03−06 14:03:58.395214<br>MSK; rels: base/16391/24783<br></code></pre></td></tr></table></figure><p>第一个条目记录了新表的创建 (因为 TRUNCATE 实际上重写了表)。</p><p>接下来的四个条目与系统表操作相关。它们反映了 pg_class 表及其三个索引的更改。</p><p>最后，还有一个与提交相关的条目。数据插入没有被记录。</p><h4 id="11-3-2-Replica"><a href="#11-3-2-Replica" class="headerlink" title="11.3.2 Replica"></a>11.3.2 Replica</h4><p>在崩溃恢复期间，重放 WAL 条目以恢复磁盘上的数据，达到一致的状态。备份恢复以类似的方式工作，但它还可以使用 WAL 归档将数据库状态恢复至指定的恢复目标点。归档 WAL 条目的数量可能非常大 (例如，跨越好几天)，因此恢复周期将包括多个检查点。因此，minimal 级别是不够的：如果操作未被记录，就无法重复执行它。对于备份恢复，WAL 文件必须包含所有的操作。</p><p>复制也是如此：未记录日志的命令不会发送到备库，也不会在备库上重放。</p><p>如果备库用于执行查询，那么事情会变得更加复杂。首先，备库需要知道在主库上获取的排它锁的信息，因为这些排它锁可能与备库上的查询冲突。其次，备库必须能够捕获快照，这需要活跃事务的信息。当我们处理备库时，本地事务和在主库上运行的事务都必须考虑在内。</p><p>将这些数据发送给备库的唯一方式是定期将其写入 WAL 19 文件。这项工作由 bgwriter 20 进程完成，每 15 秒执行一次 (此间隔时间是硬编码的)。</p><p>从备份中进行数据恢复和使用物理复制的能力在 replica 级别下得到保证。</p><p>默认使用 replica 级别 ，因此我们可以简单地重置上面配置的参数并重启服务器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> RESET wal_level;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> RESET max_wal_senders;<br><br>postgres$ pg_ctl restart <span class="hljs-operator">-</span>l <span class="hljs-operator">/</span>home<span class="hljs-operator">/</span>postgres<span class="hljs-operator">/</span>logfile<br></code></pre></td></tr></table></figure><p>让我们重复与之前相同的工作流 (但这次我们将只插入一行，以获得更整洁的输出)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_wal_insert_lsn();<br> pg_current_wal_insert_lsn<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">45</span>D88E48<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> wal;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> wal <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">42</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_wal_insert_lsn();<br> pg_current_wal_insert_lsn<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">45</span>D89108<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>看一下生成的 WAL 条目。</p><p>除了我们在 minimal 级别看到的内容之外，我们还获得了以下条目：</p><pre><code class="hljs">与复制相关的 Standby 资源管理器条目：RUNNING_XACTS (活跃事务) 和 LOCK记录 INSERT + INIT 操作的条目，该操作初始化了一个新页面并将新行插入到此页面</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">/usr/local/pgsql/bin/pg_waldump \</span><br><span class="language-bash">-p /usr/local/pgsql/data/pg_wal -s 0/45D88E48 -e 0/45D89108</span><br>rmgr: Standby     len (rec/tot):     42/    42, tx:     122846, lsn:<br>0/45D88E48, prev 0/45D88DD0, desc: LOCK xid 122846 db 16391 rel 16562<br>rmgr: Storage     len (rec/tot):     42/    42, tx:     122846, lsn:<br>0/45D88E78, prev 0/45D88E48, desc: CREATE base/16391/24786<br>rmgr: Heap        len (rec/tot):    123/   123, tx:     122846, lsn:<br>0/45D88EA8, prev 0/45D88E78, desc: UPDATE off 49 xmax 122846 flags<br>0x60 ; new off 50 xmax 0, blkref #0: rel 1663/16391/1259 blk 0<br>rmgr: Btree       len (rec/tot):    64/     64, tx:     122846, lsn:<br>0/45D88F28, prev 0/45D88EA8, desc: INSERT_LEAF off 178, blkref #0:<br>rel 1663/16391/2662 blk 2<br>rmgr: Btree       len (rec/tot):    64/     64, tx:     122846, lsn:<br>0/45D88F68, prev 0/45D88F28, desc: INSERT_LEAF off 149, blkref #0:<br>rel 1663/16391/2663 blk 2<br>rmgr: Btree       len (rec/tot):    64/     64, tx:     122846, lsn:<br>0/45D88FA8, prev 0/45D88F68, desc: INSERT_LEAF off 256, blkref #0:<br>rel 1663/16391/3455 blk 4<br>rmgr: Heap        len (rec/tot):    59/     59, tx:     122846, lsn:<br>0/45D88FE8, prev 0/45D88FA8, desc: INSERT+INIT off 1 flags 0x00,<br>blkref #0: rel 1663/16391/24786 blk 0<br>rmgr: Standby     len (rec/tot):    42/     42, tx:          0, lsn:<br>0/45D89028, prev 0/45D88FE8, desc: LOCK xid 122846 db 16391 rel 16562<br>rmgr: Standby     len (rec/tot):    54/     54, tx:          0, lsn:<br>0/45D89058, prev 0/45D89028, desc: RUNNING_XACTS nextXid 122847<br>latestCompletedXid 122845 oldestRunningXid 122846; 1 xacts: 122846<br>rmgr: Transaction len (rec/tot):   114/    114, tx:     122846, lsn:<br>0/45D89090, prev 0/45D89058, desc: COMMIT 2023−03−06 14:04:14.538399<br>MSK; rels: base/16391/24785; inval msgs: catcache 51 catcache 50<br>relcache 16562<br></code></pre></td></tr></table></figure><h4 id="11-3-3-Logical"><a href="#11-3-3-Logical" class="headerlink" title="11.3.3 Logical"></a>11.3.3 Logical</h4><p>最后但同样重要的是，logical 级别支持逻辑解码和逻辑复制。它必须在发布端激活。</p><p>如果我们查看 WAL 条目，会发现该级别与 replica 几乎相同：它添加了与复制源相关的条目，以及一些可能由应用程序生成的任意逻辑条目。大多数情况下，逻辑解码依赖于有关活跃事务的信息 (RUNNING_XACTS)，因为逻辑解码需要捕获快照以跟踪系统表的更改。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch10. Write-Ahead Log</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch10/ch10/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch10/ch10/</url>
    
    <content type="html"><![CDATA[<h2 id="ch10-Write-Ahead-Log"><a href="#ch10-Write-Ahead-Log" class="headerlink" title="ch10. Write-Ahead Log"></a>ch10. Write-Ahead Log</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">10.1 Logging</a></td></tr><tr><td><a href="#cp2">10.2 WAL Structure</a></td></tr><tr><td><a href="#cp3">10.3 Checkpoint</a></td></tr><tr><td><a href="#cp4">10.4 Recovery</a></td></tr><tr><td><a href="#cp5">10.5 Background Writing</a></td></tr><tr><td><a href="#cp6">10.6 WAL Setup</a></td></tr></tbody></table><h3 id="10-1-Logging"><a href="#10-1-Logging" class="headerlink" title="10.1 Logging"></a><a name="cp1"></a>10.1 Logging</h3><p>当发生故障时，例如断电、 操作系统错误或数据库服务器崩溃，RAM 中所有的内容都将丢失；只有写入磁盘的数据才会持久保存。为了在故障之后启动服务器，你必须恢复数据的一致性。如果磁盘本身受损，同样的问题必须通过备份恢复来解决。</p><p>理论上，你可以始终保持磁盘上数据的一致性。但实际上，这意味着服务器必须不断地将随机页面写入磁盘(即使顺序写入代价更低)，并且这些写入的顺序必须保证在任何特定时刻都不会损害一致性 (这很难实现，尤其是在处理复杂的索引结构时)。</p><p>就像大多数数据库系统一样，PostgreSQL 采用了不同的方式。</p><p>当服务器运行时，一些当前数据仅在 RAM 中可用，然后数据被延迟写入至持久化存储中。因此，存储在磁盘上的数据在服务器操作期间总是不一致，因为页面从未一次性全部刷新过。但在 RAM 中发生的每次更改 (例如在缓冲区缓存中进行的页面更新) 都会被记录下来：PostgreSQL 会创建一个日志条目，其中包含了在需要时重复执行此操作所需的所有基本信息 1。</p><p>与页面修改相关的日志条目必须在被修改页面本身写入磁盘之前写入，因此得名：预写式日志，或者 WAL。这个要求保证了在发生故障的情况下，PostgreSQL 可以从磁盘读取 WAL 条目，并重放它们以重复已完成的操作，这些操作的结果仍在 RAM 中，在崩溃之前还没有写入到磁盘中。</p><p>维护预写式日志通常比将随机页面写入磁盘更高效。WAL 条目构成连续的数据流，即使是 HDD 也能处理。此外，WAL 条目通常比页面大小更小。</p><p>所有在发生故障时可能破坏数据一致性的操作都需要被记录。特别是，以下操作会记录在 WAL 中：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">在缓冲区缓存中执行的页面修改 — 因为写入被推迟了<br>事务提交和回滚 — 因为状态变化发生在 CLOG 缓存中，并且不会立即写入磁盘<br>文件操作 (例如在添加或删除表时创建和删除文件和目录) — 因为此类操作必须与数据更改同步<br></code></pre></td></tr></table></figure><p>以下操作不会被记录：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">在无日志表上的操作<br><br>对临时表的操作 — 因为它们的生命周期无论如何，都受限于生成它们的会话<br><br>    在 PostgreSQL 10 之前，哈希索引也不会记录 WAL。它们的唯一目的是将哈希函数与不同的数据类型相匹配<br></code></pre></td></tr></table></figure><p>除了崩溃恢复，WAL 还可以用于从备份中进行时间点恢复以及复制。</p><h3 id="10-2-WAL-Structure"><a href="#10-2-WAL-Structure" class="headerlink" title="10.2 WAL Structure"></a><a name="cp2"></a>10.2 WAL Structure</h3><h4 id="10-2-1-逻辑结构"><a href="#10-2-1-逻辑结构" class="headerlink" title="10.2.1 逻辑结构"></a>10.2.1 逻辑结构</h4><p>在讲述其逻辑结构时，我们可以将 WAL 2 描述为一个可变长度的日志条目流。每个条目都包含了一些关于特定操作的数据，在其前面有一个标准头结构 3。该头结构提供的信息包括：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">与条目相关的事务 ID<br><br>解析条目的资源管理器 4<br><br>用于检测数据损坏的校验和<br><br>条目长度<br><br>对前一个 WAL 条目的引用<br><br>    WAL 通常是向前读取的，但是像 pg_rewind 这样的工具可能会向后扫描。<br></code></pre></td></tr></table></figure><p>WAL 数据本身可以有不同的格式和含义。例如，它可以是一个必须在指定的偏移量处替换页面某些部分的页面片段。相应的资源管理器必须知道如何解析和重放特定条目。表、各种索引类型、事务状态和其他实体都有单独的管理器。</p><p>WAL 文件在服务器的共享内存中占用特殊的缓冲区。由 wal_buffers 参数定义 WAL 使用的缓存大小。默认情况下，其大小是自动计算的，为总缓冲区缓存大小的 1&#x2F;32。</p><p>WAL 缓存与缓冲区缓存非常相似，但它通常以环形缓冲区模式运行：新的条目添加到头部，而旧条目从尾部开始保存至磁盘。如果 WAL 缓存太小，磁盘同步的执行频率会超出以往。</p><p>在低负载下，插入的位置 (缓冲区头部) 几乎总是与已保存到磁盘的条目位置 (缓冲区尾部) 相同：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_wal_lsn(), pg_current_wal_insert_lsn();<br> pg_current_wal_lsn <span class="hljs-operator">|</span> pg_current_wal_insert_lsn<br>−−−−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">3</span>DF56000         <span class="hljs-operator">|</span> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">3</span>DF57968<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">在 PostgreSQL 10 之前，所有函数名都包含了 XLOG 首字母缩写，而不是 WAL。</code></pre><p>为了引用特定条目，PostgreSQL 使用了一种特殊的数据类型：pg_lsn (日志序列号，LSN)。它表示从 WAL 开始处到某个条目的 64 位字节偏移量。LSN 以两个 32 位的十六进制数字表示，以斜线分隔。</p><p>现在，让我们创建一个表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE TABLE</span> wal(id <span class="hljs-type">integer</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> wal <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>开启一个事务，注意 WAL 插入位置的 LSN：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_wal_insert_lsn();<br> pg_current_wal_insert_lsn<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">3</span>DF708D8<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>现在运行任意命令，比如更新一行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> wal <span class="hljs-keyword">SET</span> id <span class="hljs-operator">=</span> id <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>页面修改在 RAM 中的缓冲区缓存中进行。此更改记录在 WAL 页面中，也在 RAM 中。然后，插入的 LSN 向前推进：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_wal_insert_lsn();<br> pg_current_wal_insert_lsn<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">3</span>DF70920<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>为了确保修改后的数据页在相应的 WAL 条目之后被刷新到磁盘，页头存储了与此页面相关的最新 WAL 条目的 LSN。你可以使用 pageinspect 查看此 LSN：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> lsn <span class="hljs-keyword">FROM</span> page_header(get_raw_page(<span class="hljs-string">&#x27;wal&#x27;</span>,<span class="hljs-number">0</span>));<br>    lsn<br>−−−−−−−−−−−−<br> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">3</span>DF70920<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>整个数据库集簇只有一个 WAL，新的条目不断追加到其中。因此，存储在页面中的 LSN 可能会小于一段时间前 pg_current_wal_insert_lsn 函数返回的 LSN。但是，如果系统中没有发生任何事情，这些数字将是相同的。</p><p>现在让我们提交事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>提交操作也被记录下来，插入的 LSN 同样发生了改变：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_wal_insert_lsn();<br> pg_current_wal_insert_lsn<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">3</span>DF70948<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>事务提交会更新 CLOG 页面中的事务状态，这些页面保存在它们自己的缓存中 5。CLOG 缓存通常在共享内存中占用 128 个页面 6。为了确保 CLOG 页面不会在相应的 WAL 条目之前被刷新到磁盘，也必须跟踪 CLOG 页面最新 WAL 条目的 LSN。但这些信息存储在 RAM 中，而不是在页面本身中。</p><p>在某个时刻，WAL 条目将被写入磁盘；之后便可以从缓存中逐出 CLOG 和数据页面。如果需要提前逐出，这一情况会被发现，且 WAL 条目会首先被强制写入磁盘。7</p><p>如果知道两个 LSN 的位置，那么你可以通过从一个位置减去另一个位置来计算它们之间 WAL 条目的大小 (以字节为单位)。你只需将它们转换为 pg_lsn 类型：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;0/3DF70948&#x27;</span>::pg_lsn <span class="hljs-operator">-</span> <span class="hljs-string">&#x27;0/3DF708D8&#x27;</span>::pg_lsn;<br> ?<span class="hljs-keyword">column</span>?<br>−−−−−−−−−−<br>      <span class="hljs-number">112</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>在此特例中，与 UPDATE 和 COMMIT 操作相关的 WAL 条目占用了大约 100 字节。</p><p>你可以使用相同的方式来评估特定工作负载在单位时间内生成的 WAL 条目的数量。这些信息对于设置检查点来说是必需的。</p><h4 id="10-2-2-物理结构"><a href="#10-2-2-物理结构" class="headerlink" title="10.2.2 物理结构"></a>10.2.2 物理结构</h4><p>在磁盘上，WAL 作为单独的文件或段存储在 PGDATA&#x2F;pg_wal 目录中。其大小由只读参数 wal_segment_size 表示。</p><p>对于高负载系统，增加段大小是有意义的，因为这样可能会减少开销，但是此设置只能在集群初始化期间修改 (initdb –wal-segsize)。</p><p>WAL 条目写入当前文件，直至空间用完；然后 PostgreSQL 会创建一个新的文件。</p><p>我们可以了解特定条目位于哪个文件中，以及从文件开始的偏移量是多少：</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch10/ch10/img.png" alt="img.png"></p><p>文件名由两部分组成。最高的八位十六进制数字定义了时间线，用于从备份中恢复，而其余部分代表了最高的 LSN 位 (最低的 LSN 位显示在 file_offset 字段中)。</p><p>要查看当前的 WAL 文件，你可以使用如下函数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> pg_ls_waldir()<br><span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;00000001000000000000003E&#x27;</span>;<br>          name            <span class="hljs-operator">|</span>   size  <span class="hljs-operator">|</span>     modification<br>−−−−−−−−−−−−−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-number">00000001000000000000003</span>D <span class="hljs-operator">|</span> <span class="hljs-number">16777216</span> <span class="hljs-operator">|</span> <span class="hljs-number">2023</span>−<span class="hljs-number">03</span>−<span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">01</span>:<span class="hljs-number">48</span><span class="hljs-operator">+</span><span class="hljs-number">03</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>现在让我们使用 pg_waldump 工具查看新创建的 WAL 条目头部 ，pg_waldump 可以按 LSN 范围 (比如本例) 或特定事务 ID 过滤 WAL 条目。</p><p>pg_waldump 工具应以 postgres 操作系统用户启动，因为它需要访问磁盘上的 WAL 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">/usr/local/pgsql/bin/pg_waldump \</span><br><span class="language-bash">-p /usr/local/pgsql/data/pg_wal -s 0/3DF708D8 -e 0/3DF70948#</span><br>rmgr: Heap        len (rec/tot):     69/    69, tx:        886, lsn:<br>0/3DF708D8, prev 0/3DF708B0, desc: HOT_UPDATE off 1 xmax 886 flags<br>0x40 ; new off 2 xmax 0, blkref #0: rel 1663/16391/16562 blk 0<br>rmgr: Transaction len (rec/tot):     34/    34, tx:        886, lsn:<br>0/3DF70920, prev 0/3DF708D8, desc: COMMIT 2023−03−06 14:01:48.875861<br>MSK<br></code></pre></td></tr></table></figure><p>此处我们可以看到两个 WAL 条目的头部。</p><p>第一个是由堆资源管理器处理的 HOT_UPDATE 操作。blkref 字段显示了更新的堆页面其文件名和页面 ID ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_relation_filepath(<span class="hljs-string">&#x27;wal&#x27;</span>);<br> pg_relation_filepath<br>−−−−−−−−−−−−−−−−−−−−−−<br> base<span class="hljs-operator">/</span><span class="hljs-number">16391</span><span class="hljs-operator">/</span><span class="hljs-number">16562</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>第二个条目是事务资源管理器管理的 COMMIT 操作。</p><h3 id="10-3-Checkpoint"><a href="#10-3-Checkpoint" class="headerlink" title="10.3 Checkpoint"></a><a name="cp3"></a>10.3 Checkpoint</h3><p>为了在故障之后恢复数据一致性 (即执行恢复)，PostgreSQL 必须向前重放 WAL，并将代表丢失变更的条目应用到相应的页面。为了找出丢失的内容，PostgreSQL 会将存储在磁盘上的页面的 LSN 与 WAL 条目的 LSN 进行比较。但是应该从哪个点开始恢复呢？ 如果开始得太晚，这个点之前写入磁盘的页面将无法接收到所有更改，这将导致不可逆的数据损坏。但是从头开始也不现实：不可能存储如此海量的数据，也不可能接受这么长的恢复时间。因此我们需要一个逐渐向前移动的检查点，从这个点开始恢复是安全的，并且可以删除所有之前的 WAL 条目。</p><p>创建检查点最直接的方式是定期挂起所有系统操作，并强制刷新所有脏页至磁盘上。这种方式当然是无法接受的，因为系统将挂起相当长的时间。</p><p>因此，检查点会随着时间的推移而分散执行，这实际上构成了一个时间间隔。检查点的执行由一个名为 checkpointer 的特殊后台进程执行 8。</p><p><strong>检查点开始。</strong> checkpointer 进程将所有可以立即写入的内容刷新至磁盘：CLOG 事务状态、子事务的元数据以及其他一些结构。</p><p><strong>检查点执行。</strong> 大部分检查点的执行时间都花在了将脏页刷新至磁盘上 9。首先，在检查点开始时，所有脏缓冲区的头部中都设置了一个特殊标记。这个过程发生得非常快，因为不涉及 I&#x2F;O 操作。</p><p>然后 checkpointer 进程遍历所有缓冲区并将被标记的缓冲区写入至磁盘中。它们的页面不会从缓存中驱逐：只是简单地被写下来，因此可以忽略使用计数和锁定计数。</p><p>页面按照它们的 ID 顺序处理，以尽可能避免随机写入。为了更好地平衡负载，PostgreSQL 在不同的表空间之间交替进行 (因为它们可能位于不同的物理设备上)。</p><p>后台进程也可以将标记的缓冲区写入磁盘 — 如果后端进程先处理的话。无论如何，此阶段将移除缓冲区标记，因此对于检查点来说，每个缓冲区只会被写入一次。</p><p>当然，当检查点正在进行时，缓冲区缓存中的页面仍然可以修改。但由于新的缓冲区脏页没有被标记，因此 checkpointer 进程会忽略它们。</p><p><strong>检查点完成。</strong> 当检查点开始时，所有脏的缓冲区都写入磁盘后，检查点便认为完成了。从现在开始 (但不是更早！)，检查点的起始位置将用作恢复的新起点。在这个点之前写入的所有 WAL 条目都不再需要。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch10/ch10/img_1.png" alt="img_1.png"></p><p>最后， checkpoiner 会创建一个与检查点完成相对应的 WAL 条目，并指定检查点开始的 LSN。由于检查点在开始时不记录任何内容，因此这个 LSN 可以属于任何类型的 WAL 条目。</p><p>PGDATA&#x2F;global&#x2F;pg_control 文件也会更新，以引用最新完成的检查点 (直到这个过程结束，pg_control 都保持为之前的检查点)。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch10/ch10/img_2.png" alt="img_2.png"></p><p>为了彻底弄清楚这些位点，让我们看一个简单的例子。首先使几个缓存页面变脏：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> big <span class="hljs-keyword">SET</span> s <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;FOO&#x27;</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> pg_buffercache <span class="hljs-keyword">WHERE</span> isdirty;<br> count<br>−−−−−−−<br>  <span class="hljs-number">4119</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>注意此时 WAL 的位置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_wal_insert_lsn();<br> pg_current_wal_insert_lsn<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">3E7</span>EF7E0<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>现在让我们手动完成检查点。所有脏页将被刷新至磁盘；由于系统中没有发生任何事情，因此不会出现新的脏页：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> CHECKPOINT;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> pg_buffercache <span class="hljs-keyword">WHERE</span> isdirty;<br> count<br>−−−−−−−<br>     <span class="hljs-number">0</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>让我们看看检查点是如何反映在 WAL 中的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_wal_insert_lsn();<br> pg_current_wal_insert_lsn<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">3E7</span>EF890<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><br>postgres$ <span class="hljs-operator">/</span>usr<span class="hljs-operator">/</span><span class="hljs-keyword">local</span><span class="hljs-operator">/</span>pgsql<span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>pg_waldump \<br><span class="hljs-operator">-</span>p <span class="hljs-operator">/</span>usr<span class="hljs-operator">/</span><span class="hljs-keyword">local</span><span class="hljs-operator">/</span>pgsql<span class="hljs-operator">/</span>data<span class="hljs-operator">/</span>pg_wal <span class="hljs-operator">-</span>s <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">3E7</span>EF7E0 <span class="hljs-operator">-</span>e <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">3E7</span>EF890<br>rmgr: Standby     len (rec<span class="hljs-operator">/</span>tot):     <span class="hljs-number">50</span><span class="hljs-operator">/</span>    <span class="hljs-number">50</span>, tx:          <span class="hljs-number">0</span>, lsn:<br><span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">3E7</span>EF7E0, prev <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">3E7</span>EF7B8, <span class="hljs-keyword">desc</span>: RUNNING_XACTS nextXid <span class="hljs-number">888</span><br>latestCompletedXid <span class="hljs-number">887</span> oldestRunningXid <span class="hljs-number">888</span><br>rmgr: XLOG        len (rec<span class="hljs-operator">/</span>tot):    <span class="hljs-number">114</span><span class="hljs-operator">/</span>   <span class="hljs-number">114</span>, tx:          <span class="hljs-number">0</span>, lsn:<br><span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">3E7</span>EF818, prev <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">3E7</span>EF7E0, <span class="hljs-keyword">desc</span>: CHECKPOINT_ONLINE redo<br><span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">3E7</span>EF7E0; tli <span class="hljs-number">1</span>; prev tli <span class="hljs-number">1</span>; fpw <span class="hljs-literal">true</span>; xid <span class="hljs-number">0</span>:<span class="hljs-number">888</span>; oid <span class="hljs-number">24754</span>; multi<br><span class="hljs-number">1</span>; <span class="hljs-keyword">offset</span> <span class="hljs-number">0</span>; oldest xid <span class="hljs-number">726</span> <span class="hljs-keyword">in</span> DB <span class="hljs-number">1</span>; oldest multi <span class="hljs-number">1</span> <span class="hljs-keyword">in</span> DB <span class="hljs-number">1</span>;<br>oldest<span class="hljs-operator">/</span>newest <span class="hljs-keyword">commit</span> <span class="hljs-type">timestamp</span> xid: <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">0</span>; oldest <span class="hljs-keyword">running</span> xid <span class="hljs-number">888</span>;<br>online<br></code></pre></td></tr></table></figure><p>最新的 WAL 条目与检查点完成有关 (CHECKPOINT_ONLINE)。单词 redo 之后指定的是此检查点开始的 LSN；这个位置对应检查点开始时插入的最新 WAL 条目。</p><p>相同的信息也可以在 pg_control 文件中找到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">/usr/local/pgsql/bin/pg_controldata \</span><br><span class="language-bash">-D /usr/local/pgsql/data | egrep <span class="hljs-string">&#x27;Latest.*location&#x27;</span></span><br>Latest checkpoint location:           0/3E7EF818<br>Latest checkpoint&#x27;s REDO location:    0/3E7EF7E0<br></code></pre></td></tr></table></figure><h3 id="10-4-Recovery"><a href="#10-4-Recovery" class="headerlink" title="10.4 Recovery"></a><a name="cp4"></a>10.4 Recovery</h3><p>服务器启动时启动的第一个进程是 postmaster。接着，postmaster 会启动 startup 进程 10，此进程负责在故障发生时执行数据恢复。</p><p>为了确认是否需要恢复，startup 进程会读取 pg_control 文件并检查实例状态。pg_controldata 工具可以查看此文件的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">/usr/local/pgsql/bin/pg_controldata \</span><br><span class="language-bash">-D /usr/local/pgsql/data | grep state</span><br>Database cluster state:               in production<br></code></pre></td></tr></table></figure><p>妥善停止的服务器处于”shut down”状态；非运行状态服务器的”in production”状态表明发生了故障。在此情况下，startup 进程将自动从 pg_control 文件中找到最新完成的检查点的起始 LSN 位置处进行恢复。</p><pre><code class="hljs">如果 PGDATA 目录包含与备份相关的 backup_label 文件，那么起始 LSN 位置就从此文件中获取。</code></pre><p>startup 进程从定义的位置开始，逐个读取 WAL 条目，如果页面的 LSN 小于 WAL 条目的 LSN，则将它们应用到数据页。如果页面包含更大的 LSN，那么就不应用 WAL；事实上，也绝不能被应用，因为其条目被设计成是严格顺序重放的。</p><p>但是，一些 WAL 条目构成了一个完整的页面镜像，即 FPI。这种类型的条目可以应用于页面的任何状态，因为无论如何，所有页面内容都将被删除。这种修改被称为幂等操作。幂等操作的另一个例子是注册事务状态变化：每个事务状态在 CLOG 页中由某些位定义，无论它们之前的值是多少，都会被设置，因此不需要在 CLOG 页面中保留最新更改的 LSN。</p><p>WAL 条目被应用到缓冲区缓存中的页面，就像正常操作期间的常规页面更新一样。</p><p>文件以类似的方式从 WAL 中恢复：例如，如果 WAL 条目显示文件必须存在，但由于某种原因丢失了，那么它将被重新创建。</p><p>一旦恢复完成，所有无日志表都会被相应的初始分支覆盖。</p><p>最后，执行检查点以确保恢复状态安全地写入磁盘。</p><p>此时，startup 进程的工作就完成了。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">在传统形式中，恢复过程包括两个阶段。在前滚阶段，重放 WAL 条目，重复丢失的操作。在回滚阶段，服务器将中止故障时尚未提交的事务。<br><br>在 PostgreSQL 中，不需要第二阶段。恢复之后，CLOG 将不会包含未完成事务 (从技术上来说表示活跃事务) 的提交位或中止位，但由于可以确定该事务不再运行，因此将被视为已中止 11。<br></code></pre></td></tr></table></figure><p>我们可以通过强制以 immediate 模式停止服务器来模拟故障：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">pg_ctl stop -m immediate</span><br></code></pre></td></tr></table></figure><p>此处是新的实例状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">/usr/local/pgsql/bin/pg_controldata \</span><br><span class="language-bash">-D /usr/local/pgsql/data | grep <span class="hljs-string">&#x27;state&#x27;</span></span><br>Database cluster state:                 in production<br></code></pre></td></tr></table></figure><p>当我们启动服务器时，startup 进程发现发生了故障，于是进入恢复模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">pg_ctl start -l /home/postgres/logfile</span><br><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash"><span class="hljs-built_in">tail</span> -n 6 /home/postgres/logfile</span><br>LOG:  database system was interrupted; last known up at 2023−03−06<br>14:01:49 MSK<br>LOG:  database system was not properly shut down; automatic recovery<br>in progress<br>LOG:  redo starts at 0/3E7EF7E0<br>LOG:  invalid record length at 0/3E7EF890: wanted 24, got 0<br>LOG:  redo done at 0/3E7EF818 system usage: CPU: user: 0.00 s,<br>system: 0.00 s, elapsed: 0.00 s<br>LOG:  database system is ready to accept connections<br></code></pre></td></tr></table></figure><p>如果服务器正常停止，postmaster 会断开所有客户端，然后执行最终检查点将所有脏页刷新至磁盘。</p><p>注意此刻 WAL 的位置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_current_wal_insert_lsn();<br> pg_current_wal_insert_lsn<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> <span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-number">3E7</span>EF908<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>现在让我们妥善关闭服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">pg_ctl stop</span><br></code></pre></td></tr></table></figure><p>此处是新的实例状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">/usr/local/pgsql/bin/pg_controldata \</span><br><span class="language-bash">-D /usr/local/pgsql/data | grep state</span><br>Database cluster state:               shut down<br></code></pre></td></tr></table></figure><p>在 WAL 的末尾，我们可以看到 CHECKPOINT_SHUTDOWN 条目，表明是最终的检查点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">/usr/local/pgsql/bin/pg_waldump \</span><br><span class="language-bash">-p /usr/local/pgsql/data/pg_wal -s 0/3E7EF908</span><br>rmgr: XLOG        len (rec/tot):    114/   114, tx:          0, lsn:<br>0/3E7EF908, prev 0/3E7EF890, desc: CHECKPOINT_SHUTDOWN redo<br>0/3E7EF908; tli 1; prev tli 1; fpw true; xid 0:888; oid 24754; multi<br>1; offset 0; oldest xid 726 in DB 1; oldest multi 1 in DB 1;<br>oldest/newest commit timestamp xid: 0/0; oldest running xid 0;<br>shutdown<br>pg_waldump: fatal: error in WAL record at 0/3E7EF908: invalid record<br>length at 0/3E7EF980: wanted 24, got 0<br></code></pre></td></tr></table></figure><p>最新的 pg_waldump 信息显示该工具已经读取到了 WAL 的末尾。</p><p>让我们再次启动实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash">pg_ctl start -l /home/postgres/logfile</span><br></code></pre></td></tr></table></figure><h3 id="10-5-Background-Writing"><a href="#10-5-Background-Writing" class="headerlink" title="10.5 Background Writing"></a><a name="cp5"></a>10.5 Background Writing</h3><p>如果后端进程需要从缓冲区中驱逐脏页，它必须先将该页写入磁盘。这种情况是不希望发生的，因为会导致等待 — 在后台异步执行写操作要好得多。</p><p>这项工作，部分由 checkpointer 进程处理，但仍然不够。</p><p>因此，PostgreSQL 提供了另一个名为 bgwriter 的进程 12，专门用于后台写入。它也依赖和页面驱逐相同的缓冲区搜索算法，除了两点主要区别：</p><pre><code class="hljs">bgwriter 进程使用自己的时钟指针，这个指针永远不会落后于驱逐指针，并且通常会在它前面。在遍历缓冲区时，使用计数不会减少。</code></pre><p>如果缓冲区未被锁定且使用计数为零，那么脏页会被刷新至磁盘。因此，bgwriter 在驱逐之前运行，并主动将那些很可能很快被驱逐的页面写入磁盘。</p><p>这提高了被选中用于驱逐的缓冲区是并不是脏的的几率。</p><h3 id="10-6-WAL-Setup"><a href="#10-6-WAL-Setup" class="headerlink" title="10.6 WAL Setup"></a><a name="cp6"></a>10.6 WAL Setup</h3><h4 id="10-6-1-配置检查点"><a href="#10-6-1-配置检查点" class="headerlink" title="10.6.1 配置检查点"></a>10.6.1 配置检查点</h4><p>检查点的持续时间 (更确切地说，将脏的缓冲区写入磁盘的持续时间) 由 checkpoint_completion_target 参数定义。这个值指定了两个相邻检查点开始之间分配给写入的时间比例。不要将该参数设为 1：这可能会导致下一个检查点在前一个检查点完成之前到达。这并不会发生灾难，因为无法同时执行多个检查点，但仍有可能会扰乱常规的操作。</p><p>在配置其他参数时，我们可以使用如下方式。首先，定义两个相邻检查点之间适当的用于存储 WAL 的容量。容量越大，开销就越小，但这个值无论如何都会受到可用空间和可接受的恢复时长的限制。</p><p>要评估常规负载生成此容量大小所需的时间，你需要记录初始插入 LSN，并时不时检查此位置与当前插入位置之间的差值。</p><p>假设获取的数字是一个典型的检查点间隔时间，我们将其用作 checkpoint_timeout 参数的值。默认设置可能太小；通常会增加该值，比如增加至 30 分钟。</p><p>但是，可能 (甚至很可能) 负载有时会更高，因此在此时间间隔内生成的 WAL 文件的大小会很大。在这种情况下，必须更频繁地执行检查点。为了设置这样的触发器，我们通过 max_wal_size 参数限制恢复所需的 WAL 文件的大小。当超过这个阈值时，服务器便会触发一个额外的检查点 13。</p><p>用于恢复的 WAL 文件包含最新完成的检查点和当前尚未完成的检查点的所有条目。因此，要估算它们的总大小，你应该将计算出的检查点之间的 WAL 大小乘以 1 + checkpoint_completion_target。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">在 11 版本之前，PostgreSQL 会为两个已完成的检查点保留 WAL 文件，因此乘数为 2 + checkpoint_completion_target。<br></code></pre></td></tr></table></figure><p>按照这种方式，大多数检查点都将按计划执行，每隔 checkpoint_timeout 执行一次； 但是如果负载增加，当 WAL 的大小超过 max_wal_size 值时，便会触发检查点。</p><p>实际进展会定期与预期数字进行对比 14：</p><p><strong>实际进展</strong>由已处理的缓存页面的比例定义。</p><p><strong>预期进度 (按时间)</strong> 由已流逝的时间比例定义，检查点必须在 checkpoint_timeout × checkpoint_completion_target 时间间隔内完成。</p><p><strong>预期进度 (按大小)</strong> 由已填充的 WAL 文件的比例定义，预期数量基于 max_wal_size × checkpoint_completion_target 值估算。</p><p>如果脏页提前写入了磁盘，那么 checkpointer 进程会暂停一段时间；如果任一参数有任何延迟，它会尽可能追上 15。由于同时考虑到了时间和数据大小，PostgreSQL 可以使用相同的方式管理计划内和按需的检查点。</p><p>检查点完成后，不再需要恢复的 WAL 文件便会被删除 16；但是，部分文件 (总共最多 min_wal_size) 会被保留以供重复使用，并且简单地被重命名。</p><p>这种重命名操作减少了频繁创建文件和删除文件所带来的开销，但如果你不需要这个功能的话，可以使用 wal_recycle 参数将其关闭。</p><p>下图显示了正常情况下，存储在磁盘上的 WAL 文件大小是如何变化的。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch10/ch10/img_3.png" alt="img_3.png"></p><p>请务必记住，磁盘上 WAL 文件的实际大小可能会超过 max_wal_size 值：</p><pre><code class="hljs">max_wal_size 参数指定了预期的目标值，而不是硬限制。如果负载激增，写入可能会落后于计划。服务器无权删除尚未被复制或连续归档所处理的 WAL 文件。如果启用了此功能，那么必须不断监控，因为它很容易导致磁盘溢出。你可以通过配置 wal_keep_size 参数，保留一定数量的 WAL 文件。</code></pre><h4 id="10-6-2-配置后台写入"><a href="#10-6-2-配置后台写入" class="headerlink" title="10.6.2 配置后台写入"></a>10.6.2 配置后台写入</h4><p>配置完检查点之后，你还应该配置 bgwriter。总之，这两个进程必须能够在后端进程需要重用之前将脏的缓冲区写入磁盘。</p><p>在执行期间，bgwriter 会定期暂停，休眠 bgwriter_delay 参数所指定的单位时间。</p><p>两次暂停期间写入的页面数量取决于自上次运行以来后端进程访问的缓冲区的平均数量 (PostgreSQL 使用了一个变化的平均值来平衡可能的峰值，并同时避免依赖非常老的数据)。然后将计算出的数字乘以 bgwriter_lru_multiplier。但无论如何，单次运行写入的页面数量不能超过 bgwriter_lru_maxpages 的值。</p><p>如果没有发现脏缓冲区 (即系统中没有发生任何事情)，bgwriter 会休眠，直到其中一个后端进程访问了缓冲区。然后它会醒来并继续执行其常规操作。</p><h4 id="10-6-3-监控"><a href="#10-6-3-监控" class="headerlink" title="10.6.3 监控"></a>10.6.3 监控</h4><p>基于监控数据，可以并且也应该去调整检查点设置。</p><p>如果基于大小触发的检查点执行得比 checkpoint_warning 参数所定义的更频繁，那么 PostgreSQL 会发出警告。此设置应符合预期的峰值负载。</p><p>log_checkpoints 参数允许将与检查点相关的信息打印到服务器日志中。让我们打开它：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">SET</span> log_checkpoints <span class="hljs-operator">=</span> <span class="hljs-keyword">on</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_reload_conf();<br></code></pre></td></tr></table></figure><p>现在让我们修改一些数据，并执行检查点：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> big <span class="hljs-keyword">SET</span> s <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;BAR&#x27;</span>;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> CHECKPOINT;<br></code></pre></td></tr></table></figure><p>服务器日志显示了写入的缓冲区数量、检查点后 WAL 文件变更的一些统计数据、检查点的持续时间，以及两个相邻检查点开始之间的距离 (WAL 数据量，以字节为单位)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">postgres$ </span><span class="language-bash"><span class="hljs-built_in">tail</span> -n 2 /home/postgres/logfile</span><br>LOG:  checkpoint starting: immediate force wait<br>LOG:  checkpoint complete: wrote 4100 buffers (25.0%); 0 WAL file(s)<br>added, 1 removed, 0 recycled; write=0.076 s, sync=0.009 s,<br>total=0.099 s; sync files=3, longest=0.007 s, average=0.003 s;<br>distance=9213 kB, estimate=9213 kB<br></code></pre></td></tr></table></figure><p>影响配置决策的最有用的数据是 pg_stat_bgwriter 视图中提供的有关后台写入和检查点执行的统计数据。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">在 9.2 版本之前，这两项任务都由 bgwriter 执行；后来，引入了一个单独的 checkpointer 进程，但共用的视图保持不变。<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pg_stat_bgwriter \gx<br>−[ RECORD <span class="hljs-number">1</span> ]−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br>checkpoints_timed     <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br>checkpoints_req       <span class="hljs-operator">|</span> <span class="hljs-number">14</span><br>checkpoint_write_time <span class="hljs-operator">|</span> <span class="hljs-number">33111</span><br>checkpoint_sync_time  <span class="hljs-operator">|</span> <span class="hljs-number">221</span><br>buffers_checkpoint    <span class="hljs-operator">|</span> <span class="hljs-number">14253</span><br>buffers_clean         <span class="hljs-operator">|</span> <span class="hljs-number">13066</span><br>maxwritten_clean      <span class="hljs-operator">|</span> <span class="hljs-number">122</span><br>buffers_backend       <span class="hljs-operator">|</span> <span class="hljs-number">84226</span><br>buffers_backend_fsync <span class="hljs-operator">|</span> <span class="hljs-number">0</span><br>buffers_alloc         <span class="hljs-operator">|</span> <span class="hljs-number">86700</span><br>stats_reset           <span class="hljs-operator">|</span> <span class="hljs-number">2023</span>−<span class="hljs-number">03</span>−<span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">00</span>:<span class="hljs-number">07.369124</span><span class="hljs-operator">+</span><span class="hljs-number">03</span><br></code></pre></td></tr></table></figure><p>这个视图除了其他信息外，还显示了完成的检查点数量：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">checkpoints_timed 字段显示了计划的检查点 (达到 checkpoint_timeout 间隔时触发)。<br>checkpoints_req 字段显示了按需检查点 (包括达到 max_wal_size 大小时触发的检查点)。<br></code></pre></td></tr></table></figure><p>较大的 checkpoint_req 值 (与 checkpoints_timed 相比) 表明检查点比预期执行地更频繁。</p><p>以下统计数据也很重要，与写入的页面数量有关：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">buffers_checkpoint：由 checkpointer 进程写入的页面<br>buffers_backend：由后端进程写入的页面<br>buffers_clean：由 bgwriter 写入的页面<br></code></pre></td></tr></table></figure><p>在配置良好的系统中，buffers_backend 值必须远低于 buffers_checkpoint 和 buffers_clean 的总和。</p><p>在配置后台写入时，请注意 maxwritten_clean 值：它显示了 bgwriter 因超过由 bgwriter_lru_maxpages 定义的阈值而不得不停止的次数。</p><p>以下调用将重置已收集的统计数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_stat_reset_shared(<span class="hljs-string">&#x27;bgwriter&#x27;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ch1. Introduction</title>
    <link href="/2025/05/05/DB/PostgreSQL14_Internals/ch1/ch1/"/>
    <url>/2025/05/05/DB/PostgreSQL14_Internals/ch1/ch1/</url>
    
    <content type="html"><![CDATA[<h2 id="ch1-Introduction"><a href="#ch1-Introduction" class="headerlink" title="ch1. Introduction"></a>ch1. Introduction</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#data-Organization">1.1 Data Organization</a></td></tr><tr><td><a href="#process-mem">1.2 Processes and Memory</a></td></tr><tr><td><a href="#client">1.3 Clients and the Client-Server Protocol</a></td></tr></tbody></table><h3 id="1-1-Data-Organization"><a href="#1-1-Data-Organization" class="headerlink" title="1.1 Data Organization"></a><a name="data-Organization"></a>1.1 Data Organization</h3><h4 id="1-1-1-数据库"><a href="#1-1-1-数据库" class="headerlink" title="1.1.1 数据库"></a>1.1.1 数据库</h4><p>集簇初始化之后，PGDATA 包含三个相同的数据库：</p><p>template0 用于从逻辑备份中恢复数据或创建一个含有不同编码的数据库等情况，绝对不可修改此数据库。</p><p>template1 作为用户在集簇中创建的所有其他数据库的模板。</p><p>postgres 是一个常规的数据库，你可以根据需要使用。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch1/ch1/img.png" alt="img.png"></p><h4 id="1-1-2-系统目录"><a href="#1-1-2-系统目录" class="headerlink" title="1.1.2 系统目录"></a>1.1.2 系统目录</h4><p>所有集簇对象 (例如表、索引、数据类型或函数) 的元数据都存储在属于系统目录 (postgresql.org&#x2F;docs&#x2F;14&#x2F;catalogs.html) 的表中。每个数据库都有其自己的一组用于描述该数据库对象的表 (和视图)。有几个系统目录表是整个集簇共有的，它们不属于任何特定的数据库 (从技术上讲，使用的是一个 ID 为零的虚拟数据库)，但可以从所有数据库中访问这些表。</p><p>系统目录可以使用常规 SQL 查询进行查看，所有对系统目录的修改都是通过 DDL 命令执行的。psql 客户端还提供了一系列命令，用于显式系统目录的内容。</p><p>所有系统目录表的名称都以 pg_ 开头，比如 pg_database。列名通常以对应于表名的三个字母前缀开头，比如 datname。</p><p>在所有的系统目录表中，声明为主键的列称之为 oid (对象标识符)，其类型是一个 32 位整数，也被称为 oid。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">在 PostgreSQL 中，oid 对象标识符的实现几乎与序列相同，但它出现得更早。其特殊之处在于，由公共计数器生成的唯一 ID 被用于不同的系统目录表。当分配的 ID 超过最大值时，计数器将重置。为了确保特定表中的所有值都是唯一的，下一个生成的 oid 会通过唯一索引进行检查；如果在这个表中已经使用过，计数器就会增加，然后再次检查。<br><br>backend/catalog/catalog.c, GetNewOidWithIndex function<br></code></pre></td></tr></table></figure><h4 id="1-1-3-模式"><a href="#1-1-3-模式" class="headerlink" title="1.1.3 模式"></a>1.1.3 模式</h4><p>模式 (postgresql.org&#x2F;docs&#x2F;14&#x2F;ddl-schemas.html) 是存储数据库中所有对象的命名空间。除了用户模式，PostgreSQL 还提供了几个预定义的模式：</p><p>public 是用户对象的默认模式，除非指定了其他设置。</p><p>pg_catalog 用于系统目录表。</p><p>information_schema 为 SQL 标准定义的系统目录提供了一个替代视图。</p><p>pg_toast 用于与 TOAST 相关的对象。</p><p>pg_temp 由临时表所组成。虽然不同的用户在名为 pg_temp_N 的不同模式中创建临时表，但每个用户都使用 pg_temp 别名来访问他们的对象。</p><p>每个模式都限定在特定的数据库中，并且所有数据库对象都属于其中一个模式。</p><p>如果在访问对象时没有明确指定模式，PostgreSQL 会从搜索路径中选择第一个合适的模式。搜索路径基于 search_path 参数的值，该参数隐式扩展了 pg_catalog 和 (如有需要) pg_temp。这意味着不同的模式可以包含具有相同名称的对象。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">information_schema、pg_catalog、pg_toast、public它们的含义和区别是什么？<br><br>information_schema：它是一个视图，包含了数据库中所有schema、tables、columns等对象的元数据信息。不存储任何实际数据，只是提供关于数据库结构的信息。<br><br>pg_catalog：它是系统表的命名空间，存储了PostgreSQL中所有内置的数据类型、函数等系统对象的定义信息。它也不存储实际数据，只是提供系统级别的信息。<br><br>pg_toast：它用于存储大型字段值（比如Text、Varchar、Bytea等），当字段的值太大无法存储在主表中时，则会将其存储到toast表中。这是一种优化策略，避免了表变得过于庞大。<br><br>public：它是用户自定义数据的存储命名空间，是默认的用户模式，所有用户创建的表都默认存储在public模式下。<br><br><br></code></pre></td></tr></table></figure><h4 id="1-1-4-表空间"><a href="#1-1-4-表空间" class="headerlink" title="1.1.4 表空间"></a>1.1.4 表空间</h4><p>不同于决定对象逻辑分布的数据库和模式，表空间定义了物理数据布局。表空间实际上是文件系统中的一个目录。你可以在表空间之间分布数据，使得归档数据存储在低速磁盘上，而频繁更新的数据则存储在快速磁盘上。</p><p>同一个表空间可以被不同数据库使用，并且每个数据库可以在多个表空间中存储数据。这意味着逻辑结构和物理数据布局并不相互依赖。</p><p>每个数据库都有所谓的默认表空间。除非指定了其他位置，否则所有数据库对象都在此表空间中创建。与该数据库相关的系统目录对象也存储在那里。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch1/ch1/img_1.png" alt="img_1.png"></p><p>在集簇初始化期间，会创建两个表空间：</p><p>pg_default 位于 PGDATA&#x2F;base 目录中；除非明确选择了另一个表空间，否则它会被用作默认表空间。</p><p>pg_global 位于 PGDATA&#x2F;global 目录中；它存储着整个集簇公共的系统目录对象。</p><p>在创建自定义表空间时，你可以指定任意目录；PostgreSQL 会在 PGDATA&#x2F;pg_tblspc 目录中创建指向该目录位置的符号链接。实际上，PostgreSQL 使用的所有路径都是相对于 PGDATA 目录的，这允许你将其移动到不同的位置 (当然，前提是你已经停止了服务)。</p><p>前一页的插图将数据库、模式和表空间放在了一起。此处， postgres 数据库使用表空间 xyzzy 作为默认表空间，而 template1 数据库使用 pg_default。表空间和模式的交叉处展示了各种数据库对象。</p><h4 id="1-1-5-关系"><a href="#1-1-5-关系" class="headerlink" title="1.1.5 关系"></a>1.1.5 关系</h4><p>尽管表和索引 (最重要的数据库对象) 之间存在着诸多差异，但它们有一个共同点：都由行组成。当我们联想到表时，这一点是不言而喻的，但对于 B 树节点 (包含索引值和对其他节点或表行的引用) 来说，这同样成立。</p><p>其他一些对象也具有相同的结构；比如序列 (实际上是单行表) 和物化视图 (可以认为是”保持”相关查询的表)。此外，还有一些常规视图，它们不存储任何数据，但在其他方面与表非常相似。</p><p>在 PostgreSQL 中，所有这些对象都被统称为”关系”。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">我并不认为这是一个好的术语，因为它将数据库中的表与关系理论中定义的&quot;真正&quot;关系混淆了。在这里，我们可以感受到此项目的学术遗产和其创始人 Michael Stonebraker 将一切均视为关系的倾向。在他的一项工作中，他甚至引入了&quot;有序关系&quot;的概念，来表示行的顺序由索引定义的表。<br><br>关系的系统目录表最初被称为 pg_relation，但随着面向对象趋势的发展，它很快被重命名为我们现在熟悉的 pg_class。尽管如此，它的列仍然有 REL 前缀。<br></code></pre></td></tr></table></figure><h4 id="1-1-6-文件和分支"><a href="#1-1-6-文件和分支" class="headerlink" title="1.1.6 文件和分支"></a>1.1.6 文件和分支</h4><p>与关系相关的所有信息都存储在几个不同的分支 (postgresql.org&#x2F;docs&#x2F;14&#x2F;storage-file-layout.html) 中，每个分支包含特定类型的数据。</p><p>起初，分支由一个单一文件表示。其文件名由一个数字 ID (oid) 组成，可以通过与分支类型相对应的后缀来扩展。</p><p>随着时间的推移，文件会增长，当其大小达到 1GB 时，就会创建该分支的另一个文件 (这些文件有时被称为段)。段的序列号会被添加到文件名的末尾。</p><p>1GB 的文件大小限制历史上是为了支持各种无法处理大文件的文件系统而设定的。在编译 PostgreSQL 时，你可以更改此限制 (.&#x2F;configure –with-segsize)。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch1/ch1/img_2.png" alt="img_2.png"></p><p>因此，单个关系在磁盘上由多个文件表示。即使是没有索引的小表，也至少会有三个文件，对应于必需的分支数量。</p><p>每个表空间目录 (pg_global 除外) 都包含特定数据库的单独子目录。属于同一表空间和数据库的对象，其所有文件都位于同一子目录中。你必须要考虑到这一点，因为文件系统可能无法很好地处理单个目录中存在太多文件的情况。</p><p>有几种标准类型的分支。</p><p>主分支代表实际的数据：表行或者索引行。此分支适用于任何关系 (除了视图，视图中没有数据)。</p><p>主分支的文件以它们的数字 ID 命名，这些 ID 作为 relfilenode 的值存储在 pg_class 表中。</p><p>让我们看一下在 pg_default 表空间中创建的表的所属文件路径：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> UNLOGGED <span class="hljs-keyword">TABLE</span> t(<br>  a <span class="hljs-type">integer</span>, <br>  b <span class="hljs-type">numeric</span>, <br>  c text, <br>  d json<br>);  <br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">INSERT INTO</span> t <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>, <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> pg_relation_filepath(<span class="hljs-string">&#x27;t&#x27;</span>);  <br> pg_relation_filepath <br>−−−−−−−−−−−−−−−−−−−−−− <br> base<span class="hljs-operator">/</span><span class="hljs-number">16384</span><span class="hljs-operator">/</span><span class="hljs-number">16385</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>base 目录对应于 pg_default 表空间，下一个子目录对应数据库，在这里我们找到了要查找的文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> oid <span class="hljs-keyword">FROM</span> pg_database <span class="hljs-keyword">WHERE</span> datname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;internals&#x27;</span>;<br>  oid<br>−−−−−−−<br> <span class="hljs-number">16384</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> relfilenode <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;t&#x27;</span>;<br> relfilenode<br>−−−−−−−−−−−−−<br>       <span class="hljs-number">16385</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>这是文件系统上对应的文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> size<br><span class="hljs-keyword">FROM</span> pg_stat_file(<span class="hljs-string">&#x27;/usr/local/pgsql/data/base/16384/16385&#x27;</span>);<br> size<br>−−−−−−<br> <span class="hljs-number">8192</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>初始分支 (postgresql.org&#x2F;docs&#x2F;14&#x2F;storage-init.html) 仅适用于无日志表 (使用 UNLOGGED 子句创建) 及其索引。此类对象与常规对象相同，不同之处在于对它们执行的任何操作都不会写入预写式日志。这使得这些操作的速度非常的快，但如果发生故障，将无法恢复一致的数据。因此，在恢复期间，PostgreSQL 会简单地删除此类对象的所有分支，并用初始分支覆盖主分支，从而创建了一个伪文件。</p><p>t 表以 unlogged 的方式创建，因此存在初始分支。它与主分支的名称相同，但带有 _init 的后缀。</p><p>空闲空间映射 8 用于跟踪页内的可用空间。其容量一直在变化，vacuum 后变大，并在新的行版本出现时变小。空闲空间映射用于快速找到可以容纳被插入的新数据的页面。所有与空闲空间映射相关的文件都带有 _fsm 后缀。最初，不会创建此类文件，它们仅在必要时出现。获取它们最简单的方式是对表进行 vacuum：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> VACUUM t;<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> size<br><span class="hljs-keyword">FROM</span> pg_stat_file(<span class="hljs-string">&#x27;/usr/local/pgsql/data/base/16384/16385_fsm&#x27;</span>);<br> size<br>−−−−−−−<br> <span class="hljs-number">24576</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>为了加快搜索速度，空闲空间映射以一棵树的形式组织，它至少有三个数据页 (因此即使是几乎空的表，其文件大小也会有所体现)。</p><p>空闲空间映射既适用于表，也适用于索引。但是，由于索引行不能被添加到任意页面 (例如，B 树根据排序的顺序定义插入位置)，PostgreSQL 只跟踪那些已经完全清空并且可以在索引结构中重用的页面。</p><p>可见性映射 9 可以快速显示页面是否需要被清理或冻结。 为此，它为每个表页面提供了两个比特位。第一个比特，为仅包含最新行版本的页面设置。vacuum 操作会跳过这样的页面，因为没有东西需要清理。此外，当某个事务尝试从这样的页面读取一行数据时，没有必要检查其可见性，因此便可以使用仅索引扫描。</p><p>**当页面包含的行版本都已被冻结后，**便会设置第二个比特。我将使用”冻结映射”术语来指代这部分分支。</p><p>可见性映射文件带有 _vm 后缀。它们通常是最小的文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> size<br><span class="hljs-keyword">FROM</span> pg_stat_file(<span class="hljs-string">&#x27;/usr/local/pgsql/data/base/16384/16385_vm&#x27;</span>);<br> size<br>−−−−−−<br> <span class="hljs-number">8192</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>可见性映射文件适用于表，索引没有此文件。</p><h4 id="1-1-7-页面"><a href="#1-1-7-页面" class="headerlink" title="1.1.7 页面"></a>1.1.7 页面</h4><p>为了提升 I&#x2F;O 效率，所有文件在逻辑上都被分割成页 (或者块)，表示可以读取或写入的最小数据量。因此，许多内部的 PostgreSQL 算法都针对页面处理进行了优化。</p><p>页面大小通常是 8 kB。在某种程度上可以配置页面大小 (最大 32 kB)，但只能在编译时进行配置 (.&#x2F;configure –with-blocksize)，但通常没有人这样做。一旦编译并启动，实例只能处理大小相同的页面，因此无法创建支持不同页面大小的表空间。</p><p>无论属于哪个分支，所有文件都被服务器以大致相同的方式进行处理。页面首先被移动到缓冲区缓存中 (在那里，页面可以被进程读取和更新)，然后根据需要刷回磁盘。</p><h4 id="1-1-8-TOAST"><a href="#1-1-8-TOAST" class="headerlink" title="1.1.8 TOAST"></a>1.1.8 TOAST</h4><p>每一行都必须适合单个页面：无法在下一个页面继续存储一行数据。为了存储较长的行，PostgreSQL 使用了一种称为 TOAST (postgresql.org&#x2F;docs&#x2F;14&#x2F;storage-toast.html、include&#x2F;access&#x2F;heaptoast.h ) (超长属性存储技术) 的特殊机制。</p><p>TOAST 涉及多种策略。你可以将长属性值移动到一个单独的表中，并将它们切成较小的”toasts”块。另一种选项是将长值进行压缩，以适合页面。或者你可以二者都做：先将值压缩，然后切分并移动。</p><p>如果主表包含可能很长的属性，那么会立即为其创建一张单独的 TOAST 表，用于其所有的属性。例如，如果某个表有一个 numeric 或 text 的列，即使该列永远不会存储任何长值，也会创建一个 TOAST 表。</p><p>对于索引，TOAST 机制只能提供压缩功能，不支持将长属性移动到一张单独的表中。这限制了可以索引的键的大小 (具体实现取决于特定的操作符类)。</p><p>默认情况下，根据列的数据类型选择 TOAST 的策略。查看所用策略的最简单方法是在 psql 中运行 \d+ 命令，但我将查询系统目录以获得更清晰的输出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> attname, atttypid::regtype,<br>  <span class="hljs-keyword">CASE</span> attstorage<br>    <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;p&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;plain&#x27;</span><br>    <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;e&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;external&#x27;</span><br>    <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;m&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;main&#x27;</span><br>    <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;extended&#x27;</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> storage<br><span class="hljs-keyword">FROM</span> pg_attribute<br><span class="hljs-keyword">WHERE</span> attrelid <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;t&#x27;</span>::regclass <span class="hljs-keyword">AND</span> attnum <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>;<br> attname <span class="hljs-operator">|</span> atttypid <span class="hljs-operator">|</span> storage<br>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<br> a       <span class="hljs-operator">|</span> <span class="hljs-type">integer</span>  <span class="hljs-operator">|</span> plain<br> b       <span class="hljs-operator">|</span> <span class="hljs-type">numeric</span>  <span class="hljs-operator">|</span> main<br> c       <span class="hljs-operator">|</span> text     <span class="hljs-operator">|</span> extended<br> d       <span class="hljs-operator">|</span> json     <span class="hljs-operator">|</span> extended<br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>PostgreSQL支持如下策略：</p><p>plain 意味着不使用 TOAST (此策略适用于已知是”短”的数据类型，例如整数类型)。</p><p>extended 允许压缩属性并将它们存储在单独的 TOAST 表中。</p><p>external 意味着长属性以未压缩的状态存储在 TOAST 表中。</p><p>main 需要先压缩长属性，只有在压缩没有帮助的情况下时，它们才会被移动到 TOAST 表中。</p><p>一般而言，算法如下 (backend&#x2F;access&#x2F;heap&#x2F;heaptoast.c)。PostgreSQL 的目标是在每个页面中至少包含四行数据。因此，如果行的大小超过了页面的四分之一，不包括行头大小 (对于标准大小的页面大约为 2000 字节)，那么我们必须对一些值应用 TOAST 机制。按照下面所描述的工作流程，一旦行的长度不再超过阈值，我们便停止：</p><p>首先，我们从最长的属性开始，遍历具有 external 和 extended 策略的属性。extended 属性会被压缩，如果压缩后的值 (单独考虑，不考虑其他列) 超过了页面的四分之一，那么它将被立即移动到 TOAST 表中。external 属性的处理方式相同，只是跳过了压缩阶段。</p><p>如果在第一个阶段之后这一行仍然不适合页面，我们将剩余使用 external 或 extended 策略的属性逐个移动到 TOAST 表中。</p><p>如果这也没有帮助，我们会尝试压缩使用 main 策略的属性，将它们保留在表页面中。</p><p>如果这一行仍然不够短，那么 main 属性将被移动到 TOAST 表中。</p><p>阈值是 2000 字节，但可以通过使用 toast_tuple_target 存储参数<strong>在表级别重新定义。</strong></p><p>有时更改某些列的默认策略可能是有用的。如果事先知道特定列中的数据不能被压缩 (例如，此列存储 JPEG 图像)，那么你可以设置该列为 external 策略；这可以避免去徒劳地尝试压缩数据。策略可以按如下所示进行更改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER TABLE</span> t <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> d <span class="hljs-keyword">SET</span> STORAGE <span class="hljs-keyword">external</span>;<br></code></pre></td></tr></table></figure><p>如果我们重复查询，我们将得到以下结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"> attname <span class="hljs-operator">|</span> atttypid <span class="hljs-operator">|</span> storage<br>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−<br> a       <span class="hljs-operator">|</span> <span class="hljs-type">integer</span>  <span class="hljs-operator">|</span> plain<br> b       <span class="hljs-operator">|</span> <span class="hljs-type">numeric</span>  <span class="hljs-operator">|</span> main<br> c       <span class="hljs-operator">|</span> text     <span class="hljs-operator">|</span> extended<br> d       <span class="hljs-operator">|</span> json     <span class="hljs-operator">|</span> <span class="hljs-keyword">external</span><br>(<span class="hljs-number">4</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>TOAST 表位于一个名为 pg_toast 的单独模式中；它不包含在搜索路径中，因此 TOAST 表通常是隐藏的。对于临时表，类似于 pg_temp_N，使用的是 pg_toast_temp_N 模式。</p><p>让我们来看看这个过程的内部机制。假设表 t 包含三个可能很长的属性；这意味着必须有一个相应的 TOAST 表。如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> relnamespace::regnamespace, relname<br><span class="hljs-keyword">FROM</span> pg_class<br><span class="hljs-keyword">WHERE</span> oid <span class="hljs-operator">=</span> (<br>  <span class="hljs-keyword">SELECT</span> reltoastrelid<br>  <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;t&#x27;</span><br>);<br> relnamespace <span class="hljs-operator">|</span> relname<br>−−−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−<br> pg_toast     <span class="hljs-operator">|</span> pg_toast_16385<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> \d<span class="hljs-operator">+</span> pg_toast.pg_toast_16385<br>TOAST <span class="hljs-keyword">table</span> &quot;pg_toast.pg_toast_16385&quot;<br>   <span class="hljs-keyword">Column</span>   <span class="hljs-operator">|</span>  Type   <span class="hljs-operator">|</span> Storage<br>−−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<br> chunk_id <span class="hljs-operator">|</span> oid     <span class="hljs-operator">|</span> plain<br> chunk_seq <span class="hljs-operator">|</span> <span class="hljs-type">integer</span> <span class="hljs-operator">|</span> plain<br> chunk_data <span class="hljs-operator">|</span> bytea   <span class="hljs-operator">|</span> plain<br>Owning <span class="hljs-keyword">table</span>: &quot;public.t&quot;<br>Indexes:<br>    &quot;pg_toast_16385_index&quot; <span class="hljs-keyword">PRIMARY KEY</span>, btree (chunk_id, chunk_seq)<br>Access <span class="hljs-keyword">method</span>: heap<br></code></pre></td></tr></table></figure><p>合乎逻辑的是，TOAST 行的结果块使用的是 plain 策略：没有第二级 TOAST。</p><p>除了 TOAST 表本身，PostgreSQL 在同一模式中还会创建相应的索引。此索引始终用于访问 TOAST 块。索引的名称显示在输出中，但是也可以通过执行以下查询查看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> indexrelid::regclass <span class="hljs-keyword">FROM</span> pg_index<br><span class="hljs-keyword">WHERE</span> indrelid <span class="hljs-operator">=</span> (<br>  <span class="hljs-keyword">SELECT</span> oid<br>  <span class="hljs-keyword">FROM</span> pg_class <span class="hljs-keyword">WHERE</span> relname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;pg_toast_16385&#x27;</span><br>);<br>          indexrelid<br>−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−<br> pg_toast.pg_toast_16385_index<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-number">27</span><br><br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> \d pg_toast.pg_toast_16385_index<br>Unlogged index &quot;pg_toast.pg_toast_16385_index&quot;<br>    <span class="hljs-keyword">Column</span> <span class="hljs-operator">|</span>  Type  <span class="hljs-operator">|</span> Key? <span class="hljs-operator">|</span> Definition<br>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br> chunk_id  <span class="hljs-operator">|</span> oid     <span class="hljs-operator">|</span> yes <span class="hljs-operator">|</span> chunk_id<br> chunk_seq <span class="hljs-operator">|</span> <span class="hljs-type">integer</span> <span class="hljs-operator">|</span> yes <span class="hljs-operator">|</span> chunk_seq<br><span class="hljs-keyword">primary key</span>, btree, <span class="hljs-keyword">for</span> <span class="hljs-keyword">table</span> &quot;pg_toast.pg_toast_16385&quot;<br></code></pre></td></tr></table></figure><p>因此，TOAST 表将表使用的分支文件的最小数量增加至八个：主表三个，TOAST 表三个，TOAST 索引两个。</p><p>c 列使用 extended 策略，因此它的值会被压缩：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> t <span class="hljs-keyword">SET</span> c <span class="hljs-operator">=</span> repeat(<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-number">5000</span>);<br><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> pg_toast.pg_toast_16385;<br> chunk_id <span class="hljs-operator">|</span> chunk_seq <span class="hljs-operator">|</span> chunk_data<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−<br>(<span class="hljs-number">0</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>TOAST 表是空的：重复的符号已经通过 LZ 算法压缩，因此这个值适合表页面。</p><p>现在让我们构造由随机符号组成的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UPDATE</span> t <span class="hljs-keyword">SET</span> c <span class="hljs-operator">=</span> (<br>  <span class="hljs-keyword">SELECT</span> string_agg( chr(trunc(<span class="hljs-number">65</span><span class="hljs-operator">+</span>random()<span class="hljs-operator">*</span><span class="hljs-number">26</span>)::<span class="hljs-type">integer</span>), <span class="hljs-string">&#x27;&#x27;</span>)<br>  <span class="hljs-keyword">FROM</span> generate_series(<span class="hljs-number">1</span>,<span class="hljs-number">5000</span>)<br>)<br>RETURNING <span class="hljs-keyword">left</span>(c,<span class="hljs-number">10</span>) <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;...&#x27;</span> <span class="hljs-operator">||</span> <span class="hljs-keyword">right</span>(c,<span class="hljs-number">10</span>);<br>        ?<span class="hljs-keyword">column</span>?<br>−−−−−−−−−−−−−−−−−−−−−−−−−<br> YEYNNDTSZR...JPKYUGMLDX<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>此序列值无法被压缩，所以它被存储到了 TOAST 表中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> chunk_id,<br>  chunk_seq,<br>  length(chunk_data),<br>  <span class="hljs-keyword">left</span>(encode(chunk_data,<span class="hljs-string">&#x27;escape&#x27;</span>)::text, <span class="hljs-number">10</span>) <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;...&#x27;</span> <span class="hljs-operator">||</span><br>  <span class="hljs-keyword">right</span>(encode(chunk_data,<span class="hljs-string">&#x27;escape&#x27;</span>)::text, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">FROM</span> pg_toast.pg_toast_16385;<br> chunk_id <span class="hljs-operator">|</span> chunk_seq <span class="hljs-operator">|</span> length <span class="hljs-operator">|</span>        ?<span class="hljs-keyword">column</span>?<br>−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−<span class="hljs-operator">+</span>−−−−−−−−−−−−−−−−−−−−−−−−−<br>    <span class="hljs-number">16390</span> <span class="hljs-operator">|</span>         <span class="hljs-number">0</span> <span class="hljs-operator">|</span>   <span class="hljs-number">1996</span> <span class="hljs-operator">|</span> YEYNNDTSZR...TXLNDZOXMY<br>    <span class="hljs-number">16390</span> <span class="hljs-operator">|</span>         <span class="hljs-number">1</span> <span class="hljs-operator">|</span>   <span class="hljs-number">1996</span> <span class="hljs-operator">|</span> EWEACUJGZD...GDBWMUWTJY<br>    <span class="hljs-number">16390</span> <span class="hljs-operator">|</span>         <span class="hljs-number">2</span> <span class="hljs-operator">|</span>   <span class="hljs-number">1008</span> <span class="hljs-operator">|</span> GSGDYSWTKF...JPKYUGMLDX<br>(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)<br></code></pre></td></tr></table></figure><p>我们可以看到字符被切成块。块大小的选择方式是：使得 TOAST 表的页面可以容纳四行。这个值在不同的版本中有所差异，取决于页头的大小。</p><p>当访问一个长属性时，PostgreSQL 会自动恢复原始值并返回给客户端，这一切对于应用来说无缝进行。如果长属性不参与查询，那么根本不会读取 TOAST 表。这就是为什么在生产解决方案中应避免使用 * 的原因之一。</p><p>如果客户端查询长值的前几个块，即使值已被压缩，PostgreSQL 也只会读取所需的块。</p><p>然而，数据压缩和切片需要大量资源；恢复原始值也是如此。这就是为什么将大量数据存储在 PostgreSQL 中并不是一个好主意，特别是如果这些数据正在被频繁使用，并且不需要事务逻辑 (如扫描的账户文件)。一个可能的更好选择是将这些数据存储在文件系统中，数据库中只保留相应文件的名称。但这样数据库系统就不能保证数据的一致性了。</p><h3 id="1-2-Processes-and-Memory"><a href="#1-2-Processes-and-Memory" class="headerlink" title="1.2 Processes and Memory"></a><a name="process-mem"></a>1.2 Processes and Memory</h3><p>一个 PostgreSQL 服务实例由多个相辅相成的进程组成。</p><p>服务启动时，启动的第一个进程是 postgres，传统上称之为 postmaster。它负责创建所有其他进程 (类 Unix 系统使用 fork 系统调用实现) 并管理它们：如果有任何进程失败，postmaster 会重新启动它 (或者如果存在共享数据已损坏的风险，则重启整个服务)。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">由于其简单性，进程模型自 PostgreSQL 最初开始就一直在使用，并且自那以后，关于切换到线程的讨论就从未停止过。<br><br>当前模型有几个缺点：静态共享内存分配不允许动态调整缓冲区缓存之类的结构；并行算法难以实现，并且效率也不如预期的高；会话与进程紧密绑定。使用线程听起来前景很不错，尽管它涉及到一些与隔离性、操作系统兼容性和资源管理相关的挑战。然而，它们的实现将需要对代码进行彻底的重构和多年的工作，因此目前保守的观点占主导地位：在不久的将来，并不预期会有此类变化。<br></code></pre></td></tr></table></figure><p>服务操作由后台进程维护。以下是主要的后台进程：</p><p>startup：在故障之后恢复系统。</p><p>autovacuum：从表和索引中移除过期数据。</p><p>wal writer：将 WAL 写入到磁盘中。</p><p>checkpointer：执行检查点。</p><p>writer：将脏页刷到磁盘。</p><p>stats collector：收集实例的使用统计信息。</p><p>wal sender：将 WAL 条目发送给副本。</p><p>wal receiver：在副本上接收 WAL 条目。</p><p>其中一些进程在任务完成后就会终止，其他一些进程则一直在后台运行，还有一些可以关闭。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">每个进程都由配置参数管理，有时需要几十个参数管理。为了全面地配置服务器，你需要了解内部工作原理。但是通用考虑只会帮助你选择或多或少合适的初始值；之后，这些设置需要根据监控数据进行微调。<br></code></pre></td></tr></table></figure><p>为了实现进程间的交互，postmaster 会分配共享内存，所有进程都可以访问该内存。</p><p>由于磁盘 (尤其是 HDD，但 SSD 也是如此) 的速度比 RAM 慢得多，因此 PostgreSQL 使用了缓存：保留一部分共享内存用于最近读取的页面，寄希望于这些页面会被多次使用，从而减少重复访问磁盘的开销。被修改的数据会在一定的延迟后再刷盘，而不是立即刷新。</p><p>缓冲区缓存占据了大部分的共享内存，共享内存中还包含其他由服务器用来加速磁盘访问的缓冲区。</p><p>操作系统也有其自己的缓存。PostgreSQL (几乎) 从不绕过操作系统机制而使用 direct I&#x2F;O，因此这会导致双缓存。</p><p><img src="/2025/05/05/DB/PostgreSQL14_Internals/ch1/ch1/img_3.png" alt="img_3.png"></p><p>如果发生故障 (例如断电或操作系统崩溃) ，存储在 RAM 中的数据会丢失，包括缓冲区缓存中的数据。保留在磁盘上的文件包括在不同时间点写入的页面。为了能够恢复数据的一致性，PostgreSQL 在其运行期间维护了预写式日志 (WAL)，这使得在必要时，可以重复执行丢失的操作。</p><h3 id="1-3-Clients-and-the-Client-Server-Protocol"><a href="#1-3-Clients-and-the-Client-Server-Protocol" class="headerlink" title="1.3 Clients and the Client-Server Protocol"></a><a name="client"></a>1.3 Clients and the Client-Server Protocol</h3><p>postmaster 进程的另一项任务是监听传入的连接。一旦出现新的客户端，postmaster 便会生成一个单独的后端进程 (backend&#x2F;tcop&#x2F;postgres.c, PostgresMain function)，并与该后端进程建立连接，开始会话。会话持续至客户端断开连接或连接丢失。</p><p>服务器必须为每个客户端生成一个单独的后端进程。如果许多客户端都在尝试连接，这可能会成为一个问题。</p><p>每个进程都需要 RAM 来缓存系统目录表、预备语句、中间查询结果和其他数据。打开的连接越多，需要的内存就越多。<br>如果连接是短而频繁的 (客户端执行一个小查询并断开连接)，那么建立连接、生成新进程和执行无意义的本地缓存的成本过高。<br>启动的进程越多，扫描它们的列表所需的时间就越多，而且这种操作非常频繁。因此，性能可能会随着客户端数量的增加而下降。<br>这个问题可以通过连接池来解决，它限制了生成的后端进程的数量。PostgreSQL 本身没有内置的连接池功能，因此我们必须依赖第三方解决方案：集成到应用服务器的连接池管理器或外部工具 (如 PgBouncer 13 或 Odyssey 14) 。这种方式通常意味着每个服务器后端进程可以依次执行不同客户端的事务。这对应用程序开发施加了一些限制，因为它只允许使用事务本地的资源，而不是整个会话的资源。</p><p>为了进行交互，客户端和服务器必须使用相同的接口协议 15。这通常基于标准的 libpq 库，但也有其他自定义的实现。</p><p>通俗地说，这种协议允许客户端连接到服务器并执行 SQL 查询。</p><p>连接总是代表一个特定的角色或用户建立到一个特定的数据库。尽管服务器支持数据库集簇，但你需要在应用中对每个数据库分别建立连接。此时会进行身份验证：后端进程验证用户的身份 (例如，通过请求密码) 并检查该用户是否有权限连接到服务器和指定的数据库。</p><p>SQL 查询作为文本字符串传递给后端进程，然后该进程解析文本、优化查询与执行，并将结果返回给客户端。</p>]]></content>
    
    
    <categories>
      
      <category>BOOK</category>
      
      <category>PostgreSQL14_Internals</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
      <tag>database</tag>
      
      <tag>transactions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>An Empirical Evaluation of In-Memory Multi-Version Concurrency Control</title>
    <link href="/2025/05/05/DB/lunwen/paper1/paper1/"/>
    <url>/2025/05/05/DB/lunwen/paper1/paper1/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>An Empirical Evaluation of In-Memory Multi-Version Concurrency Control</p><p>内存中多版本并发控制的实证评估</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><table><thead><tr><th>Paper Contents</th></tr></thead><tbody><tr><td><a href="#ABSTRACT">ABSTRACT</a></td></tr><tr><td><a href="#INTRODUCTION">1. INTRODUCTION</a></td></tr><tr><td><a href="#BACKGROUND">2. BACKGROUND</a></td></tr><tr><td><a href="#MVCC-Overview">2.1 MVCC Overview</a></td></tr><tr><td><a href="#DBMS-Meta-Data">2.2 DBMS Meta-Data</a></td></tr><tr><td><a href="#CC-PROTOCOL">3. CONCURRENCY CONTROL PROTOCOL</a></td></tr></tbody></table><h3 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a><a name="ABSTRACT"></a>ABSTRACT</h3><p>多版本并发控制（MVCC）目前是在现代数据库管理系统（DBMS）中最流行的事务管理方案。<br>尽管MVCC是在20世纪70年代末期被发现的，但它几乎被过去十年中发布的每一个主要关系型DBMS所采用。<br>维护数据的多个版本在处理事务时不牺牲可串行性的前提下潜在地增加了并行性。但在多核和内存中的环境中<br>扩展MVCC并非易事：当有大量线程并行运行时，同步开销可能会超过多版本带来的好处。<br>为了理解MVCC在现代硬件环境下处理事务时的表现，我们对这一方案的四个关键设计决策进行了广泛的研究：<br>并发控制协议、版本存储、垃圾回收和索引管理。我们在一个内存中的DBMS中实现了这些方面的最新变体，<br>并使用OLTP工作负载对其进行了评估。我们的分析确定了每个设计选择的根本瓶颈。</p><h3 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1. INTRODUCTION"></a><a name="INTRODUCTION"></a>1. INTRODUCTION</h3><p>计算机架构的进步推动了多核、内存中的DBMS的发展，这些系统采用了高效的事务管理机制以最大化并行性而不牺牲可串行性。<br>过去十年开发的DBMS中最流行的方案是多版本并发控制（MVCC）。MVCC的基本思想是DBMS为数据库中的每个逻辑对象维护多<br>个物理版本，以便对同一对象的操作可以并行进行。这些对象可以在任何粒度级别上，但几乎所有MVCC DBMS都使用元组，<br>因为这在并行性和版本跟踪开销之间提供了良好的平衡。多版本化允许只读事务访问元组的旧版本，而不会阻止读写事务<br>同时生成新版本。相比之下，在单版本系统中，每当更新元组时总是会用新信息覆盖它。</p><p>最近的DBMS使用MVCC的趋势有趣之处在于该方案并不新颖。首次提及出现在1979年的博士论文[38]中，<br>而首个实现始于1981年，用于InterBase DBMS（现在开源为Firebird）。MVCC也被当今一些最广泛部署的磁盘导向型<br>DBMS所采用，包括Oracle（自1984年起[4]）、Postgres（自1985年起[41]）以及MySQL的InnoDB引擎（自2001年起）。<br>但是与这些较老的系统使用单版本方案的当代系统（例如IBM DB2、Sybase）相比，几乎所有的新事务型DBMS都放弃了<br>这种做法，转而支持MVCC[37]。这包括商业系统<br>（例如Microsoft Hekaton[16]、SAP HANA[40]、MemSQL[1]、NuoDB[3]）和<br>学术系统（例如HYRISE[21]、HyPer[36]）。</p><p>尽管所有这些新系统都在使用MVCC，但却没有一种“标准”的实现。存在几种设计选择，它们具有不同的权衡和性能表现。<br>到目前为止，尚未对现代DBMS运行环境下的MVCC进行全面评估。最后一次广泛的评估是在20世纪80年代[13]，<br>但它使用的是在单CPU核心的磁盘导向型DBMS上运行的模拟工作负载。传统磁盘导向型DBMS的设计选择对于在拥有<br>大量CPU核心的机器上运行的内存中的DBMS来说并不适用。因此，先前的工作并未反映最近在无锁[27]并发控制、<br>可串行化[20]并发控制以及内存存储[36]和混合工作负载[40]方面的趋势。</p><p>在本文中，我们对MVCC DBMS中关键的事务管理设计决策进行了这样的研究：<br>(1)并发控制协议；(2)版本存储；(3)垃圾回收；(4)索引管理。对于这些主题中的每一个，<br>我们都描述了内存中DBMS的最新实现，并讨论了它们之间的权衡。我们也指出了它们在支持更大的<br>线程数量和更复杂的工作负载方面存在的问题。作为这项研究的一部分，我们在Peloton[5]内存中的MVCC DBMS中实现了<br>所有方法。这为我们提供了一个统一的平台来比较各种实现，不受其他架构方面的影响。我们在一台拥有40个核心的<br>机器上部署了Peloton，并使用两个OLTP基准测试对其进行评估。我们的分析确定了给各个实现带来压力的情景，<br>并探讨了缓解这些问题的方法（如果可能的话）。</p><h3 id="2-BACKGROUND"><a href="#2-BACKGROUND" class="headerlink" title="2. BACKGROUND"></a><a name="BACKGROUND"></a>2. BACKGROUND</h3><p>我们首先概述多版本并发控制（MVCC）的高级概念。</p><p>然后，我们讨论数据库管理系统（DBMS）用来追踪事务和维护版本信息的元数据。</p><h3 id="2-1-MVCC-Overview"><a href="#2-1-MVCC-Overview" class="headerlink" title="2.1 MVCC Overview"></a><a name="MVCC-Overview"></a>2.1 MVCC Overview</h3><p><img src="/2025/05/05/DB/lunwen/paper1/paper1/img.png" alt="img.png"><br>表 1：MVCC 实现 —— 商业和研究型 MVCC DBMS 所做出的设计决策概览。对于每个系统（除 Oracle 外）<br>的年份属性是指其首次发布或宣布的时间。对于 Oracle，则是指系统首次包含 MVCC 的年份。<br>除了 Oracle、MySQL 和 Postgres 之外，所有系统均假设数据库的主要存储位置是在内存中。</p><p>一种事务管理方案允许终端用户以多程序方式访问数据库，同时保持每个用户都在专用系统上单独执行的假象[9]。<br>它确保了数据库管理系统（DBMS）的原子性和隔离性保证。</p><p>多版本系统的优点对于现代数据库应用至关重要。最重要的是，它可能比单版本系统允许更高的并发性。<br>例如，一个多版本并发控制（MVCC）DBMS允许一个事务读取对象的旧版本，同时另一个事务正在更新同一个对象。<br>这对于在同一时间执行只读查询，而读写事务继续更新数据库尤为重要。<br>如果DBMS从不删除旧版本，则系统还可以支持“time-travel”操作，使应用程序能够查询数据库在过去某个时间点的一致快照[8]。</p><p>上述优势使得MVCC成为近年来实施的新DBMS中最受欢迎的选择。表1总结了过去三十年中的MVCC实现。<br>但是在DBMS中实现多版本的方式各不相同，每种方式都会产生额外的计算和存储开销。这些设计决策也高度相互依赖。<br>因此，要分辨哪些更好及其原因并非易事。对于内存中的DBMS尤其如此，因为磁盘不再是主要瓶颈。</p><p>在接下来的部分中，我们将讨论这些设计决策的实现问题和性能权衡。然后在第7节中，我们对它们进行全面评估。<br>我们在此文中仅考虑可串行化的事务执行。<br>虽然日志记录和恢复是DBMS架构的另一个重要方面，但我们不在本研究中涉及，因为这方面与单版本系统没有什么不同，<br>而且内存中的DBMS日志记录已经在其他地方有所涵盖[33, 49]。</p><h3 id="2-2-DBMS-Meta-Data"><a href="#2-2-DBMS-Meta-Data" class="headerlink" title="2.2 DBMS Meta-Data"></a><a name="DBMS-Meta-Data"></a>2.2 DBMS Meta-Data</h3><p><img src="/2025/05/05/DB/lunwen/paper1/paper1/img_1.png" alt="img_1.png"></p><p>无论其实现如何，一个多版本并发控制（MVCC）数据库管理系统都会为事务和数据库元组维护通用的元数据。</p><p>事务：当事务 T 首次进入系统时，DBMS 会为其分配一个唯一且单调递增的时间戳作为其标识符（Tid）。<br>并发控制协议利用此标识符来标记事务访问的元组版本。某些协议还使用它来确定事务的序列化顺序。</p><p>元组：如图 1 所示，每个物理版本在其头部包含四个由 DBMS 使用来协调并发事务执行的元数据字段<br>（下一节中讨论的一些并发控制协议还包括其他字段）。txn-id 字段充当版本的写锁。当元组未处于写锁定状态时，<br>每个元组的该字段设置为零。大多数 DBMS 使用 64 位的 txn-id，以便它可以使用单一的比较并交换（CaS）指令来<br>原子地更新值。如果具有标识符 Tid 的事务 T 想要更新元组 A，则 DBMS 会检查 A 的 txn-id 字段是否为零。<br>如果是，则 DBMS 将使用 CaS 指令将 txn-id 的值设置为 Tid [27, 44]。任何尝试更新 A 的事务，<br>如果此 txn-id 字段既不为零也不等于其 Tid，则会被中止。接下来的两个元数据字段<br>是 begin-ts 和 end-ts 时间戳，它们表示元组版本的有效期。这两个字段最初都设置为零。<br>当事务删除元组时，DBMS 将元组的 begin-ts 设置为 INF。最后一个元数据字段是指针，<br>用于存储相邻（前一个或后一个）版本（如果有）的地址。</p><h3 id="3-CONCURRENCY-CONTROL-PROTOCOL"><a href="#3-CONCURRENCY-CONTROL-PROTOCOL" class="headerlink" title="3. CONCURRENCY CONTROL PROTOCOL"></a><a name="CC-PROTOCOL"></a>3. CONCURRENCY CONTROL PROTOCOL</h3><h3 id="3-1-Timestamp-Ordering-MVTO"><a href="#3-1-Timestamp-Ordering-MVTO" class="headerlink" title="3.1  Timestamp Ordering (MVTO)"></a><a name="MVTO"></a>3.1  Timestamp Ordering (MVTO)</h3><h3 id="3-2-Optimistic-Concurrency-Control-MVOCC"><a href="#3-2-Optimistic-Concurrency-Control-MVOCC" class="headerlink" title="3.2 Optimistic Concurrency Control (MVOCC)"></a><a name="MVOCC"></a>3.2 Optimistic Concurrency Control (MVOCC)</h3><h3 id="3-3-CONCURRENCY-CONTROL-PROTOCOL"><a href="#3-3-CONCURRENCY-CONTROL-PROTOCOL" class="headerlink" title="3.3 CONCURRENCY CONTROL PROTOCOL"></a><a name="CC-PROTOCOL"></a>3.3 CONCURRENCY CONTROL PROTOCOL</h3><h3 id="3-4-CONCURRENCY-CONTROL-PROTOCOL"><a href="#3-4-CONCURRENCY-CONTROL-PROTOCOL" class="headerlink" title="3.4 CONCURRENCY CONTROL PROTOCOL"></a><a name="CC-PROTOCOL"></a>3.4 CONCURRENCY CONTROL PROTOCOL</h3><h3 id="3-5-CONCURRENCY-CONTROL-PROTOCOL"><a href="#3-5-CONCURRENCY-CONTROL-PROTOCOL" class="headerlink" title="3.5 CONCURRENCY CONTROL PROTOCOL"></a><a name="CC-PROTOCOL"></a>3.5 CONCURRENCY CONTROL PROTOCOL</h3>]]></content>
    
    
    <categories>
      
      <category>Article</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Article</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux中，如何排查内存泄漏？</title>
    <link href="/2025/05/05/note/linux/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5/"/>
    <url>/2025/05/05/note/linux/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>linux中，如何排查内存泄漏？</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1、长期稳定性测试"><a href="#1、长期稳定性测试" class="headerlink" title="1、长期稳定性测试"></a>1、长期稳定性测试</h5><p>保证软件至少运行7*24小时，测试过程中有持续的数据变化。</p><h5 id="2、大数据量测试"><a href="#2、大数据量测试" class="headerlink" title="2、大数据量测试"></a>2、大数据量测试</h5><p>这里的大数据量不仅指总数据量大，也包括单个数据的数据量大，比如单块磁盘大小超过2TB、单个虚拟机数据量超过4TB。</p><p>但大数据量只是发现内存泄漏问题的充分不必要条件。</p><h5 id="3、结合free、top等命令进行资源监控"><a href="#3、结合free、top等命令进行资源监控" class="headerlink" title="3、结合free、top等命令进行资源监控"></a>3、结合free、top等命令进行资源监控</h5><p><img src="/2025/05/05/note/linux/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5/img.png" alt="img.png"></p><h5 id="4、持续观察上层应用运行情况"><a href="#4、持续观察上层应用运行情况" class="headerlink" title="4、持续观察上层应用运行情况"></a>4、持续观察上层应用运行情况</h5><p>在长期和大数据量环境下，内存泄漏可能会导致上层应用卡死、应用进程被kill等现象。此时可以通过日志查看是否与内存有关。<br>查看日志文件：可以在&#x2F;var&#x2F;log&#x2F;messages文件中查看操作系统的日志信息，若出现“Out of memory”的报错，则可能存在内存泄漏的问题。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>内存泄漏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux中，使用targetcli搭建iscsi</title>
    <link href="/2025/05/05/note/linux/targetcli%E6%90%AD%E5%BB%BAiscsi/targetcli%E6%90%AD%E5%BB%BAiscsi/"/>
    <url>/2025/05/05/note/linux/targetcli%E6%90%AD%E5%BB%BAiscsi/targetcli%E6%90%AD%E5%BB%BAiscsi/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>linux中，使用targetcli搭建iscsi</p><p>假设使用磁盘分区或者逻辑卷，&#x2F;dev&#x2F;sdb1 &#x2F;dev&#x2F;sdb2，并且一台机器为服务器，两台机器为客户端</p><p>服务器：192.168.0.3<br>客户端：192.168.0.4 192.168.0.5</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1、下载安装软件"><a href="#1、下载安装软件" class="headerlink" title="1、下载安装软件"></a>1、下载安装软件</h5><p>Centos下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install targetcli<br><br>其他自行下载<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">https://pkgs.org/<br><br>自行下载<br></code></pre></td></tr></table></figure><p>下载安装后需要在服务端保证服务启动，执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start target<br>或<br>systemctl start tgt.service<br></code></pre></td></tr></table></figure><p>服务端保证iSCSI正常启动，执行如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl status iscsi<br><br>systemctl start iscsi<br></code></pre></td></tr></table></figure><p><strong>防火墙或者开放端口，主要是3260端口，自行设置。</strong></p><h5 id="2、服务端配置"><a href="#2、服务端配置" class="headerlink" title="2、服务端配置"></a>2、服务端配置</h5><p>执行如下进入targetcli界面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">targetcli<br></code></pre></td></tr></table></figure><p>首先创建要使用的逻辑卷，如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">/backstores/block/ create xendata1 /dev/sdb1<br>/backstores/block/ create xendata2 /dev/sdb2<br></code></pre></td></tr></table></figure><p>如图：<br><img src="/2025/05/05/note/linux/targetcli%E6%90%AD%E5%BB%BAiscsi/targetcli%E6%90%AD%E5%BB%BAiscsi/image.png" alt="alt text"></p><p>然后配置ISCSITarget命名，即创建 IQN (Iscsi Qualified Name) ，执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">iscsi/ create iqn.2024-05.com.smile:smile1<br></code></pre></td></tr></table></figure><p>创建完成后开始下面的配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd iscsi/iqn.2024-05.com.smile:smile1/tpg1/<br></code></pre></td></tr></table></figure><p>创建lun(target块设备的逻辑单元)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">luns/ create /backstores/block/xendata1<br>luns/ create /backstores/block/xendata2<br></code></pre></td></tr></table></figure><p>后续我们的客户端都会共享到这两个逻辑卷，如果更多配置请自行设置。</p><p>此处如果没有portals&#x2F;，需要自行创建，并且后续使用此端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">portals/ create 0.0.0.0 3261<br></code></pre></td></tr></table></figure><p>创建ACL允许ISCSI客户机连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">acls/ create iqn.2018-06.com.xenserver:client<br><br>此处的 “iqn.2018-06.com.xenserver:client” 应该去客户端上看，位于 /etc/iscsi/initiatorname.iscsi 下，应该和此文件中的名称一致<br></code></pre></td></tr></table></figure><p>创建用户和密码，执行如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd acls/<br>cd iqn.2018-06.com.xenserver:client/<br>set auth userid=ye<br>set auth password=123456<br>info<br></code></pre></td></tr></table></figure><p>如果需要多台机器共享，重复创建acls即可<br><img src="/2025/05/05/note/linux/targetcli%E6%90%AD%E5%BB%BAiscsi/targetcli%E6%90%AD%E5%BB%BAiscsi/image-1.png" alt="alt text"><br><img src="/2025/05/05/note/linux/targetcli%E6%90%AD%E5%BB%BAiscsi/targetcli%E6%90%AD%E5%BB%BAiscsi/image-2.png" alt="alt text"></p><h5 id="3、客户端配置"><a href="#3、客户端配置" class="headerlink" title="3、客户端配置"></a>3、客户端配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">安装：<br>yum -y install iscsi-initiator-utils<br>或<br>yum -y install iscsi-initiator-utils<br></code></pre></td></tr></table></figure><p>配置ISCSIInitiator名称（此处InitiatorName须与服务端配置的ACL允许ISCSI客户机连接的名称一致），如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">InitiatorName=iqn.2018-06.com.xenserver:client<br></code></pre></td></tr></table></figure><p><strong>最好不要修改这个文件！！！！！！</strong></p><p>修改ISCSIInitiator配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/iscsi/iscsid.conf<br><br>添加：<br>node.session.auth.authmethod = CHAP<br>node.session.auth.username = ye<br>node.session.auth.password = 123456<br></code></pre></td></tr></table></figure><p>查找、连接ISCSI设备，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">iscsiadm --mode discovery --type st --portal xxxx:xx<br>iscsiadm --mode node --targetname xxx --portal xxxx:xx --login<br><br></code></pre></td></tr></table></figure><p><img src="/2025/05/05/note/linux/targetcli%E6%90%AD%E5%BB%BAiscsi/targetcli%E6%90%AD%E5%BB%BAiscsi/image-3.png" alt="alt text"></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>iscsi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux磁盘与文件系统管理</title>
    <link href="/2025/05/05/note/linux/DiskManager/ch7/ch7/"/>
    <url>/2025/05/05/note/linux/DiskManager/ch7/ch7/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch7. Linux磁盘与文件系统管理</p><p><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img.png" alt="img.png"></p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="7-1-认识Linux文件系统"><a href="#7-1-认识Linux文件系统" class="headerlink" title="7.1 认识Linux文件系统"></a>7.1 认识Linux文件系统</h5><p>Linux 最传统的磁盘文件系统 （filesystem） 使用的是 EXT2。  </p><h6 id="7-1-1-磁盘组成与分区的复习"><a href="#7-1-1-磁盘组成与分区的复习" class="headerlink" title="7.1.1 磁盘组成与分区的复习"></a>7.1.1 磁盘组成与分区的复习</h6><p>各项磁盘的物理组成我们在第零章里面就介绍过， 同时第二章也谈过分区的概念了<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_1.png" alt="img_1.png"><br>从上面我们知道数据储存与读取的重点在于盘片，而盘片上的物理组成则为（假设此磁盘为单碟片， 盘片图示请参考第二章图2.2.1的示意）：<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_2.png" alt="img_2.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_3.png" alt="img_3.png"><br>至于磁盘的文件名部份，基本上，所有实体磁盘的文件名都已经被仿真成 &#x2F;dev&#x2F;sd[a-p] 的格式，第一颗磁盘文件名为 &#x2F;dev&#x2F;sda。<br>而分区的文件名若以第一颗磁盘为例，则为 &#x2F;dev&#x2F;sda[1-128] 。除了实体磁盘之外，虚拟机的磁盘通常为 &#x2F;dev&#x2F;vd[a-p] 的格式。 若有使用到软件磁盘<br>阵列的话，那还有 &#x2F;dev&#x2F;md[0-128] 的磁盘文件名。使用的是 LVM 时，文件名则为&#x2F;dev&#x2F;VGNAME&#x2F;LVNAME 等格式。<br>关于软件磁盘阵列与 LVM 我们会在后面继续介绍，这里主要介绍的以实体磁盘及虚拟磁盘为主喔！<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_4.png" alt="img_4.png"></p><h6 id="7-1-2-文件系统特性"><a href="#7-1-2-文件系统特性" class="headerlink" title="7.1.2 文件系统特性"></a>7.1.2 文件系统特性</h6><p>我们都知道磁盘分区完毕后还需要进行格式化（format），之后操作系统才能够使用这个文件系统。<br>为什么需要进行“格式化”呢？<br>这是因为每种操作系统所设置的文件属性&#x2F;权限并不相同， 为了存放这些文件所需的数据，因此就需要将分区进行格式化，以成为操作系统能够利用的“文件系统格式（filesystem）”。<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_5.png" alt="img_5.png"><br>传统的磁盘与文件系统之应用中，一个分区就是只能够被格式化成为一个文件系统，所以我们可以说一个 filesystem 就是一个 partition。<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_6.png" alt="img_6.png"><br>inode&#x2F;block数据图：<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_7.png" alt="img_7.png"><br>常常会听到所谓的“磁盘重组”吧？<br>需要磁盘重组的原因就是文件写入的 block 太过于离散了，此时文件读取的性能将会变的很差所致。<br>FAT 的文件系统需要三不五时的磁盘重组一下，那么 Ext2 是否需要磁盘重整呢？<br>由于 Ext2 是索引式文件系统，基本上不太需要常常进行磁盘重组的。但是如果文件系统使用太久，<br>常常删除&#x2F;编辑&#x2F;新增文件时，那么还是可能会造成文件数据太过于离散的问题，此时或许会需要进行重整一下的。  </p><h6 id="7-1-3-Linux-的-EXT2-文件系统（inode）"><a href="#7-1-3-Linux-的-EXT2-文件系统（inode）" class="headerlink" title="7.1.3 Linux 的 EXT2 文件系统（inode）"></a>7.1.3 Linux 的 EXT2 文件系统（inode）</h6><p>标准的Linux 文件系统 Ext2 就是使用这种 inode 为基础的文件系统啦！<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_8.png" alt="img_8.png"><br>在整体的规划当中，文件系统最前面有一个开机扇区（boot sector），这个开机扇区可以安装开机管理程序， 这是个非常重要的设计，<br>因为如此一来我们就能够将不同的开机管理程序安装到个别的文件系统最前端，而不用覆盖整颗磁盘唯一的 MBR， 这样也才能够制作出多重<br>开机的环境啊！<br>至于每一个区块群组（block group）的六个主要内容说明如后：<br>1、data block （数据区块）<br>data block 是用来放置文件内容数据地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K 三种而已。<br>在格式化时 block 的大小就固定了，且每个 block 都有编号，以方便 inode 的记录啦。<br>不过要注意的是，由于 block 大小的差异，会导致该文件系统能够支持的最大磁盘容量与最大单一文件大小并不相同。 因为 block 大小而产生的 Ext2 文件系统限制如下：<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_9.png" alt="img_9.png"><br>除此之外 Ext2 文件系统的 block 还有什么限制呢？有的！基本限制如下：<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_10.png" alt="img_10.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_11.png" alt="img_11.png">  </p><p>2、inode table （inode 表格）<br>inode 的内容在记录文件的属性以及该文件实际数据是放置在哪几号 block 内！<br>基本上，inode 记录的文件数据至少有下面这些：<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_12.png" alt="img_12.png"><br>inode 的数量与大小也是在格式化时就已经固定了，除此之外 inode 还有些什么特色呢？<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_13.png" alt="img_13.png"><br>我们约略来分析一下 EXT2 的 inode &#x2F; block 与文件大小的关系好了。<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_14.png" alt="img_14.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_15.png" alt="img_15.png"><br>即操作系统书上的图。<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_16.png" alt="img_16.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_17.png" alt="img_17.png">  </p><p>3、Superblock （超级区块）<br>Superblock 是记录整个 filesystem 相关信息的地方， 没有 Superblock ，就没有这个filesystem 了。<br>他记录的信息主要有：<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_18.png" alt="img_18.png"><br>此外，每个 block group 都可能含有 superblock 喔！<br>但是我们也说一个文件系统应该仅有一个 superblock 而已，那是怎么回事啊？<br>事实上除了第一个 block group 内会含有 superblock之外，后续的 block group 不一定含有 superblock ， 而若含有 superblock 则该 superblock<br>主要是做为第一个 block group 内 superblock 的备份咯，这样可以进行 superblock 的救援呢！  </p><p>4、Filesystem Description （文件系统描述说明）<br>这个区段可以描述每个 block group 的开始与结束的 block 号码，以及说明每个区段<br>（superblock, bitmap, inodemap, data block） 分别介于哪一个 block 号码之间。这部份也能够用 dumpe2fs 来观察的。  </p><p>5、block bitmap （区块对照表）<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_19.png" alt="img_19.png">  </p><p>6、inode bitmap （inode 对照表）<br>这个其实与 block bitmap 是类似的功能，只是 block bitmap 记录的是使用与未使用的 block 号码， 至于 inode bitmap 则是记录使用与未使用的 inode 号码啰！  </p><p>7、dumpe2fs： 查询 Ext 家族 superblock 信息的指令<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_20.png" alt="img_20.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_21.png" alt="img_21.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_22.png" alt="img_22.png"></p><h6 id="7-1-4-与目录树的关系"><a href="#7-1-4-与目录树的关系" class="headerlink" title="7.1.4 与目录树的关系"></a>7.1.4 与目录树的关系</h6><p>那么目录与文件在文件系统当中是如何记录数据的呢？基本上可以这样说：  </p><p>1、目录<br>当我们在 Linux 下的文件系统创建一个目录时，文件系统会分配一个 inode 与至少一块 block 给该目录。<br>其中，inode 记录该目录的相关权限与属性，并可记录分配到的那块 block 号码；而 block 则是记录在这个目录下的文件名与该文件名占用的 inode 号码数据。<br>也就是说目录所占用的 block 内容在记录如下的信息：<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_23.png" alt="img_23.png"><br>如果想要实际观察 root 主文件夹内的文件所占用的 inode 号码时，可以使用 ls -i 这个选项来处理：<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_24.png" alt="img_24.png">  </p><p>2、文件<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_25.png" alt="img_25.png">  </p><p>3、目录树读取：<br>好了，经过上面的说明你也应该要很清楚的知道 inode 本身并不记录文件名，文件名的记录是在目录的 block 当中。<br>到“新增&#x2F;删除&#x2F;更名文件名与目录的 w 权限有关”的特色！那么因为文件名是记录在目录的 block 当中，<br>因此当我们要读取某个文件时，就务必会经过目录的 inode 与 block ，然后才能够找到那个待读取文件的 inode 号码， 最终才会读到正确的文件的 block 内的数据。<br>由于目录树是由根目录开始读起，因此系统通过挂载的信息可以找到挂载点的 inode 号码， 此时就能够得到根目录的 inode 内容，并依据该 inode 读取根目录的 block 内的文件名数据，<br>再一层一层的往下读到正确的文件名。<br>举例来说，如果我想要读取 &#x2F;etc&#x2F;passwd 这个文件时， 系统是如何读取的呢？<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_26.png" alt="img_26.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_27.png" alt="img_27.png"></p><h6 id="7-1-5-EXT2-EXT3-EXT4-文件的存取与日志式文件系统的功能"><a href="#7-1-5-EXT2-EXT3-EXT4-文件的存取与日志式文件系统的功能" class="headerlink" title="7.1.5 EXT2&#x2F;EXT3&#x2F;EXT4 文件的存取与日志式文件系统的功能"></a>7.1.5 EXT2&#x2F;EXT3&#x2F;EXT4 文件的存取与日志式文件系统的功能</h6><p>上一小节谈到的仅是读取而已，那么如果是新建一个文件或目录时，我们的文件系统是如何处理的呢？<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_28.png" alt="img_28.png">  </p><p>一般来说，我们将 inode table 与 data block 称为数据存放区域，至于其他例如 superblock、block bitmap 与 inode bitmap 等区段就被称为 metadata （中介数据） 啰，因为 superblock,<br>inode bitmap 及 block bitmap 的数据是经常变动的，每次新增、移除、编辑时都可能会影响到这三个部分的数据，因此才被称为中介数据的啦。  </p><p>1、数据的不一致 （Inconsistent） 状态<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_29.png" alt="img_29.png">  </p><p>2、日志式文件系统 （Journaling filesystem）<br>为了避免上述提到的文件系统不一致的情况发生，因此我们的前辈们想到一个方式， 如果在我们的 filesystem 当中规划出一个区块，<br>该区块专门在记录写入或修订文件时的步骤， 那不就可以简化一致性检查的步骤了？<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_30.png" alt="img_30.png">  </p><h6 id="7-1-6-Linux-文件系统的运行"><a href="#7-1-6-Linux-文件系统的运行" class="headerlink" title="7.1.6 Linux 文件系统的运行"></a>7.1.6 Linux 文件系统的运行</h6><p><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_31.png" alt="img_31.png"><br>为了解决这个效率的问题，因此我们的 Linux 使用的方式是通过一个称为非同步处理（asynchronously） 的方式。所谓的非同步处理是这样的：<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_32.png" alt="img_32.png">  </p><h6 id="7-1-7-挂载点的意义-（mount-point）"><a href="#7-1-7-挂载点的意义-（mount-point）" class="headerlink" title="7.1.7 挂载点的意义 （mount point）"></a>7.1.7 挂载点的意义 （mount point）</h6><p>每个 filesystem 都有独立的 inode &#x2F; block &#x2F; superblock 等信息，这个文件系统要能够链接到目录树才能被我们使用。<br>将文件系统与目录树结合的动作我们称为“挂载”。挂载点一定是目录，该目录为进入该文件系统的入口。<br>因此并不是你有任何文件系统都能使用，必须要“挂载”到目录树的某个目录后，才能够使用该文件系统的。<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_33.png" alt="img_33.png"></p><h6 id="7-1-8-其他-Linux-支持的文件系统与-VFS"><a href="#7-1-8-其他-Linux-支持的文件系统与-VFS" class="headerlink" title="7.1.8 其他 Linux 支持的文件系统与 VFS"></a>7.1.8 其他 Linux 支持的文件系统与 VFS</h6><p><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_34.png" alt="img_34.png"><br>想要知道你的 Linux 支持的文件系统有哪些，可以察看下面这个目录：<br>ls -l &#x2F;lib&#x2F;modules&#x2F;$(uname -r)&#x2F;kernel&#x2F;fs<br>系统目前已载入到内存中支持的文件系统则有：<br>cat &#x2F;proc&#x2F;filesystems  </p><p>1、Linux VFS （Virtual Filesystem Switch）<br>了解了我们使用的文件系统之后，再来则是要提到，那么 Linux 的核心又是如何管理这些认识的文件系统呢？<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_35.png" alt="img_35.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_36.png" alt="img_36.png"></p><h6 id="7-1-9-XFS-文件系统简介"><a href="#7-1-9-XFS-文件系统简介" class="headerlink" title="7.1.9 XFS 文件系统简介"></a>7.1.9 XFS 文件系统简介</h6><p>CentOS 7 开始，默认的文件系统已经由原本的 EXT4 变成了 XFS 文件系统了！为啥CentOS 要舍弃对 Linux 支持度最完整的 EXT 家族而改用 XFS 呢？<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_37.png" alt="img_37.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_38.png" alt="img_38.png">  </p><p>1、XFS 文件系统的配置<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_39.png" alt="img_39.png">  </p><p>xfs 文件系统在数据的分佈上，主要规划为三个部份，一个数据区 （data section）、一个文<br>件系统活动登录区 （log section）以及一个实时运行区 （realtime section）。 这三个区域的<br>数据内容如下：<br>2、数据区 （data section）<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_40.png" alt="img_40.png"><br>3、实时运行区 （realtime section）<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_41.png" alt="img_41.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_42.png" alt="img_42.png">  </p><h5 id="7-2-文件系统的简单操作"><a href="#7-2-文件系统的简单操作" class="headerlink" title="7.2 文件系统的简单操作"></a>7.2 文件系统的简单操作</h5><h6 id="7-2-1-磁盘与目录的容量"><a href="#7-2-1-磁盘与目录的容量" class="headerlink" title="7.2.1 磁盘与目录的容量"></a>7.2.1 磁盘与目录的容量</h6><p>df du</p><h6 id="7-2-2-实体链接与符号链接-ln"><a href="#7-2-2-实体链接与符号链接-ln" class="headerlink" title="7.2.2 实体链接与符号链接 ln"></a>7.2.2 实体链接与符号链接 ln</h6><p>在 Linux 下面的链接文件有两种，一种是类似 Windows 的捷径功能的文件，可以让你快速的<br>链接到目标文件（或目录）； 另一种则是通过文件系统的 inode 链接来产生新文件名，而不<br>是产生新文件！这种称为实体链接 （hard link）。 这两种玩意儿是完全不一样的东西呢！现<br>在就分别来谈谈。<br>1、Hard Link （实体链接, 硬式链接或实际链接）<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_43.png" alt="img_43.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_44.png" alt="img_44.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_45.png" alt="img_45.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_46.png" alt="img_46.png">  </p><p>2、Symbolic Link （符号链接，亦即是捷径）<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_47.png" alt="img_47.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_48.png" alt="img_48.png"><br>这里还是得特别留意，这个 Symbolic Link 与 Windows 的捷径可以给他划上等号，由<br>Symbolic link 所创建的文件为一个独立的新的文件，所以会占用掉 inode 与 block 喔！<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_49.png" alt="img_49.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_50.png" alt="img_50.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_51.png" alt="img_51.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_52.png" alt="img_52.png">  </p><h5 id="7-3-磁盘的分区、格式化、检验与挂载"><a href="#7-3-磁盘的分区、格式化、检验与挂载" class="headerlink" title="7.3 磁盘的分区、格式化、检验与挂载"></a>7.3 磁盘的分区、格式化、检验与挂载</h5><p><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_53.png" alt="img_53.png"></p><h6 id="7-3-1-观察磁盘分区状态"><a href="#7-3-1-观察磁盘分区状态" class="headerlink" title="7.3.1 观察磁盘分区状态"></a>7.3.1 观察磁盘分区状态</h6><h6 id="7-3-2-磁盘分区：gdisk-fdisk"><a href="#7-3-2-磁盘分区：gdisk-fdisk" class="headerlink" title="7.3.2 磁盘分区：gdisk&#x2F;fdisk"></a>7.3.2 磁盘分区：gdisk&#x2F;fdisk</h6><p>gdisk – gpt<br>fdisk – mbr  </p><h6 id="7-3-3-磁盘格式化-创建文件系统"><a href="#7-3-3-磁盘格式化-创建文件系统" class="headerlink" title="7.3.3 磁盘格式化(创建文件系统)"></a>7.3.3 磁盘格式化(创建文件系统)</h6><p>1、XFS 文件系统 mkfs.xfs<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_54.png" alt="img_54.png">  </p><p>2、XFS 文件系统 for RAID 性能优化 （Optional）  </p><h6 id="7-3-6-磁盘-文件系统参数修订"><a href="#7-3-6-磁盘-文件系统参数修订" class="headerlink" title="7.3.6 磁盘&#x2F;文件系统参数修订"></a>7.3.6 磁盘&#x2F;文件系统参数修订</h6><p>你可能会希望修改一下目前文件系统的一些相关信息：<br>1、mknod<br>还记得我们说过，在 Linux 下面所有的设备都以文件来代表吧！但是那个文件如何代表该设备呢？<br>通过文件的 major 与 minor 数值来替代的～所以，那个 major 与 minor 数值是有特殊意义的，不是随意设置的喔！<br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_55.png" alt="img_55.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_56.png" alt="img_56.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_57.png" alt="img_57.png">  </p><h5 id="7-5-内存交换空间（swap）之创建"><a href="#7-5-内存交换空间（swap）之创建" class="headerlink" title="7.5 内存交换空间（swap）之创建"></a>7.5 内存交换空间（swap）之创建</h5><p><img src="/2025/05/05/note/linux/DiskManager/ch7/ch7/img_58.png" alt="img_58.png">  </p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>磁盘管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>磁盘配额（Quota）与进阶文件系统管理</title>
    <link href="/2025/05/05/note/linux/DiskManager/ch14/ch14/"/>
    <url>/2025/05/05/note/linux/DiskManager/ch14/ch14/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>ch14. 磁盘配额（Quota）与进阶文件系统管理</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img.png" alt="img.png"></p><h5 id="14-1-磁盘配额-（Quota）-的应用与实作"><a href="#14-1-磁盘配额-（Quota）-的应用与实作" class="headerlink" title="14.1 磁盘配额 （Quota） 的应用与实作"></a>14.1 磁盘配额 （Quota） 的应用与实作</h5><p>Quota 这个玩意儿就字面上的意思来看，就是有多少“限额”的意思啦！  </p><h6 id="14-1-1-什么是-Quota"><a href="#14-1-1-什么是-Quota" class="headerlink" title="14.1.1 什么是 Quota"></a>14.1.1 什么是 Quota</h6><p>在 Linux 系统中，由于是多用户多任务的环境，所以会有多人共同使用一个硬盘空间的情况<br>发生， 如果其中有少数几个使用者大量的占掉了硬盘空间的话，那势必压缩其他使用者的使<br>用权力！ 因此管理员应该适当的限制硬盘的容量给使用者，以妥善的分配系统资源！避免有<br>人抗议呀！<br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_1.png" alt="img_1.png">  </p><h5 id="14-3-逻辑卷轴管理员-（Logical-Volume-Manager）"><a href="#14-3-逻辑卷轴管理员-（Logical-Volume-Manager）" class="headerlink" title="14.3 逻辑卷轴管理员 （Logical Volume Manager）"></a>14.3 逻辑卷轴管理员 （Logical Volume Manager）</h5><p><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_2.png" alt="img_2.png"></p><h6 id="14-3-1-什么是-LVM：-PV-PE-VG-LV-的意义"><a href="#14-3-1-什么是-LVM：-PV-PE-VG-LV-的意义" class="headerlink" title="14.3.1 什么是 LVM： PV, PE, VG, LV 的意义"></a>14.3.1 什么是 LVM： PV, PE, VG, LV 的意义</h6><p>LVM 的全名是 Logical Volume Manager，中文可以翻译作逻辑卷轴管理员。之所以称为“卷轴”可能是因为可以将 filesystem 像卷轴一样伸长或缩短之故吧！<br>LVM 的作法是将几个实体的 partitions （或 disk） 通过软件组合成为一块看起来是独立的大磁盘 （VG） ，然后将这块大<br>磁盘再经过分区成为可使用分区 （LV）， 最终就能够挂载使用了。但是为什么这样的系统可<br>以进行 filesystem 的扩充或缩小呢？其实与一个称为 PE 的项目有关！ 下面我们就得要针对<br>这几个项目来好好聊聊！  </p><p>1、Physical Volume, PV, 实体卷轴<br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_3.png" alt="img_3.png">  </p><p>2、Volume Group, VG, 卷轴群组<br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_4.png" alt="img_4.png">  </p><p>3、Physical Extent, PE, 实体范围区块<br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_5.png" alt="img_5.png">  </p><p>4、Logical Volume, LV, 逻辑卷轴<br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_6.png" alt="img_6.png">  </p><p>5、实作流程<br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_7.png" alt="img_7.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_8.png" alt="img_8.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_9.png" alt="img_9.png">  </p><h6 id="14-3-2-LVM实作流程"><a href="#14-3-2-LVM实作流程" class="headerlink" title="14.3.2 LVM实作流程"></a>14.3.2 LVM实作流程</h6><p>LVM 必需要核心有支持且需要安装 lvm2 这个软件，好佳在的是， CentOS 与其他较新的<br>distributions 已经默认将 lvm 的支持与软件都安装妥当了！所以你不需要担心这方面的问题！<br>用就对了！<br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_10.png" alt="img_10.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_11.png" alt="img_11.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_12.png" alt="img_12.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_13.png" alt="img_13.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_14.png" alt="img_14.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_15.png" alt="img_15.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_16.png" alt="img_16.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_17.png" alt="img_17.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_18.png" alt="img_18.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_19.png" alt="img_19.png">  </p><h6 id="14-3-3-放大-LV-容量"><a href="#14-3-3-放大-LV-容量" class="headerlink" title="14.3.3 放大 LV 容量"></a>14.3.3 放大 LV 容量</h6><p><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_20.png" alt="img_20.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_21.png" alt="img_21.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_22.png" alt="img_22.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_23.png" alt="img_23.png">  </p><h6 id="14-3-4-使用-LVM-thin-Volume-让-LVM-动态自动调整磁盘使用率"><a href="#14-3-4-使用-LVM-thin-Volume-让-LVM-动态自动调整磁盘使用率" class="headerlink" title="14.3.4 使用 LVM thin Volume 让 LVM 动态自动调整磁盘使用率"></a>14.3.4 使用 LVM thin Volume 让 LVM 动态自动调整磁盘使用率</h6><h6 id="14-3-5-LVM-的-LV-磁盘快照"><a href="#14-3-5-LVM-的-LV-磁盘快照" class="headerlink" title="14.3.5 LVM 的 LV 磁盘快照"></a>14.3.5 LVM 的 LV 磁盘快照</h6><p><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_24.png" alt="img_24.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_25.png" alt="img_25.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_26.png" alt="img_26.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_27.png" alt="img_27.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_28.png" alt="img_28.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_29.png" alt="img_29.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_30.png" alt="img_30.png">  </p><h6 id="14-3-6-LVM-相关指令汇整与-LVM-的关闭"><a href="#14-3-6-LVM-相关指令汇整与-LVM-的关闭" class="headerlink" title="14.3.6 LVM 相关指令汇整与 LVM 的关闭"></a>14.3.6 LVM 相关指令汇整与 LVM 的关闭</h6><p><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_31.png" alt="img_31.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_32.png" alt="img_32.png"><br><img src="/2025/05/05/note/linux/DiskManager/ch14/ch14/img_33.png" alt="img_33.png"></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>磁盘管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos 更换yum源</title>
    <link href="/2025/05/05/note/linux/CentOS%20%E6%8D%A2yum%E6%BA%90/Centos_CS/"/>
    <url>/2025/05/05/note/linux/CentOS%20%E6%8D%A2yum%E6%BA%90/Centos_CS/</url>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>由于CentOS7默认的yum源是国外的，<br>导致我们使用yum下载软件的下载速度不是很理想，这时候我们就需要将yum源更换成国内的源。</p><h3 id="可联网"><a href="#可联网" class="headerlink" title="可联网"></a>可联网</h3><h4 id="1-首先我们先对系统本身的yum源进行备份"><a href="#1-首先我们先对系统本身的yum源进行备份" class="headerlink" title="1.首先我们先对系统本身的yum源进行备份"></a>1.首先我们先对系统本身的yum源进行备份</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup<br></code></pre></td></tr></table></figure><h4 id="2-下载国内yum源配置文件到-etc-yum-repos-d-CentOS-Base-repo"><a href="#2-下载国内yum源配置文件到-etc-yum-repos-d-CentOS-Base-repo" class="headerlink" title="2.下载国内yum源配置文件到&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo"></a>2.下载国内yum源配置文件到&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs commandline">阿里云 CentOS 7 源（推荐）：<br>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo<br> <br>网易163 CentOS 7 源：<br>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.163.com/.help/CentOS7-Base-163.repo<br> <br>搜狐 CentOS 7 源：<br>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.sohu.com/help/CentOS7-Base-sohu.repo<br> <br>华为云 CentOS 7 源：<br>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.myhuaweicloud.com/repo/CentOS-7.repo<br> <br>华东理工大学 CentOS 7 源：<br>wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.ustc.edu.cn/centos/7/os/x86_64<br> <br>清华大学 CentOS 7 源：<br>wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.tuna.tsinghua.edu.cn/centos/7/os/x86_64/<br> <br>北京理工大学 CentOS 7 源：<br>wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.bfsu.edu.cn/centos/7/os/x86_64/<br> <br>上海交通大学 CentOS 7 源：<br>wget -O /etc/yum.repos.d/CentOS-Base.repo https://ftp.sjtu.edu.cn/centos/7/os/x86_64/<br> <br>中国科学技术大学 CentOS 7 源：<br>wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.ustc.edu.cn/centos/7/os/x86_64/<br> <br>兰州大学 CentOS 7 源：<br>wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirror.lzu.edu.cn/centos/7/os/x86_64/<br></code></pre></td></tr></table></figure><h4 id="3-清理yum缓存，并生成新的缓存"><a href="#3-清理yum缓存，并生成新的缓存" class="headerlink" title="3.清理yum缓存，并生成新的缓存"></a>3.清理yum缓存，并生成新的缓存</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum clean all<br>yum makecache<br></code></pre></td></tr></table></figure><h4 id="4-更新yum源检查是否生效"><a href="#4-更新yum源检查是否生效" class="headerlink" title="4. 更新yum源检查是否生效"></a>4. 更新yum源检查是否生效</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum update<br></code></pre></td></tr></table></figure><h3 id="内网环境"><a href="#内网环境" class="headerlink" title="内网环境"></a>内网环境</h3><h4 id="1-下载ISO，上传到服务器上"><a href="#1-下载ISO，上传到服务器上" class="headerlink" title="1. 下载ISO，上传到服务器上"></a>1. 下载ISO，上传到服务器上</h4><h4 id="2-备份本地源"><a href="#2-备份本地源" class="headerlink" title="2. 备份本地源"></a>2. 备份本地源</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /etc/yum.repos.d<br>mkdir bak<br>mv *.repo bak/ &amp;&amp; ll<br></code></pre></td></tr></table></figure><h4 id="3-挂载镜像"><a href="#3-挂载镜像" class="headerlink" title="3. 挂载镜像"></a>3. 挂载镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /mnt/Centos<br>mount -t iso9660 /home/CentOS-7-x86_64-DVD-2009.iso /mnt/Centos<br>df -h<br></code></pre></td></tr></table></figure><h4 id="4-开机挂载（非必要）"><a href="#4-开机挂载（非必要）" class="headerlink" title="4. 开机挂载（非必要）"></a>4. 开机挂载（非必要）</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">写入开机自挂载一定要写对源路径和挂载路径，不然容易导致开不起机，非必要可以不写入开机挂载，写完后用mount -a 测试下<br>vim /etc/fstab<br>/home/CentOS-7-x86_64-DVD-2009.iso /mnt/Centos iso9660 defaults 0 0<br></code></pre></td></tr></table></figure><h4 id="5-写入源"><a href="#5-写入源" class="headerlink" title="5. 写入源"></a>5. 写入源</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /etc/yum.repos.d<br><br>tee &gt;/etc/yum.repos.d/local.repo&lt;&lt;EOF<br>[mnt]<br>name=mnt<br>baseurl=file:///mnt/Centos<br>enabled=1<br>gpgcheck=0<br>EOF<br><br>yum clean all &amp;&amp; yum makecache<br></code></pre></td></tr></table></figure><h4 id="6-测试安装软件"><a href="#6-测试安装软件" class="headerlink" title="6. 测试安装软件"></a>6. 测试安装软件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum list available<br>yum install vim<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>磁盘管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQLServer 死锁优先级</title>
    <link href="/2025/05/05/note/DB/sqlserver/lock/deadlock_priority/"/>
    <url>/2025/05/05/note/DB/sqlserver/lock/deadlock_priority/</url>
    
    <content type="html"><![CDATA[<h2 id="SQLServer-死锁优先级"><a href="#SQLServer-死锁优先级" class="headerlink" title="SQLServer 死锁优先级"></a>SQLServer 死锁优先级</h2><p>SET DEADLOCK_PRIORITY (Transact-SQL)</p><p>本文主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">1 语法</a></td></tr><tr><td><a href="#cp2">2 参数</a></td></tr><tr><td><a href="#cp3">3 备注</a></td></tr><tr><td><a href="#cp4">4 权限</a></td></tr><tr><td><a href="#cp5">5 示例</a></td></tr><tr><td><a href="#cp6">6 后续步骤</a></td></tr></tbody></table><p>指定当前会话与其他会话发生死锁时继续处理的相对重要性。</p><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a><a name="cp1"></a>1 语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> DEADLOCK_PRIORITY &#123; LOW <span class="hljs-operator">|</span> NORMAL <span class="hljs-operator">|</span> HIGH <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span><span class="hljs-type">numeric</span><span class="hljs-operator">-</span>priority<span class="hljs-operator">&gt;</span> <span class="hljs-operator">|</span> <span class="hljs-variable">@deadlock_var</span> <span class="hljs-operator">|</span> <span class="hljs-variable">@deadlock_intvar</span> &#125;<br>  <br><span class="hljs-operator">&lt;</span><span class="hljs-type">numeric</span><span class="hljs-operator">-</span>priority<span class="hljs-operator">&gt;</span> ::<span class="hljs-operator">=</span> &#123; <span class="hljs-number">-10</span> <span class="hljs-operator">|</span> <span class="hljs-number">-9</span> <span class="hljs-operator">|</span> <span class="hljs-number">-8</span> <span class="hljs-operator">|</span> ... <span class="hljs-operator">|</span> <span class="hljs-number">0</span> <span class="hljs-operator">|</span> ... <span class="hljs-operator">|</span> <span class="hljs-number">8</span> <span class="hljs-operator">|</span> <span class="hljs-number">9</span> <span class="hljs-operator">|</span> <span class="hljs-number">10</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="2-参数"><a href="#2-参数" class="headerlink" title="2 参数"></a><a name="cp2"></a>2 参数</h3><p>LOW</p><p>指定如果当前会话发生死锁，并且死锁链中涉及的其他会话的死锁优先级设置为 NORMAL 或 HIGH 或大于 -5 的整数值，则当前会话将成为死锁牺牲品。 如果其他会话的死锁优先级设置为小于 -5 的整数值，则当前会话将不会成为死锁牺牲品。 此参数还指定如果其他会话的死锁优先级设置为 LOW 或 -5，则当前会话将可能成为死锁牺牲品。</p><p>NORMAL</p><p>指定如果死锁链中涉及的其他会话的死锁优先级设置为 HIGH 或大于 0 的整数值，则当前会话将成为死锁牺牲品，但如果其他会话的死锁优先级设置为 LOW 或小于 0 的整数值，则当前会话将不会成为死锁牺牲品。 此参数还指定如果其他会话的死锁优先级设置为 NORMAL 或 0，则当前会话将可能成为死锁牺牲品。 NORMAL 为默认优先级。</p><p>HIGH</p><p>指定如果死锁链中涉及的其他会话的死锁优先级设置为大于 5 的整数值，则当前会话将成为死锁牺牲品，或者如果其他会话的死锁优先级设置为 HIGH 或 5，则当前会话可能成为死锁牺牲品。</p><numeric-priority><p>用以提供 21 个死锁优先级别的整数值范围（-10 到 10）。 它指定如果死锁链中涉及的其他会话以更高的死锁优先级值运行，则当前会话将成为死锁牺牲品，但如果其他会话以低于当前会话的死锁优先级值运行，则当前会话不会成为死锁牺牲品。 它还指定如果其他会话以相同于当前会话的死锁优先级值运行，则当前会话可能成为死锁牺牲品。 LOW 对应于 -5、NORMAL 对应于 0 以及 HIGH 对应于 5。</p><p>@deadlock_var</p><p>指定死锁优先级的字符变量。 此变量必须设置为“LOW”、“NORMAL”或“HIGH”中的一个值。 而且必须足够大以保存整个字符串。</p><p>@deadlock_intvar</p><p>指定死锁优先级的整数变量。 此变量必须设置为 -10 到 10 范围中的一个整数值。</p><h3 id="3-备注"><a href="#3-备注" class="headerlink" title="3 备注"></a><a name="cp3"></a>3 备注</h3><p>当两个会话同时等待访问由其他会话锁定的资源时，便会发生死锁。 当 SQL Server 实例检测到两个会话发生死锁时，将选择其中一个会话作为死锁牺牲品来解决死锁。 此牺牲品的当前事务将回滚，且死锁错误消息 1205 返回客户端。 这样可释放由该会话所控制的所有锁，从而允许其他会话继续进行。</p><p>将哪个会话选为死锁牺牲品取决于每个会话的死锁优先级：</p><pre><code class="hljs">(1) 如果两个会话的死锁优先级相同，则 SQL Server 实例将回滚的开销较低的会话选为死锁牺牲品。 例如，如果两个会话都将其死锁优先级设置为 HIGH，则此实例便将它估计回滚的开销较低的会话选为牺牲品。 该成本是通过比较各事务此时已写入的日志字节数来确定的。 （可以在死锁图中将此值看作“已用日志”）。(2) 如果会话的死锁优先级不同，则将死锁优先级最低的会话选为死锁牺牲品。</code></pre><p>SET DEADLOCK_PRIORITY 是在执行或运行时设置，而不是在分析时设置。</p><p>此语法在 Azure Synapse Analytics 专用 SQL 池中不受支持。 它在 Azure Synapse Analytics 无服务器 SQL 池中受支持。</p><h3 id="4-权限"><a href="#4-权限" class="headerlink" title="4 权限"></a><a name="cp4"></a>4 权限</h3><p>要求 公共 角色具有成员身份。</p><h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5 示例"></a><a name="cp5"></a>5 示例</h3><p>以下示例使用变量将死锁优先级设置为 LOW。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DECLARE</span> <span class="hljs-variable">@deadlock_var</span> <span class="hljs-type">NCHAR</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@deadlock_var</span> <span class="hljs-operator">=</span> N<span class="hljs-string">&#x27;LOW&#x27;</span>;<br>  <br><span class="hljs-keyword">SET</span> DEADLOCK_PRIORITY <span class="hljs-variable">@deadlock_var</span>;<br>GO<br></code></pre></td></tr></table></figure><p>以下示例将死锁优先级设置为 NORMAL。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> DEADLOCK_PRIORITY NORMAL;<br>GO<br></code></pre></td></tr></table></figure><h3 id="6-后续步骤"><a href="#6-后续步骤" class="headerlink" title="6 后续步骤"></a><a name="cp6"></a>6 后续步骤</h3></numeric-priority>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
      <category>sqlserver</category>
      
      <category>lock</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>sqlserver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出无日志表</title>
    <link href="/2025/05/05/note/DB/postgresql/unlogged/README/"/>
    <url>/2025/05/05/note/DB/postgresql/unlogged/README/</url>
    
    <content type="html"><![CDATA[<h2 id="深入浅出无日志表"><a href="#深入浅出无日志表" class="headerlink" title="深入浅出无日志表"></a>深入浅出无日志表</h2><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">1 前言</a></td></tr><tr><td><a href="#cp2">2 分析</a></td></tr><tr><td><a href="#cp3">3 见微知著</a></td></tr><tr><td><a href="#cp4">4 表的转换</a></td></tr><tr><td><a href="#cp5">5 块结构</a></td></tr><tr><td><a href="#cp6">6 小结</a></td></tr></tbody></table><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a><a name="cp1"></a>1. 前言</h3><p>在 PostgreSQL 中，支持多种类型的表 — 临时表、普通表，以及无日志表。</p><ol><li><p>顾名思义，”无日志”其优势在于不用记录 WAL，那么写入速度自然也杠杠的</p></li><li><p>同理，无日志表在备库上没有数据(只有一个壳)，也无法进行访问，会提示<br>ERROR: cannot access temporary or unlogged relations during recovery，</p><p> pg_basebackup<br> 的时候也会跳过无日志表 (除了 init 分支)。</p></li></ol><p>那么无日志表又有哪些鲜为人知的细节呢？</p><h3 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a><a name="cp2"></a>2. 分析</h3><p>首先，让我们思考一下，无日志表的数据会落盘吗？或者说，按照常识，执行正常检查点的时候会落盘吗？</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">However, they are not crash-safe: an unlogged table is automatically truncated after a <br>crash or unclean shutdown. The contents of an unlogged table are also not replicated <br>to standby servers. Any indexes created on an unlogged table are automatically unlogged as well.<br><br>然而，它们不具有崩溃安全性：未记录的表在崩溃或不正常关闭后会自动被截断。<br>未记录表的内容也不会被复制到备用服务器。在未记录表上创建的任何索引也会自动变为未记录状态。<br></code></pre></td></tr></table></figure><p>根据官网解释，在崩溃或者非正常关闭的时候，表文件会被截断，也就是说，在正常关闭的情况下，数据是会正常落盘的，让我们验证一下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br>postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">create</span> unlogged <span class="hljs-keyword">table</span> t1(id <span class="hljs-type">int</span>,info text);<br><span class="hljs-keyword">CREATE TABLE</span><br>postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">insert into</span> t1 <span class="hljs-keyword">select</span> n,md5(random()::text) <span class="hljs-keyword">from</span> generate_series(<span class="hljs-number">1</span>,<span class="hljs-number">10000</span>) <span class="hljs-keyword">as</span> n;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-number">0</span> <span class="hljs-number">10000</span><br>postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">select</span> pg_relation_filepath(<span class="hljs-string">&#x27;t1&#x27;</span>);<br> pg_relation_filepath <br><span class="hljs-comment">----------------------</span><br> base<span class="hljs-operator">/</span><span class="hljs-number">5</span><span class="hljs-operator">/</span><span class="hljs-number">51158</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br>postgres<span class="hljs-operator">=</span># checkpoint ;<br>CHECKPOINT<br>[postgres<span class="hljs-variable">@mypg</span> <span class="hljs-number">5</span>]$ ls <span class="hljs-operator">-</span>lrth <span class="hljs-number">51158</span><span class="hljs-operator">*</span><br><span class="hljs-operator">-</span>rw<span class="hljs-comment">------- targetcli搭建iscsi postgres postgres    0 Dec  7 15:04 51158_init</span><br><span class="hljs-operator">-</span>rw<span class="hljs-comment">------- targetcli搭建iscsi postgres postgres  24K Dec  7 15:04 51158_fsm</span><br><span class="hljs-operator">-</span>rw<span class="hljs-comment">------- targetcli搭建iscsi postgres postgres 672K Dec  7 15:04 51158</span><br><span class="hljs-operator">-</span>rw<span class="hljs-comment">------- targetcli搭建iscsi postgres postgres 8.0K Dec  7 15:04 51158_vm</span><br>[postgres<span class="hljs-variable">@mypg</span> <span class="hljs-number">5</span>]$ hexdump <span class="hljs-operator">-</span>C <span class="hljs-number">51158</span><br><span class="hljs-number">00000000</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-operator">|</span>................<span class="hljs-operator">|</span><br><span class="hljs-operator">*</span><br><span class="hljs-number">000</span>a8000<br></code></pre></td></tr></table></figure><p>hexdump 会将相同的都是 0 的行标记为 *，用 vim 打开也确实全是 0。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>0000000: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>0000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>0000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>....<br></code></pre></td></tr></table></figure><p>让我们正常关闭，再观察一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">postgres=# \q<br>[postgres@mypg ~]$ pg_ctl -D 17data stop<br>waiting for server to shut down.... done<br>server stopped<br>[postgres@mypg 5]$ hexdump -C 51158 | head -n 10<br>00000000  00 00 00 00 00 00 00 00  00 00 04 00 f8 01 00 02  |................|<br>00000010  00 20 04 20 00 00 00 00  c0 9f 7a 00 80 9f 7a 00  |. . ......z...z.|<br>00000020  40 9f 7a 00 00 9f 7a 00  c0 9e 7a 00 80 9e 7a 00  |@.z...z...z...z.|<br>00000030  40 9e 7a 00 00 9e 7a 00  c0 9d 7a 00 80 9d 7a 00  |@.z...z...z...z.|<br>00000040  40 9d 7a 00 00 9d 7a 00  c0 9c 7a 00 80 9c 7a 00  |@.z...z...z...z.|<br>00000050  40 9c 7a 00 00 9c 7a 00  c0 9b 7a 00 80 9b 7a 00  |@.z...z...z...z.|<br>00000060  40 9b 7a 00 00 9b 7a 00  c0 9a 7a 00 80 9a 7a 00  |@.z...z...z...z.|<br>00000070  40 9a 7a 00 00 9a 7a 00  c0 99 7a 00 80 99 7a 00  |@.z...z...z...z.|<br>00000080  40 99 7a 00 00 99 7a 00  c0 98 7a 00 80 98 7a 00  |@.z...z...z...z.|<br>00000090  40 98 7a 00 00 98 7a 00  c0 97 7a 00 80 97 7a 00  |@.z...z...z...z.|<br></code></pre></td></tr></table></figure><p>这次就可以很清楚地看到，数据都被刷盘了。那么这二者有什么区别？其实代码的注释就很清楚:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  * Unless this is a shutdown checkpoint or we have been explicitly told,</span><br><span class="hljs-comment">  * we write only permanent, dirty buffers.  But at shutdown or end of</span><br><span class="hljs-comment">  * recovery, we write all dirty buffers.</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">if</span> (!((flags &amp; (CHECKPOINT_IS_SHUTDOWN | CHECKPOINT_END_OF_RECOVERY |<br>                 CHECKPOINT_FLUSH_ALL))))<br>     mask |= BM_PERMANENT;<br></code></pre></td></tr></table></figure><p>也就是说，如果 checkpoint 的时候，其 flags<br>不是 CHECKPOINT_IS_SHUTDOWN、CHECKPOINT_END_OF_RECOVERY 或者 CHECKPOINT_FLUSH_ALL，<br>那么只会刷持久化的表。让我们验证一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>(gdb) b CreateCheckPoint<br>Breakpoint 1 at 0x569430: file xlog.c, line 6827.<br>(gdb) signal SIGINT<br>Continuing with signal SIGINT.<br>Program received signal SIGINT, Interrupt.<br>0x00007f0ccd0ae0c3 in __epoll_wait_nocancel () from /lib64/libc.so.6<br>(gdb) c<br>Continuing.<br>Breakpoint targetcli搭建iscsi, CreateCheckPoint (flags=108) at xlog.c:6827<br>6827    xlog.c: No such file or directory.<br>(gdb) p/x flags<br><span class="hljs-meta prompt_">$</span><span class="language-bash">1 = 0x6c</span><br>(gdb) p flags<br><span class="hljs-meta prompt_">$</span><span class="language-bash">2 = 108</span><br></code></pre></td></tr></table></figure><p>108 等于：</p><pre><code class="hljs">• CHECKPOINT_REQUESTED (0x0040 = 64)• CHECKPOINT_WAIT (0x0020 = 32)• CHECKPOINT_FORCE (0x0008 = 8)• CHECKPOINT_IMMEDIATE (0x0004 = 4)</code></pre><p>说明不带有 CHECKPOINT_IS_SHUTDOWN 或者 CHECKPOINT_FLUSH_ALL，对应到我们前面的现象，<br>没有刷新 unlogged tables。再看看正常关机的情况 (注意此处需要用 SIGUSR2 的信号)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>(gdb) b CreateCheckPoint<br>Breakpoint 1 at 0x569430: file xlog.c, line 6827.<br>(gdb) signal SIGUSR2<br>Continuing with signal SIGUSR2.<br>Program received signal SIGUSR2, User defined signal 2.<br>0x00007f0ccd0ae0c3 in __epoll_wait_nocancel () from /lib64/libc.so.6<br>(gdb) c<br>Continuing.<br>Breakpoint targetcli搭建iscsi, CreateCheckPoint (flags=5) at xlog.c:6827<br>6827    xlog.c: No such file or directory.<br>(gdb) p/x flags<br><span class="hljs-meta prompt_">$</span><span class="language-bash">1 = 0x5</span><br></code></pre></td></tr></table></figure><p>flags &#x3D; 5 表示 CHECKPOINT_IS_SHUTDOWN | CHECKPOINT_IMMEDIATE，所以对应到我们前面的现象，正常关机会进行刷盘。</p><p>另外上面细心的读者可能发现了，执行正常的 checkpoint，其大小也变为了同样的大小，我没有看具体代码，<br>猜测是类似于打开 wal_init_zero 参数，调用 pg_pwrite_zeros，直接调用 mdextend -&gt; FileWrite</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * mdextend() -- Add a block to the specified relation.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The semantics are nearly the same as mdwrite(): write at the</span><br><span class="hljs-comment"> * specified position.  However, this is to be used for the case of</span><br><span class="hljs-comment"> * extending a relation (i.e., blocknum is at or beyond the current</span><br><span class="hljs-comment"> * EOF).  Note that we assume writing a block beyond current EOF</span><br><span class="hljs-comment"> * causes intervening file space to become filled with zeroes.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">mdextend</span><span class="hljs-params">(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum,</span><br><span class="hljs-params">         <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buffer, <span class="hljs-type">bool</span> skipFsync)</span><br>&#123;<br>    <span class="hljs-type">off_t</span>        seekpos;<br>    <span class="hljs-type">int</span>            nbytes;<br>    MdfdVec    *v;<br></code></pre></td></tr></table></figure><h3 id="3-见微知著"><a href="#3-见微知著" class="headerlink" title="3. 见微知著"></a><a name="cp3"></a>3. 见微知著</h3><p>简单浏览了一下代码，CHECKPOINT_FLUSH_ALL 一共在两处进行了调用：</p><p>CreateDatabaseUsingFileCopy：Create a new database using the FILE_COPY strategy.<br>FILE_COPY 可以参照官网</p><p>movedb：对应到 ALTER DATABASE SET TABLESPACE</p><p>所以，对应到这些场景的时候，包括 unlogged tables，也需要进行刷盘，注意潜在的性能影响。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>/*<br> * Perform a checkpoint --- either during shutdown, or on-the-fly<br> *<br> * flags is a bitwise OR of the following:<br> *    CHECKPOINT_IS_SHUTDOWN: checkpoint is for database shutdown.<br> *    CHECKPOINT_END_OF_RECOVERY: checkpoint is for end of WAL recovery.<br> *    CHECKPOINT_IMMEDIATE: finish the checkpoint ASAP,<br> *        ignoring checkpoint_completion_target parameter.<br> *    CHECKPOINT_FORCE: force a checkpoint even if no XLOG activity has occurred<br> *        since the last one (implied by CHECKPOINT_IS_SHUTDOWN or<br> *        CHECKPOINT_END_OF_RECOVERY).<br> *    CHECKPOINT_FLUSH_ALL: also flush buffers of unlogged tables.<br></code></pre></td></tr></table></figure><h3 id="4-表的转换"><a href="#4-表的转换" class="headerlink" title="4. 表的转换"></a><a name="cp4"></a>4. 表的转换</h3><p>还有需要注意的点在于，普通表和无日志表之间的转换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> mytable <span class="hljs-keyword">SET</span> UNLOGGED; <span class="hljs-comment">-- cheap! </span><br><span class="hljs-keyword">ALTER TABLE</span> mytable <span class="hljs-keyword">SET</span> LOGGED; <span class="hljs-comment">-- expensive!</span><br></code></pre></td></tr></table></figure><p>也就是将无日志表转为普通表的时候，会需要写大量的 REDO，不难理解，不然崩溃了就无法恢复数据了。<br>反之则很快，只需要修改一下元数据即可。</p><p>因此，这种行为也可以进行发散，直接通过修改元数据的方式，<br>避免将无日志表转为普通表的时候写入大量 WAL，但是有什么幺蛾子就不好说了，<br>比如 PITR，都没有这个表的 WAL，那自然恢复出来的数据也不一致了。</p><h3 id="5-块结构"><a href="#5-块结构" class="headerlink" title="5. 块结构"></a><a name="cp5"></a>5. 块结构</h3><p>还有一点值得注意的细节是，块上面的 LSN👇🏻</p><p><img src="/2025/05/05/note/DB/postgresql/unlogged/README/img.png" alt="img.png"></p><p>无日志表的 LSN 为 0，这意味着无日志表由其自己的数据文件中的数据表示，但不由日志文件中的数据表示。</p><h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a><a name="cp6"></a>6. 小结</h3><p><img src="/2025/05/05/note/DB/postgresql/unlogged/README/img_1.png" alt="img_1.png"></p><p>参考：</p><p><a href="https://www.crunchydata.com/blog/postgresl-unlogged-tables">https://www.crunchydata.com/blog/postgresl-unlogged-tables</a></p><p><a href="https://levelup.gitconnected.com/logged-unlogged-and-temporary-tables-in-postgresql-d390d9a4ef15">https://levelup.gitconnected.com/logged-unlogged-and-temporary-tables-in-postgresql-d390d9a4ef15</a></p><p><a href="https://blog.japinli.top/2022/11/postgresql-debug-checkpointer/">https://blog.japinli.top/2022/11/postgresql-debug-checkpointer/</a></p><p><a href="https://github.com/digoal/blog/blob/master/202405/20240510_03.md">https://github.com/digoal/blog/blob/master/202405/20240510_03.md</a></p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
      <category>PostgreSQL</category>
      
      <category>unlogged</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DelayCheckpoint</title>
    <link href="/2025/05/05/note/DB/postgresql/Transactions/delayChkpt/DelayChkpt/"/>
    <url>/2025/05/05/note/DB/postgresql/Transactions/delayChkpt/DelayChkpt/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>DelayCheckpoint</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1、事务提交"><a href="#1、事务提交" class="headerlink" title="1、事务提交"></a>1、事务提交</h5><p>三个关键步骤：</p><p>提交标志的设置 ：执行“s-&gt;state&#x3D;TRANS_COMMIT”设置事务的状态。</p><p>记载到日志 ：调用RecordTransactionCommit（）记录日志并刷出日志<br>（不一定刷出到物理存储，需要根据fsync参数的设置值确定）。</p><p>释放锁 ：释放锁的位置是在设置提交标志之前还是之后，可以表明使用的封锁算法是否是<br>SS2PL。</p><p>CommitTransaction函数：</p><p><img src="/2025/05/05/note/DB/postgresql/Transactions/delayChkpt/DelayChkpt/img.png" alt="img.png"></p><p>RecordTransactionCommit 函数<br>为了保证事务的原子性、一致性，<br>日志一定要在提交事务前刷出完成。</p><p><img src="/2025/05/05/note/DB/postgresql/Transactions/delayChkpt/DelayChkpt/img_1.png" alt="img_1.png"><br><img src="/2025/05/05/note/DB/postgresql/Transactions/delayChkpt/DelayChkpt/img_2.png" alt="img_2.png"><br><img src="/2025/05/05/note/DB/postgresql/Transactions/delayChkpt/DelayChkpt/img_3.png" alt="img_3.png"><br><img src="/2025/05/05/note/DB/postgresql/Transactions/delayChkpt/DelayChkpt/img_4.png" alt="img_4.png"></p><h5 id="2、DelayChkpt是什么"><a href="#2、DelayChkpt是什么" class="headerlink" title="2、DelayChkpt是什么"></a>2、DelayChkpt是什么</h5><p>综合上述代码，delayChkpt阻塞checkpoint发生位置如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">RecordTransactionCommit<br>  ...<br>  START_CRIT_SECTION();<br>  MyPgXact-&gt;delayChkpt = true;<br>  /* 写XLOG：COMMIT */<br>  /* 写CLOG：内存写不刷盘 */<br>  MyPgXact-&gt;delayChkpt = false;<br>  ...<br></code></pre></td></tr></table></figure><p>delayChkpt生效位置：<br>CreateCheckPoint等待delayChkpt</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs text">CreateCheckPoint<br>  // 【1】计算位置（重要）<br>  WALInsertLockAcquireExclusive();<br>  curInsert = XLogBytePosToRecPtr(Insert-&gt;CurrBytePos);<br>  freespace = INSERT_FREESPACE(curInsert);<br>if (freespace == 0)<br>&#123;<br>if (curInsert % XLogSegSize == 0)<br>curInsert += SizeOfXLogLongPHD;<br>else<br>curInsert += SizeOfXLogShortPHD;<br>&#125;<br>checkPoint.redo = curInsert;<br>RedoRecPtr = XLogCtl-&gt;Insert.RedoRecPtr = checkPoint.redo;<br>WALInsertLockRelease();<br>  <br>// 【2】通过delayChkpt等其他所有正在提交中、正在写日志的事务<br>vxids = GetVirtualXIDsDelayingChkpt(&amp;nvxids);<br>if (nvxids &gt; 0)<br>&#123;<br>do<br>&#123;<br>pg_usleep(10000L);/* wait for 10 msec */<br>&#125; while (HaveVirtualXIDsDelayingChkpt(vxids, nvxids));<br>&#125;<br>pfree(vxids);<br>  <br>  // 【3】刷数据<br>CheckPointGuts(checkPoint.redo, flags);<br>  // 【4】记chkpt日志<br>XLogBeginInsert();<br>XLogRegisterData((char *) (&amp;checkPoint), sizeof(checkPoint));<br>recptr = XLogInsert(RM_XLOG_ID,<br>shutdown ? XLOG_CHECKPOINT_SHUTDOWN :<br>XLOG_CHECKPOINT_ONLINE);<br><br>XLogFlush(recptr);<br></code></pre></td></tr></table></figure><h5 id="3、为什么需要DelayChkpt"><a href="#3、为什么需要DelayChkpt" class="headerlink" title="3、为什么需要DelayChkpt"></a>3、为什么需要DelayChkpt</h5><p>确定REDO点位是在createCheckpoint的函数前面执行的，<br>checkpoint和事务提交并发会有下面三种情况发生：</p><p><img src="/2025/05/05/note/DB/postgresql/Transactions/delayChkpt/DelayChkpt/img_5.png" alt="img_5.png"></p><p>情况一：redo point在commit提交前，那么如果crash发生了，redo过程会覆盖这条xlog，<br>不会有问题</p><p>情况三：redo point在事务提交后，redo时xlog虽然还是做不到，但是clog一定会被刷下去，<br>所以我们不会丢失事务提交信息。</p><p>情况二：如果没有delayChkpt，redo point可能发生在上图中的位置<br>（然后checkpoint刷完数据后，当前事务才写clog），XLOG已经先写了，如果crash发生了，<br>redo过程不会覆盖这条xlog，而且clog信息不存在，那么commit信息彻底丢掉了。</p><h5 id="4、目前RAC中的DelayChkpt"><a href="#4、目前RAC中的DelayChkpt" class="headerlink" title="4、目前RAC中的DelayChkpt"></a>4、目前RAC中的DelayChkpt</h5><p>各个节点分别进行</p><h5 id="5、RAC支持2PC中的DelayChkpt"><a href="#5、RAC支持2PC中的DelayChkpt" class="headerlink" title="5、RAC支持2PC中的DelayChkpt"></a>5、RAC支持2PC中的DelayChkpt</h5><p>在RAC支持2PC的需求中，支持跨界点提交事务。<br>即node1 执行prepare的事务 p1，node2 可以执行 commit prepared ‘p1’进行提交操作。<br>如果执行了跨节点的事务提交，<br>那么目前的实现中，RecordTransactionCommit函数中xlog、clog的写入分别在两个节点进行，<br>其中xlog由执行SQL的节点写入，clog由执行prepare节点写入。</p><p>由于目前实现delayChkpt是各个节点分别进行，就需要考虑DelayChkpt的问题，</p><p>目前采用下图实现方法：假设node2提交node1 prepare的事务。<br><img src="/2025/05/05/note/DB/postgresql/Transactions/delayChkpt/DelayChkpt/img_8.png" alt="img_8.png"></p><p>分析可行性：</p><p><img src="/2025/05/05/note/DB/postgresql/Transactions/delayChkpt/DelayChkpt/img_7.png" alt="img_7.png"></p><p>对于情况一、情况三，事务clog 不会发生丢失;</p><p>重点分析情况二(1)~(3):</p><p>对于(1)，任一节点发起 checkpoint,首先node1未被阻塞，可正常完成，node2<br>被阻塞，直到 xlog 和 node1 clog 写入完成并且delayChkpt 为false时才开始<br>checkpoint，如图中(4)时刻 node2开始执行checkpoint，那么 node1 的clog<br>页面不会刷盘。<br>但是，在这种情况下，发起checkpoint时已经获取过全部节点的redo point,而<br>本次事务的 xlog 在 redo point 之后，因此此时发生故障也会回放这条xlog.不<br>会导致事务状态丢失。</p><p>对于(2)，处于 node1、node2的delayChkpt中，会被阻塞，发生故障则不会<br>丢失事务状态。<br>对于(3)，node1正常 checkpoint，将clog刷盘，node2 被阻塞。如果发生故<br>障，xlog 会被回放，不会丢失事务状态。</p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
      <category>PostgreSQL</category>
      
      <category>transactions</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>toast</title>
    <link href="/2025/05/05/note/DB/postgresql/toast/README/"/>
    <url>/2025/05/05/note/DB/postgresql/toast/README/</url>
    
    <content type="html"><![CDATA[<h2 id="toast"><a href="#toast" class="headerlink" title="toast"></a>toast</h2><p>toast in pg</p><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th><th>sub Chapter</th></tr></thead><tbody><tr><td><a href="#cp1">1 TOAST in PG</a></td><td><a href="#cp1.1">1.1 xx</a></td></tr><tr><td></td><td><a href="#cp1.2">1.2 xx</a></td></tr><tr><td><a href="#cp2">2 xx</a></td><td></td></tr><tr><td><a href="#cp3">3 xx</a></td><td></td></tr></tbody></table><h3 id="1-xx"><a href="#1-xx" class="headerlink" title="1 xx"></a><a name="cp1"></a>1 xx</h3><h4 id="1-1-xx"><a href="#1-1-xx" class="headerlink" title="1.1 xx"></a><a name="cp1.1"></a>1.1 xx</h4><h4 id="1-2-xx"><a href="#1-2-xx" class="headerlink" title="1.2 xx"></a><a name="cp1.2"></a>1.2 xx</h4><h3 id="2-xx"><a href="#2-xx" class="headerlink" title="2 xx"></a><a name="cp2"></a>2 xx</h3><h3 id="3-xx"><a href="#3-xx" class="headerlink" title="3 xx"></a><a name="cp3"></a>3 xx</h3>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
      <category>PostgreSQL</category>
      
      <category>toast</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL中的WAL文件与LSN深入探索和分析</title>
    <link href="/2025/05/05/note/DB/postgresql/PostgreSQL%E4%B8%AD%E7%9A%84WAL/WAL/"/>
    <url>/2025/05/05/note/DB/postgresql/PostgreSQL%E4%B8%AD%E7%9A%84WAL/WAL/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>PostgreSQL中的WAL文件与LSN深入探索和分析</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h5><p>在16MB段大小的前提下，WAL文件的排列大概是这个样子的：<br><img src="/2025/05/05/note/DB/postgresql/PostgreSQL%E4%B8%AD%E7%9A%84WAL/WAL/img.png" alt="img.png"><br><img src="/2025/05/05/note/DB/postgresql/PostgreSQL%E4%B8%AD%E7%9A%84WAL/WAL/img_1.png" alt="img_1.png">  </p><h5 id="2、-16MB-wal-seg下的WAL段文件命名及LSN编码规则"><a href="#2、-16MB-wal-seg下的WAL段文件命名及LSN编码规则" class="headerlink" title="2、 16MB wal seg下的WAL段文件命名及LSN编码规则"></a>2、 16MB wal seg下的WAL段文件命名及LSN编码规则</h5><p><img src="/2025/05/05/note/DB/postgresql/PostgreSQL%E4%B8%AD%E7%9A%84WAL/WAL/img_2.png" alt="img_2.png"><br>00000001 00000002 000000FA<br>分为三段，分别是 “时间线”、“32bit 逻辑日志号”、“32bit 日志段号”<br>我们也可以看到，上边的日志段号FE-&gt;FF然后又回到了00，但是这个时候日志号会从00000002递增到了00000003。<br>再看看当前的LSN号与WAL文件的对应关系：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">mydb<span class="hljs-operator">=</span># <span class="hljs-keyword">select</span> pg_current_wal_lsn() <span class="hljs-keyword">as</span> lsn,  pg_walfile_name(pg_current_wal_lsn()) <span class="hljs-keyword">as</span> filename, pg_walfile_name_offset(pg_current_wal_lsn()) <span class="hljs-keyword">as</span> lsn_offset;<br>    lsn     <span class="hljs-operator">|</span>         filename         <span class="hljs-operator">|</span>             lsn_offset<br><span class="hljs-comment">------------+--------------------------+-------------------------------------</span><br> <span class="hljs-number">3</span><span class="hljs-operator">/</span><span class="hljs-number">3</span>A993360 <span class="hljs-operator">|</span> <span class="hljs-number">00000001000000030000003</span>A <span class="hljs-operator">|</span> (<span class="hljs-number">00000001000000030000003</span>A,<span class="hljs-number">10040160</span>)<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><br>mydb<span class="hljs-operator">=</span># <span class="hljs-keyword">insert into</span> t <span class="hljs-keyword">select</span> n, <span class="hljs-string">&#x27;test&#x27;</span> <span class="hljs-operator">||</span> n <span class="hljs-keyword">from</span> generate_series(<span class="hljs-number">1</span>, <span class="hljs-number">550000</span>) <span class="hljs-keyword">as</span> n;                                                        <span class="hljs-keyword">INSERT</span> <span class="hljs-number">0</span> <span class="hljs-number">550000</span><br>mydb<span class="hljs-operator">=</span># <span class="hljs-keyword">select</span> pg_current_wal_lsn() <span class="hljs-keyword">as</span> lsn,  pg_walfile_name(pg_current_wal_lsn()) <span class="hljs-keyword">as</span> filename, pg_walfile_name_offset(pg_current_wal_lsn()) <span class="hljs-keyword">as</span> lsn_offset;<br>    lsn     <span class="hljs-operator">|</span>         filename         <span class="hljs-operator">|</span>            lsn_offset<br><span class="hljs-comment">------------+--------------------------+-----------------------------------</span><br> <span class="hljs-number">3</span><span class="hljs-operator">/</span><span class="hljs-number">3</span>D023F10 <span class="hljs-operator">|</span> <span class="hljs-number">00000001000000030000003</span>D <span class="hljs-operator">|</span> (<span class="hljs-number">00000001000000030000003</span>D,<span class="hljs-number">147216</span>)<br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br></code></pre></td></tr></table></figure><p>看看上边的LSN:   3&#x2F;3D023F10 , 它是一个64位的BIGINT，划分为4部分：<br><img src="/2025/05/05/note/DB/postgresql/PostgreSQL%E4%B8%AD%E7%9A%84WAL/WAL/img_3.png" alt="img_3.png"><br>但是这个023F10也只是个总体的偏移量，要想得到3D这个段文件里头具体哪一块，块内偏移，将这个二进制切成(11bit, 13bit)两部分，分别求值即可。<br><img src="/2025/05/05/note/DB/postgresql/PostgreSQL%E4%B8%AD%E7%9A%84WAL/WAL/img_4.png" alt="img_4.png"><br>为什么上边段号最大是000000FF，然后重新回到00000000，这是因为一个段是16MB, 2^^24，最多总共提供2^^32的空间，只能分成2^^8 &#x3D; 256个段。<br><img src="/2025/05/05/note/DB/postgresql/PostgreSQL%E4%B8%AD%E7%9A%84WAL/WAL/img_5.png" alt="img_5.png">  </p><h5 id="3、64MB-wal-seg下的WAL段文件命名及LSN编码规则"><a href="#3、64MB-wal-seg下的WAL段文件命名及LSN编码规则" class="headerlink" title="3、64MB wal seg下的WAL段文件命名及LSN编码规则"></a>3、64MB wal seg下的WAL段文件命名及LSN编码规则</h5><p><img src="/2025/05/05/note/DB/postgresql/PostgreSQL%E4%B8%AD%E7%9A%84WAL/WAL/img_6.png" alt="img_6.png"><br><img src="/2025/05/05/note/DB/postgresql/PostgreSQL%E4%B8%AD%E7%9A%84WAL/WAL/img_7.png" alt="img_7.png"></p><h5 id="4、-4MB-wal-seg大小下的WAL段文件命名及LSN编码规则"><a href="#4、-4MB-wal-seg大小下的WAL段文件命名及LSN编码规则" class="headerlink" title="4、 4MB wal seg大小下的WAL段文件命名及LSN编码规则"></a>4、 4MB wal seg大小下的WAL段文件命名及LSN编码规则</h5><p><img src="/2025/05/05/note/DB/postgresql/PostgreSQL%E4%B8%AD%E7%9A%84WAL/WAL/img_8.png" alt="img_8.png"><br><img src="/2025/05/05/note/DB/postgresql/PostgreSQL%E4%B8%AD%E7%9A%84WAL/WAL/img_9.png" alt="img_9.png"><br><img src="/2025/05/05/note/DB/postgresql/PostgreSQL%E4%B8%AD%E7%9A%84WAL/WAL/img_10.png" alt="img_10.png">  </p><h5 id="5、默认page-size为16kB下wal段为8MB的分析"><a href="#5、默认page-size为16kB下wal段为8MB的分析" class="headerlink" title="5、默认page size为16kB下wal段为8MB的分析"></a>5、默认page size为16kB下wal段为8MB的分析</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://ftp.postgresql.org/pub/source/v14.7/postgresql-14.7.tar.gz<br>tar zxf postgresql-14.7.tar.gz<br>cd postgresql-14.7<br>su<br>yum install -y readline readline-devel flex bison openssl openssl-devel<br> mkdir build<br> cd build<br> ../configure -with-extra-version=&quot; [Sean]&quot; --prefix=/usr/pgsql-14.7build --with-blocksize=16<br><br>make -j 4 world-bin<br>su -c &quot;make install-world-bin&quot;<br><br>[07:17:13-postgres@sean-rh3:/opt/pg]$ cat env14build.sh<br>export PGROOT=/usr/pgsql-14.7build<br>export PGHOME=/var/lib/pgsql/14<br>export PGPORT=5555<br>export PGDATA=$PGHOME/data<br>export PATH=$PGROOT/bin:$PATH<br>export LD_LIBRARY_PATH=$PGROOT/lib:$LD_LIBRARY_PATH<br></code></pre></td></tr></table></figure><p><img src="/2025/05/05/note/DB/postgresql/PostgreSQL%E4%B8%AD%E7%9A%84WAL/WAL/img_11.png" alt="img_11.png"><br><img src="/2025/05/05/note/DB/postgresql/PostgreSQL%E4%B8%AD%E7%9A%84WAL/WAL/img_12.png" alt="img_12.png"><br><img src="/2025/05/05/note/DB/postgresql/PostgreSQL%E4%B8%AD%E7%9A%84WAL/WAL/img_13.png" alt="img_13.png"><br><img src="/2025/05/05/note/DB/postgresql/PostgreSQL%E4%B8%AD%E7%9A%84WAL/WAL/img_14.png" alt="img_14.png"><br><a href="https://www.postgresql.org/docs/15/app-initdb.html">https://www.postgresql.org/docs/15/app-initdb.html</a></p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
      <category>PostgreSQL</category>
      
      <category>WAL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL中的WAL文件与LSN深入探索和分析</title>
    <link href="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/"/>
    <url>/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>PostgreSQL中MemoryContext机制解析</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><h5 id="1-MemoryContext概述"><a href="#1-MemoryContext概述" class="headerlink" title="1. MemoryContext概述"></a>1. MemoryContext概述</h5><p>MemoryContext 以功能为单位组织起来的树形数据结构，不同的阶段使用不同的 MemoryContext，它的存在是为了更清晰的管理内存。  </p><p>合理管理碎片小内存。频繁的向 OS 申请和释放内存效率是很差的。<br>MemoryContext 会以 trunk 为单位向 OS 申请成块的内存，并管理起来。当程序需求小内存时从 trunk 中分配，<br>用完后归还给对应的 MemoryContext ，并不归还给 OS。<br>赋予内存功能和生命周期属性<br>（1）以功能为单位管理内存。不同功能和阶段使用对应的 MemoryContext。<br>（2）TopTransactionContext：一个事务的生命周期，事务管理相关数据放在 TopTransactionContext，当一个事务提交时该上下文被整个释放。  </p><p>树形的 MemoryContext 结构<br>（1）不同功能间的 MemoryContext 是以为树为单位组织起来的<br>（2）每个数据库后端进程顶层是 TopMemoryContext<br>（3）删除或重置一个 MemoryContext，它的子 MemoryContext 也一并被删除或重置。<br>（4）删除或重置一个 MemoryContext，它的子 MemoryContext 也一并被删除或重置。  </p><h5 id="2-内存上下文相关的四个数据类型"><a href="#2-内存上下文相关的四个数据类型" class="headerlink" title="2. 内存上下文相关的四个数据类型"></a>2. 内存上下文相关的四个数据类型</h5><p>相关数据结构</p><h6 id="2-1-MemoryContext"><a href="#2-1-MemoryContext" class="headerlink" title="2.1 MemoryContext"></a>2.1 MemoryContext</h6><p><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img.png" alt="img.png"><br>下面是该数据类型中各成员变量所代表的含义：  </p><ul><li><p>type – 是一个枚举类型，用于标示内存上下文类型。在默认只有一种类型，T_AllocSetContext。<br>NodeTag声明于src&#x2F;include&#x2F;nodes&#x2F;nodes.h 头文件中，下面列出了与内存上下文节点相关的几个枚举值。<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_1.png" alt="img_1.png">  </p></li><li><p>isReset – 如果为true，表明该上下文自从上次Reset（重置）后没有在上面分配过内存，可以避免一些不必要的操作。如果为false，则表明已经发生内存申请。  </p></li><li><p>allowInCritSection – 是否允许在临界区中分配内存。通常来说是不允许进行这样分配的，分配失败会导致PANIC，但这可以用于调试代码，方便开发调试，这些代码不建议进入实际生成环境中。    </p></li><li><p>mem_allocated – 跟踪为此上下文分配的内存。类似于C++ STL中的size()函数功能。  </p></li><li><p>methods – 记录了内存上下文使用的函数指针。类似于C++中的虚函数（vptr虚函数表），正如前面所言，MemoryContext类似于抽象类，所以存在虚函数是必须具有的。<br>methods的数据类型是MemoryContextMethods ，其结构如下：</p></li></ul><p><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_2.png" alt="img_2.png">  </p><ul><li>parent – 内存上下文的父节点，对于TopMemoryContext，其parent字段为NULL，因为TopMemoryContext是所有内存上下文的父节点。  </li><li>firstchild – 它是树形结构中所有子内存上下文（双向）链表的头节点，TopMemoryContext父节点中的firstchild指针变量永远指向子内存上下文的链表头节点。详情请阅读本文的第4节内容的说明。  </li><li>prevchild – 同一个父节点下（即兄弟节点）的prev指针，用于指向该双向链表节点（这里的节点均指MemoryContext类型的内存上下文）的前一个节点。   </li><li>nextchild – 同一个父节点下（即兄弟节点）的next指针，用于指向该双向链表节点（这里的节点均指MemoryContext类型的内存上下文）的下一个节点。  </li><li>name – 具体MemoryContext的名称，比如对于TopMemoryContext内存上下文，则name即为“TopMemoryContext”，ErrorContext内存上下文，其name成员的值就是“ErrorContext”。不同的MemoryContext具有不同的名称，主要用于调试使用。  </li><li>ident – MemoryContext的ID，主要用于调试使用。  </li><li>reset_cbs – reset&#x2F;delete回调函数列表。它是Postgres 9.5中引入的一项功能，允许将内存上下文用于管理更多资源，而不仅仅是普通的palloc分配的内存。<br>这是通过为内存上下文注册“重置回调函数”来完成的。在下一次重置或删除上下文之前，将调用一次此类函数。它可以用来放弃在某种意义上与上下文中分配的对象相关联的资源。<br>其数据类型为MemoryContextCallback ，结构如下所示：</li></ul><p><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_3.png" alt="img_3.png">  </p><p>在讲解了MemoryContext数据类型之后，下面就是MemoryContext抽象类的具体（也是唯一）实现AllocSetContext，参见本文的2.2节内容。  </p><h6 id="2-2-AllocSetContext"><a href="#2-2-AllocSetContext" class="headerlink" title="2.2 AllocSetContext"></a>2.2 AllocSetContext</h6><p>AllocSetContext是MemoryContext的标准实现。其结构如下：<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_4.png" alt="img_4.png"><br>下面将对这个AllocSetContext数据类型中的各成员进行讲解：  </p><ul><li>header – 标准的内存上下文区域，即抽象类型MemoryContext（可理解为子类对象中的基类对象的内存区域。），通过这个字段可以区分各内存上下文的层次关系（如本文第4节中的示意图所示）。  </li><li>blocks – 内存块链表，记录内存上下文向操作系统申请的连续大块内存。它是实际分配内存的地方，AllocSetContext中内存的分配是以Block（块）为单位向OS申请的，多个Block之间以单链表的方式连接起来。此blocks是单链表的头节点，在清除内存上下文时从它开始遍历整个链表，是否所有的Block中的内存。  </li><li>freelist – 组织该内存上下文里所有内存块中已释放的内存片的链表结构。它是一个数组成员，其数组大小是ALLOCSET_NUM_FREELISTS（该值是11）。freelist数组中各成员分别表示不同大小的AllocChunkData。在AllocSetContext的实现中，对于小的内存块（8 ~ 8192Byte）来说，当释放的时候不会归还给OS，而是将其缓存到freelist中。  </li><li>initBlockSizeBlock的初始化大小，默认8KB。  </li><li>maxBlockSizeBlock的最大大小。  </li><li>nextBlockSize下一个Block的大小。  </li><li>allocChunkLimit内存片的阈值，申请的内存超过此阀值直接分配新的block。  </li><li>keeper为防止一些需要频繁重置的小的内存上下文重复的进行malloc，重置时保留第一次申请的内存块。  </li><li>freeListIndex – 在context_freelists全局数组中的顺序，0表示默认freelist，1表示小内存的freelist，-1表示不需要进入freelist（比如超过allocChunkLimit的Block）。<br>context_freelists的的数据类型是AllocSetFreeList ，结构如下所示：<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_5.png" alt="img_5.png"></li></ul><p>注意：上面的AllocSetFreeList和AllocSetContext中的freelist不同，这里指的是空闲的AllocSetContextData，而非AllocChunkData。当发生delete时候，会将删除后的AllocSetContextData放入到AllocSetFreeList。  </p><h6 id="2-3-AllocBlockData"><a href="#2-3-AllocBlockData" class="headerlink" title="2.3 AllocBlockData"></a>2.3 AllocBlockData</h6><p>PostgreSQL向OS申请内存分配的基本单位是Block（块），一个Block可能被拆分为若干个Chunk，也可能只包含一个Chunk（比如较大块内存）。在chunk释放时候会放入freelist链表中，以便于下次分配，最后由Block统一释放归还给OS。<br>AllocBlockData的结构如下图所示：<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_6.png" alt="img_6.png"><br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_8.png" alt="img_8.png">  </p><h6 id="2-4-AllocChunkData"><a href="#2-4-AllocChunkData" class="headerlink" title="2.4 AllocChunkData"></a>2.4 AllocChunkData</h6><p>AllocChunkData是AllocBlockData中每段内存的前缀。<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_7.png" alt="img_7.png"><br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_9.png" alt="img_9.png">  </p><h5 id="3-启动内存上下文子系统"><a href="#3-启动内存上下文子系统" class="headerlink" title="3. 启动内存上下文子系统"></a>3. 启动内存上下文子系统</h5><p>这必须在创建上下文或在上下文中分配内存之前调用。TopMemoryContext和ErrorContext在这里初始化；之后必须创建其他内存上下文。  </p><h6 id="3-1-初始化内存上下文"><a href="#3-1-初始化内存上下文" class="headerlink" title="3.1 初始化内存上下文"></a>3.1 初始化内存上下文</h6><p><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_10.png" alt="img_10.png">  </p><p>CurrentMemoryContext、ErrorContext、PostmasterContext、CacheMemoryContext、MessageContext、TopTransactionContext、CurTransactionContext和PortalContext均作为TopMemoryContext的子上下文。<br>它们之间以树的形式进行分布与管理，这几个内存上下文之间的关系如图所示：<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_11.png" alt="img_11.png"><br>函数 MemoryContextInit 的实现如下：(postgresql-12.1\src\backend\utils\mmgr\mcxt.c)  </p><h6 id="3-2-初始化-TopMemoryContext"><a href="#3-2-初始化-TopMemoryContext" class="headerlink" title="3.2 初始化 TopMemoryContext"></a>3.2 初始化 TopMemoryContext</h6><p>首先，需要初始化TopMemoryContext内存上下文，因为它是所有其他内存上下文的父节点。<br>其初始化功能由函数AllocSetContextCreate()完成，该函数支持五个参数，其函数原型如下：<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_12.png" alt="img_12.png">  </p><p>由于是初始化TopMemoryContext内存上下文，所以第二个参数就以该内存上下文变量为名称（TopMemoryContext）。在这里，ALLOCSET_DEFAULT_SIZES是一个宏定义，其声明于文件src&#x2F;include&#x2F;utils&#x2F;memutils.h中。如下：<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_13.png" alt="img_13.png">  </p><p>AllocSetContextCreateInternal 实现解析：<br>postgresql-12.1\src\backend\utils\mmgr\aset.c  </p><p>####### 3.2.1 断言正确填充AllocChunkData<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_14.png" alt="img_14.png"><br>StaticAssertStmt()函数类似于C++11中的static_assert断言宏，它接收两个参数，第一个参数是判别式，需要为true；第二个参数是在第一个判别式为false情况下进行的错误字符串信息打印，并终止进程。<br>因此这里若表达式 ALLOC_CHUNKHDRSZ &#x3D;&#x3D; MAXALIGN(ALLOC_CHUNKHDRSZ不为true 的时候，打印”sizeof(AllocChunkData) is not maxaligned”，并终止进程。<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_15.png" alt="img_15.png"><br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_16.png" alt="img_16.png"><br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_17.png" alt="img_17.png">  </p><p>MAXIMUM_ALIGNOF的值是8，(???声明于Solution.pm文件中。)<br>因此，若sizeof(struct AllocChunkData)的值为8，则通过TYPEALIGN()宏的调用及内部位运算之后得到的值也是8，<br>即表达式ALLOC_CHUNKHDRSZ &#x3D;&#x3D; MAXALIGN(ALLOC_CHUNKHDRSZ为true，说明我们正确地填充了AllocChunkData，即struct AllocChunkData。  </p><p><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_18.png" alt="img_18.png">  </p><p>####### 3.2.2 对参数进行校验<br>这里接着对函数AllocSetContextCreateInternal()中的第三、四、五个参数进行校验，用来判别其值是否合理、对齐。<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_19.png" alt="img_19.png">  </p><p>函数AllocHugeSizeIsValid()是一个函数宏，声明于memutils.h文件中，用于检验“初始化最大分配块大小（maxBlockSize）”不能超过一定阈值。如下：<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_20.png" alt="img_20.png"><br>宏SIZE_MAX 声明于exprscan.c文件中：<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_21.png" alt="img_21.png">  </p><p>####### 3.2.3 检查参数是否与freelist匹配<br>这里是对TomMemoryContext内存上下文进行初始化，且其实参是minContextSize &#x3D; 0，initBlockSize &#x3D; 8 * 1024。所以freeListIndex &#x3D; 0。<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_22.png" alt="img_22.png"><br>freeListIndex用于对全局结构体数组变量（context_freelists）中的成员进行释放操作，该结构体后面会详细说明。  </p><p>####### 3.2.4 如果有匹配的freelist，则释放其空间<br>由于这里freeListIndex &#x3D; 0，所以得到的freelist指针变量中其成员变量first_free的值为NULL，不会进入if (freelist-&gt;first_free !&#x3D; NULL)的函数体中。<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_23.png" alt="img_23.png">  </p><p>####### 3.2.5 确定初始化块大小<br>ALLOC_BLOCKHDRSZ 和ALLOC_CHUNKHDRSZ都是一个宏，分别是等价于sizeof(AllocBlockData)和sizeof(struct AllocChunkData)。其中AllocBlockData声明如下：<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_24.png" alt="img_24.png"><br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_25.png" alt="img_25.png"><br>实参minContextSize 的值为0，所以走else{}分支。其中initBlockSize的值是8KB，<br>显然这里的MAXALIGN(sizeof(AllocSetContext)) + ALLOC_BLOCKHDRSZ + ALLOC_CHUNKHDRSZ值是小于8KB的，因此firstBlockSize 最终的值是8KB。<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_26.png" alt="img_26.png">  </p><p>####### 3.2.6 分配AllocSetContextData块<br>在得到了初始化块分配大小（firstBlockSize，8KB）之后，接下来就需要为我们的set申请内存空间，然后将这片内存地址强制转换为AllocSet类型。在这里需要对其内存申请结果状态信息进行判断。<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_27.png" alt="img_27.png"><br>如果set的值为NULL，表明系统内存不足，申请失败。此时需要对TopMemoryContext内存向下文及其所有的子内存上下文进行打印其统计信息处理。<br>由函数MemoryContextStats()负责，同时打印相应的错误日志提示信息。函数MemoryContextStats()实现如下：<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_28.png" alt="img_28.png"><br>函数MemoryContextStatsDetail()实现如下：<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_29.png" alt="img_29.png"><br>在该函数体实现中，有一个新的结构体数据类型MemoryContextCounters ，它声明于memnodes.h(src&#x2F;include&#x2F;nodes&#x2F;memnodes.h)头文件中，详情如下：<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_30.png" alt="img_30.png"><br>在函数MemoryContextStatsDetail()内部间接调用MemoryContextStatsInternal()来进行子内存上下文的状态信息统计。<br>关于该函数的内部实现将不进行过多展开，只需要知道该函数内部完成TopMemoryContext中所有子内存上下文的状态信息（总空间、已使用空间、空闲空间等）统计。</p><p>####### 3.2.7 填写初始块的块头<br>当set内存申请成功后，它位于8KB的内存空间的头部。紧接着在set（AllocSet）数据类型的后面分配一个AllocBlock数据类型大小的空间。<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_31.png" alt="img_31.png"><br>同时使set中的成员blocks和keeper指向新分配的block变量的位置。并使用函数AllocSetContextCreateInternal()中提供的参数来<br>初始化set中的成员变量initBlockSize、maxBlockSize等。并将set中的成员数组freelist的值全部初始化零操作（freelist数组大小是11）。<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_32.png" alt="img_32.png"><br>当set（AllocSet类型）指针变量内存空间申请成功、以及block初始化完成之后，其set和block（AllocBlock）之间的关联示意图如下所示：<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_33.png" alt="img_33.png">  </p><p>####### 3.2.8 计算内存上下文分配内存片大小限制<br>接下来计算指定的内存上下文中的分配内存片大小限制。由于freelist成员数组大小固定（为数组大小是11），它不能超过ALLOC_CHUNK_LIMIT（8192Byte）。<br>如果 maxBlockSize 很小，那么超过 maxBlockSize 甚至很大一部分的请求也应该被视为大内存片。对于maxBlockSize的2次方的典型情况，<br>内存片大小的限制最多为maxBlockSize的1&#x2F;8，因此，给定一个全部为最大块内存片大小的请求流，我们最多会浪费1&#x2F;8的分配空间。<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_34.png" alt="img_34.png"><br>们必须让allocChunkLimit是2的幂，因为任何内存片的请求大小和实际分配的大小都必须在限制的同一侧，否则我们会对该内存片是否 “big “感到困惑。<br>此外，allocChunkLimit不能超过ALLOCSET_SEPARATE_THRESHOLD（8192Byte）。<br>接下来要执行最为重要的一步就是初始化set指针变量中的其他成员的初始化操作。以及如果本次是非TopMemoryText内存上下文的初始化操作，<br>则需要将新创建的set添加到TopMemoryContext中。详细过程见3.2.9节内容。  </p><p>####### 3.2.9 执行与类型无关的上下文创建部分<br>执行与类型无关的内存上下文创建部分主要由函数MemoryContextCreate()负责完成，如下所示。<br>其中：<br>参数set是指向malloc的（8KB）内存空间地址，<br>T_AllocSetContext是该set的类型；<br>AllocSetMethods是一个指针数组，里面的各成员是函数指针，表明用来对内存上下文进行相关操作的函数实现；<br>parent是该内存上下文的父亲，如果是本次创建的内存上下文是TopMemoryContext，则parent参数为NULL；<br>name是该内存上下文的名字。<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_35.png" alt="img_35.png"><br>实现如下：<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_36.png" alt="img_36.png"><br>该函数执行完成之后，其初始化效果如下图所示：<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_37.png" alt="img_37.png"><br>之后，重新初始化mem_allocated的值为firstBlockSize大小。并将set强制类型转换为MemoryContext。<br>并返回上层调用的具体待初始化的内存上下文，比如TopMemoryContext，或ErrorContext、PostmasterContext等。<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_38.png" alt="img_38.png"><br>在执行完成TopMemoryContext内存上下文的初始化操作之后，接下来就是初始化ErrorContext，在该内存上下文初始化之后，其与TopMemoryContext之间的关联如下图所示：<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_39.png" alt="img_39.png"><br>紧接着执行PostmasterContext内存上下文的初始化，在初始化完成之后，其与TopMemoryContext、ErrorContext间的关联如下图所示：<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_40.png" alt="img_40.png">  </p><h5 id="4-内存上下文树形图"><a href="#4-内存上下文树形图" class="headerlink" title="4. 内存上下文树形图"></a>4. 内存上下文树形图</h5><p>在本文的第1节中也曾提到过，Mmeory Context是以树形结构来组织各内存上下文之间的关联关系。其中TopMemoryContext内存上下文是所有其他内存上下文的父（根）节点，<br>其中firstchild指针变量用于指向该节点的第一个孩子（内存上下文）节点。之后通过prevchild和nextchild指针变量可以分别向后、向前变量位于TopMemoryContext下的所有子内存上下文节点，就向一个双向链表。<br>此外，对于TopMemoryContext的子内存上下文节点，采用的是“前插法”的方式添加，详细细节如下图所示：<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_41.png" alt="img_41.png"><br>把ErrorContext、PostmasterContext和MessageContext这三个内存上下文中的parent指针变量的指向由折线修改为直线后的效果图如下所示：<br><img src="/2025/05/05/note/DB/postgresql/MemoryContext%E5%88%86%E6%9E%90/MemoryContext/img_42.png" alt="img_42.png">  </p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
      <category>PostgreSQL</category>
      
      <category>MemoryContext</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL pg_recovery 拓展插件</title>
    <link href="/2025/05/05/note/DB/postgresql/extension/PgExtension/pg_recovery/pg_recovery/"/>
    <url>/2025/05/05/note/DB/postgresql/extension/PgExtension/pg_recovery/pg_recovery/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PostgreSQL pg_recovery 拓展插件</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#%E4%B8%80%E6%9D%A1SQL%E5%AE%9E%E7%8E%B0PostgreSQL%E6%95%B0%E6%8D%AE%E6%89%BE%E5%9B%9E">1. 一条 SQL 实现 PostgreSQL 数据找回</a><br><a href="pg_recovery%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB">2. pg_recovery 设计原理与源码解读</a></p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="一条SQL实现PostgreSQL数据找回"><a href="#一条SQL实现PostgreSQL数据找回" class="headerlink" title="一条SQL实现PostgreSQL数据找回"></a>一条SQL实现PostgreSQL数据找回</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">快速找回丢失数据，是数据库的一项重要功能需求，一般建议使用官方推荐的工具。面向开源数据库，生态中也出现很多好用的开源工具。<br><br>PostgreSQL 是非常流行的开源数据库，接下来介绍一款近期在社区开源的 PostgreSQL 数据找回工具 pg_recovery ，并实例演示如何找回误操作而丢失的数据。<br></code></pre></td></tr></table></figure><h4 id="什么是-pg-recovery"><a href="#什么是-pg-recovery" class="headerlink" title="什么是 pg_recovery?"></a>什么是 pg_recovery?</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">pg_recovery 是一款 PostgreSQL 数据找回工具。可以恢复 COMMIT / DELETE / UPDATE / ROLLBACK / DROP COLUMN 操作后导致的数据变化，并以表的形式返回。安装方便，操作简单。仓库地址：https://github.com/radondb/pg_recovery<br></code></pre></td></tr></table></figure><h5 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">根据环境配置 PG_CONFIG。<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make PG_CONFIG=/home/lzzhang/PG/postgresql/base/bin/pg_config</span><br>gcc -Wall -Wmissing-prototypes -Wpointer-arith -Wdeclaration-after-statement -Werror=vla -Wendif-labels -Wmissing-format-attribute -Wformat-security -fno-strict-aliasing -fwrapv -fexcess-precision=standard -Wno-format-truncation -Wno-stringop-truncation -g -g -O0 -fPIC -I. -I./ -I/home/lzzhang/PG/postgresql/base/include/server -I/home/lzzhang/PG/postgresql/base/include/internal  -D_GNU_SOURCE   -c -o pg_recovery.o pg_recovery.c<br>gcc -Wall -Wmissing-prototypes -Wpointer-arith -Wdeclaration-after-statement -Werror=vla -Wendif-labels -Wmissing-format-attribute -Wformat-security -fno-strict-aliasing -fwrapv -fexcess-precision=standard -Wno-format-truncation -Wno-stringop-truncation -g -g -O0 -fPIC -shared -o pg_recovery.so pg_recovery.o -L/home/lzzhang/PG/postgresql/base/lib    -Wl,--as-needed -Wl,-rpath,&#x27;/home/lzzhang/PG/postgresql/base/lib&#x27;,--enable-new-dtags  <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make install PG_CONFIG=/home/lzzhang/PG/postgresql/base/bin/pg_config</span><br>/usr/bin/mkdir -p &#x27;/home/lzzhang/PG/postgresql/base/lib&#x27;<br>/usr/bin/mkdir -p &#x27;/home/lzzhang/PG/postgresql/base/share/extension&#x27;<br>/usr/bin/mkdir -p &#x27;/home/lzzhang/PG/postgresql/base/share/extension&#x27;<br>/usr/bin/install -c -m 755  pg_recovery.so &#x27;/home/lzzhang/PG/postgresql/base/lib/pg_recovery.so&#x27;<br>/usr/bin/install -c -m 644 .//pg_recovery.control &#x27;/home/lzzhang/PG/postgresql/base/share/extension/&#x27;<br>/usr/bin/install -c -m 644 .//pg_recovery--1.0.sql  &#x27;/home/lzzhang/PG/postgresql/base/share/extension/&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 初始化插件成功，返回如下信息。</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">create extension pg_recovery ;</span><br>CREATE EXTENSION<br></code></pre></td></tr></table></figure><h4 id="数据找回演示"><a href="#数据找回演示" class="headerlink" title="数据找回演示"></a>数据找回演示</h4><h5 id="1-准备初始化数据"><a href="#1-准备初始化数据" class="headerlink" title="1. 准备初始化数据"></a>1. 准备初始化数据</h5><p>准备表和一些数据  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create table</span> lzzhang(id <span class="hljs-type">int</span>, dp <span class="hljs-type">int</span>);<br><span class="hljs-keyword">insert into</span> lzzhang <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert into</span> lzzhang <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h5 id="2-找回-UPDATE-数据"><a href="#2-找回-UPDATE-数据" class="headerlink" title="2. 找回 UPDATE 数据"></a>2. 找回 UPDATE 数据</h5><p>对数据进行变更操作，不加 WHERE 条件。<br><img src="/2025/05/05/note/DB/postgresql/extension/PgExtension/pg_recovery/pg_recovery/image.png" alt="Alt text">  </p><h5 id="3-找回-DELETE-数据"><a href="#3-找回-DELETE-数据" class="headerlink" title="3. 找回 DELETE 数据"></a>3. 找回 DELETE 数据</h5><p>尝试恢复 DELETE 的数据。<br><img src="/2025/05/05/note/DB/postgresql/extension/PgExtension/pg_recovery/pg_recovery/image-1.png" alt="Alt text">  </p><h5 id="4-找回-ROLLBACK-数据"><a href="#4-找回-ROLLBACK-数据" class="headerlink" title="4. 找回 ROLLBACK 数据"></a>4. 找回 ROLLBACK 数据</h5><p>尝试恢复回滚操作之前的数据。<br><img src="/2025/05/05/note/DB/postgresql/extension/PgExtension/pg_recovery/pg_recovery/image-2.png" alt="Alt text">  </p><h5 id="5-找回-DROP-COLUMN-数据"><a href="#5-找回-DROP-COLUMN-数据" class="headerlink" title="5. 找回 DROP COLUMN 数据"></a>5. 找回 DROP COLUMN 数据</h5><p>尝试恢复表中被删除的列及数据。<br><img src="/2025/05/05/note/DB/postgresql/extension/PgExtension/pg_recovery/pg_recovery/image-3.png" alt="Alt text">  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql">$ <span class="hljs-keyword">alter table</span> lzzhang <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> dp;<br><span class="hljs-keyword">ALTER TABLE</span><br>$ <span class="hljs-keyword">select</span> attnum <span class="hljs-keyword">from</span> pg_attribute, pg_class <span class="hljs-keyword">where</span> attrelid <span class="hljs-operator">=</span> pg_class.oid <span class="hljs-keyword">and</span> pg_class.relname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;lzzhang&#x27;</span> <span class="hljs-keyword">and</span> attname <span class="hljs-operator">~</span> <span class="hljs-string">&#x27;dropped&#x27;</span>;<br> attnum <br><span class="hljs-comment">--------</span><br>      <span class="hljs-number">2</span><br>(<span class="hljs-number">1</span> <span class="hljs-type">row</span>)<br><br>$ <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> lzzhang;<br> id <br><span class="hljs-comment">----</span><br>(<span class="hljs-number">0</span> <span class="hljs-keyword">rows</span>)<br><br>$ <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> pg_recovery(<span class="hljs-string">&#x27;lzzhang&#x27;</span>) <span class="hljs-keyword">as</span> (id <span class="hljs-type">int</span>, dropped_attnum_2 <span class="hljs-type">int</span>);<br> id <span class="hljs-operator">|</span> dropped_attnum_2 <br><span class="hljs-comment">----+------------------</span><br>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span>                <span class="hljs-number">1</span><br>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span>                <span class="hljs-number">2</span><br>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span>                <span class="hljs-number">3</span><br>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span>                <span class="hljs-number">3</span><br>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span>                <span class="hljs-number">4</span><br>(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)<br><br><span class="hljs-comment">-- dropped_attnum_2: if the drop attnum is 5, set dropped_attnum_2 to dropped_attnum_5</span><br></code></pre></td></tr></table></figure><h5 id="6-显示找回数据"><a href="#6-显示找回数据" class="headerlink" title="6. 显示找回数据"></a>6. 显示找回数据</h5><p>显示该表历史上所有写入过的数据。<br><img src="/2025/05/05/note/DB/postgresql/extension/PgExtension/pg_recovery/pg_recovery/image-4.png" alt="Alt text">  </p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><h5 id="支持的-PostgreSQL-版本"><a href="#支持的-PostgreSQL-版本" class="headerlink" title="支持的 PostgreSQL 版本"></a>支持的 PostgreSQL 版本</h5><p>目前 pg_revovery工具已支持 PostgreSQL 12&#x2F;13&#x2F;14 。  </p><h5 id="可恢复事务数"><a href="#可恢复事务数" class="headerlink" title="可恢复事务数"></a>可恢复事务数</h5><p>PostgreSQL 通过参数 vacuum_defer_cleanup_age 值大小，可限制可恢复的事务数。如果预期需要恢复的数据量较大，可通过配置参数值，提高可恢复的事务数。  </p><p>pg_recovery 通过读取 PostgreSQL dead 元组来恢复不可见的表数据。如果元组被 vacuum 清除掉，那么 pg_recovery 便不能恢复数据。  </p><h5 id="锁请求"><a href="#锁请求" class="headerlink" title="锁请求"></a>锁请求</h5><p>pg_recovery 使用期间，支持正常的读表的锁请求。此外 pg_recovery未使用期间，不会对数据库造成任何额外的开销或是影响，无需暂停服务。  </p><h3 id="pg-recovery设计原理与源码解读"><a href="#pg-recovery设计原理与源码解读" class="headerlink" title="pg_recovery设计原理与源码解读"></a>pg_recovery设计原理与源码解读</h3><h4 id="数据找回的实现原理"><a href="#数据找回的实现原理" class="headerlink" title="数据找回的实现原理"></a>数据找回的实现原理</h4><p>一个数据库系统正常的数据读取方式，是从做 select * from pg_recovery 的查询开始（即执行事务），执行查询操作过程将同时生成事务的快照，通过 GetActiveSnapshot()函数，便可以看到当前可见的数据。  </p><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><h5 id="1-如何读取-Dead-元组？"><a href="#1-如何读取-Dead-元组？" class="headerlink" title="1. 如何读取 Dead 元组？"></a>1. 如何读取 Dead 元组？</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">PostgreSQL 通过 快照 来决定当前数据库数据的可见性，因此当一条数据被删除时，数据的实体仍然存在于数据库实例中，通常管这种不可见的数据叫做 Dead 元组（PostgreSQL 中一条数据称为一个元组）。<br><br>PostgreSQL 中提供了 SnapshotAny 的特殊快照（还有很多其他类型）。这个快照可以读取任何数据，pg_recovery 便是通过该方式读取的所有数据。默认情况下，只返回 recovery 的数据，不返回可见的数据。<br></code></pre></td></tr></table></figure><h5 id="2-函数一次返回多少数据？"><a href="#2-函数一次返回多少数据？" class="headerlink" title="2. 函数一次返回多少数据？"></a>2. 函数一次返回多少数据？</h5><p>数据量是按行返回的，并且每次限定一行。  </p><h5 id="3-如何控制内存？"><a href="#3-如何控制内存？" class="headerlink" title="3. 如何控制内存？"></a>3. 如何控制内存？</h5><p>函数会多次执行，而有些状态是全局级的。因此可以使用 multi_call_memory_ctx （内存池的上下文）参数，来控制内存。  </p><h5 id="关于函数的参数"><a href="#关于函数的参数" class="headerlink" title="关于函数的参数"></a>关于函数的参数</h5><p>通过 SQL 创建函数时，执行如下语句。函数使用请参照上一期内容。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> pg_recovery(regclass, recoveryrow bool <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">true</span>) <span class="hljs-keyword">RETURNS</span> SETOF record<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">regclass：PostgreSQL 的表类型，会将表名自动转换成 OID（OID 数据库内部对象的唯一标识），因此只需输入表名即可。<br><br>reconveryrow bool DEFAULT ture：默认值 true，表示只返回 recovery 数据。取值 false, 表示返回所有数据。<br>执行下列语句，修改参数默认值<br>select * from pg_recovery(&#x27;aa&#x27;, recoveryrow =&gt; false)<br><br>RETURNS SETOF record：函数返回行类型数据。<br></code></pre></td></tr></table></figure><h4 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h4><h5 id="必要的数据"><a href="#必要的数据" class="headerlink" title="必要的数据"></a>必要的数据</h5><p><img src="/2025/05/05/note/DB/postgresql/extension/PgExtension/pg_recovery/pg_recovery/image-5.png" alt="Alt text">  </p><h5 id="隐藏列"><a href="#隐藏列" class="headerlink" title="隐藏列"></a>隐藏列</h5><p>增加 recoveryrow 的隐藏列，当返回全部信息时，通过此列可以辨别出该行数据是 recovery 的数据，还是用户可见的数据。<br><img src="/2025/05/05/note/DB/postgresql/extension/PgExtension/pg_recovery/pg_recovery/image-6.png" alt="Alt text">  </p><h5 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h5>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
      <category>PostgreSQL</category>
      
      <category>extension</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL pg_pageinspect 拓展插件</title>
    <link href="/2025/05/05/note/DB/postgresql/extension/PgExtension/pageinspect/PageInspect/"/>
    <url>/2025/05/05/note/DB/postgresql/extension/PgExtension/pageinspect/PageInspect/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PostgreSQL pg_pageinspect 拓展插件</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#Postgresql%E7%9A%84pageinspect%E6%8F%92%E4%BB%B6%E6%A1%86%E6%9E%B6">1. Postgresql的pageinspect插件框架</a><br><a href="#%E4%BD%BF%E7%94%A8pageinspect%E7%A0%94%E7%A9%B6PostgreSQL%E7%9A%84infomask">2. 使用pageinspect研究PostgreSQL的infomask</a></p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="Postgresql的pageinspect插件框架"><a href="#Postgresql的pageinspect插件框架" class="headerlink" title="Postgresql的pageinspect插件框架"></a>Postgresql的pageinspect插件框架</h3><h4 id="1、插件源码分析"><a href="#1、插件源码分析" class="headerlink" title="1、插件源码分析"></a>1、插件源码分析</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">pageinspect是一个非常典型、简单的插件，大部分流程可以学习、复用。<br><br>如果需要写新的插件，可以直接<span class="hljs-keyword">copy</span>修改下面两个函数，大部分框架代码可以直接使用。<br></code></pre></td></tr></table></figure><h5 id="get-raw-page读取页面的经典流程"><a href="#get-raw-page读取页面的经典流程" class="headerlink" title="get_raw_page读取页面的经典流程"></a>get_raw_page读取页面的经典流程</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">get_raw_page 只返回一行数据，所以无需走插件循环产生元组的流程。<br><br>读取页面的经典流程：<br><br><span class="hljs-number">1</span>、<span class="hljs-keyword">schema</span>+<span class="hljs-keyword">table</span>名包装：makeRangeVarFromNameList<br><span class="hljs-number">2</span>、打开表：relation_openrv<br><span class="hljs-number">3</span>、读页面（返回pin住的页面）：ReadBufferExtended<br><span class="hljs-number">4</span>、页面加锁：LockBuffer<br><span class="hljs-number">5</span>、读取数据：memcpy<br><span class="hljs-number">6</span>、页面解锁：LockBuffer<br><span class="hljs-number">7</span>、释放页面（unpin）：ReleaseBuffer<br><span class="hljs-number">8</span>、关闭表：relation_close<br></code></pre></td></tr></table></figure><p><img src="/2025/05/05/note/DB/postgresql/extension/PgExtension/pageinspect/PageInspect/image.png" alt="get_raw_page">  </p><h5 id="heap-page-items"><a href="#heap-page-items" class="headerlink" title="heap_page_items"></a>heap_page_items</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">如果插件需要返回多行数据，这里是一个典型的PG插件框架：<br></code></pre></td></tr></table></figure><p><img src="/2025/05/05/note/DB/postgresql/extension/PgExtension/pageinspect/PageInspect/image-1.png" alt="heap_page_items">  </p><h4 id="2、恢复数据探索"><a href="#2、恢复数据探索" class="headerlink" title="2、恢复数据探索"></a>2、恢复数据探索</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">遇到一个客户刚刚删除一条数据，问有没有快捷的方法可以查到被删数据的某个字段？<br>这里尝试使用pageinspect做恢复实验。<br><br>结论先行：<br><br><span class="hljs-number">1</span>、使用pageinspect的data字段是可以反转为原数据的，但是前提是data字段还在。<br><span class="hljs-number">2</span>、即使没有<span class="hljs-keyword">vacuum</span>，下一次对删除数据所在页面的读写，都可能对页面进行purne，导致删除数据不再能被pageinspect发现。<br><span class="hljs-number">3</span>、使用pageinspect恢复数据可行性不大。<br></code></pre></td></tr></table></figure><p>实验数据：  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create table</span> t21(id <span class="hljs-type">int</span>, d1 <span class="hljs-type">int</span>, d2 <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>), d3 text);<br><span class="hljs-keyword">alter table</span> t21 <span class="hljs-keyword">set</span> ( autovacuum_enabled <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, toast.autovacuum_enabled <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">insert into</span> t21 <span class="hljs-keyword">select</span> a, a<span class="hljs-operator">+</span><span class="hljs-number">100</span>, <span class="hljs-string">&#x27;aA012345&#x27;</span>,md5(random()::text) <span class="hljs-keyword">from</span> generate_series(<span class="hljs-number">1</span>,<span class="hljs-number">10000</span>) a;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t21;<br>  id   <span class="hljs-operator">|</span>  d1   <span class="hljs-operator">|</span>    d2    <span class="hljs-operator">|</span>                d3                <br><span class="hljs-comment">-------+-------+----------+----------------------------------</span><br>     <span class="hljs-number">1</span> <span class="hljs-operator">|</span>   <span class="hljs-number">101</span> <span class="hljs-operator">|</span> aA012345 <span class="hljs-operator">|</span> e10022e0fa6ecece950a1ab20caac824<br>     <span class="hljs-number">2</span> <span class="hljs-operator">|</span>   <span class="hljs-number">102</span> <span class="hljs-operator">|</span> aA012345 <span class="hljs-operator">|</span> <span class="hljs-number">7</span>c963b472d452c4dde9d36760b41a8de<br>     <span class="hljs-number">3</span> <span class="hljs-operator">|</span>   <span class="hljs-number">103</span> <span class="hljs-operator">|</span> aA012345 <span class="hljs-operator">|</span> <span class="hljs-number">8142</span>f1299d5cf7e384e7b3c43076710d<br>     <span class="hljs-number">4</span> <span class="hljs-operator">|</span>   <span class="hljs-number">104</span> <span class="hljs-operator">|</span> aA012345 <span class="hljs-operator">|</span> c3c76a8c0cf98e6004051b3bfe415310<br>     <span class="hljs-number">5</span> <span class="hljs-operator">|</span>   <span class="hljs-number">105</span> <span class="hljs-operator">|</span> aA012345 <span class="hljs-operator">|</span> <span class="hljs-number">163214</span>ae0c27f387d0207e89210e5a57<br>     <span class="hljs-number">6</span> <span class="hljs-operator">|</span>   <span class="hljs-number">106</span> <span class="hljs-operator">|</span> aA012345 <span class="hljs-operator">|</span> <span class="hljs-number">302</span>cb39b8ebc649d045f2a1123d379bb<br>     <span class="hljs-number">7</span> <span class="hljs-operator">|</span>   <span class="hljs-number">107</span> <span class="hljs-operator">|</span> aA012345 <span class="hljs-operator">|</span> be22d7234058e2e9247911c011eef47f<br>     <span class="hljs-number">8</span> <span class="hljs-operator">|</span>   <span class="hljs-number">108</span> <span class="hljs-operator">|</span> aA012345 <span class="hljs-operator">|</span> <span class="hljs-number">7</span>fe88087d8d6fea4470eece997f49360<br>     <span class="hljs-number">9</span> <span class="hljs-operator">|</span>   <span class="hljs-number">109</span> <span class="hljs-operator">|</span> aA012345 <span class="hljs-operator">|</span> <span class="hljs-number">279</span>eb01c225b71b083b5df2d9bd87d7b<br>    <span class="hljs-number">10</span> <span class="hljs-operator">|</span>   <span class="hljs-number">110</span> <span class="hljs-operator">|</span> aA012345 <span class="hljs-operator">|</span> <span class="hljs-number">0463</span>ef122689cb78f795c6d4309f3565<br>    <span class="hljs-number">11</span> <span class="hljs-operator">|</span>   <span class="hljs-number">111</span> <span class="hljs-operator">|</span> aA012345 <span class="hljs-operator">|</span> <span class="hljs-number">1587</span>dd3d027b6fda21d97085369434d7<br></code></pre></td></tr></table></figure><p>实验过程：<br>删除5页面数据<br>delete from t21 where ctid&#x3D;’(5,3)’;<br>DELETE 1<br>观察当前页面状态，data还在:<br><img src="/2025/05/05/note/DB/postgresql/extension/PgExtension/pageinspect/PageInspect/image-2.png" alt="Alt text"><br><img src="/2025/05/05/note/DB/postgresql/extension/PgExtension/pageinspect/PageInspect/image-3.png" alt="Alt text"><br><img src="/2025/05/05/note/DB/postgresql/extension/PgExtension/pageinspect/PageInspect/image-4.png" alt="Alt text"><br><img src="/2025/05/05/note/DB/postgresql/extension/PgExtension/pageinspect/PageInspect/image-5.png" alt="Alt text">  </p><h3 id="使用pageinspect研究PostgreSQL的infomask"><a href="#使用pageinspect研究PostgreSQL的infomask" class="headerlink" title="使用pageinspect研究PostgreSQL的infomask"></a>使用pageinspect研究PostgreSQL的infomask</h3>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
      <category>PostgreSQL</category>
      
      <category>extension</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL中的keepalive</title>
    <link href="/2025/05/05/note/DB/postgresql/conf/keepalive/"/>
    <url>/2025/05/05/note/DB/postgresql/conf/keepalive/</url>
    
    <content type="html"><![CDATA[<h2 id="xx"><a href="#xx" class="headerlink" title="xx"></a>xx</h2><p>TCP keepalive for a better PostgreSQL experience</p><p>TCP keepalive 以获得更好的 PostgreSQL 体验</p><p>本文主要内容如下：</p><table><thead><tr><th>Chapter Contents</th><th>sub Chapter</th></tr></thead><tbody><tr><td><a href="#cp1">1 Reasons for broken connections</a></td><td><a href="#cp1.1">1.1 Database server crashes</a></td></tr><tr><td></td><td><a href="#cp1.2">1.2 Connections abandoned by the client</a></td></tr><tr><td></td><td><a href="#cp1.3">1.3 Connections closed by a network component</a></td></tr><tr><td><a href="#cp2">2 What is TCP keepalive?</a></td><td></td></tr><tr><td><a href="#cp3">3 TCP keepalive default settings</a></td><td></td></tr><tr><td><a href="#cp4">4 Using TCP keepalive to keep an idle database session alive</a></td><td></td></tr><tr><td><a href="#cp5">5 Using TCP keepalive to detect dead connections</a></td><td></td></tr><tr><td><a href="#cp6">6 Setting TCP keepalive parameters on the PostgreSQL server</a></td><td></td></tr><tr><td><a href="#cp7">7 Setting TCP keepalive parameters on the PostgreSQL client</a></td><td></td></tr><tr><td><a href="#cp8">8 Setting TCP keepalive parameters on the operating system</a></td><td></td></tr><tr><td><a href="#cp9">9 Conclusion</a></td><td></td></tr><tr><td><a href="#cp10">10 Other problems</a></td><td></td></tr></tbody></table><p>如果您听说过TCP keepalive但不确定那是什么，请继续阅读。如果您曾对如下错误消息感到惊讶：</p><pre><code class="hljs">(1) 服务器意外关闭了连接(2) SSL SYSCALL 错误：检测到EOF(3) 客户端连接意外结束(4) 无法从客户端接收数据：连接被对方重置</code></pre><p><img src="/2025/05/05/note/DB/postgresql/conf/keepalive/img.png" alt="img.png"><br>那么，这篇文章就是为您准备的。</p><h3 id="1-Reasons-for-broken-connections"><a href="#1-Reasons-for-broken-connections" class="headerlink" title="1 Reasons for broken connections"></a><a name="cp1"></a>1 Reasons for broken connections</h3><p>断开的连接可能有几种原因：</p><h4 id="1-1-Database-server-crashes"><a href="#1-1-Database-server-crashes" class="headerlink" title="1.1 Database server crashes"></a><a name="cp1.1"></a>1.1 Database server crashes</h4><p>上述列表中的前两个消息可能是 PostgreSQL 服务器问题的结果。<br>如果服务器由于某种原因崩溃，您会看到类似的消息。<br>要调查是否存在服务器问题，您应该首先查看 PostgreSQL 日志，看看是否能找到匹配的崩溃报告。</p><p>我们不会在下文中处理这种情况，因为它不是网络问题。</p><h4 id="1-2-Connections-abandoned-by-the-client"><a href="#1-2-Connections-abandoned-by-the-client" class="headerlink" title="1.2 Connections abandoned by the client"></a><a name="cp1.2"></a>1.2 Connections abandoned by the client</h4><p>客户端放弃的连接</p><p>如果客户端退出时未正确关闭数据库连接，则服务器在网络套接字通信时将收到文件结束符或错误。<br>自 v14 版本引入的新会话统计信息中，您可以跟踪此类“被放弃”的数据库连接数量，<br>在 pg_stat_database.sessions_abandoned 中。</p><p>(<a href="https://www.cybertec-postgresql.com/en/estimating-connection-pool-size-with-postgresql-database-statistics/">https://www.cybertec-postgresql.com/en/estimating-connection-pool-size-with-postgresql-database-statistics/</a>).</p><p>例如，如果应用程序服务器出现故障并重新启动，通常它不会关闭与数据库服务器的连接。<br>这并不令人惊慌，当服务器尝试向客户端发送数据时，数据库服务器会迅速检测到。但如果数据库会话处于空闲状态，<br>服务器进程则等待客户端发送下一个语句（您可以在 pg_stat_activity 中看到 wait_event “ClientRead”）。<br>然后服务器不会立即注意到客户端已不存在！这种滞留的后端进程占用了一个进程槽，<br>并可能导致您超出 max_connections。</p><p>PostgreSQL v14 引入了一个新参数 idle_session_timeout，该参数会在一段时间后关闭空闲连接。<br>但这也会终止“健康”的空闲连接，因此这不是一个很好的解决方案。TCP keepalive 为此问题提供了一个更好的解决方案。</p><h4 id="1-3-Connections-closed-by-a-network-component"><a href="#1-3-Connections-closed-by-a-network-component" class="headerlink" title="1.3 Connections closed by a network component"></a><a name="cp1.3"></a>1.3 Connections closed by a network component</h4><p>由网络组件关闭的连接</p><p>有时数据库连接的两端都会遇到相同的问题：每一端都发现另一端“挂断了”。在这种情况下，<br>问题是位于数据库客户端和服务器之间的某个地方。</p><p>如果有实际的连接问题，网络连接可能会断开。在软件级别上您无法对此进行更改。但通常情况下，<br>断开连接是由防火墙或路由器的配置方式引起的。网络组件可能必须“记住”每个开放连接的状态，<br>而用于此的资源是有限的。因此，放弃并丢弃长时间空闲的连接似乎是一种权宜之计。</p><p>由于当今大部分的 TCP 流量是通过 HTTP 进行的，而 HTTP 是无状态的，这通常不是问题。<br>如果您的 HTTP 连接中断，只需为下一个请求建立一个新的连接即可，这并不会非常耗资源。但是数据库则不同：</p><pre><code class="hljs">(1) 建立数据库连接的成本很高(2) 数据库连接不是无状态的；例如，连接关闭时，打开的事务、临时表和预准备语句都会丢失(3) 对于数据库会话来说，长时间处于空闲状态是正常的，例如如果您正在使用连接池，或者当客户端正在等待长时间运行的分析查询的结果时</code></pre><p>这时 TCP keepalive 就派上用场了，它可以保持空闲连接的开放。</p><h3 id="2-What-is-TCP-keepalive"><a href="#2-What-is-TCP-keepalive" class="headerlink" title="2 What is TCP keepalive?"></a><a name="cp2"></a>2 What is TCP keepalive?</h3><p>Keepalive 是 TCP 协议的一项功能。当您在 TCP 网络套接字上设置 SO_KEEPALIVE 选项时，<br>一旦套接字进入空闲状态，计时器将开始运行。当 keepalive 空闲时间到期且套接字上没有进一步活动时，<br>内核将向通信伙伴发送一个“keepalive 数据包”。如果伙伴回应，连接被视为良好，计时器将重新开始运行。</p><p>如果没有收到回应，内核会在发送另一个 keepalive 数据包之前等待 keepalive 间隔时间。<br>此过程会重复进行，直到发送的 keepalive packets数量达到 keepalive count。之后，连接被视为已断开，<br>尝试使用网络套接字将会导致错误。</p><p>请注意，是操作系统内核而不是应用程序（数据库服务器或客户端）发送 keepalive 消息。<br>应用程序并不知晓这一过程。</p><p>TCP keepalive 有两个目的：</p><p>(1) 防止网络连接长时间处于空闲状态；<br>(2) 检测另一端通信方是否在未关闭网络连接的情况下离开。<br>（名称“keepalive”并不能很好地描述这一点——“detectdead”会更准确一些）。</p><h3 id="3-TCP-keepalive-default-settings"><a href="#3-TCP-keepalive-default-settings" class="headerlink" title="3 TCP keepalive default settings"></a><a name="cp3"></a>3 TCP keepalive default settings</h3><p>TCP keepalive 默认设置<br>keepalive 参数的默认值因操作系统而异。在 Linux 和 Windows 上，默认值为：</p><p>keepalive 空闲时间：Linux、MacOS 和 Windows 上为 2 小时<br>keepalive 间隔：Linux 和 MacOS 上为 75 秒，Windows 上为 1 秒<br>keepalive 计数：MacOS 上为 8，Linux 上为 9，Windows 上为 10（此值在 Windows 上无法更改）</p><h3 id="4-Using-TCP-keepalive-to-keep-an-idle-database-session-alive"><a href="#4-Using-TCP-keepalive-to-keep-an-idle-database-session-alive" class="headerlink" title="4 Using TCP keepalive to keep an idle database session alive"></a><a name="cp4"></a>4 Using TCP keepalive to keep an idle database session alive</h3><p>使用 TCP keepalive 维持空闲数据库会话</p><p>为了防止防火墙和路由器关闭空闲连接，我们需要将 keepalive 空闲时间设置得更低。<br>这样，在连接被关闭之前就会发送 keepalive 数据包。这会欺骗有问题的网络组件，使其认为连接并未空闲，<br>即使数据库客户端和服务器都没有发送任何数据。</p><h3 id="5-Using-TCP-keepalive-to-detect-dead-connections"><a href="#5-Using-TCP-keepalive-to-detect-dead-connections" class="headerlink" title="5 Using TCP keepalive to detect dead connections"></a><a name="cp5"></a>5 Using TCP keepalive to detect dead connections</h3><p>使用 TCP keepalive 检测死连接</p><p>对于这种用例，减少 keepalive 空闲时间通常是不够的。如果服务器发送了九个间隔时间为 75 秒的 keepalive 数据包，<br>则需要超过 10 分钟才能检测到死连接。因此，我们也会减少 keepalive 计数，或 keepalive 间隔，或同时减少两者。</p><p>这里还有一个缺失的部分：即使操作系统检测到网络连接已断开，除非数据库服务器尝试使用网络套接字，<br>否则它不会注意到这一点。如果它正在等待来自客户端的请求，这将立即发生。但如果服务器忙于执行<br>长时间运行的 SQL 语句，它将不会注意到死连接，直到查询完成并尝试将结果返回给客户端！<br>为了避免这种情况的发生，PostgreSQL v14 引入了一个新参数 client_connection_check_interval，<br>目前仅在 Linux 上支持。设置此参数会导致服务器定期“轮询”套接字，即使它还没有任何要发送的数据。<br>这样，它可以检测到已关闭的连接并中断 SQL 语句的执行。</p><h3 id="6-Setting-TCP-keepalive-parameters-on-the-PostgreSQL-server"><a href="#6-Setting-TCP-keepalive-parameters-on-the-PostgreSQL-server" class="headerlink" title="6 Setting TCP keepalive parameters on the PostgreSQL server"></a><a name="cp6"></a>6 Setting TCP keepalive parameters on the PostgreSQL server</h3><p>在 PostgreSQL 服务器上设置 TCP keepalive 参数</p><p>PostgreSQL 服务器总是在 TCP 套接字上设置 SO_KEEPALIVE 以检测断开的连接，但默认的两小时空闲超时时间非常长。</p><p>您可以设置配置参数 tcp_keepalives_idle、tcp_keepalives_interval 和 tcp_keepalives_count<br>（最后一个在 Windows 上不支持）来更改所有服务器套接字的设置。</p><p>这是为所有数据库连接配置 TCP keepalive 的最便捷方式，无论使用何种客户端。</p><h3 id="7-Setting-TCP-keepalive-parameters-on-the-PostgreSQL-client"><a href="#7-Setting-TCP-keepalive-parameters-on-the-PostgreSQL-client" class="headerlink" title="7 Setting TCP keepalive parameters on the PostgreSQL client"></a><a name="cp7"></a>7 Setting TCP keepalive parameters on the PostgreSQL client</h3><p>在 PostgreSQL 客户端上设置 TCP keepalive 参数</p><p>PostgreSQL 客户端共享库 libpq 具有连接参数 keepalives_idle、keepalives_interval<br>和 keepalives_count（同样，后者在 Windows 上不支持），以便在客户端配置 keepalive。</p><p>这些参数可以与所有链接到 libpq 的客户端接口一起在 PostgreSQL 连接字符串中使用，例如 Psycopg 或 PHP。</p><p>不使用 libpq 的 PostgreSQL JDBC 驱动程序仅有一个连接参数 tcpKeepAlive 来<br>启用 TCP keepalive（默认情况下禁用），但没有参数来配置 keepalive 空闲时间和其它 keepalive 设置。</p><h3 id="8-Setting-TCP-keepalive-parameters-on-the-operating-system"><a href="#8-Setting-TCP-keepalive-parameters-on-the-operating-system" class="headerlink" title="8 Setting TCP keepalive parameters on the operating system"></a><a name="cp8"></a>8 Setting TCP keepalive parameters on the operating system</h3><p>而不是专门为 PostgreSQL 连接配置 keepalive 设置，您可以更改操作系统中所有 TCP 连接的<br>默认值——这在您使用的 PostgreSQL 客户端应用程序不允许设置 keepalive 连接参数时非常有用。</p><p><img src="/2025/05/05/note/DB/postgresql/conf/keepalive/img_1.png" alt="img_1.png"></p><p><img src="/2025/05/05/note/DB/postgresql/conf/keepalive/img_2.png" alt="img_2.png"></p><p>如上所述，没有设置 keepalive 探针的数量，该数量被硬编码为 10。注册表项必须是 DWORD 类型，且值以毫秒为单位而非秒。</p><p>更改这些键后，重新启动 Windows 以激活它们。</p><h3 id="9-Conclusion"><a href="#9-Conclusion" class="headerlink" title="9 Conclusion"></a><a name="cp9"></a>9 Conclusion</h3><p>配置 TCP keepalive 可以通过保持空闲数据库连接的开放或通过及时检测断开的连接来<br>提升您的 PostgreSQL 体验。您可以在 PostgreSQL 客户端、服务器或操作系统上配置 keepalive。</p><p>除了配置 keepalive 之外，还应设置新参数 client_connection_check_interval，以便在客户端放弃<br>会话时取消长时间运行的查询。</p><h3 id="10-Other-problems"><a href="#10-Other-problems" class="headerlink" title="10 Other problems"></a><a name="cp10"></a>10 Other problems</h3><p>(1) 一些防火墙默认策略是阻止 keepalive 数据包。注意在 postgres 服务器和客户端之间没有任何此类防火墙。如果有，请允许 postgres 端口的 keepalive 数据包。</p><p>(2) 我想知道下面两个错误有什么区别？</p><p>“could not receive data from client: Connection reset by peer”</p><p>“could not receive data from client: Connection timed out”。</p><p>这两个都是由于 keepalive 相关的问题吗？</p><p>答：不，只有第一个错误与 keepalive 相关：对等端（TCP 连接的另一端）终止了连接。<br>第二个错误意味着在一定时间内没有人响应 TCP 连接请求。<br>这种情况通常发生在您尝试连接到已关闭、不存在或被防火墙阻止的机器时。</p><p>(3) 发散文章：<br><a href="https://blog.csdn.net/liuzhenghua66/article/details/145260469">https://blog.csdn.net/liuzhenghua66/article/details/145260469</a> (连接池偶现15分钟超时问题)</p><p><a href="https://www.cnblogs.com/trust-freedom/p/6992952.html">https://www.cnblogs.com/trust-freedom/p/6992952.html</a></p><p><a href="https://www.laoxiong.net/firewall-dcd-and-tcp-keep-alive.html">https://www.laoxiong.net/firewall-dcd-and-tcp-keep-alive.html</a></p><p><a href="https://www.cnblogs.com/trust-freedom/p/6992952.html">https://www.cnblogs.com/trust-freedom/p/6992952.html</a></p><p><a href="https://blog.csdn.net/zhang_road/article/details/104473143">https://blog.csdn.net/zhang_road/article/details/104473143</a></p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
      <category>PostgreSQL</category>
      
      <category>conf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL 调试 checkpointer 进程</title>
    <link href="/2025/05/05/note/DB/postgresql/checkpoint/gdb/README/"/>
    <url>/2025/05/05/note/DB/postgresql/checkpoint/gdb/README/</url>
    
    <content type="html"><![CDATA[<h2 id="How-to-gdb-checkpointer"><a href="#How-to-gdb-checkpointer" class="headerlink" title="How to gdb checkpointer?"></a>How to gdb checkpointer?</h2><p>PostgreSQL 调试 checkpointer 进程</p><p><a href="https://blog.japinli.top/2022/11/postgresql-debug-checkpointer/">https://blog.japinli.top/2022/11/postgresql-debug-checkpointer/</a></p><p><a href="https://stackoverflow.com/questions/36993909/debugging-a-program-that-uses-sigint-with-gdb">https://stackoverflow.com/questions/36993909/debugging-a-program-that-uses-sigint-with-gdb</a></p><p>本章主要内容如下：</p><p>Checkpointer 进程负责将 PostgreSQL 数据库中的脏页刷到磁盘中，当我们通过 GDB 附加<br>到 checkpointer 进程之后，通过执行 CHECKPOINT 语句发现不能触发后续的 checkpoint 代码。<br>本文针对这个问题简要介绍一下如何调试 PostgreSQL 数据库的 checkpointer 进程。</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#cp1">1 现象</a></td></tr><tr><td><a href="#cp2">2 分析</a></td></tr></tbody></table><h3 id="1-现象"><a href="#1-现象" class="headerlink" title="1. 现象"></a><a name="cp1"></a>1. 现象</h3><p>当我们通过 GDB 附加到 checkponter 进程之后，我们可以在 CheckpointerMain() 函数的 for 循环中<br>打断点来跟踪其执行流程，这里我断点打在 HandleCheckpointerInterrupts() 函数上，因此，<br>每次循环都将执行该函数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> gdb -p $(ps -ef | awk <span class="hljs-string">&#x27;$NF ~ /checkpointer/ &#123;print $2&#125;&#x27;</span>)</span><br>(gdb) b HandleCheckpointerInterrupts<br></code></pre></td></tr></table></figure><p>随后，我们新建一个连接，并执行 CHECKPOINIT 语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">$ psql postgres<br>postgres<span class="hljs-operator">=</span># CHECKPOINT;<br></code></pre></td></tr></table></figure><p>我们在 GDB 的窗口中，可以看到如下所示的信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Program received signal SIGINT, Interrupt.<br>0x00007f83751d342a in epoll_wait (epfd=8, events=0x55afd620a668, maxevents=1, timeout=299000) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30<br>30      ../sysdeps/unix/sysv/linux/epoll_wait.c: No such file or directory.<br>(gdb)<br>Continuing.<br></code></pre></td></tr></table></figure><p>此时，psql 进程也阻塞在了 CHECKPOINT 语句上，我们可以通过 Ctrl-C 来结束 CHECKPOINT 的执行。这是为什么呢？</p><h3 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a><a name="cp2"></a>2. 分析</h3><p>通过分析 RequestCheckpoint() 函数，可以看到它实际上是向 checkpointer 进程发送了 SIGINT 信号，如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">RequestCheckpoint</span><span class="hljs-params">(<span class="hljs-type">int</span> flags)</span><br>&#123;<br>    [...]<br><br>    <span class="hljs-keyword">for</span> (ntries = <span class="hljs-number">0</span>;; ntries++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (CheckpointerShmem-&gt;checkpointer_pid == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (ntries &gt;= MAX_SIGNAL_TRIES || !(flags &amp; CHECKPOINT_WAIT))<br>            &#123;<br>                elog((flags &amp; CHECKPOINT_WAIT) ? ERROR : LOG,<br>                     <span class="hljs-string">&quot;could not signal for checkpoint: checkpointer is not running&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (kill(CheckpointerShmem-&gt;checkpointer_pid, SIGINT) != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (ntries &gt;= MAX_SIGNAL_TRIES || !(flags &amp; CHECKPOINT_WAIT))<br>            &#123;<br>                elog((flags &amp; CHECKPOINT_WAIT) ? ERROR : LOG,<br>                     <span class="hljs-string">&quot;could not signal for checkpoint: %m&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;              <span class="hljs-comment">/* signal sent successfully */</span><br><br>        CHECK_FOR_INTERRUPTS();<br>        pg_usleep(<span class="hljs-number">100000L</span>);     <span class="hljs-comment">/* wait 0.1 sec, then retry */</span><br>    &#125;<br><br>    [...]<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，当我们在通过 GDB 附加进程之后，SIGINT 信号被 GDB 拦截了并且不会向<br>程序发送 SIGINT 信息，因此导致 checkpointer 进程始终接收不到 SIGINT 信号。<br>我们可以通过 GDB 的 info signals 命令看到 GDB 拦截的信号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) info signals<br>Signal        Stop      Print   Pass to program Description<br><br>SIGHUP        Yes       Yes     Yes             Hangup<br>SIGINT        Yes       Yes     No              Interrupt<br>SIGQUIT       Yes       Yes     Yes             Quit<br>SIGILL        Yes       Yes     Yes             Illegal instruction<br>SIGTRAP       Yes       Yes     No              Trace/breakpoint trap<br>SIGABRT       Yes       Yes     Yes             Aborted<br>SIGEMT        Yes       Yes     Yes             Emulation trap<br>SIGFPE        Yes       Yes     Yes             Arithmetic exception<br>SIGKILL       Yes       Yes     Yes             Killed<br>SIGBUS        Yes       Yes     Yes             Bus error<br>SIGSEGV       Yes       Yes     Yes             Segmentation fault<br>SIGSYS        Yes       Yes     Yes             Bad system call<br>[...]<br></code></pre></td></tr></table></figure><p>因此，我们可以在 GDB 的命令行中手动的向 checkpointer 进程发送 SIGINT 信号来触发后续的 checkpoint 代码流程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) c<br>Continuing.<br><br>Program received signal SIGINT, Interrupt.<br>0x00007f83751d342a in epoll_wait (epfd=8, events=0x55afd620a668, maxevents=1, timeout=169802) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30<br>30      in ../sysdeps/unix/sysv/linux/epoll_wait.c<br>(gdb) signal SIGINT<br>Continuing with signal SIGINT.<br><br>Breakpoint 1, HandleCheckpointerInterrupts ()<br>    at /home/japin/Codes/postgresql/Debug/../src/backend/postmaster/checkpointer.c:545<br>(gdb)<br></code></pre></td></tr></table></figure><p>接着，我们便可以跟踪后续的 checkpoint 执行流程，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b CreateCheckPoint<br>Breakpoint 2 at 0x55afd4492083: file /home/japin/Codes/postgresql/Debug/../src/backend/access/transam/xlog.c, line 6441.<br>(gdb) c<br>Continuing.<br><br>Breakpoint 2, CreateCheckPoint (flags=32766)<br>    at /home/japin/Codes/postgresql/Debug/../src/backend/access/transam/xlog.c:6441<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
      <category>PostgreSQL</category>
      
      <category>checkpoint</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Global Resource Drectory (GRD)</title>
    <link href="/2025/05/05/note/DB/Oracle/RAC/GRD/README/"/>
    <url>/2025/05/05/note/DB/Oracle/RAC/GRD/README/</url>
    
    <content type="html"><![CDATA[<p>Global Resource Drectory (GRD)</p><h2 id="Global-Resource-Drectory-GRD"><a href="#Global-Resource-Drectory-GRD" class="headerlink" title="Global Resource Drectory (GRD)"></a>Global Resource Drectory (GRD)</h2><p>本章主要内容如下：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#ch1">1.1 GRD introduction</a></td></tr><tr><td><a href="#ch2">1.2 Cache Coherency</a></td></tr><tr><td><a href="#ch3">1.3 Resources and Enqueues</a></td></tr><tr><td><a href="#ch4">1.4 Global Enqueue Services (GES)</a></td></tr><tr><td><a href="#ch5">1.5 Global Locks</a></td></tr><tr><td><a href="#ch6">1.6 Messaging</a></td></tr><tr><td><a href="#ch7">1.7 Global Cache Services (GCS)</a></td></tr></tbody></table><h3 id="1-1-GRD-introduction"><a href="#1-1-GRD-introduction" class="headerlink" title="1.1 GRD introduction"></a><a name="data-Organization"></a>1.1 GRD introduction</h3><p>RAC 环境包括许多资源，如不同模式下的缓冲区缓存中的多个版本的数据块缓冲区。<br>Oracle 使用锁定和排队机制来协调锁资源、数据和实例间的数据请求。诸如数据块和锁<br>之类的资源必须在节点之间进行同步，因为集群内的节点会获取和释放它们的所有权。<br>由全局资源目录 (GRD) 提供的同步维护了资源在整个集群中的并发性，从而确保共享数据的<br>完整性。对于缓冲区缓存管理也需要同步，因为它被划分为多个缓存，每个实例负责管理其<br>自己的本地版本的缓冲区缓存。数据副本在节点之间交换，这有时被称为全局缓存，<br>但实际上每个节点的缓冲区缓存是分开的，通过传统的分布式锁定机制交换块的副本。</p><p>全局缓存服务 (GCS) 维护跨缓冲区缓存资源的缓存一致性，全局队列服务 (GES) 控制集群内<br>非缓冲区缓存资源的资源管理。</p><h3 id="1-2-Cache-Coherency"><a href="#1-2-Cache-Coherency" class="headerlink" title="1.2 Cache Coherency"></a><a name="data-Organization"></a>1.2 Cache Coherency</h3><p>缓存一致性识别资源的最新副本，也称为主副本，它使用一种机制来确保在Oracle实例之间保持对象的多个副本之间的一致性。并行缓存管理（PCM）确保数据块的主副本存储在一个缓冲区缓存中，而数据块的一致副本存储在其他缓冲区缓存中，进程LCKx负责此任务。</p><p>实例锁的锁和资源结构位于GRD（也称为DLM）中，这是共享池中的一个专用区域。关于数据块资源和缓存版本的详细信息由GCS维护。其他详细信息，如最新版本的位置、缓冲区状态、数据块的角色（本地或全局）和所有权由GES维护。全局缓存与GES一起构成GRD。每个实例在其SGA中维护GRD的一部分。GCS和GES指定一个实例作为资源主控，以管理有关特定资源的所有信息。每个实例都知道哪个实例是哪个资源的主控。</p><h3 id="1-3-Resources-and-Enqueues"><a href="#1-3-Resources-and-Enqueues" class="headerlink" title="1.3 Resources and Enqueues"></a><a name="data-Organization"></a>1.3 Resources and Enqueues</h3><p>资源是可标识的实体，它具有名称或引用。所引用的实体通常是一个内存区域、磁盘文件、数据块或抽象实体。资源可以以各种状态（独占或共享）被拥有或锁定，所有资源都是可锁定的。全局资源在整个集群中可见，因此本地资源只能由其本地实例使用。每个资源可以有一个当前授予用户的锁列表，称为授予队列。转换队列是一组等待转换为特定模式的锁，这是将锁从一种模式更改为另一种模式的过程，甚至NULL也是一种锁。资源有一个锁值块（LVB）。全局资源管理器（GRM）确保跨集群的锁信息有效且正确。</p><p>锁被放置在资源的授予队列或转换队列上，如果锁发生更改，则它会在这些队列之间移动。锁在以下情况下离开转换队列：</p><pre><code class="hljs">1. 进程请求终止锁（移除锁）2. 进程取消转换，锁以之前的模式移回授予队列3. 请求的模式与授予队列中最严格的锁及转换队列之前的所有模式兼容，并且锁位于转换队列的头部</code></pre><p>转换请求按先进先出的原则处理，授予队列和转换队列与由GES管理的每个资源相关联。</p><p><img src="/2025/05/05/note/DB/Oracle/RAC/GRD/README/img.png" alt="img.png"></p><p>队列基本上是支持排队机制并且可以在不同模式下获取的锁。一个队列可以由一个进程以独占模式持有，其他进程可以根据类型持有非独占模式。RAC中的队列与单实例中的相同。</p><h3 id="1-4-Global-Enqueue-Services-GES"><a href="#1-4-Global-Enqueue-Services-GES" class="headerlink" title="1.4 Global Enqueue Services (GES)"></a><a name="data-Organization"></a>1.4 Global Enqueue Services (GES)</h3><p>GES协调所有全局队列的请求，它还处理死锁和超时。有两种类型的本地锁，闩锁和队列，闩锁不影响集群只影响本地实例，队列可以影响集群和实例。</p><p>队列是用于序列化对数据库资源访问的共享结构，它们支持多种模式并且持有时间比闩锁长，它们保护诸如表或库缓存对象之类的持久对象。队列可以使用以下任何一种模式：</p><table><thead><tr><th>Mode</th><th>Summary</th><th>Description</th></tr></thead><tbody><tr><td>NULL</td><td>NULL</td><td>无访问权限，锁在此级别保持以指示进程对资源感兴趣</td></tr><tr><td>SS</td><td>SubShared</td><td>可以在不被保护的情况下读取资源，其他进程可以读取和写入资源，该锁也称为行共享锁</td></tr><tr><td>SX</td><td>Shared Exclusive</td><td>资源可以在不被保护的情况下读取和写入，这也被称为RX（行独占）锁</td></tr><tr><td>S</td><td>Shared</td><td>进程不能写入资源，但多个进程可以读取它。这是传统的共享锁。</td></tr><tr><td>SSX</td><td>SubShared Exclusive</td><td>只有一个进程可以在此级别持有锁，这确保了每次只能由进程进行修改。其他进程可以执行未受保护的读取。这也被称为SRX（共享行独占）表锁。</td></tr><tr><td>X</td><td>Exclusive</td><td>授予持有进程对资源的独占访问权，其他进程不能读取或写入资源。这也是传统的独占锁。</td></tr></tbody></table><h3 id="1-5-Global-Locks"><a href="#1-5-Global-Locks" class="headerlink" title="1.5 Global Locks"></a><a name="data-Organization"></a>1.5 Global Locks</h3><p>每个节点都有一组资源的信息，Oracle使用哈希算法来确定哪个节点持有资源的目录树信息。全局锁主要有两种类型：</p><pre><code class="hljs">1. GCS用于缓冲区缓存管理的锁，这些被称为PCM锁。2. Oracle在集群内同步以协调非PCM资源的全局锁（全局队列），它们保护队列结构。</code></pre><p>当资源进入实例的SGA时，实例拥有保护资源（即数据块或数据字典条目）的全局锁。</p><p>GES锁控制对数据文件（不是数据块）和控制文件的访问，并且也序列化实例间通信。它们还控制库缓存和字典缓存。例如DDL、DML队列表锁、事务队列以及DDL锁或字典锁。SCN和挂载锁是全局锁。</p><p>事务锁和行锁与单实例数据库相同，唯一的区别是队列是全局队列，查看锁定机制以深入了解Oracle锁定的工作原理。</p><h3 id="1-6-Messaging"><a href="#1-6-Messaging" class="headerlink" title="1.6 Messaging"></a><a name="data-Organization"></a>1.6 Messaging</h3><p>RAC与单实例消息传递之间的区别在于，RAC使用高速互连，而单实例则使用共享内存和信号量，在多CPU架构中，当一个或多个进程希望使用处理器时会用到中断。全局增强系统（GES）使用消息进行实例间通信，这是通过消息和异步陷阱（ASTs）完成的。LMON和LMD都使用消息与其他实例通信，当需要锁时，全局资源目录（GRD）将被更新。可以使用视图V$GES_MISC查看消息流量。</p><p>三路锁消息最多涉及三个实例，包括主实例（M）、持有实例（H）和请求实例（R），具体序列如下所示，其中请求实例R对持有实例H的块B1感兴趣。资源在主实例M中被管理。</p><p><img src="/2025/05/05/note/DB/Oracle/RAC/GRD/README/img_1.png" alt="img_1.png"></p><pre><code class="hljs">1. 实例R从GRD获取关于资源的所有权信息，然后实例R向主实例M发送消息请求访问该资源。此消息通过直接发送，因为它至关重要。2. 实例M接收到消息并将其转发给持有实例H。这也通过直接方式发送，这被称为阻塞异步陷阱（BAST）。3. 实例H使用互连将资源发送给实例R，资源被复制到实例R的内存中。4. 一旦在资源上获得了锁句柄，实例R就向实例M发送确认消息。此消息被排队发送，因为它不那么关键，这称为获取异步陷阱（AAST）。</code></pre><p>由于GES严重依赖消息传递，互连必须是高质量的（高性能、低延迟），同时消息保持较小（128字节）以提高性能。交通控制器（TRFC）用于控制集群中实例之间的DLM流量，它使用缓冲来适应大流量。TRFC通过使用票证（序列号）跟踪一切，有一个预定义的票证池，这取决于网络发送缓冲区大小。在发送任何消息之前需要获取一张票证，一旦消息发送出去，票证就会返回到池中，由LMS或LMD执行此操作。如果没有可用的票证，则消息必须等待直到有票证可用。你可以控制票证的数量并查看它们。</p><p><img src="/2025/05/05/note/DB/Oracle/RAC/GRD/README/img_2.png" alt="img_2.png"></p><h3 id="1-7-Global-Cache-Services-GCS"><a href="#1-7-Global-Cache-Services-GCS" class="headerlink" title="1.7 Global Cache Services (GCS)"></a><a name="data-Organization"></a>1.7 Global Cache Services (GCS)</h3><p>GCS锁仅保护全局缓存中的数据块（也称为PCM锁），可以在共享或独占模式下获取。每个锁元素可以将其锁角色设置为本地（与单实例相同）或全局。当处于全局角色时，可能有三种锁模式：共享、独占和空。在全局角色模式下，你只能根据该资源的主实例的指示读取或写入数据块。锁和状态信息保存在SGA中，并由GCS维护，这些被称为锁元素。它还持有一系列由相应锁元素覆盖的缓存缓冲区链。这些可以通过v$lock_element查看，参数_db_block_hash_buckets控制哈希缓冲区链桶的数量。</p><p>如上所述，GCS锁使用以下模式。</p><table><thead><tr><th>锁模式</th><th>描述</th></tr></thead><tbody><tr><td>独占 (X)</td><td>在更新或任何DML操作期间使用，如果另一个实例需要具有独占锁的块，则请求GES让第二个实例放弃全局锁。</td></tr><tr><td>共享 (S)</td><td>用于选择操作，读取数据不需要实例放弃全局锁。</td></tr><tr><td>空 (N)</td><td>允许实例在没有权限的情况下保持对块的锁。此模式用于避免频繁创建和销毁锁，只需将一个锁转换为另一个。</td></tr></tbody></table><p>锁角色由Cache Fusion使用，它可以是本地的或全局的。如果块仅在本地缓存中变脏，则资源是本地的；如果块在一个远程缓存或多个远程缓存中变脏，则资源是全局的。当一个块被发送到另一个实例时，该实例会保留一个过去的映像（PI），然后角色变为全局角色，因此PI表示脏缓冲区的状态。节点必须保持PI直到它从主实例接收到写入磁盘已完成的通知覆盖该版本后，节点将记录一个块写入记录（BWR）。我已经在我的备份部分讨论了PI和BWR。</p><p>当新的当前块到达时，先前的PI保持不变以防其他节点需要它。如果有多个PI存在，它们可能会也可能不会合并为单个PI，这取决于主实例根据是否需要旧的PI来决定，可以存在不确定数量的PI。</p><p>在本地角色中，只允许S和X模式。当主实例请求时，持有实例向其他实例提供块的副本。如果块在全球范围内是干净的，此实例锁角色保持本地。如果块被修改（变脏），则保留PI并且锁变为全局。在全局锁角色中，锁模式可以是N、S和X，块是全局的，甚至可能在任何实例中都是脏的，并且磁盘版本可能已过时。感兴趣的一方只能使用X模式修改块，实例不能从磁盘读取因为它可能不是最新的，持有实例可以根据主实例的指示发送副本给其他实例。</p><p>在我的cache_fusion部分有一个完整的详细指南，这将帮助你更好地理解。</p><p>锁元素持有锁状态信息（转换、授予等）。锁元素由锁进程管理以确定锁的模式，它们也保存一系列由锁元素覆盖的缓存缓冲区，允许Oracle数据库跟踪在锁元素（模式）需要降级（X &gt; N）的情况下必须写入磁盘的缓存缓冲区。</p><p><img src="/2025/05/05/note/DB/Oracle/RAC/GRD/README/img_3.png" alt="img_3.png"></p><p>锁元素保护缓冲缓存中的所有数据块，下面的列表描述了由LEs使用GCS锁管理的数据块类别（x$bh.class）。</p><p><img src="/2025/05/05/note/DB/Oracle/RAC/GRD/README/img_4.png" alt="img_4.png"></p><p>因此，将所有这些放在一起，你得到以下内容：GCS在GRD中管理PCM锁，PCM锁管理全局缓存中的数据块。数据块可以保存在任何一个实例的缓冲缓存（这是全局的）中，如果找不到，则可以通过请求实例从磁盘读取。GCS监控并维护所有实例中块的列表和模式。每个实例将管理一定数量的资源，但一个资源只能由一个实例管理。GCS通过要求实例在修改或读取数据库块之前获取锁来确保缓存一致性。GCS锁不是行级锁，行级锁与PCM锁结合使用。GCS锁确保块由一个实例访问，然后行级锁在行级别管理这些块。如果一个块被修改，所有过去的映像(PI)不再是最新的，需要获得新的副本。</p><p>一致读处理意味着读者永远不会阻塞写者，这与单实例中的情况相同。一个可以帮助的参数是_db_block_max_cr_dba，它限制了缓冲缓存中每个DBA的CR副本数量。如果有太多针对特定缓冲区的CR请求到达，持有者可以放弃该缓冲区上的锁并将缓冲区写入磁盘，这样请求者就可以从磁盘读取它，特别是当请求的块有较旧的SCN并需要重建时（称为CR构造）。这在技术上被称为公平降级转换，参数_fairness_threshold可以用于配置它。</p><p>当CR构造涉及过多工作且缓存中没有当前块或PI块可用于块清除时，lightwork规则会被触发。下面的内容可以用来查看降级转换发生的次数。</p><p><img src="/2025/05/05/note/DB/Oracle/RAC/GRD/README/img_5.png" alt="img_5.png"></p><p>GRD是锁和资源的中央存储库，它分布在所有节点上（不是单个节点），但只有一个实例管理一个资源。维护资源信息的过程称为锁主控或资源主控。我在备份部分谈到了锁重新主控。</p><p>资源亲和性允许在其本地节点上对常用资源进行资源主控，它使用动态资源主控来移动资源主的位置。通常，资源主控仅在实例加入或离开RAC环境时发生，从Oracle 10g R2开始，主控发生在对象级别，这有助于细粒度的对象重新主控。可以使用多个参数动态地对对象进行重新主控。</p><p><img src="/2025/05/05/note/DB/Oracle/RAC/GRD/README/img_6.png" alt="img_6.png"></p><p>在更改上述任何参数之前，应咨询Oracle。</p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
      <category>Oracle</category>
      
      <category>RAC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>oracle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oracle DBMS_LOCK</title>
    <link href="/2025/05/05/note/DB/Oracle/PLSQL/DBMS_LOCK/README/"/>
    <url>/2025/05/05/note/DB/Oracle/PLSQL/DBMS_LOCK/README/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>oracle DBMS_LOCK 包</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>DBMS_LOCK包为Oracle锁定管理服务提供了接口。</p><p>您可以请求特定模式的锁，为其分配一个唯一名称，使得该名称在同一实例或其他实例中的另一个进程中可被识别，<br>进而改变锁的模式并释放该锁。</p><p>本章包含以下内容：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#Overview">1. 概述</a></td></tr><tr><td><a href="#Security-Model">2. 安全模型</a></td></tr><tr><td><a href="#Constants">3. 常量</a></td></tr><tr><td><a href="#Rules-and-Limits">4. 规则与限制</a></td></tr><tr><td><a href="#Operational-Notes">5. 操作注意事项</a></td></tr><tr><td><a href="#Summary-of-DBMS_LOCK-Subprograms">6. DBMS_LOCK子程序摘要</a></td></tr><tr><td><a href="#USE-of-DBMS_LOCK">7. 使用Oracle锁定管理服务（用户锁）</a></td></tr></tbody></table><p>另请参阅：</p><p>欲了解更多详细信息及如何使用DBMS_LOCK包的示例，请参考《Oracle数据库开发人员指南》。</p><h3 id="1-DBMS-LOCK-概述"><a href="#1-DBMS-LOCK-概述" class="headerlink" title="1. DBMS_LOCK 概述"></a><a name="Overview"></a>1. DBMS_LOCK 概述</h3><p>DBMS_LOCK包有许多有益的用途，包括以下方面：</p><ol><li><p>为设备（如终端）提供独占访问权限。</p></li><li><p>在应用级别实施读取锁的强制执行。</p></li><li><p>检测锁何时释放及在应用程序后进行清理。</p></li><li><p>同步应用程序并强制执行顺序处理。</p></li></ol><h3 id="2-DBMS-LOCK-安全模型"><a href="#2-DBMS-LOCK-安全模型" class="headerlink" title="2. DBMS_LOCK 安全模型"></a><a name="Security-Model"></a>2. DBMS_LOCK 安全模型</h3><p>可能存在操作系统特定的限制，影响可获得的最大锁总数。在使用锁或向其他用户开放此包时，必须考虑这一点。<br>可以考虑仅向特定用户或角色授予执行权限。</p><p>一个更好的替代方案是创建一个封装包，限制所使用的锁的数量，并仅向特定用户授予执行权限。<br>封装包的一个示例在DBMS_LOCK.SQL包规范文件中有记录。这些锁在企业管理器监控中显示的缩写形式也在括号中进行了说明。</p><h3 id="3-DBMS-LOCK-常量"><a href="#3-DBMS-LOCK-常量" class="headerlink" title="3. DBMS_LOCK 常量"></a><a name="Constants"></a>3. DBMS_LOCK 常量</h3><p>DBMS_LOCK包包含了一些常量，用于在指定参数值时使用。这些常量在下表中展示。</p><p>Table 94-1 DBMS_LOCK Constants</p><table><thead><tr><th>Name</th><th>Alternate Name(s)</th><th>Type</th><th>Value</th><th>OEM Abbreviation(OEM缩写)</th><th>Description</th></tr></thead><tbody><tr><td>NL_MODE</td><td>NuL1</td><td>INTEGER</td><td>1</td><td>-</td><td>-</td></tr><tr><td>SS_MODE</td><td>Sub Shared</td><td>INTEGER</td><td>2</td><td>ULRS</td><td>这可用于聚合对象上，以指示正在对对象的各个子部分获取共享锁。</td></tr><tr><td>SX_MODE</td><td>1.Sub eXclusive  2.Row Exclusive Mode</td><td>INTEGER</td><td>3</td><td>ULRX</td><td>这可用于聚合对象，以表明正在对对象的各子部分获取排他锁。</td></tr><tr><td>S_MODE</td><td>1.Shared  2.Row Exclusive Mode 3. Intended Exclusive</td><td>INTEGER</td><td>4</td><td>ULRSX</td><td>-</td></tr><tr><td>SSX_MODE</td><td>1.Shared Sub eXclusive  2.Share Row Exclusive Mode</td><td>INTEGER</td><td>5</td><td>-</td><td>这表示整个聚合对象已被共享锁锁定，但该对象的部分子集可能还额外持有排他锁。</td></tr><tr><td>X_MODE</td><td>Exclusive</td><td>INTEGER</td><td>6</td><td>ULX</td><td>-</td></tr></tbody></table><p>这些是不同的锁模式：</p><ul><li><strong>nl（NuLl）</strong>：无锁模式，</li><li><strong>ss（Sub Shared）</strong>：子共享锁，</li><li><strong>sx（Sub eXclusive）</strong>：子独占锁，</li><li><strong>s（Shared）</strong>：共享锁，</li><li><strong>ssx（Shared Sub eXclusive）</strong>：共享子独占锁，</li><li><strong>x（eXclusive）</strong>：独占锁。</li></ul><h3 id="4-DBMS-LOCK-规则与限制"><a href="#4-DBMS-LOCK-规则与限制" class="headerlink" title="4. DBMS_LOCK 规则与限制"></a><a name="Rules-and-Limits"></a>4. DBMS_LOCK 规则与限制</h3><p>当另一个进程持有“held”时，尝试获取“get”的操作会成功或失败，这取决于持有的模式和get的类型。</p><p>下表描述了这些结果：</p><table><thead><tr><th>HELD MODE</th><th>GET NL</th><th>GET SS</th><th>GET SX</th><th>GET S</th><th>GET SSX</th><th>GET X</th></tr></thead><tbody><tr><td>NL</td><td>&check;</td><td>&check;</td><td>&check;</td><td>&check;</td><td>&check;</td><td>&check;</td></tr><tr><td>SS</td><td>&check;</td><td>&check;</td><td>&check;</td><td>&check;</td><td>&check;</td><td>&times;</td></tr><tr><td>SX</td><td>&check;</td><td>&check;</td><td>&check;</td><td>&times;</td><td>&times;</td><td>&times;</td></tr><tr><td>S</td><td>&check;</td><td>&check;</td><td>&times;</td><td>&check;</td><td>&times;</td><td>&times;</td></tr><tr><td>SSX</td><td>&check;</td><td>&check;</td><td>&times;</td><td>&times;</td><td>&times;</td><td>&times;</td></tr><tr><td>X</td><td>&check;</td><td>&times;</td><td>&times;</td><td>&times;</td><td>&times;</td><td>&times;</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">maxwait  constant <span class="hljs-type">integer</span> :<span class="hljs-operator">=</span> <span class="hljs-number">32767</span>;<br></code></pre></td></tr></table></figure><p>常量maxwait表示永久等待。</p><h3 id="5-DBMS-LOCK-操纵注意事项"><a href="#5-DBMS-LOCK-操纵注意事项" class="headerlink" title="5. DBMS_LOCK 操纵注意事项"></a><a name="Operational-Notes"></a>5. DBMS_LOCK 操纵注意事项</h3><p>用户锁与Oracle锁永远不会发生冲突，因为它们以”UL”前缀标识。您可以使用企业管理器的锁监视屏幕或相应的固定视图来查看这些锁。</p><p>用户锁会在会话终止时自动释放。锁标识符是一个介于0到1073741823之间的数字。</p><p>由于预留的用户锁与Oracle锁相同，它具有Oracle锁的所有功能，例如死锁检测。<br>请确保在分布式事务中使用的任何用户锁在COMMIT时被释放，否则可能会发生未检测到的死锁。</p><p>DBMS_LOCK在每个会话限制为几百个锁时效率最高。Oracle强烈建议您制定使用这些锁的标准约定，<br>以避免尝试使用相同锁的程序之间发生冲突。例如，可以将公司名称作为锁名的一部分包含在内。</p><h3 id="6-DBMS-LOCK-子程序摘要"><a href="#6-DBMS-LOCK-子程序摘要" class="headerlink" title="6. DBMS_LOCK 子程序摘要"></a><a name="Summary-of-DBMS_LOCK-Subprograms"></a>6. DBMS_LOCK 子程序摘要</h3><p>此表列出了DBMS_LOCK子程序并简要描述了它们。</p><table><thead><tr><th>Subprogram</th><th>Description</th></tr></thead><tbody><tr><td><a href="#ALLOCATE_UNIQUE">6.1 ALLOCATE_UNIQUE 过程</a></td><td>分配给命名锁的一个唯一锁ID</td></tr><tr><td><a href="#ALLOCATE_UNIQUE_AUTONOMOUS">6.2 ALLOCATE_UNIQUE_AUTONOMOUS 过程</a></td><td>分配给命名锁的一个唯一锁ID</td></tr><tr><td><a href="#CONVERT">6.3 CONVERT 函数</a></td><td>将锁从一种模式转换为另一种模式</td></tr><tr><td><a href="#RELEASE">6.4 RELEASE 函数</a></td><td>释放一个锁</td></tr><tr><td><a href="#REQUEST">6.5 REQUEST 函数</a></td><td>请求特定模式的锁</td></tr><tr><td><a href="#SLEEP">6.6 SLEEP 过程</a></td><td>让会话睡眠指定的时间</td></tr></tbody></table><h4 id="6-1-ALLOCATE-UNIQUE-过程"><a href="#6-1-ALLOCATE-UNIQUE-过程" class="headerlink" title="6.1 ALLOCATE_UNIQUE 过程"></a><a name="ALLOCATE_UNIQUE"></a>6.1 ALLOCATE_UNIQUE 过程</h4><p>此过程为指定的锁名分配一个唯一的锁标识符（范围在1073741824到1999999999之间）。<br>锁标识符用于使应用程序能够协调它们对锁的使用。这是因为它可能使得应用程序基于锁名称而非锁编号来协调它们的锁使用更为简便。</p><p>句法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">DBMS_LOCK.ALLOCATE_UNIQUE (<br>   lockname         <span class="hljs-keyword">IN</span>  VARCHAR2,<br>   lockhandle       <span class="hljs-keyword">OUT</span> VARCHAR2,<br>   expiration_secs  <span class="hljs-keyword">IN</span>  <span class="hljs-type">INTEGER</span>   <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">864000</span>);<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td>lockname</td><td>您想为其生成唯一ID的锁的名称。<br> 不要使用以ORA$开头的锁名称；这些名称保留给Oracle提供的产品使用。</td></tr><tr><td>lockhandle</td><td>返回由ALLOCATE_UNIQUE生成的锁ID的句柄。<br> 您可以在后续的REQUEST、CONVERT和RELEASE调用中使用这个句柄。 <br> 返回句柄而不是实际的锁ID是为了减少因编程错误意外创建了不正确但有效的锁ID的可能性。这为使用此包的不同应用程序之间提供了更好的隔离。<br> LOCKHANDLE可以是长度最多为VARCHAR2(128)的字符串。<br>所有使用ALLOCATE_UNIQUE相同锁名返回的锁句柄的会话都指的是同一个锁。因此，请不要在不同会话之间传递锁句柄。</td></tr><tr><td>expiration_specs</td><td>在允许从DBMS_LOCK_ALLOCATED表中删除指定锁之前，自上次对该锁执行ALLOCATE_UNIQUE后需要等待的秒数。 <br> 默认的等待期限是10天。你不应该从这个表中手动删除锁。后续对ALLOCATE_UNIQUE的调用可能会删除过期的锁以回收空间。</td></tr></tbody></table><p>使用说明</p><p>如果您选择通过名称来识别锁，可以使用ALLOCATE_UNIQUE为这些命名锁生成一个唯一的锁标识号。</p><p>首个使用新锁名调用ALLOCATE_UNIQUE的会话将导致生成一个唯一的锁ID，并将其存储在dbms_lock_allocated表中。<br>随后的调用（通常由其他会话发起）将返回之前生成的锁ID。</p><p>至少在最后一次针对指定锁名调用ALLOCATE_UNIQUE之后的expiration_secs（默认为10天）期间，锁名会与返回的锁ID关联。<br>在此时间之后，为了回收空间，该锁名在dbms_lock_allocated表中的行可能会被删除。ALLOCATE_UNIQUE执行一次提交操作。</p><p><strong>警告：命名用户锁可能效率较低，因为Oracle需使用SQL来确定与指定名称相关的锁。</strong></p><p>异常：</p><p>ORA-20000, ORU-10003: 无法在dbms_lock_allocated目录中查找或插入锁<lockname>。</lockname></p><h4 id="6-2-ALLOCATE-UNIQUE-AUTONOMOUS-过程"><a href="#6-2-ALLOCATE-UNIQUE-AUTONOMOUS-过程" class="headerlink" title="6.2 ALLOCATE_UNIQUE_AUTONOMOUS 过程"></a><a name="ALLOCATE_UNIQUE_AUTONOMOUS"></a>6.2 ALLOCATE_UNIQUE_AUTONOMOUS 过程</h4><p>此过程为指定的锁名分配一个唯一的锁标识符（范围在1073741824到1999999999之间）。<br>锁标识符用于使应用程序能够协调它们对锁的使用。这是因为它可能使得应用程序基于锁名称而非锁编号来协调它们的锁使用更为简便。</p><p>句法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">DBMS_LOCK.ALLOCATE_UNIQUE_AUTONOMOUS (<br>   lockname         <span class="hljs-keyword">IN</span>  VARCHAR2,<br>   lockhandle       <span class="hljs-keyword">OUT</span> VARCHAR2,<br>   expiration_secs  <span class="hljs-keyword">IN</span>  <span class="hljs-type">INTEGER</span>   <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">864000</span>);<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td>lockname</td><td>您想为其生成唯一ID的锁的名称。<br> 不要使用以ORA$开头的锁名称；这些名称保留给Oracle提供的产品使用。</td></tr><tr><td>lockhandle</td><td>返回由ALLOCATE_UNIQUE_AUTONOMOUS生成的锁ID的句柄。<br> 您可以在后续的REQUEST、CONVERT和RELEASE调用中使用这个句柄。 <br> 返回句柄而不是实际的锁ID是为了减少因编程错误意外创建了不正确但有效的锁ID的可能性。这为使用此包的不同应用程序之间提供了更好的隔离。<br> LOCKHANDLE可以是长度最多为VARCHAR2(128)的字符串。<br>所有使用ALLOCATE_UNIQUE_AUTONOMOUS相同锁名返回的锁句柄的会话都指的是同一个锁。因此，请不要在不同会话之间传递锁句柄。</td></tr><tr><td>expiration_specs</td><td>在允许从DBMS_LOCK_ALLOCATED表中删除指定锁之前，自上次对该锁执行ALLOCATE_UNIQUE_AUTONOMOUS后需要等待的秒数。 <br> 默认的等待期限是10天。你不应该从这个表中手动删除锁。后续对ALLOCATE_UNIQUE_AUTONOMOUS的调用可能会删除过期的锁以回收空间。</td></tr></tbody></table><p>使用说明</p><p>如果您选择通过名称来识别锁，可以使用ALLOCATE_UNIQUE_AUTONOMOUS为这些命名锁生成一个唯一的锁标识号。</p><p>首个使用新锁名调用ALLOCATE_UNIQUE_AUTONOMOUS的会话将导致生成一个唯一的锁ID，并将其存储在dbms_lock_allocated表中。<br>随后的调用（通常由其他会话发起）将返回之前生成的锁ID。</p><p>至少在最后一次针对指定锁名调用ALLOCATE_UNIQUE_AUTONOMOUS之后的expiration_secs（默认为10天）期间，锁名会与返回的锁ID关联。<br>在此时间之后，为了回收空间，该锁名在dbms_lock_allocated表中的行可能会被删除。ALLOCATE_UNIQUE_AUTONOMOUS执行一次提交操作。</p><p><strong>警告：命名用户锁可能效率较低，因为Oracle需使用SQL来确定与指定名称相关的锁。</strong></p><p>异常：</p><p>ORA-20000, ORU-10003: 无法在dbms_lock_allocated目录中查找或插入锁<lockname>。</lockname></p><h4 id="6-3-CONVERT-函数"><a href="#6-3-CONVERT-函数" class="headerlink" title="6.3 CONVERT 函数"></a><a name="CONVERT"></a>6.3 CONVERT 函数</h4><p>此函数将锁从一种模式转换为另一种模式。CONVERT 是一个重载函数，它可以接受用户定义的<br>锁标识符，或是由 ALLOCATE_UNIQUE 过程返回的锁句柄。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">DBMS_LOCK.CONVERT(<br>   id         <span class="hljs-keyword">IN</span> <span class="hljs-type">INTEGER</span> <span class="hljs-operator">||</span> <br>   lockhandle <span class="hljs-keyword">IN</span> VARCHAR2,<br>   lockmode   <span class="hljs-keyword">IN</span> <span class="hljs-type">INTEGER</span>,<br>   timeout    <span class="hljs-keyword">IN</span> NUMBER <span class="hljs-keyword">DEFAULT</span> MAXWAIT)<br>  <span class="hljs-keyword">RETURN</span> <span class="hljs-type">INTEGER</span>;<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td>id or lockhandle</td><td>用户分配的锁标识符，取值范围从0到1073741823，或你想要更改其模式的锁的锁句柄，该锁句柄由ALLOCATE_UNIQUE过程返回。</td></tr><tr><td>lockmode</td><td>你想要分配给指定锁的新模式。<br> 可用模式及其关联的整数标识符，请参见常量。</td></tr><tr><td>timeout</td><td>继续尝试改变锁模式的秒数。<br>如果在这个时间段内无法转换锁模式，则调用将返回1（表示超时）。</td></tr></tbody></table><p>返回值：</p><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>成功</td></tr><tr><td>1</td><td>超时</td></tr><tr><td>2</td><td>死锁</td></tr><tr><td>3</td><td>参数错误</td></tr><tr><td>4</td><td>未拥有由id或lockhandle指定的锁</td></tr><tr><td>5</td><td>非法的锁句柄</td></tr></tbody></table><h4 id="6-4-RELEASE-函数"><a href="#6-4-RELEASE-函数" class="headerlink" title="6.4 RELEASE 函数"></a><a name="RELEASE"></a>6.4 RELEASE 函数</h4><p>此函数显式释放先前使用REQUEST函数获取的锁。</p><p>锁会在会话结束时自动释放。RELEASE是一个重载函数，它可以接受用户定义的锁标识符，或者是ALLOCATE_UNIQUE过程返回的锁句柄。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">DBMS_LOCK.RELEASE (<br>   id         <span class="hljs-keyword">IN</span> <span class="hljs-type">INTEGER</span>)<br>  <span class="hljs-keyword">RETURN</span> <span class="hljs-type">INTEGER</span>;<br><br>DBMS_LOCK.RELEASE (<br>   lockhandle <span class="hljs-keyword">IN</span> VARCHAR2)<br>  <span class="hljs-keyword">RETURN</span> <span class="hljs-type">INTEGER</span>;<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td>id or lockhandle</td><td>用户分配的锁标识符，取值范围从0到1073741823，或你想更改其模式的锁的锁句柄，该锁句柄由ALLOCATE_UNIQUE过程返回。</td></tr></tbody></table><p>返回值：</p><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>成功</td></tr><tr><td>3</td><td>参数错误</td></tr><tr><td>4</td><td>未拥有由id或lockhandle指定的锁</td></tr><tr><td>5</td><td>非法的锁句柄</td></tr></tbody></table><h4 id="6-5-REQUEST-函数"><a href="#6-5-REQUEST-函数" class="headerlink" title="6.5 REQUEST 函数"></a><a name="REQUEST"></a>6.5 REQUEST 函数</h4><p>此函数请求具有指定模式的锁。</p><p>REQUEST是一个重载函数，它可以接受用户定义的锁标识符，或者是ALLOCATE_UNIQUE过程返回的锁句柄。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">DBMS_LOCK.REQUEST(<br>   id                 <span class="hljs-keyword">IN</span>  <span class="hljs-type">INTEGER</span> <span class="hljs-operator">||</span><br>   lockhandle         <span class="hljs-keyword">IN</span>  VARCHAR2,<br>   lockmode           <span class="hljs-keyword">IN</span>  <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">DEFAULT</span> X_MODE,<br>   timeout            <span class="hljs-keyword">IN</span>  <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">DEFAULT</span> MAXWAIT,<br>   release_on_commit  <span class="hljs-keyword">IN</span>  <span class="hljs-type">BOOLEAN</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">FALSE</span>)<br>  <span class="hljs-keyword">RETURN</span> <span class="hljs-type">INTEGER</span>;<br></code></pre></td></tr></table></figure><p>当前的默认值，如X_MODE和MAXWAIT，是在DBMS_LOCK包规范中定义的。</p><p>参数：</p><table><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td>id or lockhandle</td><td>用户分配的锁标识符，取值范围从0到1073741823，或你想要更改其模式的锁的锁句柄，该锁句柄由ALLOCATE_UNIQUE过程返回。</td></tr><tr><td>lockmode</td><td>你想要分配给指定锁的新模式。<br> 可用模式及其关联的整数标识符，请参见常量。</td></tr><tr><td>timeout</td><td>继续尝试授予锁的秒数。如果在这段时间内无法授予锁，则调用将返回值1（超时）。</td></tr><tr><td>release_on_commit</td><td>将此参数设置为TRUE可在提交或回滚时释放锁。<br> 否则，锁将一直保持直到被显式释放或会话结束。</td></tr></tbody></table><p>返回值：</p><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>成功</td></tr><tr><td>1</td><td>超时</td></tr><tr><td>2</td><td>死锁</td></tr><tr><td>3</td><td>参数错误</td></tr><tr><td>4</td><td>未拥有由id或lockhandle指定的锁</td></tr><tr><td>5</td><td>非法的锁句柄</td></tr></tbody></table><h4 id="6-6-SLEEP-过程"><a href="#6-6-SLEEP-过程" class="headerlink" title="6.6 SLEEP 过程"></a><a name="SLEEP"></a>6.6 SLEEP 过程</h4><p>此过程使会话暂停指定的一段时间。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">DBMS_LOCK.SLEEP (<br>   seconds  <span class="hljs-keyword">IN</span> NUMBER);<br></code></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td>seconds</td><td>暂停会话的时间长度，以秒为单位。<br> 最小的时间增量可以输入到百分之一秒；例如，1.95 是一个合法的时间值。</td></tr></tbody></table><h3 id="7-使用Oracle锁定管理服务（用户锁）"><a href="#7-使用Oracle锁定管理服务（用户锁）" class="headerlink" title="7. 使用Oracle锁定管理服务（用户锁）"></a><a name="USE-of-DBMS_LOCK"></a>7. 使用Oracle锁定管理服务（用户锁）</h3><p>您的应用程序可以通过调用DBMS_LOCK包中的子程序来使用Oracle锁定管理服务（用户锁）。</p><p>一个应用程序可以请求特定模式的锁，给予它一个唯一名称（在同一个或另一个实例中的另一个子程序中可识别），改变锁的模式，并释放它。<br>因为保留的用户锁是Oracle数据库锁，所以它具有数据库锁的所有特性，比如死锁检测。</p><p>确保在分布式事务中使用的任何用户锁在COMMIT时都会被释放，否则可能会发生未被检测到的死锁。</p><table><thead><tr><th>Topic</th></tr></thead><tbody><tr><td><a href="#WHEN_TO_USE">7.1 何时使用用户锁</a></td></tr><tr><td><a href="#HOW_TO_LOOK">7.2 查看与监控锁</a></td></tr></tbody></table><h4 id="7-1-何时使用用户锁"><a href="#7-1-何时使用用户锁" class="headerlink" title="7.1 何时使用用户锁"></a><a name="WHEN_TO_USE"></a>7.1 何时使用用户锁</h4><p>用户锁可以协助实现以下功能：</p><ol><li><p>为设备提供独占访问：如终端的独占使用。</p></li><li><p>在应用层实施读取锁控制。</p></li><li><p>检测锁释放并进行应用后的清理。</p></li><li><p>同步应用程序并强制顺序处理。</p></li></ol><p>示例8-2演示了Pro*COBOL预编译器如何使用锁来确保当多人必须访问同一设备时，不会发生冲突。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <br><span class="hljs-operator">*</span> Print <span class="hljs-keyword">Check</span>                                                    <span class="hljs-operator">*</span> <br><span class="hljs-operator">*</span> <span class="hljs-keyword">Any</span> cashier may issue a refund <span class="hljs-keyword">to</span> a customer returning goods.  <span class="hljs-operator">*</span> <br><span class="hljs-operator">*</span> Refunds under $<span class="hljs-number">50</span> <span class="hljs-keyword">are</span> given <span class="hljs-keyword">in</span> cash, more than $<span class="hljs-number">50</span> <span class="hljs-keyword">by</span> check.   <span class="hljs-operator">*</span> <br><span class="hljs-operator">*</span> This code prints the check. <span class="hljs-keyword">One</span> printer <span class="hljs-keyword">is</span> opened <span class="hljs-keyword">by</span> <span class="hljs-keyword">all</span>       <span class="hljs-operator">*</span> <br><span class="hljs-operator">*</span> the cashiers <span class="hljs-keyword">to</span> avoid the overhead <span class="hljs-keyword">of</span> opening <span class="hljs-keyword">and</span> closing it   <span class="hljs-operator">*</span> <br><span class="hljs-operator">*</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">every</span> <span class="hljs-keyword">check</span>, meaning that lines <span class="hljs-keyword">of</span> output <span class="hljs-keyword">from</span> multiple    <span class="hljs-operator">*</span> <br><span class="hljs-operator">*</span> cashiers can become interleaved if you do <span class="hljs-keyword">not</span> ensure exclusive <span class="hljs-operator">*</span> <br><span class="hljs-operator">*</span> access <span class="hljs-keyword">to</span> the printer. The DBMS_LOCK package <span class="hljs-keyword">is</span> used <span class="hljs-keyword">to</span>        <span class="hljs-operator">*</span> <br><span class="hljs-operator">*</span> ensure exclusive access.                                       <span class="hljs-operator">*</span> <br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <br>打印支票<br>任何收银员均可向退货的顾客发放退款。 <br>退款金额低于<span class="hljs-number">50</span>美元的以现金形式给予，超过<span class="hljs-number">50</span>美元则开具支票。 <br>本代码用于打印支票。所有收银员共用一台打印机以避免为每张支票打开和关闭所带来的开销，<br>这意味着如果不对打印机进行独占访问控制，来自多个收银员的输出行可能会相互交织。 <br>使用DBMS_LOCK包来确保对打印机的独占访问。<br><br><span class="hljs-keyword">CHECK</span><span class="hljs-operator">-</span>PRINT <br><span class="hljs-operator">*</span>    <span class="hljs-keyword">Get</span> the lock &quot;handle&quot; <span class="hljs-keyword">for</span> the printer lock. <br>   MOVE &quot;CHECKPRINT&quot; <span class="hljs-keyword">TO</span> LOCKNAME<span class="hljs-operator">-</span>ARR. <br>   MOVE <span class="hljs-number">10</span> <span class="hljs-keyword">TO</span> LOCKNAME<span class="hljs-operator">-</span>LEN. <br>   <span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">EXECUTE</span> <br>      <span class="hljs-keyword">BEGIN</span> DBMS_LOCK.ALLOCATE_UNIQUE ( :LOCKNAME, :LOCKHANDLE ); <br>      <span class="hljs-keyword">END</span>; <span class="hljs-keyword">END</span><span class="hljs-operator">-</span>EXEC. <br><span class="hljs-operator">*</span>   Lock the printer <span class="hljs-keyword">in</span> exclusive mode (<span class="hljs-keyword">default</span> mode).<br>   <span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">EXECUTE</span> <br>      <span class="hljs-keyword">BEGIN</span> DBMS_LOCK.REQUEST ( :LOCKHANDLE ); <br>      <span class="hljs-keyword">END</span>; <span class="hljs-keyword">END</span><span class="hljs-operator">-</span>EXEC. <br><span class="hljs-operator">*</span>   You now have exclusive use <span class="hljs-keyword">of</span> the printer, print the check. <br>  ... <br><span class="hljs-operator">*</span>   Unlock the printer so other people can use it <br><span class="hljs-keyword">EXEC</span> <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">EXECUTE</span> <br>      <span class="hljs-keyword">BEGIN</span> DBMS_LOCK.RELEASE ( :LOCKHANDLE ); <br>      <span class="hljs-keyword">END</span>; <span class="hljs-keyword">END</span><span class="hljs-operator">-</span>EXEC.<br></code></pre></td></tr></table></figure><h4 id="7-2-查看与监控锁"><a href="#7-2-查看与监控锁" class="headerlink" title="7.2 查看与监控锁"></a><a name="HOW_TO_LOOK"></a>7.2 查看与监控锁</h4><p>表8-3描述了Oracle数据库中用于显示实例内正在进行的事务锁定信息的设施。</p><table><thead><tr><th>Tool</th><th>Description</th></tr></thead><tbody><tr><td>性能监控数据字典视图</td><td><a href="https://docs.oracle.com/en/database/oracle/oracle-database/12.2/admin/monitoring-the-database.html#GUID-93C0C7B2-33E1-4733-909F-1CDCAC636791">https://docs.oracle.com/en/database/oracle/oracle-database/12.2/admin/monitoring-the-database.html#GUID-93C0C7B2-33E1-4733-909F-1CDCAC636791</a></td></tr><tr><td>UTLLOCKT.SQL</td><td>UTLLOCKT.SQL 脚本用于以树状结构的方式展示一个简单的字符锁等待图。通过任何SQL工具（如SQL*Plus）运行此脚本，它会打印系统中正在等待锁的会话以及相应的阻塞锁。该脚本文件的位置取决于操作系统。（在使用UTLLOCKT.SQL之前，必须先运行CATBLOCK.SQL脚本。）</td></tr></tbody></table><p>你可以查询一组数据字典视图来监控Oracle数据库实例。</p><p>这些视图的范围较为广泛。针对特定进程的其他视图，则会在本书描述该进程的部分进行讨论。</p><table><thead><tr><th>视图</th><th>描述</th></tr></thead><tbody><tr><td>V$LOCK</td><td>列出Oracle数据库当前持有的锁及待处理的锁或 latch 请求</td></tr><tr><td>DBA_BLOCKERS</td><td>显示持有对象锁导致其他会话等待的会话</td></tr><tr><td>DBA_WAITERS</td><td>显示等待对象锁的会话</td></tr><tr><td>DBA_DDL_LOCKS</td><td>列出DDL锁及待处理的DDL锁请求</td></tr><tr><td>DBA_DML_LOCKS</td><td>列出DML锁及待处理的DML锁请求</td></tr><tr><td>DBA_LOCK</td><td>列出所有锁及待处理的锁或 latch 请求</td></tr><tr><td>DBA_LOCK_INTERNAL</td><td>显示每条事务的锁详情及待处理的锁请求</td></tr><tr><td>V$SESSION_WAIT</td><td>列出活跃会话正在等待的资源或事件</td></tr><tr><td>V$SYSSTAT</td><td>包含会话统计信息</td></tr><tr><td>V$RESOURCE_LIMIT</td><td>提供系统资源当前使用与最大限制信息</td></tr><tr><td>V$SQLAREA</td><td>包含共享SQL区域统计信息，每个SQL字符串一行，及已解析和执行的SQL统计信息</td></tr><tr><td>V$LATCH</td><td>包含非顶层 latch 统计数据及顶层 latch 的汇总统计</td></tr></tbody></table><p>|</p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
      <category>Oracle</category>
      
      <category>package</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>oracle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL Locking Functions</title>
    <link href="/2025/05/05/note/DB/mysql/LockFunc/README/"/>
    <url>/2025/05/05/note/DB/mysql/LockFunc/README/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>MySQL Locking Functions</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/locking-functions.html">https://dev.mysql.com/doc/refman/8.0/en/locking-functions.html</a></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>本章包含以下内容：</p><table><thead><tr><th>Chapter Contents</th></tr></thead><tbody><tr><td><a href="#ch1">1. GET_LOCK</a></td></tr><tr><td><a href="#ch2">2. IS_FREE_LOCK</a></td></tr><tr><td><a href="#ch3">3. IS_USED_LOCK</a></td></tr><tr><td><a href="#ch4">4. RELEASE_ALL_LOCKS</a></td></tr><tr><td><a href="#ch5">5. RELEASE_LOCK</a></td></tr><tr><td><a href="#ch6">6. 总结</a></td></tr></tbody></table><p>以下是内容简介：</p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>GET_LOCK()</td><td>Get a named lock</td></tr><tr><td>IS_FREE_LOCK()</td><td>Whether the named lock is free</td></tr><tr><td>IS_USED_LOCK()</td><td>Whether the named lock is in use; return connection identifier if true</td></tr><tr><td>RELEASE_ALL_LOCKS()</td><td>Release all current named locks</td></tr><tr><td>RELEASE_LOCK()</td><td>Release the named lock</td></tr></tbody></table><h3 id="1-GET-LOCK-str-timeout"><a href="#1-GET-LOCK-str-timeout" class="headerlink" title="1. GET_LOCK(str,timeout)"></a><a name="ch1"></a>1. GET_LOCK(str,timeout)</h3><p>尝试使用由字符串 str 给定的名称获取一个锁，并使用 timeout 秒作为超时时间。<br>负的超时值表示无限超时。该锁是exclusive模式。当被一个会话持有时，其他会话不能获得相同名称的锁。</p><p>如果成功获得锁，则返回 1；如果尝试超时（例如，因为另一个客户端之前已锁定该名称），则返回 0；<br>如果发生错误（如内存不足或线程被 mysqladmin kill 命令终止），则返回 NULL。</p><p>通过 GET_LOCK() 获得的锁可以通过执行 RELEASE_LOCK() 显式释放，<br>或者在会话结束时（无论是正常还是异常）隐式释放。<strong>通过 GET_LOCK() 获得的锁在事务提交或回滚时不会被释放。</strong></p><p>GET_LOCK() 使用元数据锁定 (MDL) 子系统实现。可以同时获得多个锁，并且 GET_LOCK() 不会释放任何现有的锁。<br>例如，假设你执行以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> GET_LOCK(<span class="hljs-string">&#x27;lock1&#x27;</span>,<span class="hljs-number">10</span>);<br><span class="hljs-keyword">SELECT</span> GET_LOCK(<span class="hljs-string">&#x27;lock2&#x27;</span>,<span class="hljs-number">10</span>);<br><span class="hljs-keyword">SELECT</span> RELEASE_LOCK(<span class="hljs-string">&#x27;lock2&#x27;</span>);<br><span class="hljs-keyword">SELECT</span> RELEASE_LOCK(<span class="hljs-string">&#x27;lock1&#x27;</span>);<br></code></pre></td></tr></table></figure><p>第二个 GET_LOCK() 获得第二个锁，并且两个 RELEASE_LOCK() 调用都返回 1（成功）。</p><p>甚至可以在给定会话中对同一名称多次获得锁。直到获取会话释放所有对该名称的锁，其他会话才能获得该名称的锁。</p><p>通过 GET_LOCK() 获得的唯一命名锁会出现在 Performance Schema 的 metadata_locks 表中。<br>OBJECT_TYPE 列显示 USER LEVEL LOCK，OBJECT_NAME 列指示锁的名称。<br>如果有多个锁对同一名称进行获取，只有第一个锁为该名称注册一行到 metadata_locks 表中。<br>后续对该名称的锁会增加锁中的计数器，但不会获取额外的元数据锁。当最后一个锁实例在该名称上释放时，<br>该名称的 metadata_locks 行将被删除。</p><p>能够获取多个锁意味着客户端之间可能存在死锁。当发生这种情况时，<br>服务器会选择一个调用者并以其 ER_USER_LOCK_DEADLOCK 错误终止其锁获取请求。此错误不会导致事务回滚。</p><p>MySQL 对锁名称的最大长度强制限制为 64 个字符。</p><p>GET_LOCK() 可用于实现应用程序锁或模拟记录锁。名称是在服务器范围内锁定的。如果在一个会话中已经锁定了某个名称，<br>GET_LOCK() 将阻止任何其他会话对该名称发出的锁请求。这使得同意某一给定锁名称的客户端可以使用该名称进行协作式<br>的建议锁定。但要注意的是，这也允许不属于合作客户端集的一个客户端无意或故意锁定一个名称，从而阻止任何合作<br>客户端锁定该名称。减少这种情况可能性的一种方法是使用特定于数据库或应用程序的锁名称。例如，使用<br>形式为 db_name.str 或 app_name.str 的锁名称。</p><p>如果有多个客户端正在等待一个锁，他们获取锁的顺序是未定义的。应用程序不应假设客户端按照它们<br>发出锁请求的顺序获取锁。</p><p>GET_LOCK() 在基于语句的复制中是不安全的。如果你在 binlog_format 设置为 STATEMENT 时使用此函数，则会记录一条警告。</p><p>由于 GET_LOCK() 仅在单个 mysqld 上建立锁，因此不适合与 NDB Cluster 一起使用，因为没有方法在多个 MySQL 服务<br>器之间强制执行 SQL 锁。更多信息请参阅第 25.2.7.10 节，“与多个 NDB 集群节点相关的限制”。</p><pre><code class="hljs">**注意**由于能够获取多个命名锁，单个语句可能会获得大量锁。例如：INSERT INTO ... SELECT GET_LOCK(t1.col_name) FROM t1;这类语句可能会产生某些不良影响。例如，如果语句在执行过程中部分失败并回滚，则到失败点为止已获得的锁仍然存在。如果意图是使插入的行与获得的锁之间存在对应关系，则该意图无法实现。此外，如果锁必须按照特定顺序授予，请注意结果集的顺序可能因优化器选择的执行计划而异。基于这些原因，最好将应用程序限制为每个语句只调用一次锁获取。</code></pre><p>还提供了一个不同的锁定接口，作为插件服务或一组可加载函数。此接口提供了锁命名空间以及独立的读锁和写锁，<br>不同于 GET_LOCK() 及相关函数提供的接口。有关详细信息，请参阅第 7.6.9.1 节，“锁定服务”。<br>(<a href="https://dev.mysql.com/doc/refman/8.0/en/locking-service.html">https://dev.mysql.com/doc/refman/8.0/en/locking-service.html</a>)</p><h3 id="2-IS-FREE-LOCK-str"><a href="#2-IS-FREE-LOCK-str" class="headerlink" title="2. IS_FREE_LOCK(str)"></a><a name="ch2"></a>2. IS_FREE_LOCK(str)</h3><p>检查名为 str 的锁是否空闲可用（即未被锁定）。如果锁是空闲的（无人使用该锁），则返回 1；<br>如果锁正在使用中，则返回 0；如果发生错误（如参数不正确），则返回 NULL。</p><p>此函数在基于语句的复制中是不安全的。如果你在 binlog_format 设置为 STATEMENT<br>时使用此函数，则会记录一条警告。</p><h3 id="3-IS-USED-LOCK-str"><a href="#3-IS-USED-LOCK-str" class="headerlink" title="3. IS_USED_LOCK(str)"></a><a name="ch3"></a>3. IS_USED_LOCK(str)</h3><p>检查名为 str 的锁是否正在使用中（即已锁定）。如果是，则返回持有该锁的客户端会话的连接标识符。<br>否则，返回 NULL。</p><p>此函数在基于语句的复制中是不安全的。如果你在 binlog_format<br>设置为 STATEMENT 时使用此函数，则会记录一条警告。</p><h3 id="4-RELEASE-ALL-LOCKS"><a href="#4-RELEASE-ALL-LOCKS" class="headerlink" title="4. RELEASE_ALL_LOCKS()"></a><a name="ch4"></a>4. RELEASE_ALL_LOCKS()</h3><p>释放当前会话持有的所有命名锁，并返回释放的锁数量（如果没有锁，则返回 0）。</p><p>此函数在基于语句的复制中是不安全的。如果你在 binlog_format 设置为 STATEMENT 时使用此函数，则会记录一条警告。</p><h3 id="5-RELEASE-ALL-LOCKS"><a href="#5-RELEASE-ALL-LOCKS" class="headerlink" title="5. RELEASE_ALL_LOCKS()"></a><a name="ch5"></a>5. RELEASE_ALL_LOCKS()</h3><p>释放由字符串 str 命名的锁，该锁通过 GET_LOCK() 获得。如果成功释放锁，则返回 1；<br>如果该线程未建立此锁（在此情况下不会释放锁），则返回 0；如果指定名称的锁不存在，<br>则返回 NULL。如果从未通过 GET_LOCK() 获得该锁或之前已经释放，则该锁不存在。</p><p>DO 语句与 RELEASE_LOCK() 结合使用非常方便。详见第 15.2.3 节，“DO 语句”。</p><p>此函数在基于语句的复制中是不安全的。如果你在 binlog_format 设置为 STATEMENT 时使用此函数，则会记录一条警告。</p><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><a name="ch6"></a>6. 总结</h3><pre><code class="hljs">注意事项锁的范围：GET_LOCK() 获取的锁是MySQL服务级别的，不是数据库或表级别的。这意味着它适用于跨数据库或表的操作保护。锁的释放：必须显式地使用 RELEASE_LOCK() 释放锁，或者当持有锁的会话结束时锁会被自动释放。其他线程无法释放。锁的性能：在高并发环境下，频繁地获取和释放锁可能会对性能产生影响。应该谨慎使用，并确保其必要性。锁的可见性：锁是MySQL服务级别的，不是跨服务器的。如果应用是分布式的，并且需要在不同的 MySQL服务实例间共享锁，那么可能需要实现自己的分布式锁机制。锁的名称：锁的名称在数据库实例中是唯一的，但是不同的 MySQL 实例之间锁的名称可以相同，它们互不干扰。</code></pre><p>函数锁虽然对于流程处理非常严谨，但对MySQL数据库性能来说，非常不友好。这种服务级别锁，因为获取锁之后，<br>就是等待过程，所以消耗CPU资源。大量的函数锁，会占有CPU资源（信号量、自旋锁），<br>导致无法处理其他任务。实际生产中，不建议使用。</p>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
      <category>MySQL</category>
      
      <category>lock</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2025/05/05/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2025/05/05/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>1</p><p>2</p><p>3</p><p>45</p><p><img src="/2025/05/05/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/123.jpg" alt="123"></p><p>6</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
